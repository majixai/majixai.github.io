[
    // --- Existing English Lessons (Keep all 30+ from previous step) ---
    {
        "title": "Paragraph Unity: The Topic Sentence",
        "content": "<h3>Structural Concept:</h3><p>Paragraph unity demands that all sentences within a paragraph directly support a single controlling idea. This idea is typically stated in the <strong>topic sentence</strong>.</p><h3>Function:</h3><p>The topic sentence acts as the structural anchor, ensuring the paragraph remains focused and doesn't drift into unrelated points. It guides both the writer and the reader.</p><h3>Example Analysis:</h3><p><em>'[<strong>Topic Sentence:</strong> Effective academic paraphrasing requires more than just changing a few words.] [Supporting sentence defining paraphrasing]. [Supporting sentence explaining the need to alter sentence structure]. [Supporting sentence stressing citation importance].'</em> ← All sentences elaborate *only* on effective paraphrasing.</p><h3>Takeaway:</h3><p>Before writing a paragraph, formulate a clear topic sentence. During revision, check that every sentence directly serves that sentence's structural purpose.</p>"
    },
    {
        "title": "Sentence Structure: Independent Clauses",
        "content": "<h3>Structural Unit:</h3><p>An <strong>independent clause</strong> (or main clause) is the fundamental building block of sentences. It contains a subject and a verb and expresses a complete thought. It can stand alone as a sentence.</p><h3>Structure:</h3><p><code>Subject + Verb + (Optional Complements/Modifiers)</code></p><h3>Examples:</h3><ul><li><code>Research requires patience.</code> (S+V+O)</li><li><code>The experiment succeeded.</code> (S+V)</li><li><code>Effective writing is clear and concise.</code> (S+V+Complement)</li></ul><h3>Function:</h3><p>Forms the core meaning of simple sentences and acts as the foundation to which other clauses and phrases can be attached in more complex sentences.</p><h3>Takeaway:</h3><p>Identify the independent clause(s) to understand the core statement(s) being made in any sentence.</p>"
    },
    // ... (Include ALL other English lessons from the previous step here) ...
    {
        "title": "Analyzing Sentence Structure for Meaning",
        "content": "<h3>Concept: Structure Creates Meaning</h3><p>How a sentence is constructed (its syntax) significantly impacts its meaning, emphasis, and tone. Analyzing structure reveals authorial choices.</p><h3>Questions to Ask:</h3><ul><li>What is the core independent clause? What is the main statement?</li><li>What are the dependent clauses/phrases doing? (Adding reasons, conditions, descriptions?)</li><li>Is coordination or subordination used? What relationship does this show?</li><li>Is the sentence simple, compound, complex, or compound-complex? Why might this structure be used here?</li><li>Is the sentence loose or periodic? What is the effect?</li><li>Are there parallel structures? What is being balanced or listed?</li><li>Is voice active or passive? Who or what is emphasized?</li></ul><h3>Takeaway:</h3><p>Don't just read for content; analyze the sentence structure itself as a key component of how meaning is built and conveyed in academic texts.</p>"
    },

    // --- NEW: Mathematics Lessons ---
    {
        "title": "Math: Concept of a Limit (Calculus)",
        "content": "<h3>Concept: Approaching a Value</h3><p>A <strong>limit</strong> in calculus describes the value that a function 'approaches' as the input (variable) gets arbitrarily close to some specific point.</p><h3>Notation:</h3><p><code>lim (x→c) f(x) = L</code> reads 'The limit of f(x) as x approaches c equals L'.</p><h3>Key Idea:</h3><p>We care about the function's behavior <em>near</em> the point 'c', not necessarily *at* the point 'c'. The function might not even be defined at 'c'.</p><h3>Example Intuition:</h3><p>Consider <code>f(x) = (x^2 - 1) / (x - 1)</code>. It's undefined at x=1. But as x gets very close to 1 (e.g., 0.9, 0.99, 1.1, 1.01), f(x) gets very close to 2. So, the limit as x approaches 1 is 2.</p><h3>Takeaway:</h3><p>Limits are foundational for defining continuity, derivatives, and integrals. They capture the idea of 'getting arbitrarily close'.</p>"
    },
    {
        "title": "Math: The Derivative (Calculus)",
        "content": "<h3>Concept: Instantaneous Rate of Change</h3><p>The <strong>derivative</strong> of a function <code>f(x)</code> at a point 'c', denoted <code>f'(c)</code> or <code>dy/dx|_(x=c)</code>, measures the instantaneous rate at which the function's value is changing with respect to its input at that specific point.</p><h3>Geometric Interpretation:</h3><p>It represents the <strong>slope of the tangent line</strong> to the function's graph at the point (c, f(c)).</p><h3>Definition (Limit Form):</h3><p><code>f'(c) = lim (h→0) [f(c + h) - f(c)] / h</code></p><h3>Application:</h3><p>Used to find velocity from position, acceleration from velocity, optimize functions (find maxima/minima), and analyze function behavior (increasing/decreasing).</p><h3>Takeaway:</h3><p>The derivative gives the precise 'steepness' or rate of change of a function at any given point.</p>"
    },
    {
        "title": "Math: The Definite Integral (Calculus)",
        "content": "<h3>Concept: Accumulated Change / Area</h3><p>The <strong>definite integral</strong> of a function <code>f(x)</code> from <code>a</code> to <code>b</code>, denoted <code>∫[a,b] f(x) dx</code>, represents the net accumulated change of an antiderivative of f(x) over the interval [a, b].</p><h3>Geometric Interpretation (for f(x) ≥ 0):</h3><p>It calculates the exact <strong>area under the curve</strong> of <code>y=f(x)</code> between <code>x=a</code> and <code>x=b</code>.</p><h3>Fundamental Theorem of Calculus (Part 2):</h3><p>If F(x) is an antiderivative of f(x) (meaning F'(x) = f(x)), then <code>∫[a,b] f(x) dx = F(b) - F(a)</code>. This provides a powerful way to compute definite integrals.</p><h3>Takeaway:</h3><p>The definite integral sums up infinitesimal contributions to find a total accumulation or net area over an interval.</p>"
    },
    {
        "title": "Math: Vectors (Linear Algebra)",
        "content": "<h3>Concept: Directed Quantity</h3><p>A <strong>vector</strong> (in linear algebra) is often visualized as an arrow having both <strong>magnitude</strong> (length) and <strong>direction</strong>. It can represent displacement, velocity, force, etc.</p><h3>Representation:</h3><p>Typically represented as an ordered list of numbers (components) in column or row form, e.g., <code>v = [v1, v2, ..., vn]</code> or <code>v = <v1, v2, ..., vn></code>. The number of components 'n' is the vector's dimension.</p><h3>Basic Operations:</h3><ul><li><strong>Addition:</strong> Add corresponding components. <code>u + v = [u1+v1, u2+v2, ...]</code></li><li><strong>Scalar Multiplication:</strong> Multiply each component by a scalar (number). <code>c * v = [c*v1, c*v2, ...]</code></li></ul><h3>Takeaway:</h3><p>Vectors are fundamental objects in linear algebra, representing quantities with directionality, forming the basis of vector spaces.</p>"
    },
    {
        "title": "Math: Matrix Multiplication (Linear Algebra)",
        "content": "<h3>Concept: Composing Linear Transformations</h3><p><strong>Matrix multiplication</strong> (<code>C = A * B</code>) is defined if the number of columns in matrix A equals the number of rows in matrix B. It corresponds to composing the linear transformations represented by A and B.</p><h3>Calculation (Entry C_ij):</h3><p>The entry in the i-th row and j-th column of the product matrix C is calculated by taking the <strong>dot product</strong> of the i-th <strong>row</strong> of A and the j-th <strong>column</strong> of B.</p><h3>Dimensions:</h3><p>If A is <code>m x n</code> and B is <code>n x p</code>, the product C will be <code>m x p</code>.</p><h3>Key Property:</h3><p>Matrix multiplication is generally <strong>NOT commutative</strong> (i.e., <code>A * B ≠ B * A</code>).</p><h3>Takeaway:</h3><p>Matrix multiplication is a core operation combining matrices, essential for solving systems, representing transformations, and many applications.</p>"
    },
    {
        "title": "Math: Eigenvalues & Eigenvectors (Linear Algebra)",
        "content": "<h3>Concept: Invariant Directions</h3><p>For a square matrix A, an <strong>eigenvector</strong> <code>v</code> is a non-zero vector that, when multiplied by A, only changes in magnitude (scaled), not direction. The scaling factor is the corresponding <strong>eigenvalue</strong> <code>λ</code> (lambda).</p><h3>Defining Equation:</h3><p><code>A * v = λ * v</code> (where <code>v ≠ 0</code>)</p><h3>Significance:</h3><p>Eigenvectors represent the directions that remain unchanged (up to scaling) under the linear transformation defined by matrix A. Eigenvalues indicate the amount of stretching or shrinking along those directions.</p><h3>Applications:</h3><p>Used in stability analysis, principal component analysis (PCA), vibration analysis, quantum mechanics, and understanding matrix behavior.</p><h3>Takeaway:</h3><p>Eigenvalues and eigenvectors reveal fundamental properties about how a matrix transforms space.</p>"
    },
     {
        "title": "Math: Partial Derivatives (Advanced Calculus)",
        "content": "<h3>Concept: Rate of Change in Multivariable Functions</h3><p>For a function of multiple variables (e.g., <code>f(x, y)</code>), a <strong>partial derivative</strong> measures the rate of change with respect to *one* variable, while holding all *other* variables constant.</p><h3>Notation:</h3><p>The partial derivative of <code>f</code> with respect to <code>x</code> is denoted <code>∂f/∂x</code>, <code>f_x</code>, or <code>D_x f</code>.</p><h3>Calculation:</h3><p>To find <code>∂f/∂x</code>, treat <code>y</code> (and any other variables) as constants and differentiate <code>f</code> with respect to <code>x</code> using standard single-variable rules.</p><h3>Example:</h3><p>If <code>f(x, y) = x^2 * y + 3y^2</code>, then <code>∂f/∂x = 2x * y + 0 = 2xy</code> (treating y as constant).</p><h3>Takeaway:</h3><p>Partial derivatives extend the concept of the derivative to functions of multiple dimensions, analyzing change along specific axes.</p>"
    },
    {
        "title": "Math: The Gradient (Advanced Calculus)",
        "content": "<h3>Concept: Direction of Steepest Ascent</h3><p>The <strong>gradient</strong> of a scalar function <code>f(x, y, ...)</code>, denoted <code>∇f</code> (nabla f), is a <strong>vector</strong> containing all its partial derivatives.</p><h3>Structure (e.g., in 3D):</h3><p><code>∇f = < ∂f/∂x, ∂f/∂y, ∂f/∂z ></code></p><h3>Key Properties:</h3><ul><li>Points in the direction of the <strong>greatest rate of increase</strong> of the function <code>f</code> at a given point.</li><li>Its magnitude <code>||∇f||</code> gives the *value* of that maximum rate of increase.</li><li>It is perpendicular (orthogonal) to the level surfaces/curves of the function <code>f</code>.</li></ul><h3>Applications:</h3><p>Used in optimization (gradient ascent/descent), physics (relating potential fields to forces), and geometric analysis.</p><h3>Takeaway:</h3><p>The gradient vector packages all the partial derivative information, pointing towards the 'uphill' direction of a multivariable function.</p>"
    },
     {
        "title": "Math: Double Integrals (Advanced Calculus)",
        "content": "<h3>Concept: Volume / Accumulated Quantity over a Region</h3><p>A <strong>double integral</strong>, denoted <code>∬_R f(x, y) dA</code>, integrates a function <code>f(x, y)</code> over a two-dimensional region <code>R</code> in the xy-plane.</p><h3>Geometric Interpretation:</h3><p>If <code>f(x, y) ≥ 0</code>, the double integral represents the <strong>volume</strong> under the surface <code>z = f(x, y)</code> and above the region <code>R</code>.</p><h3>Calculation (Iterated Integrals):</h3><p>Typically evaluated as an <strong>iterated integral</strong>, integrating first with respect to one variable (holding the other constant) and then the other. The order (<code>dx dy</code> or <code>dy dx</code>) and integration limits depend on the shape of region R.<br><em>Example Form:</em> <code>∫[c,d] ( ∫[g1(y), g2(y)] f(x, y) dx ) dy</code></p><h3>Takeaway:</h3><p>Double integrals extend definite integration to 2D regions, used to calculate volume, mass, center of mass, and average values over areas.</p>"
    },
     {
        "title": "Math: Linear Independence (Linear Algebra)",
        "content": "<h3>Concept: Non-Redundancy in Vectors</h3><p>A set of vectors <code>{v1, v2, ..., vk}</code> is <strong>linearly independent</strong> if the only way to form a linear combination that equals the zero vector is by using all zero scalars (coefficients).</p><h3>Defining Equation:</h3><p>The equation <code>c1*v1 + c2*v2 + ... + ck*vk = 0</code> has *only* the trivial solution <code>c1 = c2 = ... = ck = 0</code>.</p><h3>Intuition:</h3><p>None of the vectors in the set can be expressed as a linear combination of the *other* vectors in the set. Each vector adds a new, unique direction or dimension.</p><h3>Contrast (Linear Dependence):</h3><p>If there's a non-trivial solution (at least one <code>ci ≠ 0</code>), the set is <strong>linearly dependent</strong>, meaning at least one vector is redundant (lies in the span of the others).</p><h3>Takeaway:</h3><p>Linear independence is crucial for defining bases and dimension of vector spaces, ensuring a minimal set of generating vectors.</p>"
    },

    // --- NEW: Computer Science Lessons ---
    {
        "title": "CS: C Language - Pointers & Memory",
        "content": "<h3>Core Feature: Manual Memory Management</h3><p>C provides direct memory access via <strong>pointers</strong>. A pointer stores the memory address of another variable.</p><h3>Syntax Basics:</h3><ul><li><code>int *ptr;</code> Declares a pointer <code>ptr</code> to an integer.</li><li><code>&var</code> Gets the memory address of variable <code>var</code>.</li><li><code>*ptr</code> Dereferences the pointer, accessing the value *at* the stored address.</li></ul><h3>Dynamic Allocation:</h3><p>Functions like <code>malloc()</code> allocate memory on the heap; <code>free()</code> releases it. The programmer is responsible for managing this memory lifecycle.</p><h3>Significance:</h3><p>Offers high performance and control but increases the risk of errors like memory leaks, dangling pointers, and segmentation faults if not handled carefully.</p><h3>Takeaway:</h3><p>Pointers are a powerful but dangerous feature of C, requiring careful management of memory addresses.</p>"
    },
    {
        "title": "CS: Java - JVM & Garbage Collection",
        "content": "<h3>Key Concept: Platform Independence</h3><p>Java code compiles to platform-neutral <strong>bytecode</strong>, which runs on the <strong>Java Virtual Machine (JVM)</strong>. A JVM implementation exists for many operating systems, allowing Java programs ('Write Once, Run Anywhere').</p><h3>Automatic Memory Management:</h3><p>Java features <strong>automatic garbage collection (GC)</strong>. The JVM periodically identifies and reclaims memory occupied by objects that are no longer reachable by the program, freeing the programmer from manual <code>free()</code> calls.</p><h3>Object Creation:</h3><p>Objects are typically created using the <code>new</code> keyword (e.g., <code>MyClass obj = new MyClass();</code>).</p><h3>Takeaway:</h3><p>The JVM enables portability, while garbage collection simplifies memory management compared to languages like C/C++, though it can introduce performance pauses.</p>"
    },
    {
        "title": "CS: C++ - RAII & Smart Pointers",
        "content": "<h3>Concept: Resource Management</h3><p>C++ supports manual memory management (like C with <code>new</code>/<code>delete</code>) but strongly encourages <strong>Resource Acquisition Is Initialization (RAII)</strong>.</p><h3>RAII Principle:</h3><p>Tie the lifetime of a resource (memory, file handle, network socket) to the lifetime of an object with automatic duration (a stack object). Resource acquisition happens in the constructor, release in the destructor.</p><h3>Smart Pointers:</h3><p>RAII is implemented for memory using <strong>smart pointers</strong> (e.g., <code>std::unique_ptr</code>, <code>std::shared_ptr</code>). These objects automatically manage the underlying raw pointer, calling <code>delete</code> when the smart pointer goes out of scope or its reference count drops to zero.</p><h3>Takeaway:</h3><p>RAII via smart pointers is the modern C++ way to prevent memory leaks and manage resources safely and automatically, reducing manual `delete` calls.</p>"
    },
    {
        "title": "CS: Rust - Ownership & Borrowing",
        "content": "<h3>Core Feature: Memory Safety without GC</h3><p>Rust achieves memory safety (preventing dangling pointers, data races, etc.) at <strong>compile time</strong> without needing a garbage collector. This is done through its <strong>ownership</strong> and <strong>borrowing</strong> system.</p><h3>Ownership Rules:</h3><ol><li>Each value has a variable called its <em>owner</em>.</li><li>There can only be one owner at a time.</li><li>When the owner goes out of scope, the value is dropped (memory freed).</li></ol><h3>Borrowing:</h3><p>Allows accessing data without taking ownership, via references (<code>&</code> for shared/immutable borrows, <code>&mut</code> for mutable/exclusive borrows). The compiler enforces rules to prevent simultaneous mutable access or mutable access while shared borrows exist.</p><h3>Takeaway:</h3><p>Rust's unique ownership system enforces strict memory management rules at compile time, providing C++-like performance with guaranteed memory safety.</p>"
    },
    {
        "title": "CS: JavaScript - Event Loop & Asynchronicity",
        "content": "<h3>Context: Single-Threaded Non-Blocking I/O</h3><p>JavaScript in browsers and Node.js typically runs application code on a single thread. To handle potentially long-running operations (like network requests, timers, file I/O) without blocking this thread, it uses an <strong>event loop</strong>.</p><h3>Mechanism:</h3><ol><li>Long-running operations are initiated and handed off to browser/OS APIs.</li><li>The JS thread continues executing other code.</li><li>When the operation completes, a callback function (or Promise resolution) is placed in a queue.</li><li>The <strong>event loop</strong> constantly checks if the main call stack is empty. If so, it takes the next task from the queue and pushes it onto the stack for execution.</li></ol><h3>Keywords:</h3><p><code>async</code>/<code>await</code>, Promises (<code>.then()</code>), Callbacks.</p><h3>Takeaway:</h3><p>The event loop enables efficient handling of I/O-bound tasks in single-threaded JavaScript, making applications responsive despite waiting for external operations.</p>"
    },
    {
        "title": "CS: Zsh Shell - Beyond Bash",
        "content": "<h3>Concept: Command-Line Interpreter</h3><p><strong>Zsh</strong> (Z shell) is a Unix shell, an alternative to Bash (the default on many Linux/macOS systems). It acts as a command-line interpreter, allowing users to interact with the operating system.</p><h3>Key Features (Often Enhanced vs Bash):</h3><ul><li><strong>Improved Tab Completion:</strong> More sophisticated completion for commands, arguments, paths, etc.</li><li><strong>Spelling Correction:</strong> Can suggest corrections for mistyped commands.</li><li><strong>Plugin/Theme Support:</strong> Easily extensible via frameworks like 'Oh My Zsh', allowing extensive customization (prompts, aliases, functions).</li><li><strong>Globbing Enhancements:</strong> More powerful file matching patterns.</li></ul><h3>Usage:</h3><p>Used for navigating directories (<code>cd</code>), listing files (<code>ls</code>), running programs, scripting automation tasks.</p><h3>Takeaway:</h3><p>Zsh offers a powerful and highly customizable command-line experience, popular among developers for its enhanced features over traditional shells.</p>"
    },
    {
        "title": "CS: CPython Interpreter",
        "content": "<h3>Concept: Python's Reference Implementation</h3><p><strong>CPython</strong> is the original and most widely used implementation of the Python programming language. It's written primarily in C.</p><h3>Execution Process (Simplified):</h3><ol><li><strong>Parsing:</strong> Reads Python source code (<code>.py</code> files).</li><li><strong>Compilation to Bytecode:</strong> Translates source code into intermediate <strong>bytecode</strong> (<code>.pyc</code> files - platform-independent instructions).</li><li><strong>Interpretation:</strong> A Virtual Machine within CPython executes this bytecode instruction by instruction.</li></ol><h3>GIL (Global Interpreter Lock):</h3><p>A key feature (and limitation) of CPython is the GIL, a mutex that allows only one thread to hold control of the Python interpreter at any time, simplifying memory management but limiting CPU-bound parallelism on multi-core processors.</p><h3>Takeaway:</h3><p>When you run <code>python your_script.py</code>, you are typically using the CPython interpreter to compile your code to bytecode and then execute that bytecode.</p>"
    },
    {
        "title": "CS: AJAX - Asynchronous Web Updates",
        "content": "<h3>Concept: Updating Pages Dynamically</h3><p><strong>AJAX</strong> (Asynchronous JavaScript and XML - though XML is often replaced by JSON now) is a set of web development techniques used to create interactive web applications.</p><h3>Core Idea:</h3><p>Allows web pages to request small amounts of data from the server and update parts of the page <strong>without reloading the entire page</strong>.</p><h3>Mechanism (Modern):</h3><p>JavaScript's <code>fetch</code> API (or older <code>XMLHttpRequest</code>) is used to send an HTTP request to a server URL. When the server responds (often with JSON data), JavaScript code processes the response and updates the page's Document Object Model (DOM) dynamically.</p><h3>Benefit:</h3><p>Creates faster, more responsive user experiences by avoiding full page refreshes for minor updates (e.g., loading new posts, checking usernames, submitting forms).</p><h3>Takeaway:</h3><p>AJAX enables dynamic, desktop-like interactivity in web applications by fetching and displaying data asynchronously.</p>"
    },
    {
        "title": "CS: Relational Databases (SQL)",
        "content": "<h3>Concept: Structured Data Storage</h3><p><strong>Relational Databases</strong> store data in a structured format using tables (relations) composed of rows (records/tuples) and columns (attributes/fields). Examples: PostgreSQL, MySQL, SQL Server.</p><h3>Key Features:</h3><ul><li><strong>Schema:</strong> Predefined structure for tables, specifying column names and data types (e.g., INT, VARCHAR, DATE).</li><li><strong>Relationships:</strong> Defined using primary keys (unique identifiers for rows) and foreign keys (linking rows in one table to rows in another).</li><li><strong>SQL (Structured Query Language):</strong> The standard language for querying and manipulating data (<code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, <code>DELETE</code>).</li><li><strong>ACID Transactions:</strong> Guarantee Atomicity, Consistency, Isolation, Durability for reliable data operations.</li></ul><h3>Takeaway:</h3><p>Relational databases excel at managing structured, related data with strong consistency guarantees, queried using SQL.</p>"
    },
    {
        "title": "CS: NoSQL Databases",
        "content": "<h3>Concept: Alternatives to Relational Model</h3><p><strong>NoSQL</strong> ('Not Only SQL') databases provide data storage mechanisms that differ from the relational model's tables. They arose to handle challenges like large scale, high availability, and unstructured/semi-structured data.</p><h3>Common Types:</h3><ul><li><strong>Document Stores (e.g., MongoDB):</strong> Store data in flexible document formats like JSON or BSON. Schema-flexible.</li><li><strong>Key-Value Stores (e.g., Redis, Memcached):</strong> Simple stores associating a unique key with a value. Very fast lookups.</li><li><strong>Column-Family Stores (e.g., Cassandra):</strong> Store data in columns rather than rows, optimized for queries over large datasets.</li><li><strong>Graph Databases (e.g., Neo4j):</strong> Focus on storing entities (nodes) and relationships (edges). Excel at traversing connections.</li></ul><h3>Takeaway:</h3><p>NoSQL databases offer diverse models optimized for different use cases, often prioritizing scalability and flexibility over the strict consistency of SQL databases.</p>"
    },
    {
        "title": "CS: Big O Notation - Algorithm Efficiency",
        "content": "<h3>Concept: Describing Performance Scaling</h3><p><strong>Big O notation</strong> is used in computer science to classify algorithms according to how their run time or space requirements (memory) grow as the input size (<code>n</code>) grows.</p><h3>Focus: Upper Bound / Worst Case</h3><p>It describes the <strong>asymptotic upper bound</strong> – how the algorithm behaves for very large inputs, ignoring constant factors and lower-order terms.</p><h3>Common Examples:</h3><ul><li><code>O(1)</code>: Constant time (e.g., accessing an array element by index).</li><li><code>O(log n)</code>: Logarithmic time (e.g., binary search). Very efficient.</li><li><code>O(n)</code>: Linear time (e.g., iterating through a list).</li><li><code>O(n log n)</code>: Log-linear time (e.g., efficient sorting algorithms like Merge Sort).</li><li><code>O(n^2)</code>: Quadratic time (e.g., nested loops, bubble sort).</li><li><code>O(2^n)</code>: Exponential time. Becomes impractical very quickly.</li></ul><h3>Takeaway:</h3><p>Big O notation provides a standard way to compare the efficiency and scalability of different algorithms independent of hardware or specific implementation details.</p>"
    },
    {
        "title": "CS: Version Control - Git Basics",
        "content": "<h3>Concept: Tracking Changes</h3><p><strong>Version Control Systems (VCS)</strong> like <strong>Git</strong> track changes made to files (typically source code) over time. They allow developers to revert to previous versions, collaborate effectively, and manage different lines of development (branches).</p><h3>Core Workflow:</h3><ol><li><strong>Modify Files:</strong> Make changes in your working directory.</li><li><strong>Stage Changes (<code>git add <file></code>):</strong> Select specific changes you want to include in the next snapshot.</li><li><strong>Commit Changes (<code>git commit -m \"message\"</code>):</strong> Create a permanent snapshot (commit) of the staged changes in your local repository, with a descriptive message.</li><li><strong>Push Changes (<code>git push</code>):</strong> (Optional) Upload your local commits to a remote repository (like GitHub, GitLab) for backup and collaboration.</li><li><strong>Pull Changes (<code>git pull</code>):</strong> Download and merge changes from a remote repository into your local one.</li></ol><h3>Takeaway:</h3><p>Git is essential for modern software development, enabling change tracking, collaboration, and non-linear development via branching and merging.</p>"
    },
    {
        "title": "CS: Compilation vs. Interpretation",
        "content": "<h3>Concept: Translating Source Code</h3><p>These are two primary methods for executing programs written in high-level languages.</p><h3>Compilation:</h3><ol><li>A <strong>compiler</strong> translates the entire source code into machine code (or an intermediate code like bytecode) *before* execution.</li><li>This machine code is specific to the target OS/architecture.</li><li>Execution involves running the generated machine code directly.</li><li><em>Examples:</em> C, C++, Rust.</li><li><em>Pros:</em> Often faster execution speed. <em>Cons:</em> Extra compilation step, less platform portable (usually).</li></ol><h3>Interpretation:</h3><ol><li>An <strong>interpreter</strong> reads and executes the source code line by line (or statement by statement) *during* execution.</li><li>No separate machine code file is typically generated beforehand (though bytecode intermediates are common, e.g., Python, Java).</li><li><em>Examples:</em> Python (CPython), Ruby, Shell Scripts, classic JavaScript (in browser).</li><li><em>Pros:</em> More platform portable, easier debugging (often). <em>Cons:</em> Generally slower execution.</li></ol><h3>Takeaway:</h3><p>Compilers translate fully before running; interpreters translate and run incrementally. Many modern languages use hybrid approaches.</p>"
    },
    {
        "title": "CS: Array vs. Linked List",
        "content": "<h3>Concept: Linear Data Structures</h3><p>Two fundamental ways to store a sequence of elements.</p><h3>Array:</h3><ul><li>Stores elements in a <strong>contiguous block of memory</strong>.</li><li><strong>Access:</strong> O(1) - Direct access by index (<code>arr[i]</code>) is very fast.</li><li><strong>Insertion/Deletion (Middle):</strong> O(n) - Slow, requires shifting subsequent elements.</li><li><strong>Memory:</strong> Fixed size (often) or requires reallocation if dynamic.</li></ul><h3>Linked List:</h3><ul><li>Stores elements as <strong>nodes</strong>, each containing data and a pointer/reference to the next node. Nodes can be scattered in memory.</li><li><strong>Access:</strong> O(n) - Must traverse the list from the head to reach an element by position.</li><li><strong>Insertion/Deletion (Known Position/Node):</strong> O(1) - Fast, only requires updating pointers of adjacent nodes.</li><li><strong>Memory:</strong> Dynamic size, memory overhead per node (for the pointer).</li></ul><h3>Takeaway:</h3><p>Choose arrays for fast random access. Choose linked lists for frequent insertions/deletions in the middle of the sequence.</p>"
    }

]
