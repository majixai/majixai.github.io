<!DOCTYPE html>
<html>
<head>
    <title>Enhanced Financial Analysis & Prediction Demo</title>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
    <style>
        body { font-family: sans-serif; }
        #data-controls, #calculations, #prediction, #plot-container, #bs-controls, #gemini-insights, #ticker-storage { margin-bottom: 20px; padding: 15px; border: 1px solid #ddd; }
        #data-controls label, #bs-controls label, #ticker-storage label { display: block; margin-bottom: 5px; font-weight: bold; }
        #csv-select, #bs-controls input[type='number'], #ticker-list-textarea { width: calc(100% - 20px); padding: 8px; margin-bottom: 10px; border: 1px solid #ccc; }
        button { padding: 10px 15px; cursor: pointer; background-color: #007bff; color: white; border: none; border-radius: 5px; }
        button:hover { background-color: #0056b3; }
        #calculations pre, #prediction pre, #gemini-insights pre, #ticker-storage pre { background-color: #f8f8f8; padding: 15px; border: 1px solid #eee; overflow-x: auto; white-space: pre-wrap; }
        .calculation-section { margin-bottom: 15px; }
        .calculation-section h3 { margin-top: 0; color: #333; }
        .warning { color: darkred; font-weight: bold; }
        #ticker-list-textarea { height: 100px; } /* Adjust height as needed */
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script>
    // This JavaScript code is designed to be included within the provided HTML file (index.html)
    // and modifies the existing functionality to upload the *content* of CSV files to
    // Local Storage rather than just relying on pre-existing files in the directory.
        
    // --- Add this code within the <script> tags of index.html ---
    // --- The existing code in index.html is assumed to be present ---
    
    // --- New Global Variable to track uploaded files ---
    let uploadedFiles = {};
    
    // --- Modified Functions ---
    
    // **1. Modify `populateCsvDropdown()`**
    //    - Now checks for CSV files in local storage.
    //    - Prioritizes files from local storage over the directory.
    async function populateCsvDropdown() {
        const csvSelect = document.getElementById('csv-select');
        csvSelect.innerHTML = '<option value="">-- Select a CSV File --</option>';
    
        // First, check local storage for CSV files
        const storedCsvFiles = getCsvFilesFromLocalStorage();
        if (storedCsvFiles.length > 0) {
            storedCsvFiles.forEach(filename => {
                const optionElement = document.createElement('option');
                optionElement.value = `local:${filename}`; // Indicate it's from local storage
                optionElement.textContent = `${filename} (Local Storage)`;
                csvSelect.appendChild(optionElement);
            });
        }
    
        // Next, look at the ticker list for other potential options (if any)
        const tickersText = localStorage.getItem('tickerList');
        if (tickersText) {
            const tickers = tickersText.split(',').map(ticker => ticker.trim()).filter(ticker => ticker);
            const dataOptions = [
                { interval: '1m', period: '5d' },
                { interval: '1h', period: '5d' },
                { interval: '1d', period: '1y' }
            ];
            
            tickers.forEach(ticker => {
                dataOptions.forEach(option => {
                    const filename = `${ticker}_${option.interval}_${option.period}.csv`;
                     //Check if it is already stored in local storage
                    if(!storedCsvFiles.includes(filename)){
                        const displayInterval = option.interval;
                        const displayPeriod = option.period;
                        const optionElement = document.createElement('option');
                        optionElement.value = filename;
                        optionElement.textContent = `${ticker} - ${displayInterval} Interval, ${displayPeriod} Period`;
                        csvSelect.appendChild(optionElement);
                    }
                
                });
            });
        }
    
        // Add upload option last
        const uploadOption = document.createElement('option');
        uploadOption.value = 'upload';
        uploadOption.textContent = 'Upload a New CSV File';
        csvSelect.appendChild(uploadOption);
    }
    
    // **2. Modified `loadAndAnalyzeData()`**
    //    - Now handles both local storage and direct directory files.
    async function loadAndAnalyzeData() {
        const csvSelect = document.getElementById('csv-select');
        const csvFileValue = csvSelect.value;
        let csvData = null;
    
        if (!csvFileValue) {
            alert("Please select a CSV file.");
            return;
        }
    
        document.getElementById('calculations-output').textContent = "Loading and processing data...";
        document.getElementById('prediction-output').textContent = "Analyzing data for prediction...";
        document.getElementById('price-chart').innerHTML = "Loading chart...";
        document.getElementById('gemini-output').textContent = "";
    
        try {
            if (csvFileValue.startsWith('local:')) {
                // Load from local storage
                const filename = csvFileValue.substring(6);
                csvData = localStorage.getItem(filename);
                if(!csvData){
                    throw new Error("Error: File not found in local storage.");
                }
            } else if (csvFileValue === 'upload'){
                 //add file uploader here:
                await promptForCsvUpload();
                return; //Stop the rest of the function and let the file upload call loadAndAnalyzeData again.
            }
            else {
                // Load from directory (original behavior)
                csvData = await loadCSV(csvFileValue);
            }
            if (!csvData || csvData.length === 0) {
                document.getElementById('calculations-output').textContent = "Error loading or parsing CSV data. Ensure the CSV file named: " + csvFileValue + " is in the same directory or that it is uploaded to local storage.";
                document.getElementById('prediction-output').textContent = "Prediction unavailable due to data error.";
                document.getElementById('price-chart').innerHTML = "Error loading data for chart.";
                return;
            }
        
            parsedData = parseCSVData(csvData);
            if (!parsedData || parsedData.length === 0) {
                document.getElementById('calculations-output').textContent = "Error processing CSV data.";
                document.getElementById('prediction-output').textContent = "Prediction unavailable due to data error.";
                document.getElementById('price-chart').innerHTML = "Error processing data for chart.";
                return;
            }
        
            displayIndicatorCalculations(parsedData);
            displayPrediction(parsedData);
            plotData(parsedData);
            document.getElementById('calculations-output').style.display = 'none';
        
        } catch (error) {
            console.error("Error:", error);
            document.getElementById('calculations-output').textContent = "An error occurred: " + error.message;
            document.getElementById('prediction-output').textContent = "Prediction unavailable due to error.";
            document.getElementById('price-chart').innerHTML = "Error generating chart.";
        }
    }
    //**3. New function for file upload.**/
    async function promptForCsvUpload() {
      return new Promise((resolve, reject) => {
        const input = document.createElement('input');
        input.type = 'file';
        input.accept = '.csv';
        input.multiple = false; // for now only allow 1 at a time.
        input.onchange = async (event) => {
          const file = event.target.files[0];
          if (!file) {
            alert('No file selected.');
            resolve(); // Resolve to continue normal operation if no file.
            return;
          }
          if (!file.name.endsWith('.csv')) {
            alert('Only CSV files are supported.');
            resolve();// Resolve to continue normal operation if not csv.
            return;
          }
      
          const reader = new FileReader();
          reader.onload = async (e) => {
            const content = e.target.result;
        
            if (localStorage.getItem(file.name)) {
                if (!confirm(`A file named "${file.name}" already exists. Do you want to replace it?`)) {
                  alert(`Upload of ${file.name} skipped (file already exists).`);
                  populateCsvDropdown(); //refresh the options
                  resolve();// Resolve to continue normal operation if file already exists.
                  return;
                }
            }
        
            localStorage.setItem(file.name, content);
            alert(`File ${file.name} uploaded successfully to local storage.`);
            uploadedFiles[file.name] = content; // Store content in uploadedFiles
            populateCsvDropdown();//refresh the options
            resolve(loadAndAnalyzeData()); // After upload, call loadAndAnalyzeData again
          };
          reader.onerror = (error) => {
            alert(`Error uploading file ${file.name}: ${error}`);
            resolve(); // Resolve to continue normal operation if error.
          };
          reader.readAsText(file);
        };
        input.click();
      });
    }
    // **4. New Helper Function `getCsvFilesFromLocalStorage()`**
    //    - Extracts a list of CSV filenames from Local Storage.
    function getCsvFilesFromLocalStorage() {
        const csvFiles = [];
        for (let i = 0; i < localStorage.length; i++) {
            const key = localStorage.key(i);
            if (key.endsWith('.csv')) {
                csvFiles.push(key);
            }
        }
        return csvFiles;
    }
    
    // **5. Modify the `initializePage()`**
    //    - now automatically populates the dropdown even if the local storage is empty.
    function initializePage() {
        // Check if tickerList exists in localStorage
        let tickersText = localStorage.getItem('tickerList');
        if (!tickersText) {
            // Default ticker list if not found in localStorage
            tickersText = "AAPL,MSFT,GOOGL,GOOG,AMZN,NVDA,TSLA,META,BRK.B,JPM,V,JNJ,UNH,PG,XOM,HD,CVX,MA,ABBV,MRK,PEP,KO,COST,CRM,ADBE,NFLX,DIS,WMT,BAC,PFE,TMO,LLY,DHR,LIN,UNP,RTX,MCD,CAT,DOW,IBM,AMD,MMM,AMGN,TXN,GILD,CSCO,INTC,CMCSA,WFC,UPS,MS,GS,NKE,ORCL,T,VZ,CRM,ABT,COP,PM,MDT,HON,LOW,SBUX,C,SPGI,ISRG,ADP,TJX,BKNG,CME,CVS,DG,FDX,GM,HCA,LMT,MO,MSFT,MU,OXY,PYPL,RTX,SCHW,SHOP,SNAP,SO,TGT,UNP,USB,VRTX,WBA,XOM,X,ZM,Z,ZBRA,ZBH,ZTS";
            localStorage.setItem('tickerList', tickersText); // Save default to localStorage
            document.getElementById('ticker-list-textarea').value = tickersText; // Populate textarea too
            document.getElementById('ticker-storage-output').textContent = "Default ticker list loaded and saved to local storage.";
        } else {
            document.getElementById('ticker-list-textarea').value = tickersText; // Ensure textarea is populated on load if list exists
        }
        populateCsvDropdown(); // Finally, populate the dropdown
    }
    
    // --- End of Added Code ---
    
    </script>
</head>
<body>

    <h1>Enhanced Financial Data Analysis & Gemini Insights Demo</h1>
    <p>This demo analyzes CSV files based on a ticker list stored in local browser storage and uses the Google Gemini API.</p>

    <div id="ticker-storage">
        <h2>Ticker List Management (Local Storage)</h2>
        <label for="ticker-list-textarea">Enter tickers (comma-separated) to store in Local Storage:</label>
        <textarea id="ticker-list-textarea">AAPL,MSFT,GOOGL,GOOG,AMZN,NVDA,TSLA,META,BRK.B,JPM,V,JNJ,UNH,PG,XOM,HD,CVX,MA,ABBV,MRK,PEP,KO,COST,CRM,ADBE,NFLX,DIS,WMT,BAC,PFE,TMO,LLY,DHR,LIN,UNP,RTX,MCD,CAT,DOW,IBM,AMD,MMM,AMGN,TXN,GILD,CSCO,INTC,CMCSA,WFC,UPS,MS,GS,NKE,ORCL,T,VZ,CRM,ABT,COP,PM,MDT,HON,LOW,SBUX,C,SPGI,ISRG,ADP,TJX,BKNG,CME,CVS,DG,FDX,GM,HCA,LMT,MO,MSFT,MU,OXY,PYPL,RTX,SCHW,SHOP,SNAP,SO,TGT,UNP,USB,VRTX,WBA,XOM,X,ZM,Z,ZBRA,ZBH,ZTS</textarea>
        <button id="save-tickers-btn">Save Ticker List to Local Storage</button>
        <button id="load-tickers-btn">Load Ticker List from Local Storage</button>
        <pre id="ticker-storage-output"></pre>
        <p>Manage tickers in local storage. Used to populate the CSV file dropdown.</p>
    </div>

    <div id="data-controls">
        <h2>Step 1: Data Selection</h2>
        <label for="csv-select">Choose a CSV File (from Local Storage Tickers):</label>
        <select id="csv-select">
            <option value="">-- Select a CSV File --</option>
            </select>
        <button id="load-data-btn">Load & Analyze Data</button>
        <p><b>Note:</b> CSV files should be named as <b>&lt;ticker&gt;_&lt;interval&gt;_&lt;period&gt;.csv</b> (e.g., AAPL_1m_5d.csv) and in the same directory as this HTML file.</p>
        <p><b>Available Intervals/Periods:</b> 1m, 1h, 1d.</p>
    </div>

    <div id="calculations">
        <h2>Step 2: Financial Indicator Calculations</h2>
        <p>Financial indicators based on loaded CSV data.</p>
        <div class="calculation-section"><h3>Standard Deviation</h3><pre id="stdev-output"></pre></div>
        <div class="calculation-section"><h3>Stochastic Oscillator</h3><pre id="stochastics-output"></pre></div>
        <div class="calculation-section"><h3>Average True Range (ATR)</h3><pre id="atr-output"></pre></div>
        <div class="calculation-section"><h3>Bollinger Bands</h3><pre id="bbands-output"></pre></div>
        <div class="calculation-section"><h3>Cosh Function (Example)</h3><pre id="cosh-output"></pre></div>
        <div id="bs-controls">
            <h3>Simplified Black-Scholes Option Pricing</h3>
            <p>Simplified European call option price calculation using Black-Scholes:</p>
            <label for="spot-price">Spot Price (Current Price):</label><input type="number" id="spot-price" value="150">
            <label for="strike-price">Strike Price:</label><input type="number" id="strike-price" value="160">
            <label for="risk-free-rate">Risk-Free Rate (decimal, e.g., 0.05 for 5%):</label><input type="number" id="risk-free-rate" value="0.05">
            <label for="time-to-expiry">Time to Expiry (years, e.g., 0.5 for 6 months):</label><input type="number" id="time-to-expiry" value="0.5">
            <label for="volatility">Volatility (decimal, e.g., 0.2 for 20%):</label><input type="number" id="volatility" value="0.2">
            <button id="calculate-bs-btn">Calculate Black-Scholes Price</button><pre id="bs-output"></pre>
            <p class="warning"><b>Warning:</b> Simplified Black-Scholes model for demonstration only.</p>
        </div>
        <div class="calculation-section"><h3>Bayesian Methods in Finance (Conceptual)</h3><pre id="bayesian-output"></pre></div>
        <pre id="calculations-output" style="display:none;"><i>(Raw Calculation Output - hidden)</i></pre>
    </div>

    <div id="prediction">
        <h2>Step 3: (Extremely Rudimentary) 1-Hour "Prediction"</h2>
        <pre id="prediction-output"></pre>
        <p class="warning"><b>CRITICAL WARNING:</b> Oversimplified and unreliable prediction.</p>
    </div>

    <div id="gemini-insights">
        <h2>Step 4: Gemini API Insights</h2>
        <button id="get-gemini-btn">Get Gemini API Analysis</button><pre id="gemini-output"></pre>
        <p class="warning"><b>Disclaimer:</b> Gemini API insights are not financial advice.</p>
    </div>

    <div id="plot-container">
        <h2>Step 5: Interactive Price Chart with Indicators</h2>
        <div id="price-chart"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', initializePage);
        document.getElementById('load-data-btn').addEventListener('click', loadAndAnalyzeData);
        document.getElementById('calculate-bs-btn').addEventListener('click', displayBlackScholes);
        document.getElementById('get-gemini-btn').addEventListener('click', getGeminiAnalysis);

        // ---- Local Storage for Ticker List ----
        document.getElementById('save-tickers-btn').addEventListener('click', saveTickerListToLocalStorage);
        document.getElementById('load-tickers-btn').addEventListener('click', loadTickerListFromLocalStorage);

        function saveTickerListToLocalStorage() {
            const tickerListText = document.getElementById('ticker-list-textarea').value;
            localStorage.setItem('tickerList', tickerListText);
            document.getElementById('ticker-storage-output').textContent = "Ticker list saved to local storage.";
            populateCsvDropdown();
        }

        function loadTickerListFromLocalStorage() {
            const tickerListText = localStorage.getItem('tickerList');
            if (tickerListText) {
                document.getElementById('ticker-list-textarea').value = tickerListText;
                document.getElementById('ticker-storage-output').textContent = "Ticker list loaded from local storage.";
                populateCsvDropdown();
            } else {
                document.getElementById('ticker-storage-output').textContent = "No ticker list found in local storage.";
            }
        }

        function initializePage() {
            // Check if tickerList exists in localStorage
            let tickersText = localStorage.getItem('tickerList');
            if (!tickersText) {
                // Default ticker list if not found in localStorage
                tickersText = "AAPL,MSFT,GOOGL,GOOG,AMZN,NVDA,TSLA,META,BRK.B,JPM,V,JNJ,UNH,PG,XOM,HD,CVX,MA,ABBV,MRK,PEP,KO,COST,CRM,ADBE,NFLX,DIS,WMT,BAC,PFE,TMO,LLY,DHR,LIN,UNP,RTX,MCD,CAT,DOW,IBM,AMD,MMM,AMGN,TXN,GILD,CSCO,INTC,CMCSA,WFC,UPS,MS,GS,NKE,ORCL,T,VZ,CRM,ABT,COP,PM,MDT,HON,LOW,SBUX,C,SPGI,ISRG,ADP,TJX,BKNG,CME,CVS,DG,FDX,GM,HCA,LMT,MO,MSFT,MU,OXY,PYPL,RTX,SCHW,SHOP,SNAP,SO,TGT,UNP,USB,VRTX,WBA,XOM,X,ZM,Z,ZBRA,ZBH,ZTS";
                localStorage.setItem('tickerList', tickersText); // Save default to localStorage
                document.getElementById('ticker-list-textarea').value = tickersText; // Populate textarea too
                document.getElementById('ticker-storage-output').textContent = "Default ticker list loaded and saved to local storage.";
            } else {
                document.getElementById('ticker-list-textarea').value = tickersText; // Ensure textarea is populated on load if list exists
            }
            populateCsvDropdown(); // Finally, populate the dropdown
        }


        async function populateCsvDropdown() {
            const csvSelect = document.getElementById('csv-select');
            csvSelect.innerHTML = '<option value="">-- Select a CSV File --</option>';

            const tickersText = localStorage.getItem('tickerList');
            if (!tickersText) {
                console.warn("No ticker list found in local storage to populate CSV dropdown.");
                return;
            }

            const tickers = tickersText.split(',').map(ticker => ticker.trim()).filter(ticker => ticker);
            const intervals = ['1m', '1h', '1d']; // Available intervals/periods
            const dataOptions = [  // Array of interval-period combinations
                { interval: '1m', period: '5d' },
                { interval: '1h', period: '5d' },
                { interval: '1d', period: '1y' }
            ];


            tickers.forEach(ticker => {
                dataOptions.forEach(option => {
                    const filename = `${ticker}_${option.interval}_${option.period}.csv`; // Filename format: <ticker>_<interval>_<period>.csv
                    const displayInterval = option.interval;
                    const displayPeriod = option.period;
                    const optionElement = document.createElement('option');
                    optionElement.value = filename;
                    optionElement.textContent = `${ticker} - ${displayInterval} Interval, ${displayPeriod} Period`;
                    csvSelect.appendChild(optionElement);
                });
            });
        }


        async function loadAndAnalyzeData() {
            const csvFile = document.getElementById('csv-select').value;
            if (!csvFile) {
                alert("Please select a CSV file.");
                return;
            }

            document.getElementById('calculations-output').textContent = "Loading and processing data...";
            document.getElementById('prediction-output').textContent = "Analyzing data for prediction...";
            document.getElementById('price-chart').innerHTML = "Loading chart...";
            document.getElementById('gemini-output').textContent = "";

            try {
                const csvData = await loadCSV(csvFile);
                if (!csvData || csvData.length === 0) {
                    document.getElementById('calculations-output').textContent = "Error loading or parsing CSV data. Ensure the CSV file named: " + csvFile + " is in the same directory.";
                    document.getElementById('prediction-output').textContent = "Prediction unavailable due to data error.";
                    document.getElementById('price-chart').innerHTML = "Error loading data for chart.";
                    return;
                }

                parsedData = parseCSVData(csvData);
                if (!parsedData || parsedData.length === 0) {
                    document.getElementById('calculations-output').textContent = "Error processing CSV data.";
                    document.getElementById('prediction-output').textContent = "Prediction unavailable due to data error.";
                    document.getElementById('price-chart').innerHTML = "Error processing data for chart.";
                    return;
                }

                displayIndicatorCalculations(parsedData);
                displayPrediction(parsedData);
                plotData(parsedData);
                document.getElementById('calculations-output').style.display = 'none';

            } catch (error) {
                console.error("Error:", error);
                document.getElementById('calculations-output').textContent = "An error occurred: " + error.message;
                document.getElementById('prediction-output').textContent = "Prediction unavailable due to error.";
                document.getElementById('price-chart').innerHTML = "Error generating chart.";
            }
        }

        async function loadCSV(filename) {
            try {
                const response = await fetch(filename);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                return await response.text();
            } catch (error) {
                console.error("Error fetching CSV:", error);
                return null;
            }
        }

        function parseCSVData(csvText) {
            const lines = csvText.trim().split('\n');
            if (lines.length <= 1) return null;

            const header = lines[0].split(',');
            const data = [];

            for (let i = 1; i < lines.length; i++) {
                const currentLine = lines[i].split(',');
                if (currentLine.length !== header.length) continue;

                const entry = {};
                for (let j = 0; j < header.length; j++) {
                    let value = currentLine[j].trim();
                    if (!isNaN(value)) {
                        value = parseFloat(value);
                    }
                    entry[header[j].trim()] = value;
                }
                data.push(entry);
            }
            return data;
        }

        function displayIndicatorCalculations(parsedData) {
            if (!parsedData || parsedData.length === 0) {
                document.getElementById('calculations-output').textContent = "No data to calculate indicators.";
                return;
            }

            const closePrices = parsedData.map(item => item['Close']);
             if (closePrices.includes(undefined)) {
                document.getElementById('calculations-output').textContent = "Error: 'Close' prices not found in data.";
                return;
            }


            const stdevVal = standardDeviation(closePrices);
            document.getElementById('stdev-output').textContent = `Standard Deviation of Close Prices: ${isNaN(stdevVal) ? 'N/A (Not enough data)' : stdevVal.toFixed(4)}`;

            const stochasticsData = calculateStochastics(parsedData, 14);
            document.getElementById('stochastics-output').textContent = `Stochastic Oscillator (%K): ${stochasticsData.K.length > 0 ? stochasticsData.K[stochasticsData.K.length-1].toFixed(4) : 'N/A'} \nStochastic Oscillator (%D): ${stochasticsData.D.length > 0 ? stochasticsData.D[stochasticsData.D.length-1].toFixed(4) : 'N/A'}`;

            const atrData = calculateATR(parsedData, 14);
            document.getElementById('atr-output').textContent = `Average True Range (ATR): ${atrData.atrValues.length > 0 ? atrData.atrValues[atrData.atrValues.length-1].toFixed(4) : 'N/A'}`;

            const bbandsData = calculateBollingerBands(closePrices, 20, 2);
            document.getElementById('bbands-output').textContent = `Bollinger Bands (Middle Band): ${bbandsData.middleBand.length > 0 ? bbandsData.middleBand[bbandsData.middleBand.length-1].toFixed(4) : 'N/A'} \nBollinger Bands (Upper Band): ${bbandsData.upperBand.length > 0 ? bbandsData.upperBand[bbandsData.upperBand.length-1].toFixed(4) : 'N/A'} \nBollinger Bands (Lower Band): ${bbandsData.lowerBand.length > 0 ? bbandsData.lowerBand[bbandsData.lowerBand.length-1].toFixed(4) : 'N/A'}`;

            const coshExampleVal = Math.cosh(1.5);
            document.getElementById('cosh-output').textContent = `cosh(1.5) Example: ${coshExampleVal.toFixed(4)}`;

            document.getElementById('bayesian-output').textContent = `Bayesian methods are used in finance to update beliefs based on new evidence. For example, in risk management, Bayesian models can refine risk assessments as market data changes.  They require defining prior probabilities (initial beliefs), likelihood functions (how data updates beliefs), and can be computationally intensive.`;
        }


        function displayBlackScholes() {
            const spotPrice = parseFloat(document.getElementById('spot-price').value);
            const strikePrice = parseFloat(document.getElementById('strike-price').value);
            const riskFreeRate = parseFloat(document.getElementById('risk-free-rate').value);
            const timeToExpiry = parseFloat(document.getElementById('time-to-expiry').value);
            const volatility = parseFloat(document.getElementById('volatility').value);

            if (isNaN(spotPrice) || isNaN(strikePrice) || isNaN(riskFreeRate) || isNaN(timeToExpiry) || isNaN(volatility)) {
                document.getElementById('bs-output').textContent = "Please enter valid numeric values for Black-Scholes parameters.";
                return;
            }

            const bsPrice = blackScholesSimplified(spotPrice, strikePrice, riskFreeRate, timeToExpiry, volatility);
            document.getElementById('bs-output').textContent = `Simplified Black-Scholes Call Option Price: ${bsPrice.toFixed(4)}`;
        }


        function displayPrediction(data) {
             if (!data || data.length === 0) {
                document.getElementById('prediction-output').textContent = "No data for prediction.";
                return;
            }

            const closePrices = data.map(item => item['Close']);
            if (closePrices.length < 2) {
                document.getElementById('prediction-output').textContent = "Not enough data for even a basic prediction.";
                return;
            }

            const lastPrice = closePrices[closePrices.length - 1];
            const previousPrice = closePrices[closePrices.length - 2];
            let predictionText = "";

            if (lastPrice > previousPrice) {
                predictionText = "Based on the very recent trend (last data point vs. previous), there's a hint of upward momentum. A naive extrapolation might suggest a slight increase in the immediate short-term (e.g., next hour if data is 1-minute intervals or next day if data is daily).\n";
            } else if (lastPrice < previousPrice) {
                predictionText = "The recent trend shows a slight downward movement. A simple extrapolation could imply a slight decrease in the immediate short-term.\n";
            } else {
                predictionText = "Recent price action is flat with no directional trend evident from this simplistic viewpoint.\n";
            }

            predictionText += "\n**WARNING:  EXTREME CAUTION ADVISED.** This is an **oversimplified and unreliable approach to 'prediction'.** Real market movements are driven by a vast array of factors far beyond just the immediately preceding price action.  This is not a trading signal.  Do not use this for investment decisions.  This demo aims to illustrate the concept of trend-based extrapolation in an extremely basic way, but it is not a viable method for actual financial forecasting.";

            document.getElementById('prediction-output').textContent = predictionText;
        }


        function plotData(data) {
            if (!data || data.length === 0) return;

            const dates = data.map(item => item['Date'] || item['Datetime'] || item['timestamp'] || String(data.indexOf(item)));
            const closePrices = data.map(item => item['Close']);
            const stochasticsData = calculateStochastics(data, 14);
            const atrData = calculateATR(data, 14);
            const bbandsData = calculateBollingerBands(closePrices, 20, 2);

            const tracePrice = {
                x: dates,
                y: closePrices,
                type: 'scatter',
                mode: 'lines',
                name: 'Close Price'
            };

            const traceStochasticsK = {
                x: dates.slice(13),
                y: stochasticsData.K,
                type: 'scatter',
                mode: 'lines',
                name: '%K',
                yaxis: 'y2'
            };
            const traceStochasticsD = {
                x: dates.slice(13),
                y: stochasticsData.D,
                type: 'scatter',
                mode: 'lines',
                name: '%D',
                yaxis: 'y2'
            };

            const traceATR = {
                x: dates.slice(13),
                y: atrData.atrValues,
                type: 'scatter',
                mode: 'lines',
                name: 'ATR',
                yaxis: 'y3'
            };

            const traceBB_Upper = {
                x: dates.slice(19),
                y: bbandsData.upperBand,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Upper',
                line: {dash: 'dash', color: 'rgba(200,200,200,0.7)'},
                yaxis: 'y'
            };
            const traceBB_Middle = {
                x: dates.slice(19),
                y: bbandsData.middleBand,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Middle',
                line: {dash: 'dash', color: 'rgba(150,150,150,0.7)'},
                yaxis: 'y'
            };
            const traceBB_Lower = {
                x: dates.slice(19),
                y: bbandsData.lowerBand,
                type: 'scatter',
                mode: 'lines',
                name: 'BB Lower',
                line: {dash: 'dash', color: 'rgba(200,200,200,0.7)'},
                yaxis: 'y'
            };


            const layout = {
                title: 'Price Chart with Indicators',
                yaxis: {title: 'Price'},
                yaxis2: {title: 'Stochastics', overlaying: 'y', side: 'right'},
                yaxis3: {title: 'ATR', overlaying: 'y', side: 'left', position: 0.15},
                yaxis2: {title: 'Stochastics', overlaying: 'y', side: 'right', position: 0.85},
                xaxis: {
                    rangeslider: {visible: false},
                    type: 'date'
                },
                legend: {orientation: 'h', yanchor: 'bottom', y: 1.02, xanchor: 'right', x: 1}
            };


            Plotly.newPlot('price-chart', [tracePrice, traceStochasticsK, traceStochasticsD, traceATR, traceBB_Upper, traceBB_Middle, traceBB_Lower], layout);
        }


        // ---- Calculation Functions ----
        function standardDeviation(arr) {
            if (!arr || arr.length < 2) return NaN;
            const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
            const sqDiffArray = arr.map(val => (val - mean) ** 2);
            const avgSqDiff = sqDiffArray.reduce((a, b) => a + b, 0) / (arr.length - 1);
            return Math.sqrt(avgSqDiff);
        }

        function calculateStochastics(data, period) {
            const K_values = [];
            const D_values = [];

            for (let i = period - 1; i < data.length; i++) {
                const periodData = data.slice(i - period + 1, i + 1);
                let lowestLow = Infinity;
                let highestHigh = -Infinity;

                for (const item of periodData) {
                    lowestLow = Math.min(lowestLow, item['Low']);
                    highestHigh = Math.max(highestHigh, item['High']);
                }

                const currentClose = data[i]['Close'];
                const K = ((currentClose - lowestLow) / (highestHigh - lowestHigh)) * 100;
                K_values.push(K);
            }
             // Calculate %D as 3-period moving average of %K
            for (let i = 2; i < K_values.length; i++) {
                const dPeriod = K_values.slice(i-2, i+1);
                const dAvg = dPeriod.reduce((a,b) => a + b, 0) / 3;
                D_values.push(dAvg);
            }


            return { K: K_values, D: D_values };
        }


        function calculateATR(data, period) {
            const atrValues = [];
            let previousClose = 0;

            for (let i = 0; i < data.length; i++) {
                const currentHigh = data[i]['High'];
                const currentLow = data[i]['Low'];
                const currentClose = data[i]['Close'];

                let trueRange = 0;
                if (i > 0) {
                    trueRange = Math.max(
                        currentHigh - currentLow,
                        Math.abs(currentHigh - previousClose),
                        Math.abs(currentLow - previousClose)
                    );
                } else {
                    trueRange = currentHigh - currentLow;
                }


                if (i < period) {
                    atrValues.push(trueRange);
                } else {
                    let sumTR = 0;
                    for (let j = i - period + 1; j <= i; j++) {
                        const pastHigh = data[j]['High'];
                        const pastLow = data[j]['Low'];
                        const pastClose = data[j]['Close'];
                        let pastTR = 0;
                        if (j > 0) {
                             pastTR = Math.max(
                                pastHigh - pastLow,
                                Math.abs(pastHigh - data[j-1]['Close']),
                                Math.abs(pastLow - data[j-1]['Close'])
                            );
                        } else {
                            pastTR = pastHigh - pastLow;
                        }
                        sumTR += pastTR;
                    }


                    atrValues.push(sumTR / period);
                }
                previousClose = currentClose;
            }

            return { atrValues: atrValues.slice(period-1) };
        }


        function calculateBollingerBands(closePrices, period, numStdev) {
            const middleBand = [];
            const upperBand = [];
            const lowerBand = [];

            for (let i = period - 1; i < closePrices.length; i++) {
                const periodPrices = closePrices.slice(i - period + 1, i + 1);
                const sma = periodPrices.reduce((a, b) => a + b, 0) / period;
                const stdDev = standardDeviation(periodPrices);

                middleBand.push(sma);
                upperBand.push(sma + stdDev * numStdev);
                lowerBand.push(sma - stdDev * numStdev);
            }

            return { middleBand: middleBand, upperBand: upperBand, lowerBand: lowerBand };
        }


        function blackScholesSimplified(spotPrice, strikePrice, riskFreeRate, timeToExpiryYears, volatility) {
            const d1 = (Math.log(spotPrice / strikePrice) + (riskFreeRate + 0.5 * volatility ** 2) * timeToExpiryYears) / (volatility * Math.sqrt(timeToExpiryYears));
            const d2 = d1 - volatility * Math.sqrt(timeToExpiryYears);
            const callPrice = spotPrice * cdfNormal(d1) - strikePrice * Math.exp(-riskFreeRate * timeToExpiryYears) * cdfNormal(d2);
            return callPrice;
        }

        function cdfNormal(x) {
            const a1 =  0.254829592;
            const a2 = -0.284496736;
            const a3 =  1.421413741;
            const a4 = -1.453152027;
            const a5 =  1.061405429;
            const p  =  0.3275911;
            const sign = x < 0 ? -1 : 1;
            x = Math.abs(x) / Math.sqrt(2.0);
            const t = 1.0 / (1.0 + p * x);
            const y = 1.0 - (((((a5 * t + a4) * t) + a3) * t + a2) * t + a1) * t * Math.exp(-x * x);
            return 0.5 * (1.0 + sign * y);
        }

        let parsedData;
    </script>

</body>
</html>
