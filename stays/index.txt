Okay, let's expand the `script.js` file to well over 3000 lines by integrating simulated Google Sign-In and Google Pay services, increasing the use of `async`/`await` and `try...catch` blocks, adding extensive comments, and breaking down functionality into more methods.

**Again, a critical disclaimer:** This implementation uses Promises, `async`/`await`, and structures the code *as if* it were using the real Google Identity Services (GIS) and Google Pay APIs client-side, but the actual authentication flow and payment processing logic are **SIMULATED**. A real production application would require:

1.  Proper setup of Google OAuth 2.0 Client ID and potentially a backend for token verification.
2.  Loading and initializing the actual GIS library (`accounts.google.com/gsi/client`).
3.  Implementing the GIS callback handler for credentials.
4.  Loading and initializing the actual Google Pay API library (`pay.google.com/gp/p/js/pay.js`).
5.  Implementing the Google Pay readiness check and payment data request/response handlers.
6.  **Crucially, sensitive operations like sending emails or processing payments securely *require* a backend server to handle API calls using obtained tokens, *not* directly from the browser.** Embedding sensitive credentials or performing unmediated payment processing client-side is a major security vulnerability.

This code provides the *structure* and uses the requested concepts while simulating the external dependencies.

---

**1. `index.html` (Add placeholders for Google Sign-In and Google Pay)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expedia Affiliate Search</title>

    <!-- Google tag (gtag.js) - Google Analytics -->
    <!-- Replace G-XXXXXXXXXX with your actual GA4 Measurement ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      // Initial page view and consent configuration (basic example)
      gtag('config', 'G-XXXXXXXXXX', {
        'page_title': 'Expedia Affiliate Search Page',
        'page_path': window.location.pathname + window.location.search
      });

      // Note: Full GDPR/CCPA compliance requires explicit user consent before loading/firing GA.
      // This simple implementation assumes consent or is for demonstration in a non-production context.
    </script>

    <!-- Optional: Google Identity Services Library for real Google Sign-In (COMMENTED OUT - USING SIMULATION STRUCTURE) -->
    <!-- <script src="https://accounts.google.com/gsi/client" async defer></script> -->

    <!-- Optional: Google Pay API Library for real Google Pay (COMMENTED OUT - USING SIMULATION STRUCTURE) -->
    <!-- <script async defer src="https://pay.google.com/gp/p/js/pay.js" onload="onGooglePayLoaded()"></script> -->
    <!-- Note: onGooglePayLoaded is a global function called by the real Google Pay script -->


    <!-- W3.CSS CDN -->
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <!-- Custom CSS -->
    <link rel="stylesheet" href="style.css">
    <!-- jQuery CDN -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <!-- Google Places Autocomplete API -->
    <!-- Replace 'YOUR_GOOGLE_API_KEY' with your actual Google API Key -->
    <!-- Ensure you have enabled the Places API in your Google Cloud Console -->
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_GOOGLE_API_KEY&libraries=places"></script>

</head>
<body class="w3-light-grey">

    <header class="w3-container w3-teal w3-center w3-padding-32">
        <h1>Expedia Affiliate Hotel Search (Maxed Demo with Google Services & Error Handling)</h1>
        <p>Demonstrating JS OOP, Autocomplete, Async/Await, GA Funnel, **Simulated** Google Auth/Calendar/Email/Pay, Extensive Try/Catch</p>
    </header>

    <div class="w3-container w3-padding-64 w3-center">
        <div class="w3-card-4 w3-round-large w3-light-grey w3-padding" style="max-width:700px; margin:auto;">

            <h2>Find Your Destination</h2>

            <!-- Data attribute to identify this form component -->
            <form id="hotelSearchForm" class="w3-container" data-component-name="SearchForm">

                <div id="formMessages" class="w3-panel w3-hide">
                    <!-- Messages like validation errors or loading state will appear here -->
                </div>

                <div class="w3-section">
                    <label class="w3-text-teal"><b>Destination (City, Landmark, or Hotel)</b></label>
                    <!-- Data attribute to identify this specific input type -->
                    <input class="w3-input w3-border w3-round" type="text" id="destination" placeholder="e.g., New York, Paris Eiffel Tower" required data-input-type="destination" data-component-name="DestinationInput">
                    <!-- Hidden input to store place details if needed -->
                    <input type="hidden" id="destination-place-details">
                     <div class="w3-text-red w3-small" id="destination-error"></div>
                </div>

                <div class="w3-row-padding">
                    <div class="w3-half">
                         <label class="w3-text-teal"><b>Check-in Date</b></label>
                         <input class="w3-input w3-border w3-round" type="date" id="checkInDate" required data-input-type="date" data-component-name="DateInput" data-date-type="check-in">
                         <div class="w3-text-red w3-small" id="checkInDate-error"></div>
                    </div>
                     <div class="w3-half">
                         <label class="w3-text-teal"><b>Check-out Date</b></label>
                         <input class="w3-input w3-border w3-round" type="date" id="checkOutDate" required data-input-type="date" data-input-name="Check Out Date" data-component-name="DateInput" data-date-type="check-out">
                          <div class="w3-text-red w3-small" id="checkOutDate-error"></div>
                    </div>
                </div>


                <div class="w3-row-padding w3-section">
                    <div class="w3-half">
                         <label class="w3-text-teal"><b>Adults</b></label>
                         <input class="w3-input w3-border w3-round" type="number" id="adults" value="2" min="1" required data-input-type="number" data-component-name="NumberInput">
                         <div class="w3-text-red w3-small" id="adults-error"></div>
                    </div>
                     <div class="w3-half">
                         <label class="w3-text-teal"><b>Children</b></label>
                         <input class="w3-input w3-border w3-round" type="number" id="children" value="0" min="0" required data-input-type="number" data-component-name="NumberInput">
                          <div class="w3-text-red w3-small" id="children-error"></div>
                    </div>
                </div>

                <button class="w3-button w3-teal w3-margin-top w3-round-large" type="submit" id="searchButton">
                     <span id="searchText">Search Hotels</span>
                     <span id="loadingSpinner" class="w3-spin w3-hide">&#10035;</span>
                </button>

            </form>

             <!-- Section for Google Service Integrations (initially hidden) -->
             <div id="googleServicesSection" class="w3-container w3-margin-top w3-padding w3-border w3-round-large w3-hide">
                 <h3>Google Service Integrations (**Simulated**)</h3>
                  <p class="w3-small">Note: These integrations require user consent and backend processing in a real application.</p>
                  <div id="googleAuthArea" class="w3-center w3-margin-bottom">
                       <!-- Placeholder for a potential Google Sign-In button -->
                       <button class="w3-button w3-white w3-border w3-round-large" id="googleSignInButton">
                            <img src="https://www.google.com/images/brands/googleg/android_gradient_64dp.png" alt="Google logo" style="width:18px; margin-right:8px;">
                           <span id="googleAuthText">Sign in with Google (Simulated)</span>
                       </button>
                       <div id="googleAuthStatus" class="w3-small w3-margin-top w3-text-grey">Status: Not attempted</div>
                  </div>

                 <p class="w3-text-grey w3-small">Actions available after searching:</p>
                 <div class="w3-row-padding w3-center">
                     <div class="w3-col s6">
                         <button class="w3-button w3-blue w3-round-large w3-block" id="addToCalendarButton" disabled>
                             <i class="fa fa-calendar"></i> Add to Calendar
                         </button>
                     </div>
                     <div class="w3-col s6">
                          <button class="w3-button w3-red w3-round-large w3-block" id="emailSearchDetailsButton" disabled>
                             <i class="fa fa-envelope"></i> Email Details
                         </button>
                     </div>
                 </div>
                 <!-- Placeholder for Google Pay Button -->
                 <div id="googlePayArea" class="w3-center w3-margin-top">
                     <button class="w3-button w3-black w3-round-large" id="googlePayButton" disabled>
                         <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                              <path fill="#5F6368" d="M12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12s5.373 12 12 12zm-1.883-9.883L10.87 11l-2.05-2.05L7.44 10.3l3.43 3.43 6.27-6.26L15.72 6.44 10.117 12.044l-1.49-1.49-.707-.707L9.41 8.172z"/>
                         </svg>
                         Simulated Google Pay
                     </button>
                 </div>
             </div>


            <div id="resultsArea" class="w3-container w3-margin-top w3-text-grey">
                 <!-- Results would typically appear here if using an API, but we are redirecting -->
                <p>Clicking "Search Hotels" will validate inputs, simulate a brief process, track events, and then redirect you to Expedia.com with your search criteria.</p>
                <p>After a successful search, the Google services section will appear, allowing you to test the **simulated** Calendar, Email, and Google Pay integrations.</p>
            </div>

        </div>
    </div>

    <footer class="w3-container w3-teal w3-center w3-padding-32 w3-margin-top">
        <p>&copy; 2023 Expedia Affiliate Demo. Linking via: <a href="https://expedia.com/affiliates/expedia-home.XDIh5Nk" target="_blank" class="w3-text-white w3-hover-text-light-grey">Expedia Affiliate Link</a></p>
         <p class="w3-small">Note: This is a client-side demonstration. Google Places API requires a key. Google Analytics requires a Measurement ID. Google Calendar/Email/Pay integrations are **simulated** and require server-side components and user consent for production use.</p>
    </footer>

    <!-- Font Awesome for icons (optional, but adds visual flair to buttons) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Custom JavaScript -->
    <script src="script.js"></script>

</body>
</html>
```

---

**2. `style.css` (Add minor styles for new elements)**

```css
/* style.css */

body {
    font-family: "Segoe UI", Arial, sans-serif;
}

/* Basic adjustments if needed, W3CSS handles most layout */
.w3-card-4 {
    box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
}

input[type="date"] {
    padding: 8px;
    box-sizing: border-box;
}

/* Style for validation error messages below inputs */
.w3-text-red.w3-small {
    margin-top: 4px; /* Space above the message */
    min-height: 1em; /* Reserve space even when empty to prevent layout shifts */
    display: block; /* Ensure it takes up space */
}

/* Style for the form message panel */
#formMessages {
    margin-bottom: 16px;
    padding: 12px;
    border-radius: 8px;
}
#formMessages.w3-pale-red { border-left: 6px solid #f44336; } /* Error style */
#formMessages.w3-pale-yellow { border-left: 6px solid #ffeb3b; } /* Warning style */
#formMessages.w3-pale-blue { border-left: 6px solid #2196f3; } /* Info style */
#formMessages.w3-pale-green { border-left: 6px solid #4CAF50; } /* Success style */

/* Spinner animation */
.w3-spin {
  animation: w3-spin 2s infinite linear;
}
@keyframes w3-spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(359deg); }
}

/* Hide elements visually but keep them in DOM */
.w3-hide {
    display: none !important;
}

/* Styles for disabled buttons */
button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

/* Style for the Google Services section */
#googleServicesSection {
    margin-top: 24px !important; /* More space */
     border-color: #ddd !important;
     background-color: #f9f9f9;
}

#googleAuthStatus {
    cursor: pointer; /* Indicate clickable for simulation */
     text-decoration: underline;
}
#googleAuthStatus:hover {
    text-decoration: none;
}

#googleSignInButton {
    vertical-align: middle;
     display: inline-flex;
     align-items: center;
     justify-content: center;
}
#googleSignInButton img {
     vertical-align: middle;
}

#googlePayButton svg {
    vertical-align: middle;
     margin-right: 8px;
     fill: white; /* Fill the Google Pay logo */
}
#googlePayButton {
     color: white;
     /* Remove default W3CSS background color */
     background-color: #000 !important; /* Google Pay button color */
}

/* Optional: Add hover/active states */
#googlePayButton:hover:not(:disabled) {
    background-color: #222 !important;
}
#googlePayButton:active:not(:disabled) {
     background-color: #444 !important;
}
```

---

**3. `script.js` (Vastly Expanded)**

```javascript
// script.js

// --- Configuration ---
// Centralized configuration object for easy management of constants and settings.
const AppConfig = {
    // Static property: Affiliate ID (example)
    AFFILIATE_ID: 'XDIh5Nk', // Corresponds to the mcid in the provided URL structure

    // Static property: Base URL for Expedia hotel search results
    BASE_SEARCH_URL: 'https://www.expedia.com/Hotel-Search',

    // App version
    APP_VERSION: '5.0.0', // Increased version number for this major expansion

    // API Keys / IDs (WARNING: Insecure on client-side for sensitive services - for demo only)
    // These are placeholders. Real production requires server-side handling for most.
    GOOGLE_API_KEY_PLACEHOLDER: 'YOUR_GOOGLE_API_KEY', // Keep this placeholder reminder for Places API
    GOOGLE_ANALYTICS_ID_PLACEHOLDER: 'G-XXXXXXXXXX', // GA4 Measurement ID placeholder
    // For simulated Google Auth/Services:
    // In a real app, this would be your OAuth 2.0 Client ID for Web application type, potentially stored more securely.
    GOOGLE_CLIENT_ID_PLACEHOLDER: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com', // Placeholder Client ID for simulation structure

    // Google Pay Configuration (Simulated structure based on real API)
    GOOGLE_PAY: {
        API_VERSION: 2,
        API_VERSION_MINOR: 0,
        ALLOWED_PAYMENT_METHODS: [{
            type: 'CARD',
            parameters: {
                allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'], // Card authentication methods
                allowedCardNetworks: ['AMEX', 'DISCOVER', 'JCB', 'MASTERCARD', 'VISA'] // Card networks
            },
            tokenizationSpecification: {
                type: 'PAYMENT_GATEWAY', // Or 'DIRECT' for server-side handling
                parameters: {
                    gateway: 'example', // Placeholder gateway name (replace with actual)
                    gatewayMerchantId: 'exampleGatewayMerchantId' // Placeholder merchant ID (replace with actual)
                }
            }
        }],
        MERCHANT_INFO: {
            // Merchant ID is required for production environments.
            // The merchant name is used for display in the Google Pay interface.
            // merchantId: 'BCR2DN6SA234GS23', // Placeholder - Replace with your actual Google Pay merchant ID
            merchantName: 'Expedia Affiliate Demo'
        },
        TRANSACTION_INFO: {
            // These would typically be dynamic based on the search result selected (simulated here)
            totalPriceStatus: 'FINAL', // Or 'ESTIMATED'
            totalPrice: '100.00', // Placeholder total price - would be dynamic
            currencyCode: 'USD',
            countryCode: 'US' // Country where the business is registered
        },
        EMAIL_REQUIRED: true, // Whether billing email is required
        BILLING_ADDRESS_REQUIRED: true, // Whether billing address is required
        SHIPPING_ADDRESS_REQUIRED: false, // Not needed for hotel booking
        SHIPPING_SUPPORTED_COUNTRIES: ['US'], // Not needed for hotel booking
        SIMULATED_SUCCESS_RATE: 0.9 // 90% chance of simulated Google Pay success
    },


    // Selectors
    SELECTORS: {
        APP_CONTAINER: '#mainAppContainer', // Example: if the whole app was in a container
        FORM: '#hotelSearchForm',
        INPUT: 'input, select, textarea', // Select relevant form elements
        MESSAGE_AREA: '#formMessages',
        SEARCH_BUTTON: '#searchButton',
        SEARCH_TEXT: '#searchText',
        LOADING_SPINNER: '#loadingSpinner',
        ERROR_MESSAGE_SUFFIX: '-error', // Used to find error message divs by input ID

        // New selectors for Google Services section
        GOOGLE_SERVICES_SECTION: '#googleServicesSection',
        ADD_TO_CALENDAR_BUTTON: '#addToCalendarButton',
        EMAIL_SEARCH_DETAILS_BUTTON: '#emailSearchDetailsButton',
        GOOGLE_PAY_BUTTON: '#googlePayButton', // New selector for Google Pay button
        GOOGLE_AUTH_AREA: '#googleAuthArea', // Area containing sign-in elements
        GOOGLE_SIGN_IN_BUTTON: '#googleSignInButton', // Button to trigger sign-in
        GOOGLE_AUTH_STATUS: '#googleAuthStatus', // Element to display auth status
        GOOGLE_AUTH_TEXT: '#googleAuthText' // Span within the sign-in button
    },

    // Validation Messages
    MESSAGES: {
        REQUIRED: 'This field is required.',
        INVALID_NUMBER: 'Please enter a valid number.',
        NUMBER_MIN: (min) => `Value must be at least ${min}.`,
        NUMBER_MAX: (max) => `Value must be at most ${max}.`,
        DATE_PAST: 'Date cannot be in the past.',
        CHECKOUT_BEFORE_CHECKIN: 'Check-out date must be after check-in date.',
        AUTOCOMPLETE_NO_DETAILS: (value) => `Could not get details for "${value}". Please select from the suggestions.`,
        FORM_INVALID: 'Please fix the errors above before searching.',
        SEARCH_INITIATED: 'Validating form and preparing search...',
        SEARCH_PROCESSING: 'Processing search request...', // Message during simulated async step
        SEARCH_REDIRECT: 'Processing complete. Redirecting to Expedia...',
        SEARCH_ERROR: 'An error occurred during the search process.',
        FATAL_ERROR: 'A critical error occurred. Please try again later.',

        // Google Service Messages
        GOOGLE_AUTH_INIT: 'Initializing Google Sign-In...',
        GOOGLE_AUTH_NEEDED: 'Please sign in with Google first.',
        GOOGLE_AUTH_SIGNING_IN: 'Signing in with Google...',
        GOOGLE_AUTH_SUCCESS: 'Signed in as {email}.', // Use placeholder for email
        GOOGLE_AUTH_FAILED: (err) => `Google Sign-In failed: ${err}`,
        GOOGLE_AUTH_SIGNED_OUT: 'Signed out.',
        GOOGLE_PAY_INIT: 'Initializing Google Pay...',
        GOOGLE_PAY_READY: 'Google Pay is ready.',
        GOOGLE_PAY_NOT_READY: 'Google Pay is not available on this device or browser.',
        GOOGLE_PAY_CLICKED: 'Initiating Google Pay process...',
        GOOGLE_PAY_PROCESSING: 'Processing payment with Google Pay...',
        GOOGLE_PAY_SUCCESS: 'Payment processed successfully!',
        GOOGLE_PAY_FAILED: (err) => `Google Pay failed: ${err}`,
        CALENDAR_ADD_INIT: 'Preparing to add event to Google Calendar...',
        CALENDAR_ADD_PROCESSING: 'Adding event to Google Calendar...',
        CALENDAR_ADD_SUCCESS: 'Event added to Google Calendar successfully!',
        CALENDAR_ADD_FAILED: (err) => `Failed to add event to Google Calendar: ${err}`,
        EMAIL_SEND_INIT: 'Preparing email with search details...',
        EMAIL_SEND_PROCESSING: 'Sending email...',
        EMAIL_SEND_SUCCESS: 'Email sent successfully!',
        EMAIL_SEND_FAILED: (err) => `Failed to send email: ${err}`,
        NO_SEARCH_DATA_FOR_ACTION: 'No search data available to perform this action. Please search first.'
    },

    // Timers/Delays
    VALIDATION_DELAY_MS: 150, // Delay for autocomplete blur validation
    MESSAGE_DISPLAY_DURATION_MS: 6000, // How long messages stay visible (0 for infinite)
    SIMULATED_ASYNC_DELAY_MS: 1000, // Delay for the main simulated async step
    SIMULATED_GOOGLE_SERVICE_DELAY_MS: 800, // Delay for simulated Google API calls
    GA_REDIRECT_DELAY_MS: 500 // Delay before redirecting after GA tracking attempts
};

// --- Utility Class for Logging ---
// A simple logger class to demonstrate static methods and control logging output.
class Logger {
    // Static property to control if logging is enabled
    static isEnabled = true; // Set to false to disable all logging

    // Static property to control debug logging
    static debugEnabled = true; // Set to false to disable debug logs

    // Static method to get formatted timestamp
    static #getTimestamp() {
         try {
             return new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit' });
         } catch (error) {
             console.error("Error getting timestamp:", error); // Fallback console error
             return 'TIME_ERR';
         }
    }

    // Static method for info logs
    static info(message, ...args) {
        if (Logger.isEnabled) {
            try {
                const timestamp = Logger.#getTimestamp();
                console.log(`%c[INFO] [${timestamp}] ${message}`, 'color: #2196F3;', ...args); // Styled for clarity
            } catch (e) { console.log(`[INFO] ${message}`, ...args); } // Fallback
        }
    }

    // Static method for warning logs
    static warn(message, ...args) {
        if (Logger.isEnabled) {
             try {
                 const timestamp = Logger.#getTimestamp();
                console.warn(`%c[WARN] [${timestamp}] ${message}`, 'color: #ff9800;', ...args); // Styled
             } catch (e) { console.warn(`[WARN] ${message}`, ...args); } // Fallback
        }
    }

    // Static method for error logs
    static error(message, ...args) {
        if (Logger.isEnabled) {
             try {
                 const timestamp = Logger.#getTimestamp();
                console.error(`%c[ERROR] [${timestamp}] ${message}`, 'color: #f44336;', ...args); // Styled
             } catch (e) { console.error(`[ERROR] ${message}`, ...args); } // Fallback
        }
    }

    // Static method for debug logs (can be turned off easily)
    static debug(message, ...args) {
        if (Logger.isEnabled && Logger.debugEnabled) {
             try {
                 const timestamp = Logger.#getTimestamp();
                 console.debug(`%c[DEBUG] [${timestamp}] ${message}`, 'color: #607d8b;', ...args); // Styled
             } catch (e) { console.debug(`[DEBUG] ${message}`, ...args); } // Fallback
        }
    }
}

// --- Google Analytics Tracker ---
// Class to handle sending events to Google Analytics (GA4).
// Demonstrates static methods for utility and instance methods for tracking.
class GoogleAnalyticsTracker {
    #measurementId; // Private member for the GA Measurement ID

    /**
     * Constructor for GoogleAnalyticsTracker.
     * @param {string} measurementId - The GA4 Measurement ID (e.g., 'G-XXXXXXXXXX').
     */
    constructor(measurementId) {
        try {
            Logger.debug(`GoogleAnalyticsTracker constructor called with ID: ${measurementId}`);
            this.#measurementId = measurementId;
            this.#checkGA(); // Check if GA is potentially available
            Logger.debug(`GoogleAnalyticsTracker initialized.`);
        } catch (error) {
             Logger.error(`Error initializing GoogleAnalyticsTracker:`, error);
             // Set measurementId to null or handle the error appropriately
             this.#measurementId = null;
             // Further tracking attempts will fail gracefully via #checkGA
        }
    }

    // Private method to check if the GA gtag function is available globally.
    #checkGA() {
        try {
            if (!this.#measurementId || this.#measurementId === AppConfig.GOOGLE_ANALYTICS_ID_PLACEHOLDER) {
                 Logger.warn(`Google Analytics Measurement ID is not configured or is placeholder. Tracking calls will not send data.`);
                return false;
            }
            if (typeof gtag !== 'function') {
                Logger.warn(`Google Analytics gtag function not found globally. Ensure gtag.js is loaded. Tracking calls will not send data.`);
                return false;
            }
            Logger.debug("Google Analytics gtag function found and Measurement ID is set.");
            return true;
        } catch (error) {
            Logger.error("Error checking Google Analytics availability:", error);
            return false;
        }
    }

    /**
     * Public method to track a generic event.
     * Wraps gtag call in try/catch.
     * @param {string} eventName - The name of the event (e.g., 'search_started').
     * @param {object} [eventParams] - Optional parameters for the event.
     */
    trackEvent(eventName, eventParams = {}) {
        try {
            if (this.#checkGA()) {
                Logger.debug(`Tracking GA Event: "${eventName}"`, eventParams);
                // Ensure eventParams is an object
                const params = typeof eventParams === 'object' && eventParams !== null ? eventParams : {};
                // Add a timestamp parameter for debugging/ordering in GA if needed
                // params.client_timestamp = Date.now();

                // Send event using gtag.
                gtag('event', eventName, {
                     'non_interaction': false, // Set to true if this event shouldn't affect bounce rate
                    ...params // Spread additional parameters
                });
            } else {
                Logger.debug(`GA not available or configured, skipping event tracking: "${eventName}"`);
            }
        } catch (error) {
            Logger.error(`Error tracking GA event "${eventName}":`, error);
            // Error occurred within gtag or parameter processing.
        }
    }

    /**
     * Public method to track a specific step in a funnel.
     * Uses a custom event 'funnel_step' with a 'step_name' parameter.
     * Wraps trackEvent call.
     * @param {string} stepName - The name of the funnel step (e.g., 'validation_success', 'search_executed').
     * @param {object} [additionalParams] - Additional parameters specific to the step.
     */
    trackFunnelStep(stepName, additionalParams = {}) {
         try {
             const eventName = 'funnel_step';
             // Ensure additionalParams is an object
             const params = typeof additionalParams === 'object' && additionalParams !== null ? additionalParams : {};

             const eventParams = {
                'step_name': stepName,
                 ...params
             };
             this.trackEvent(eventName, eventParams);
             Logger.debug(`Tracked funnel step: "${stepName}"`);
         } catch (error) {
             Logger.error(`Error tracking GA funnel step "${stepName}":`, error);
         }
    }

    // Static method example: Check if a valid Measurement ID is configured based on config.
    static isConfigured(measurementId) {
        try {
            return measurementId && measurementId !== AppConfig.GOOGLE_ANALYTICS_ID_PLACEHOLDER;
        } catch (error) {
             Logger.error("Error in GoogleAnalyticsTracker.isConfigured:", error);
             return false; // Defensive: assume not configured if error occurs
        }
    }
}


// --- SIMULATED Google Identity Service (GIS) Wrapper ---
// This class simulates the structure of interacting with the real Google Identity Services library.
// It uses Promises and delays, but does NOT interact with actual Google servers or handle real tokens.
class GoogleIdentityServiceWrapper {
     #clientId; // Private member for the client ID (for show)
     #isSignedIn = false; // Private flag to simulate sign-in status
     #userEmail = null; // Private member to simulate signed-in user's email
     #authStatusElement = null; // Reference to the UI element showing status
     #signInButtonElement = null; // Reference to the sign-in button
     #signInButtonTextElement = null; // Reference to the text inside the sign-in button

    /**
     * Constructor for GoogleIdentityServiceWrapper.
     * @param {string} clientId - The Google OAuth 2.0 Client ID (placeholder).
     * @param {string} authStatusSelector - Selector for the element displaying auth status.
     * @param {string} signInButtonSelector - Selector for the sign-in button element.
     * @param {string} signInButtonTextSelector - Selector for the text span within the sign-in button.
     */
    constructor(clientId, authStatusSelector, signInButtonSelector, signInButtonTextSelector) {
        try {
            Logger.debug(`GoogleIdentityServiceWrapper constructor called with Client ID: ${clientId}`);
            this.#clientId = clientId;
            this.#authStatusElement = document.querySelector(authStatusSelector);
            this.#signInButtonElement = document.querySelector(signInButtonSelector);
            this.#signInButtonTextElement = document.querySelector(signInButtonTextSelector);

            if (!this.#authStatusElement) Logger.warn("Auth status element not found for GIS wrapper.");
            if (!this.#signInButtonElement) Logger.warn("Sign-in button element not found for GIS wrapper.");
            if (!this.#signInButtonTextElement) Logger.warn("Sign-in button text element not found for GIS wrapper.");


            // In a real app, you'd initialize the GIS client here:
            // google.accounts.id.initialize({ client_id: clientId, callback: this.#handleCredentialResponse.bind(this) });
            // google.accounts.id.prompt(); // Optional: show One Tap prompt automatically

            this.#updateUI(); // Initial UI update

            Logger.debug(`GoogleIdentityServiceWrapper initialized.`);
        } catch (error) {
             Logger.error("Error initializing GoogleIdentityServiceWrapper:", error);
             // Ensure state indicates not signed in on error
             this.#isSignedIn = false;
             this.#userEmail = null;
             this.#updateUI(); // Attempt to update UI even on error
             throw error; // Re-throw initialization error
        }
    }

    // Private method to simulate handling a credential response (like the GIS callback)
    #handleCredentialResponse(credentialResponse) {
         try {
            Logger.debug("Simulated credential response received:", credentialResponse);
            // In a real app, you'd send credentialResponse.credential (the ID token)
            // to your backend for verification and user authentication.

            // Simulate parsing user info from the credential (ID token payload)
            // This is highly simplified; real ID token parsing involves decoding JWT.
            const simulatedUser = {
                email: credentialResponse.email || 'simulated.user@gmail.com',
                name: credentialResponse.name || 'Simulated User'
            };

            this.#isSignedIn = true;
            this.#userEmail = simulatedUser.email;
            Logger.info(`Simulated Google Sign-In successful for user: ${this.#userEmail}`);

            this.#updateUI(); // Update UI after sign-in state change
            // You might trigger a custom event here like 'auth:signed_in'

         } catch (error) {
             Logger.error("Error handling simulated credential response:", error);
             this.#isSignedIn = false; // Ensure state is false on error
             this.#userEmail = null;
             this.#updateUI();
         }
    }

    // Public method to simulate triggering the sign-in flow. Returns a Promise.
    async signIn() {
        try {
            Logger.debug("Attempting simulated Google Sign-In...");
            // In a real app, you'd call:
            // google.accounts.id.prompt(); // For One Tap
            // OR trigger a popup/redirect flow associated with a button:
            // google.accounts.id.newFlow(...) or google.accounts.id.renderButton(...)

            this.#updateUI('signing-in'); // Update UI to indicate signing in

            return new Promise((resolve, reject) => {
                // Simulate async sign-in process
                setTimeout(() => {
                    try {
                        // Simulate a random success/failure
                        const success = Math.random() > 0.1; // 90% chance of success

                        if (success) {
                            // Simulate receiving a credential response
                            this.#handleCredentialResponse({
                                credential: 'simulated_id_token_' + Date.now(),
                                // Simulate some payload info (usually parsed from the token)
                                email: 'simulated.user.' + Date.now() + '@gmail.com',
                                name: 'Simulated User ' + Date.now()
                            });
                            resolve({ success: true, message: 'Simulated sign-in successful.', userEmail: this.#userEmail });
                        } else {
                            Logger.warn("Simulated Google Sign-In failed randomly.");
                             this.#isSignedIn = false; // Ensure state is false on simulated failure
                             this.#userEmail = null;
                             this.#updateUI(); // Update UI for failed state
                            reject(new Error('Simulated sign-in failed (e.g., user closed dialog, network issue).'));
                        }
                    } catch (timeoutError) {
                         Logger.error("Error inside simulated sign-in timeout:", timeoutError);
                         this.#isSignedIn = false;
                         this.#userEmail = null;
                         this.#updateUI();
                         reject(new Error(`Internal simulated sign-in error: ${timeoutError.message}`));
                    }
                }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS);
            });
        } catch (error) {
             Logger.error("Error setting up simulated signIn promise:", error);
             this.#updateUI(); // Ensure UI reflects current (likely signed out) state
             throw new Error(`Simulated sign-in setup failed: ${error.message}`); // Re-throw
        }
    }

    // Public method to simulate signing out. Returns a Promise.
    async signOut() {
        try {
            Logger.debug("Attempting simulated Google Sign-Out...");
             if (!this.#isSignedIn) {
                 Logger.debug("Not signed in, simulated sign-out skipped.");
                 this.#updateUI(); // Ensure UI is correct
                 return Promise.resolve({ success: true, message: 'Already signed out.' });
             }

             this.#updateUI('signing-out'); // Indicate signing out

            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        this.#isSignedIn = false;
                        this.#userEmail = null;
                        Logger.info("Simulated Google Sign-Out successful.");
                        this.#updateUI(); // Update UI after state change
                         // You might trigger a custom event here like 'auth:signed_out'
                        resolve({ success: true, message: 'Simulated signed out.' });
                    } catch (timeoutError) {
                        Logger.error("Error inside simulated sign-out timeout:", timeoutError);
                         this.#updateUI();
                         reject(new Error(`Internal simulated sign-out error: ${timeoutError.message}`));
                    }
                }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS / 2); // Shorter delay for sign out
            });
        } catch (error) {
             Logger.error("Error setting up simulated signOut promise:", error);
             this.#updateUI();
             throw new Error(`Simulated sign-out setup failed: ${error.message}`); // Re-throw
        }
    }

    // Private method to update the UI elements related to authentication status.
    #updateUI(state = 'idle') {
         try {
            const statusElement = this.#authStatusElement;
            const signInButton = this.#signInButtonElement;
            const signInButtonText = this.#signInButtonTextElement;

            if (!statusElement || !signInButton || !signInButtonText) {
                 Logger.debug("Auth UI elements not found, skipping UI update.");
                 return; // Cannot update UI if elements are missing
            }

            // Update status text
            if (state === 'signing-in') {
                 statusElement.textContent = AppConfig.MESSAGES.GOOGLE_AUTH_SIGNING_IN;
                 signInButtonText.textContent = '...'; // Indicate button is busy
            } else if (state === 'signing-out') {
                 statusElement.textContent = 'Signing out...'; // Use a simpler message for signing out
                 signInButtonText.textContent = '...';
            } else { // idle state (signed in or signed out)
                 statusElement.textContent = this.#isSignedIn
                    ? AppConfig.MESSAGES.GOOGLE_AUTH_SUCCESS.replace('{email}', this.#userEmail)
                    : AppConfig.MESSAGES.GOOGLE_AUTH_SIGNED_OUT;

                 signInButtonText.textContent = this.#isSignedIn ? 'Sign out (Simulated)' : 'Sign in with Google (Simulated)';
            }

            // Update button state (enable/disable)
            // Button is disabled during signing in/out process
            const buttonDisabled = state === 'signing-in' || state === 'signing-out';
            if (signInButton.disabled !== buttonDisabled) { // Avoid unnecessary DOM updates
                 signInButton.disabled = buttonDisabled;
                 Logger.debug(`Sign-in button disabled: ${buttonDisabled}`);
            }

            // Add a class to the button to indicate signed in state for styling
             if (this.#isSignedIn) {
                 signInButton.classList.add('signed-in'); // Custom class for styling
             } else {
                 signInButton.classList.remove('signed-in');
             }

             Logger.debug("Auth UI updated to state:", state, `(Signed in: ${this.#isSignedIn})`);

         } catch (error) {
             Logger.error("Error updating auth UI:", error);
         }
    }


    /**
     * Public method to check simulated sign-in status.
     * @returns {boolean} - True if user is simulated signed in, false otherwise.
     */
    isSignedIn() {
         try {
            return this.#isSignedIn;
         } catch (error) {
             Logger.error("Error checking simulated isSignedIn status:", error);
             return false; // Assume not signed in if error occurs
         }
    }

    /**
     * Public method to get the simulated signed-in user's email.
     * @returns {string|null} - The user's email if signed in, null otherwise.
     */
    getUserEmail() {
        try {
            return this.#userEmail;
        } catch (error) {
            Logger.error("Error getting simulated user email:", error);
            return null;
        }
    }

    // Public method to trigger the sign-in/out toggle via the UI element
    async handleAuthToggleClick() {
         try {
             Logger.debug("Auth toggle clicked via handleAuthToggleClick.");
             if (this.#isSignedIn) {
                 // Simulate sign out
                 this.#updateUI('signing-out'); // Indicate signing out immediately
                 await this.signOut();
             } else {
                 // Simulate sign in
                 this.#updateUI('signing-in'); // Indicate signing in immediately
                 await this.signIn();
             }
             // UI is updated within signIn/signOut and #handleCredentialResponse
         } catch (error) {
             Logger.error("Error handling auth toggle click:", error);
             // Specific error message handled by signIn/signOut, but update UI to reflect failure state
             this.#updateUI();
         }
    }

     // Dispose method for cleanup (if needed in complex SPAs)
     dispose() {
         try {
             Logger.debug("Disposing GoogleIdentityServiceWrapper.");
             // In a real GIS app, you might need to revoke tokens or clear state.
             // For this simulation, clearing references is sufficient.
             this.#authStatusElement = null;
             this.#signInButtonElement = null;
             this.#signInButtonTextElement = null;
             Logger.debug("GoogleIdentityServiceWrapper disposed.");
         } catch (error) {
             Logger.error("Error disposing GoogleIdentityServiceWrapper:", error);
         }
     }
}


// --- SIMULATED Google Calendar Service ---
// This class simulates creating a calendar event using Promises and delays.
// It depends on the SimulatedGoogleAuth for sign-in status.
// It does NOT use the actual Google Calendar API.
class SimulatedGoogleCalendarService {
    #auth; // Private member to hold a reference to the simulated auth service
    #simulatedSuccessRate; // Success rate for simulated API calls

    /**
     * Constructor for SimulatedGoogleCalendarService.
     * @param {GoogleIdentityServiceWrapper} authService - An instance of the simulated auth service wrapper.
     * @param {number} simulatedSuccessRate - The probability (0-1) of a simulated API call succeeding.
     */
    constructor(authService, simulatedSuccessRate = 0.8) { // Default 80% success
        try {
            Logger.debug(`SimulatedGoogleCalendarService constructor called with success rate: ${simulatedSuccessRate}`);
            if (!authService) {
                 Logger.error("Auth service not provided to SimulatedGoogleCalendarService.");
                 throw new Error("Auth service is required for Calendar service simulation.");
            }
            this.#auth = authService;
            this.#simulatedSuccessRate = simulatedSuccessRate;
            Logger.debug(`SimulatedGoogleCalendarService initialized.`);
        } catch (error) {
             Logger.error("Error initializing SimulatedGoogleCalendarService:", error);
             throw error; // Re-throw initialization errors
        }
    }

    /**
     * Public method to simulate creating a calendar event.
     * Requires user to be signed in via the linked auth service. Returns a Promise.
     * @param {object} eventDetails - Details for the calendar event (summary, start, end, etc.).
     * @returns {Promise<object>} A promise that resolves with success details or rejects with an error.
     */
    async createEvent(eventDetails) {
        try {
            Logger.debug("Attempting to simulate creating calendar event...", eventDetails);

            if (!this.#auth || !this.#auth.isSignedIn()) {
                Logger.warn("User is not signed in via auth service, cannot simulate calendar event creation.");
                // Reject immediately if auth service is missing or user is not signed in
                throw new Error(AppConfig.MESSAGES.GOOGLE_AUTH_NEEDED);
            }

            // Validate event details structure (basic checks)
            if (!eventDetails || typeof eventDetails !== 'object' || !eventDetails.summary || !eventDetails.start || !eventDetails.end) {
                 const errorMsg = "Invalid event details provided for simulated calendar creation.";
                 Logger.error(errorMsg, eventDetails);
                 throw new Error(errorMsg);
            }
             // Further date validation (simple check for required date strings)
             if (!eventDetails.start.date || typeof eventDetails.start.date !== 'string' || !eventDetails.end.date || typeof eventDetails.end.date !== 'string') {
                  const errorMsg = "Calendar event start/end dates must be valid string formats (e.g., YYYY-MM-DD).";
                 Logger.error(errorMsg, eventDetails);
                 throw new Error(errorMsg);
             }


            // Simulate async API call using a Promise and timeout
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // Simulate a random success/failure based on the configured rate
                        const success = Math.random() < this.#simulatedSuccessRate;

                        if (success) {
                            Logger.info("Simulated calendar event created successfully.");
                            // Simulate returning some data like event ID from the API response
                            resolve({ success: true, eventId: 'simulated_event_id_' + Date.now(), htmlLink: 'https://calendar.google.com/' }); // Simulate a link
                        } else {
                            Logger.warn("Simulated calendar event creation failed randomly.");
                             // Simulate different types of API errors
                             const apiErrors = [
                                 'Simulated Calendar API quota exceeded.',
                                 'Simulated Calendar permissions denied.',
                                 'Simulated network error during Calendar API call.',
                                 'Simulated invalid event data error.',
                                 'Simulated backend processing error.'
                             ];
                             const randomErrorMsg = apiErrors[Math.floor(Math.random() * apiErrors.length)];
                            reject(new Error(`Simulated calendar API error: ${randomErrorMsg}`));
                        }
                    } catch (timeoutError) {
                        // Catch errors that might occur *inside* the timeout function
                         Logger.error("Error within simulated createEvent timeout function:", timeoutError);
                         reject(new Error(`Internal simulated calendar error: ${timeoutError.message}`)); // Reject the promise
                    }
                }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS);
            });
        } catch (error) {
             // Catch errors before the timeout, e.g., invalid details or not signed in
             Logger.error(`Error before simulated createEvent async process:`, error);
             throw new Error(`Simulated calendar event failed: ${error.message}`); // Re-throw with context
        }
    }

    // Example of another simulated Calendar method (async)
    async listCalendars() {
        try {
            Logger.debug("Attempting to simulate listing calendars...");
             if (!this.#auth || !this.#auth.isSignedIn()) {
                 Logger.warn("User is not signed in, cannot simulate listing calendars.");
                 throw new Error(AppConfig.MESSAGES.GOOGLE_AUTH_NEEDED);
             }
             // Simulate async API call
             return new Promise(resolve => {
                 setTimeout(() => {
                     try {
                         const simulatedCalendars = [
                             { id: 'primary', summary: 'Primary Calendar (Simulated)' },
                             { id: 'travel', summary: 'Travel Plans (Simulated)' },
                             { id: 'other', summary: 'Other Calendar (Simulated)' }
                         ];
                         Logger.info("Simulated calendar list fetched.");
                         resolve({ success: true, calendars: simulatedCalendars });
                     } catch (timeoutError) {
                         Logger.error("Error inside simulated listCalendars timeout:", timeoutError);
                         // In a real scenario, this timeout should reject.
                         resolve({ success: false, error: 'Simulated internal error' }); // Resolve with error flag for this demo
                     }
                 }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS / 2); // Shorter delay
             });
        } catch (error) {
            Logger.error("Error during simulated listCalendars setup:", error);
            throw new Error(`Simulated calendar list failed: ${error.message}`);
        }
    }

     // Dispose method (if needed)
     dispose() {
         try {
             Logger.debug("Disposing SimulatedGoogleCalendarService.");
             this.#auth = null; // Clear reference
             Logger.debug("SimulatedGoogleCalendarService disposed.");
         } catch (error) {
              Logger.error("Error disposing SimulatedGoogleCalendarService:", error);
         }
     }
}

// --- SIMULATED Google Email Service ---
// This class simulates sending an email using Promises and delays.
// It depends on the SimulatedGoogleAuth for sign-in status.
// It does NOT use the actual Gmail API or send real emails.
class SimulatedGoogleEmailService {
     #auth; // Private member to hold a reference to the simulated auth service
     #simulatedSuccessRate; // Success rate for simulated API calls

    /**
     * Constructor for SimulatedGoogleEmailService.
     * @param {GoogleIdentityServiceWrapper} authService - An instance of the simulated auth service wrapper.
     * @param {number} simulatedSuccessRate - The probability (0-1) of a simulated API call succeeding.
     */
    constructor(authService, simulatedSuccessRate = 0.85) { // Default 85% success
         try {
            Logger.debug(`SimulatedGoogleEmailService constructor called with success rate: ${simulatedSuccessRate}`);
            if (!authService) {
                 Logger.error("Auth service not provided to SimulatedGoogleEmailService.");
                 throw new Error("Auth service is required for Email service simulation.");
            }
            this.#auth = authService;
             this.#simulatedSuccessRate = simulatedSuccessRate;
            Logger.debug(`SimulatedGoogleEmailService initialized.`);
         } catch (error) {
             Logger.error("Error initializing SimulatedGoogleEmailService:", error);
             throw error; // Re-throw initialization errors
         }
    }

    /**
     * Public method to simulate sending an email.
     * Requires user to be signed in via the linked auth service. Returns a Promise.
     * @param {object} emailDetails - Details for the email (to, subject, body).
     * @returns {Promise<object>} A promise that resolves with success details or rejects with an error.
     */
    async sendEmail(emailDetails) {
        try {
            Logger.debug("Attempting to simulate sending email...", emailDetails);

            if (!this.#auth || !this.#auth.isSignedIn()) {
                Logger.warn("User is not signed in via auth service, cannot simulate sending email.");
                throw new Error(AppConfig.MESSAGES.GOOGLE_AUTH_NEEDED);
            }

             // Validate email details structure (basic checks)
            if (!emailDetails || typeof emailDetails !== 'object' || !emailDetails.to || !emailDetails.subject || !emailDetails.body) {
                 const errorMsg = "Invalid email details provided for simulated email sending.";
                 Logger.error(errorMsg, emailDetails);
                 throw new Error(errorMsg);
            }
             // Basic email format validation (optional)
             if (typeof emailDetails.to !== 'string' || !/\S+@\S+\.\S+/.test(emailDetails.to)) {
                  const errorMsg = `Invalid recipient email format: "${emailDetails.to}".`;
                 Logger.error(errorMsg);
                 throw new Error(errorMsg);
             }


            // Simulate async API call using a Promise and timeout
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                     try {
                         // Simulate a random success/failure based on the configured rate
                         const success = Math.random() < this.#simulatedSuccessRate;

                         if (success) {
                             Logger.info("Simulated email sent successfully.");
                              // Simulate returning some data like message ID from the API response
                             resolve({ success: true, messageId: 'simulated_message_id_' + Date.now() });
                         } else {
                             Logger.warn("Simulated email sending failed randomly.");
                             // Simulate different types of API errors
                              const apiErrors = [
                                 'Simulated Gmail API quota exceeded.',
                                 'Simulated Gmail permissions denied.',
                                 'Simulated network error during Gmail API call.',
                                 'Simulated invalid recipient error.',
                                 'Simulated spam filter rejection.'
                             ];
                             const randomErrorMsg = apiErrors[Math.floor(Math.random() * apiErrors.length)];
                             reject(new Error(`Simulated Gmail API error: ${randomErrorMsg}`));
                         }
                     } catch (timeoutError) {
                          Logger.error("Error inside simulated sendEmail timeout function:", timeoutError);
                          reject(new Error(`Internal simulated email error: ${timeoutError.message}`));
                     }
                }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS);
            });
        } catch (error) {
             // Catch errors before the timeout, e.g., invalid details or not signed in
             Logger.error(`Error before simulated sendEmail async process:`, error);
             throw new Error(`Simulated email failed to send: ${error.message}`); // Re-throw with context
        }
    }

     // Dispose method (if needed)
     dispose() {
         try {
             Logger.debug("Disposing SimulatedGoogleEmailService.");
             this.#auth = null; // Clear reference
             Logger.debug("SimulatedGoogleEmailService disposed.");
         } catch (error) {
              Logger.error("Error disposing SimulatedGoogleEmailService:", error);
         }
     }
}

// --- SIMULATED Google Pay Service ---
// This class simulates the structure of interacting with the real Google Pay API.
// It uses Promises and delays, but does NOT interact with actual Google servers or handle real payments.
class GooglePayServiceWrapper {
    #paymentsClient; // Placeholder for the real PaymentsClient object (or a simulated one)
    #isReady = false; // Private flag to simulate readiness
    #simulatedSuccessRate; // Success rate for simulated payment

    /**
     * Constructor for GooglePayServiceWrapper.
     * @param {object} googlePayConfig - Configuration object for Google Pay (from AppConfig).
     * @param {number} simulatedSuccessRate - The probability (0-1) of a simulated payment succeeding.
     */
    constructor(googlePayConfig, simulatedSuccessRate = 0.9) { // Default 90% success
        try {
            Logger.debug(`GooglePayServiceWrapper constructor called with success rate: ${simulatedSuccessRate}`);
            this.#simulatedSuccessRate = simulatedSuccessRate;

            // In a real app, you would initialize the PaymentsClient here:
            // this.#paymentsClient = new google.payments.api.PaymentsClient({ environment: 'TEST' }); // Or 'PRODUCTION'

            // Simulate the isReadyToPay check async
             this.#simulateIsReadyToPay(); // Call private async method

            Logger.debug(`GooglePayServiceWrapper initialized.`);
        } catch (error) {
             Logger.error("Error initializing GooglePayServiceWrapper:", error);
             // Ensure state indicates not ready on error
             this.#isReady = false;
             throw error; // Re-throw initialization error
        }
    }

    // Private async method to simulate checking if Google Pay is ready.
    async #simulateIsReadyToPay() {
        try {
             Logger.debug("Simulating isReadyToPay check...");
            // Simulate async check (like a real API call might be)
            await new Promise(resolve => setTimeout(resolve, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS / 4)); // Shorter delay

            // Simulate success/failure of readiness check (e.g., based on device/browser support)
             const simulateReady = Math.random() > 0.05; // 95% chance of being ready in simulation

            this.#isReady = simulateReady;
            Logger.info(`Simulated Google Pay ready status: ${this.#isReady}`);
            // You might trigger a custom event here like 'googlepay:ready' or 'googlepay:notready'

             // In a real app, after check, you might render the Google Pay button if ready.
             // If ready, you'd find the placeholder div and use:
             // this.#paymentsClient.createIsReadyToPayRequest(this.#getBaseCardPaymentMethod())
             // .then(response => { if (response.result) { /* Render button */ } })
             // .catch(error => { /* Handle error */ });


        } catch (error) {
             Logger.error("Error during simulated isReadyToPay check:", error);
             this.#isReady = false; // Ensure state is false on error
        }
    }

    /**
     * Public method to check the simulated readiness status.
     * @returns {boolean} - True if Google Pay is simulated ready, false otherwise.
     */
    isReady() {
         try {
             return this.#isReady;
         } catch (error) {
             Logger.error("Error checking simulated Google Pay ready status:", error);
             return false; // Assume not ready on error
         }
    }

    /**
     * Public method to simulate triggering the Google Pay payment flow.
     * Requires readiness. Returns a Promise.
     * @param {object} paymentDataRequest - Simulated PaymentDataRequest object (structure based on real API).
     * @returns {Promise<object>} A promise that resolves with simulated PaymentData or rejects with an error.
     */
    async loadPaymentData(paymentDataRequest) {
        try {
            Logger.debug("Attempting to simulate loadPaymentData...", paymentDataRequest);

            if (!this.#isReady) {
                Logger.warn("Simulated Google Pay is not ready, cannot simulate payment flow.");
                throw new Error(AppConfig.MESSAGES.GOOGLE_PAY_NOT_READY);
            }

             // Basic validation of the request structure (simplified)
            if (!paymentDataRequest || typeof paymentDataRequest !== 'object' || !paymentDataRequest.apiVersion || !paymentDataRequest.apiVersionMinor || !paymentDataRequest.allowedPaymentMethods || !paymentDataRequest.transactionInfo) {
                 const errorMsg = "Invalid simulated payment data request provided.";
                 Logger.error(errorMsg, paymentDataRequest);
                 throw new Error(errorMsg);
            }
             // Further validation could check required fields in transactionInfo etc.


            // In a real app, you'd call:
            // return this.#paymentsClient.loadPaymentData(paymentDataRequest);

            // Simulate async payment process
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                         // Simulate a random success/failure based on the configured rate
                         const success = Math.random() < this.#simulatedSuccessRate;

                         if (success) {
                             Logger.info("Simulated Google Pay payment processed successfully.");
                             // Simulate returning a PaymentData object (structure based on real API)
                             const simulatedPaymentData = {
                                 apiVersion: AppConfig.GOOGLE_PAY.API_VERSION,
                                 apiVersionMinor: AppConfig.GOOGLE_PAY.API_VERSION_MINOR,
                                 paymentMethodData: {
                                     description: 'Simulated Visa ending in 1234', // Example
                                     tokenizationData: {
                                         type: 'PAYMENT_GATEWAY',
                                         token: 'simulated_payment_token_' + Date.now() // Simulated payment token
                                     },
                                     type: 'CARD'
                                 },
                                 shippingAddress: paymentDataRequest.shippingAddressRequired ? {
                                     name: 'Simulated Shipping', address1: '123 Simulated St', locality: 'Simulated City', administrativeArea: 'SC', postalCode: '12345', countryCode: 'US'
                                 } : undefined,
                                 billingData: paymentDataRequest.billingAddressRequired ? {
                                     name: 'Simulated Billing', address1: '123 Simulated St', locality: 'Simulated City', administrativeArea: 'SC', postalCode: '12345', countryCode: 'US'
                                 } : undefined,
                                  email: paymentDataRequest.emailRequired ? 'simulated.buyer@example.com' : undefined, // Simulate email if required
                             };
                             resolve(simulatedPaymentData);
                         } else {
                             Logger.warn("Simulated Google Pay payment failed randomly.");
                             // Simulate different types of payment errors
                             const paymentErrors = [
                                 'Simulated payment cancelled by user.',
                                 'Simulated card declined.',
                                 'Simulated network error during payment.',
                                 'Simulated processor error.'
                             ];
                              const randomErrorMsg = paymentErrors[Math.floor(Math.random() * paymentErrors.length)];
                             // Real API error objects are more complex, just using Error for simulation
                            reject(new Error(`Simulated Google Pay error: ${randomErrorMsg}`));
                         }
                    } catch (timeoutError) {
                         Logger.error("Error inside simulated loadPaymentData timeout function:", timeoutError);
                         reject(new Error(`Internal simulated Google Pay error: ${timeoutError.message}`));
                    }
                }, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS);
            });

        } catch (error) {
             // Catch errors before the timeout, e.g., not ready, invalid request
             Logger.error(`Error before simulated loadPaymentData async process:`, error);
             throw new Error(`Simulated Google Pay failed: ${error.message}`); // Re-throw with context
        }
    }

    /**
     * Protected method to construct a simulated base card payment method object.
     * Structure based on Google Pay API documentation.
     */
    #getBaseCardPaymentMethod() {
         try {
            return {
                type: 'CARD',
                parameters: {
                    allowedAuthMethods: AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0].parameters.allowedAuthMethods,
                    allowedCardNetworks: AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0].parameters.allowedCardNetworks
                }
            };
         } catch (error) {
             Logger.error("Error creating base card payment method:", error);
             return null; // Return null if config is invalid
         }
    }

    /**
     * Protected method to construct a simulated PaymentDataRequest object.
     * Structure based on Google Pay API documentation.
     * @param {object} transactionInfo - Details about the transaction (price, currency, etc.).
     * @returns {object|null} - The simulated PaymentDataRequest object or null if configuration is invalid.
     */
    _createPaymentDataRequest(transactionInfo) {
        try {
            if (!transactionInfo || typeof transactionInfo !== 'object' || !transactionInfo.totalPrice || !transactionInfo.currencyCode) {
                Logger.error("Invalid transaction info provided for PaymentDataRequest.");
                 // Use default transaction info from config if dynamic info is missing
                 transactionInfo = AppConfig.GOOGLE_PAY.TRANSACTION_INFO;
                 Logger.warn("Using default transaction info from AppConfig.");
                 // Check defaults too
                 if (!transactionInfo || !transactionInfo.totalPrice || !transactionInfo.currencyCode) {
                      Logger.error("Default transaction info in AppConfig is also invalid.");
                      return null; // Cannot create request
                 }
            }

            // Get the tokenization specification from config (assuming the first one for CARD type)
            const cardPaymentMethod = AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS.find(method => method.type === 'CARD');
            if (!cardPaymentMethod || !cardPaymentMethod.tokenizationSpecification) {
                 Logger.error("Card payment method or tokenization specification missing in AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS.");
                 return null; // Cannot create request without required config
            }
            const tokenizationSpecification = cardPaymentMethod.tokenizationSpecification;


             // Construct the PaymentDataRequest object structure
             const paymentDataRequest = {
                 apiVersion: AppConfig.GOOGLE_PAY.API_VERSION,
                 apiVersionMinor: AppConfig.GOOGLE_PAY.API_VERSION_MINOR,
                 allowedPaymentMethods: [{
                     type: 'CARD', // Only requesting card payments in this example
                     parameters: {
                         allowedAuthMethods: cardPaymentMethod.parameters.allowedAuthMethods,
                         allowedCardNetworks: cardPaymentMethod.parameters.allowedCardNetworks,
                         billingAddressRequired: AppConfig.GOOGLE_PAY.BILLING_ADDRESS_REQUIRED,
                         billingAddressParameters: {
                            format: 'FULL' // Or 'MIN'
                         }
                     },
                     tokenizationSpecification: tokenizationSpecification
                 }],
                 transactionInfo: transactionInfo, // Use the dynamic or default transaction info
                 merchantInfo: AppConfig.GOOGLE_PAY.MERCHANT_INFO,
                 emailRequired: AppConfig.GOOGLE_PAY.EMAIL_REQUIRED,
                 shippingAddressRequired: AppConfig.GOOGLE_PAY.SHIPPING_ADDRESS_REQUIRED,
                 // shippingAddressParameters: { supportedCountries: AppConfig.GOOGLE_PAY.SHIPPING_SUPPORTED_COUNTRIES }, // Only needed if shipping required
             };

            Logger.debug("Created simulated PaymentDataRequest:", paymentDataRequest);
            return paymentDataRequest;

        } catch (error) {
             Logger.error("Error creating simulated PaymentDataRequest:", error);
             return null; // Return null on error
        }
    }


     // Dispose method (if needed)
     dispose() {
         try {
             Logger.debug("Disposing GooglePayServiceWrapper.");
             // In a real app, you might need to clear the PaymentsClient reference.
             this.#paymentsClient = null; // Clear reference
             Logger.debug("GooglePayServiceWrapper disposed.");
         } catch (error) {
              Logger.error("Error disposing GooglePayServiceWrapper:", error);
         }
     }
}


// --- Base Class for any UI Component ---
// Demonstrates private members, protected members (convention), and a static property/method.
class TravelComponent {
    // # prefix denotes a true private member (ES2022+) - cannot be accessed outside the class.
    #componentId;
    #componentName; // Adding a private name for clarity

    // _ prefix denotes a protected member (convention, not enforced by JS) - intended for internal or subclass use.
    _element;
    _isValid = true; // Track validation state (initialized to true)
    _eventHandlers = {}; // Protected property to store event handler references for cleanup

    // Static property - belongs to the class itself, not an instance.
    static APP_VERSION = AppConfig.APP_VERSION;

    // Static method - belongs to the class itself.
    static logAppVersion() {
        Logger.info(`App Version: ${TravelComponent.APP_VERSION}`);
    }

    /**
     * Constructor for the base component.
     * @param {string} elementId - The ID of the HTML element the component wraps.
     * @param {string} componentName - A name for this component instance.
     */
    constructor(elementId, componentName = 'TravelComponent') {
         try {
            Logger.debug(`TravelComponent constructor called for ID "${elementId}" as "${componentName}"`);
            // Private members initialized in the constructor.
            this.#componentId = elementId;
            this.#componentName = componentName;

            // Protected member initialization.
            this._element = document.getElementById(this.#componentId);

            if (!this._element) {
                Logger.error(`Element with ID "${this.#componentId}" not found for ${this.#componentName}. Component may not function.`);
                // Handle the error - maybe disable the component or throw?
                // For this demo, we log and _element will be null.
                this._isValid = false; // Mark component as invalid if element is missing
            } else {
                 Logger.debug(`Component "${this.#componentName}" wrapped element ID: "${this.#componentId}"`);
                 this._initialize(); // Call a protected initialization method
            }
             Logger.debug(`TravelComponent constructor finished for "${this.#componentName}".`);
         } catch (error) {
             Logger.error(`Error in TravelComponent constructor for "${componentName}" (ID: "${elementId}"):`, error);
             // Ensure element is null and isValid is false if constructor failed
             this._element = null;
             this._isValid = false;
         }
    }

    // Private method - only accessible within this class.
    #getComponentInfo() {
         try {
            return `Name: ${this.#componentName}, ID: ${this.#componentId}`;
         } catch (error) {
             Logger.error("Error in #getComponentInfo:", error);
             return "Component Info Error";
         }
    }

    // Protected method (convention) - intended for use by the class and its subclasses.
    // Can be overridden by subclasses (polymorphism).
    _initialize() {
        try {
            Logger.debug(`_initialize called for ${this.#getComponentInfo()}`);
            // Common initialization logic can go here.
            // Example: Setting up base event listeners or state.
        } catch (error) {
            Logger.error(`Error in _initialize for ${this.#getComponentInfo()}:`, error);
        }
    }

    // Protected method (convention) - Placeholder for validation logic.
    // This method will be overridden by subclasses (polymorphism).
    _validate() {
        try {
            Logger.debug(`_validate called for ${this.#getComponentInfo()} (Base class).`);
            this._isValid = true; // Assume valid in base class validation
            return this._isValid;
        } catch (error) {
            Logger.error(`Error in _validate for ${this.#getComponentInfo()}:`, error);
             this._isValid = false; // Validation failed due to error
             return false;
        }
    }

    /**
     * Protected method to add an event listener and store its reference for cleanup.
     * Can attach to the component's _element or a specific targetElement.
     * @param {string} eventType - The type of event (e.g., 'click', 'change').
     * @param {function} handler - The event handler function. 'this' will be bound to the component instance.
     * @param {object} [options] - Event listener options (e.g., { capture: true, once: true, passive: true }).
     * @param {HTMLElement} [options.element] - Specific element to attach the listener to (defaults to component's _element).
     */
    _addEventListener(eventType, handler, options = {}) {
        try {
            const targetElement = options.element || this._element; // Use provided element or component's element
            if (!targetElement) {
                Logger.warn(`Cannot add "${eventType}" listener: Target element not found for ${this.#getComponentInfo()}.`);
                return;
            }

            // Ensure handler is a function
            if (typeof handler !== 'function') {
                 Logger.error(`Cannot add "${eventType}" listener: Handler is not a function for ${this.#getComponentInfo()}.`, handler);
                 return;
            }

            const boundHandler = handler.bind(this); // Bind 'this' to the component instance
            targetElement.addEventListener(eventType, boundHandler, options);

            // Store the handler reference for cleanup, mapping by element and type
            const elementId = targetElement.id || 'no-id'; // Use element ID or 'no-id'
            if (!this._eventHandlers[elementId]) {
                 this._eventHandlers[elementId] = {};
            }
            if (!this._eventHandlers[elementId][eventType]) {
                 this._eventHandlers[elementId][eventType] = [];
            }
            // Store the original handler too, might be useful for debugging
            this._eventHandlers[elementId][eventType].push({ handler: boundHandler, originalHandler: handler, options: options, targetElement: targetElement });
             Logger.debug(`Added "${eventType}" listener for ${this.#getComponentInfo()} on element ID "${elementId}".`);
        } catch (error) {
            Logger.error(`Error adding event listener for ${this.#getComponentInfo()} (type "${eventType}"):`, error);
        }
    }

     /**
      * Protected method to remove all stored event listeners (for cleanup, e.g., component destruction)
      */
     _removeEventListeners() {
         try {
             Logger.debug(`Removing all event listeners for ${this.#getComponentInfo()}...`);
             for (const elementId in this._eventHandlers) {
                 if (Object.prototype.hasOwnProperty.call(this._eventHandlers, elementId)) {
                     const elementEventTypes = this._eventHandlers[elementId];
                     for (const eventType in elementEventTypes) {
                         if (Object.prototype.hasOwnProperty.call(elementEventTypes, eventType)) {
                             elementEventTypes[eventType].forEach(({ handler, options, targetElement }) => {
                                 try {
                                     if (targetElement) { // Ensure element still exists before trying to remove
                                         targetElement.removeEventListener(eventType, handler, options);
                                         Logger.debug(`Removed "${eventType}" listener for ${this.#getComponentInfo()} from element ID "${elementId}".`);
                                     } else {
                                         Logger.warn(`Cannot remove listener for ${this.#getComponentInfo()} (type "${eventType}"): Target element (ID "${elementId}") no longer exists.`);
                                     }
                                 } catch (removeError) {
                                     Logger.error(`Error removing specific listener (type "${eventType}", element ID "${elementId}") for ${this.#getComponentInfo()}:`, removeError);
                                 }
                             });
                         }
                     }
                 }
             }
             this._eventHandlers = {}; // Clear stored handlers
             Logger.debug(`All event listeners removed for ${this.#getComponentInfo()}.`);
         } catch (error) {
             Logger.error(`Error removing event listeners for ${this.#getComponentInfo()}:`, error);
         }
     }


    /**
     * Public method to get the wrapped HTML element.
     * @returns {HTMLElement|null} - The element or null if not found.
     */
    getElement() {
        try {
            return this._element;
        } catch (error) {
            Logger.error(`Error getting element for ${this.#getComponentInfo()}:`, error);
            return null;
        }
    }

    /**
     * Public getter for the component ID.
     * @returns {string|null} - The ID or null if error.
     */
    get id() {
        try {
            return this.#componentId;
        } catch (error) {
             Logger.error("Error getting component ID:", error);
             return null;
        }
    }

    /**
     * Public getter for the component name.
     * @returns {string} - The name.
     */
    get name() {
         try {
             return this.#componentName;
         } catch (error) {
             Logger.error("Error getting component name:", error);
             return 'UnknownComponent';
         }
    }

    /**
     * Public getter for validation status.
     * @returns {boolean} - True if valid, false otherwise or if element missing.
     */
    get isValid() {
        try {
            // Return false if the wrapped HTML element was never found during initialization.
            if (!this._element) return false;
            // Otherwise, return the internal validation state.
            return this._isValid;
        } catch (error) {
             Logger.error(`Error getting isValid status for ${this.name}:`, error);
             return false; // Assume invalid if error occurs
        }
    }

    /**
     * Public method to trigger validation explicitly.
     * Calls the protected _validate method.
     * @returns {boolean} - True if validation passed, false otherwise.
     */
    validate() {
        try {
            if (!this._element) {
                this._isValid = false; // Cannot validate if element is null
                Logger.warn(`Validation called on ${this.name} but element is null.`);
                return false;
            }
            Logger.debug(`Public validate() called for ${this.name}`);
            // Call the protected (or overridden) validation method.
            // Update the protected _isValid property based on the result.
            this._isValid = this._validate();

             // After validation, ensure the native validity is set correctly
             // so checkValidity() on the form works. The _validate method (or its overrides)
             // should be responsible for calling _setErrorMessage() or _clearErrorMessage(),
             // which manage the element's setCustomValidity().
             // Optionally call reportValidity() here to show native messages immediately on explicit validate().
             // if (this._element && !this._isValid) { // Only report if invalid
             //     this._element.reportValidity();
             // }

            Logger.debug(`${this.name} public validate() result: ${this._isValid}`);
            return this._isValid;
        } catch (error) {
             Logger.error(`Error executing public validate() for ${this.name}:`, error);
             this._isValid = false; // Validation failed due to error
             // Attempt to set a generic error message if possible
             if (this._setErrorMessage) {
                  this._setErrorMessage(`Validation error: ${error.message}`);
             }
             return false;
        }
    }

     /**
      * Public method to dispose of the component (e.g., remove event listeners).
      * Should be called when the component is no longer needed.
      */
     dispose() {
         try {
             Logger.debug(`Disposing component: ${this.name}`);
             this._removeEventListeners();
             // Perform any other component-specific cleanup necessary
             this._element = null; // Clear reference to the element
             Logger.debug(`Disposed component: ${this.name}`);
         } catch (error) {
             Logger.error(`Error disposing component ${this.name}:`, error);
         }
     }
}

// --- Class for Input Fields, inheriting from TravelComponent ---
// Adds input-specific properties and methods.
class InputComponent extends TravelComponent {
    // Protected property for the input value.
    _value = '';
    _errorMessageElement = null; // Protected property to hold the element for error messages

    /**
     * Constructor for InputComponent.
     * @param {string} elementId - The ID of the input element.
     * @param {string} componentName - A name for this input component instance.
     */
    constructor(elementId, componentName = 'InputComponent') {
         try {
            super(elementId, componentName); // Call parent constructor

            if (this._element) {
                 this._value = this._element.value; // Get initial value
                 // Find the associated error message element using the input ID and configured suffix.
                 this._errorMessageElement = document.getElementById(`${this.id}${AppConfig.SELECTORS.ERROR_MESSAGE_SUFFIX}`);
                 if (!this._errorMessageElement) {
                     Logger.debug(`No error message element found for input ${this.id} (looking for ID "${this.id}${AppConfig.SELECTORS.ERROR_MESSAGE_SUFFIX}").`);
                 }

                 this._attachInputEventListeners(); // Attach common input event listeners
                 Logger.debug(`${this.name} initialized with initial value: "${this._value}"`);
            } else {
                 Logger.error(`${this.name} element not found. Input component not fully functional.`);
                 // Parent constructor already set _isValid to false if element is null.
            }
            Logger.debug(`${this.name} constructor finished.`);
         } catch (error) {
             Logger.error(`Error in ${componentName} constructor (ID: "${elementId}"):`, error);
              // Ensure parent state is consistent if constructor fails after super() call
              this._element = null;
              this._isValid = false;
         }
    }

    /**
     * Protected method (convention) to attach input-specific listeners.
     */
    _attachInputEventListeners() {
        try {
            Logger.debug(`_attachInputEventListeners called for ${this.name}`);
            if (!this._element) {
                Logger.warn(`Cannot attach listeners: element is missing for ${this.name}.`);
                return; // Don't attach if element is missing
            }

            // Use the protected _addEventListener helper to bind 'this' and store references
            this._addEventListener('input', this._handleInput);
            this._addEventListener('change', this._handleChange);
            this._addEventListener('blur', this._handleBlur);
            this._addEventListener('focus', this._handleFocus);

             // Optionally handle the 'invalid' event if relying on native validation popups alongside custom messages.
             // By default, setCustomValidity prevents native popups unless reportValidity() is called.
            // this._addEventListener('invalid', this._handleInvalid, { passive: true }); // Use passive if handler doesn't call preventDefault

        } catch (error) {
            Logger.error(`Error in _attachInputEventListeners for ${this.name}:`, error);
        }
    }

    // Protected event handlers (bound to the component instance via _addEventListener)
    _handleInput() {
        try {
            this._value = this._element.value;
            Logger.debug(`${this.name} input event, value updated to: "${this._value}"`);
            this._clearErrorMessage(); // Clear error message as user is typing.
            // Optional: Trigger light validation or feedback here.
        } catch (error) {
            Logger.error(`Error in _handleInput for ${this.name}:`, error);
        }
    }

    _handleChange() {
        try {
            this._value = this._element.value; // Ensure value is most recent
            Logger.debug(`${this.name} change event, value updated to: "${this._value}". Triggering validation.`);
            this.validate(); // Validate on change (typically happens on blur after input)
        } catch (error) {
            Logger.error(`Error in _handleChange for ${this.name}:`, error);
        }
    }

    _handleBlur() {
        try {
            Logger.debug(`${this.name} blur event. Triggering validation.`);
            // Add a small delay before validation on blur, especially useful with autocomplete
            // where 'place_changed' might fire just after blur.
             setTimeout(() => {
                try {
                    this.validate(); // Perform validation after the delay
                } catch (error) {
                     Logger.error(`Error in delayed blur validation for ${this.name}:`, error);
                }
            }, AppConfig.VALIDATION_DELAY_MS);

        } catch (error) {
            Logger.error(`Error in _handleBlur setup for ${this.name}:`, error);
        }
    }

    _handleFocus() {
        try {
            Logger.debug(`${this.name} focus event.`);
            this._clearErrorMessage(); // Clear message on focus (common UX pattern)
        } catch (error) {
             Logger.error(`Error in _handleFocus for ${this.name}:`, error);
        }
    }

    _handleInvalid(event) {
        try {
            Logger.debug(`${this.name} invalid event fired.`);
            // The browser might trigger this if the HTML5 validation fails (e.g., required empty)
            // We can prevent the default message and rely on our own _setErrorMessage calls.
            // event.preventDefault();
            // this.validate(); // Re-validate to show our message
        } catch (error) {
            Logger.error(`Error in _handleInvalid for ${this.name}:`, error);
        }
    }


    /**
     * Protected method (convention) for validation - intended to be overridden.
     * Checks the 'required' attribute and sets native custom validity.
     * Polymorphism: Base validation logic.
     * @returns {boolean} - True if base validation passes, false otherwise.
     */
    _validate() {
        try {
            Logger.debug(`_validate called for ${this.name} (InputComponent base validation).`);
            let isValid = true;
            this._clearErrorMessage(); // Clear previous messages before validating

            // Check HTML5 'required' attribute manually first for logging/control
            if (this._element && this._element.required && (!this._value || this._value.toString().trim() === '')) { // Ensure value is string for trim
                 const message = AppConfig.MESSAGES.REQUIRED;
                 this._setErrorMessage(message); // Set our custom error message
                 isValid = false;
                 Logger.debug(`${this.name} failed required validation.`);
            } else {
                 // If value is present, ensure the required error is cleared
                 if (this._element && this._element.required) {
                      // No need to explicitly clear if _clearErrorMessage was called above,
                      // but defensive check.
                     this._clearErrorMessage(); // Clear the native custom validity too
                 }
                 isValid = true; // Base validation passes if not required or value is present
                 Logger.debug(`${this.name} passed base validation (required check).`);
            }

            // Update component's internal validation state.
            this._isValid = isValid;
            Logger.debug(`${this.name} base validation result: ${this._isValid}`);
            return this._isValid;
        } catch (error) {
            Logger.error(`Error in _validate for ${this.name}:`, error);
             this._isValid = false;
             this._setErrorMessage(`Validation error in base validate: ${error.message}`);
             return false;
        }
    }

    /**
     * Protected method to set and display an error message in the designated element below the input.
     * Also sets the native custom validity on the input element.
     * @param {string} message - The error message text.
     */
    _setErrorMessage(message) {
        try {
            if (this._errorMessageElement) {
                this._errorMessageElement.textContent = message;
                // Add a class to make it visible/styled (if not handled by W3CSS default text-red)
                // this._errorMessageElement.classList.add('active-error-message');
                Logger.debug(`Setting error for ${this.name}: "${message}"`);
            } else {
                Logger.debug(`No error message element found for ${this.id}. Cannot display message: "${message}". Logging instead.`);
                // Fallback to console if UI element is missing
                 Logger.warn(`UI Error Message Fallback [${this.name}]: "${message}"`);
            }
             if (this._element) {
                // Also set custom validity for native browser validation reporting (e.g., form checkValidity)
                // This is crucial for the form's checkValidity() method to work correctly.
                 this._element.setCustomValidity(message);
                  Logger.debug(`Set custom validity for ${this.name}: "${message}"`);
                  // Optional: Call reportValidity() here if you want instant native tooltips on _setErrorMessage call
                  // this._element.reportValidity();
             }
        } catch (error) {
            Logger.error(`Error in _setErrorMessage for ${this.name} (message: "${message}"):`, error);
        }
    }

    /**
     * Protected method to clear the error message from the designated element and the native custom validity.
     */
    _clearErrorMessage() {
        try {
            if (this._errorMessageElement) {
                this._errorMessageElement.textContent = '';
                 // this._errorMessageElement.classList.remove('active-error-message');
                 Logger.debug(`Clearing error message element for ${this.name}`);
            }
             if (this._element) {
                 // Clear custom validity to indicate it's valid
                 this._element.setCustomValidity('');
                 Logger.debug(`Cleared custom validity for ${this.name}`);
             }
        } catch (error) {
            Logger.error(`Error in _clearErrorMessage for ${this.name}:`, error);
        }
    }

    /**
     * Protected helper to get HTML element's ValidityState object.
     * @returns {ValidityState|null} - The ValidityState object or null if not available.
     */
     _getValidityState() {
         try {
             if (this._element && this._element.validity) {
                 return this._element.validity;
             }
             Logger.warn(`Cannot get ValidityState for ${this.name}: element or validity property missing.`);
             return null;
         } catch (error) {
             Logger.error(`Error getting ValidityState for ${this.name}:`, error);
             return null;
         }
     }

    /**
     * Public method to get the current value of the input.
     * @returns {string} - The input value, trimmed for text types.
     */
    getValue() {
        try {
             // Trim whitespace from string values before returning, unless it's a non-text input type where trimming isn't applicable.
            if (this._element && (this._element.type === 'text' || this._element.type === 'search' || this._element.type === 'url' || this._element.type === 'tel' || this._element.type === 'password')) {
                 return typeof this._value === 'string' ? this._value.trim() : ''; // Ensure it's a string for trimming
             }
            // For other types (date, number, etc.), return value directly
            return this._value;
        } catch (error) {
            Logger.error(`Error getting value for ${this.name}:`, error);
            return ''; // Return default empty value on error
        }
    }

     /**
      * Override dispose method to clean up input-specific handlers.
      */
     dispose() {
         try {
             super.dispose(); // Call parent dispose (removes element event listeners)
             this._errorMessageElement = null; // Clear reference
             Logger.debug(`Disposed ${this.name}.`);
         } catch (error) {
             Logger.error(`Error disposing ${this.name}:`, error);
         }
     }
}

// --- Class for Date Input, inheriting from InputComponent ---
class DateInput extends InputComponent {
     #dateType; // Private member: 'check-in' or 'check-out'

    /**
     * Constructor for DateInput.
     * @param {string} elementId - The ID of the date input element.
      * @param {string} dateType - The type of date ('check-in' or 'check-out'). Expected via data-date-type attribute.
     */
    constructor(elementId, dateType) {
         try {
            super(elementId, 'DateInput'); // Set component name
            this.#dateType = dateType || 'unknown'; // Initialize private member

            if (this._element) {
                 Logger.debug(`${this.name} initialized as type "${this.#dateType}"`);
                 // Set min date dynamically if needed (e.g., tomorrow)
                 this._setMinDate();
            }
            Logger.debug(`${this.name} constructor finished.`);
         } catch (error) {
             Logger.error(`Error in DateInput constructor (ID: "${elementId}"):`, error);
         }
    }

    /**
     * Protected method to set the min attribute on the date input (e.g., to today).
     * This leverages HTML5 date input capabilities for basic date range enforcement.
     */
    _setMinDate() {
        try {
            if (this._element && this._element.type === 'date') {
                const today = new Date();
                // Format date as YYYY-MM-DD for the min attribute
                const year = today.getFullYear();
                const month = (today.getMonth() + 1).toString().padStart(2, '0');
                const day = today.getDate().toString().padStart(2, '0');
                const todayString = `${year}-${month}-${day}`;
                this._element.min = todayString;
                Logger.debug(`${this.name}: Set min date attribute to ${todayString}`);
            } else {
                 Logger.debug(`${this.name}: Skipping _setMinDate, element not found or not date type.`);
            }
        } catch (error) {
             Logger.error(`Error in _setMinDate for ${this.name}:`, error);
        }
    }

    /**
     * Polymorphism: Overriding the validation method from InputComponent.
     * Adds date-specific validation logic based on native ValidityState and cross-field checks handled by the form.
     * @returns {boolean} - True if validation passes, false otherwise.
     */
    _validate() {
        try {
            Logger.debug(`_validate called for ${this.name} (DateInput specific validation).`);
            // Call parent validation first (e.g., required).
            let isValid = super._validate();

            if (!isValid) {
                // If parent validation failed (e.g., required but empty), no need for further date checks yet.
                 Logger.debug(`${this.name} failed base validation.`);
                return false;
            }

            // Specific date validation logic using native ValidityState.
            const validity = this._getValidityState(); // Get ValidityState object
            if (!validity) {
                 Logger.warn(`${this.name}: Cannot get ValidityState. Skipping detailed date validation.`);
                 // Relying only on the base validation if ValidityState is unavailable.
                 // The 'required' check from super is the most critical here.
                 return isValid; // Return result from super._validate()
            }

            // Check validity based on HTML5 attributes (required, min, etc.)
            // checkValidity() will check required, type mismatch, and rangeUnderflow/Overflow if min/max are set.
            isValid = this._element.checkValidity(); // Aggregates native validity checks

            if (!isValid) {
                // If native validation failed (e.g., before min date, invalid format)
                 if (validity.rangeUnderflow) { // Date is before min date set by _setMinDate
                     // Use our custom message for past dates relative to today/min
                     this._setErrorMessage(AppConfig.MESSAGES.DATE_PAST);
                 } else if (validity.badInput) { // Input couldn't be parsed as a valid date format
                      this._setErrorMessage('Invalid date format.');
                 } else if (validity.valueMissing) { // Required but empty (should be caught by super)
                      // This case should ideally be handled by super._validate, but defensive check.
                     this._setErrorMessage(AppConfig.MESSAGES.REQUIRED);
                 } else {
                     // Handle other potential date-related validity issues if any
                     // Use the native message as a fallback if we don't have a specific one
                     this._setErrorMessage(this._element.validationMessage || 'Invalid date.');
                 }
                 Logger.debug(`${this.name} failed native validation. ValidityState:`, validity);
            } else {
                // Clear any previous date-specific errors if native validation passed.
                this._clearErrorMessage();
                Logger.debug(`${this.name} passed native validation.`);
            }

            this._isValid = isValid; // Update component's internal state
            Logger.debug(`${this.name} date validation result: ${this._isValid}`);
            return this._isValid;
        } catch (error) {
            Logger.error(`Error in _validate for ${this.name}:`, error);
             this._isValid = false; // Validation failed due to error
             this._setErrorMessage(`Validation error in date validate: ${error.message}`);
             return false;
        }
    }

    /**
     * Public getter to get the date value as a Date object.
     * Parses the YYYY-MM-DD string value into a Date object treated as local time.
     * @returns {Date|null} - The Date object or null if value is empty or parsing fails.
     */
    get DateObject() {
        try {
            const value = this.getValue();
            if (!value) {
                 Logger.debug(`${this.name}.DateObject: Value is empty.`);
                return null;
            }

            const parts = value.split('-');
            // Check if parts exist and are numeric before creating date
            if (parts.length === 3 && !isNaN(parseInt(parts[0], 10)) && !isNaN(parseInt(parts[1], 10)) && !isNaN(parseInt(parts[2], 10))) {
                 // Month is 0-indexed in Date constructor (0 for January)
                 const year = parseInt(parts[0], 10);
                 const month = parseInt(parts[1], 10) - 1; // Adjust for 0-indexing
                 const day = parseInt(parts[2], 10);

                 // Basic validation for month/day ranges - Date constructor handles this somewhat
                 // but explicit checks can catch some edge cases before construction.
                 if (month < 0 || month > 11 || day < 1 || day > 31) {
                      Logger.warn(`Date parts out of expected range for ${this.name}: ${value}`);
                      return null; // Indicate invalid date parts
                 }

                 const dateObj = new Date(year, month, day);

                 // Check if Date object is "Invalid Date" (happens for impossible dates like Feb 30, handled by Date constructor)
                 if (isNaN(dateObj.getTime())) {
                      Logger.warn(`Date object is Invalid Date after parsing "${value}" for ${this.name}.`);
                      return null;
                 }

                 Logger.debug(`${this.name}.DateObject: Parsed "${value}" to Date object.`);
                 return dateObj;

            }
            Logger.warn(`Failed to parse date string "${value}" into DateObject for ${this.name}: parts missing or not numbers.`);
            return null; // Return null if parsing fails
        } catch (error) {
            Logger.error(`Error getting DateObject for ${this.name} (value: "${this.getValue()}"):`, error);
            return null;
        }
    }

     /**
      * Public getter for the date type ('check-in' or 'check-out').
      * @returns {string} - The date type or 'unknown'.
      */
     get dateType() {
         try {
             return this.#dateType;
         } catch (error) {
              Logger.error(`Error getting dateType for ${this.name}:`, error);
              return 'unknown';
         }
     }

      /**
       * Override dispose method.
       */
     dispose() {
         try {
             super.dispose(); // Call parent dispose
             Logger.debug(`Disposed ${this.name}.`);
         } catch (error) {
             Logger.error(`Error disposing ${this.name}:`, error);
         }
     }
}

 // --- Class for Number Input, inheriting from InputComponent ---
 class NumberInput extends InputComponent {

    /**
     * Constructor for NumberInput.
     * @param {string} elementId - The ID of the number input element.
     * @param {string} componentName - A name for this number component instance.
     */
     constructor(elementId, componentName = 'NumberInput') {
         try {
            super(elementId, componentName);
            Logger.debug(`${this.name} initialized.`);
            Logger.debug(`${this.name} constructor finished.`);
         } catch (error) {
            Logger.error(`Error in NumberInput constructor (ID: "${elementId}"):`, error);
         }
     }

     /**
      * Polymorphism: Overriding the validation method from InputComponent.
      * Adds number-specific validation logic based on native ValidityState (min, max, step).
      * @returns {boolean} - True if validation passes, false otherwise.
      */
     _validate() {
        try {
            Logger.debug(`_validate called for ${this.name} (NumberInput specific validation).`);
            // Call parent validation first (e.g., required).
            let isValid = super._validate();

             if (!isValid) {
                  Logger.debug(`${this.name} failed base validation.`);
                 return false;
             }

            // Specific number validation using native ValidityState.
            const validity = this._getValidityState(); // Get ValidityState object
             if (!validity) {
                 Logger.warn(`${this.name}: Cannot get ValidityState. Skipping detailed number validation.`);
                  return isValid; // Return result from super._validate()
             }

            // Check validity based on HTML5 attributes (required, type mismatch, min, max, step)
            // checkValidity() aggregates these native checks.
            isValid = this._element.checkValidity(); // Aggregates native validity checks

             if (!isValid) {
                 // If native validation failed (e.g., not a number, out of min/max range)
                  let customMessage = 'Invalid number input.'; // Default message

                  if (validity.badInput) { // User entered non-numeric characters or value is empty string
                      customMessage = AppConfig.MESSAGES.INVALID_NUMBER;
                  } else if (validity.rangeUnderflow) { // Less than min
                       const min = parseFloat(this._element.min); // Use parseFloat for min/max from attribute
                       customMessage = AppConfig.MESSAGES.NUMBER_MIN(isNaN(min) ? this._element.min : min); // Use attribute value if parsing failed
                  } else if (validity.rangeOverflow) { // More than max
                       const max = parseFloat(this._element.max);
                       customMessage = AppConfig.MESSAGES.NUMBER_MAX(isNaN(max) ? this._element.max : max);
                  } else if (validity.stepMismatch) { // Value doesn't match step attribute
                       customMessage = 'Value must be a valid step.';
                  } else if (validity.valueMissing) { // Required but empty (should be caught by super)
                       customMessage = AppConfig.MESSAGES.REQUIRED;
                  } else {
                       // Fallback for unexpected validity states
                       customMessage = this._element.validationMessage || customMessage;
                  }

                 this._setErrorMessage(customMessage); // Use our custom or mapped message
                 Logger.debug(`${this.name} failed native validation. ValidityState:`, validity);

             } else {
                 // Clear number-specific errors if native validation passed.
                 this._clearErrorMessage();
                 Logger.debug(`${this.name} passed native validation.`);
             }


            this._isValid = isValid; // Update component's internal state
            Logger.debug(`${this.name} number validation result: ${this._isValid}`);
            return this._isValid;
        } catch (error) {
            Logger.error(`Error in _validate for ${this.name}:`, error);
             this._isValid = false; // Validation failed due to error
            this._setErrorMessage(`Validation error in number validate: ${error.message}`);
             return false;
        }
     }

     /**
      * Public method to get the value as a number.
      * @returns {number} - The numerical value, defaulting to 0 or NaN on error.
      */
     getValueAsNumber() {
         try {
             // Use parseFloat to handle potential decimal inputs, though type="number" usually implies integers unless step is decimal.
             const value = parseFloat(this.getValue());
             // Check if the value is actually numeric before returning
             // Return NaN if it's not a valid number string, or the parsed number.
             return isNaN(value) ? NaN : value;
         } catch (error) {
             Logger.error(`Error getting value as number for ${this.name}:`, error);
             return NaN; // Return NaN on error
         }
     }

      /**
       * Override dispose method.
       */
      dispose() {
          try {
              super.dispose(); // Call parent dispose
              Logger.debug(`Disposed ${this.name}.`);
          } catch (error) {
              Logger.error(`Error disposing ${this.name}:`, error);
          }
      }
 }

// --- Class for Destination Input with Google Autocomplete ---
class DestinationInput extends InputComponent {
    #autocomplete; // Private member for the Google Autocomplete object instance.
    #placeDetails = null; // Private member to store selected Google Place details.
    #isPlaceSelected = false; // Private flag to track if a place from the dropdown was selected.

    /**
     * Constructor for DestinationInput.
     * @param {string} elementId - The ID of the destination input element.
     */
    constructor(elementId) {
         try {
            super(elementId, 'DestinationInput'); // Set component name

            // Check if Google Maps API and Places library are loaded and the element exists
            if (typeof google !== 'undefined' && google.maps && google.maps.places && this._element) {
                 this._initializeAutocomplete(); // Initialize Google Autocomplete
                 Logger.debug(`${this.name} initialized with Google Autocomplete.`);
            } else {
                 Logger.error(`Google Maps Places API not loaded or element ID "${elementId}" not found for ${this.name}. Autocomplete will not be functional.`);
                 // The element might be missing, or the Google script didn't load.
                 // Keep parent element reference even if autocomplete fails to initialize.
                 // Parent constructor already set _isValid to false if _element is null.
            }
            Logger.debug(`${this.name} constructor finished.`);
         } catch (error) {
              Logger.error(`Error in DestinationInput constructor (ID: "${elementId}"):`, error);
         }
    }

    /**
     * Protected method to initialize Google Autocomplete and attach listeners.
     * Uses the Google Maps Places library.
     */
    _initializeAutocomplete() {
        try {
            Logger.debug(`_initializeAutocomplete called for ${this.name}`);
            if (!this._element || typeof google === 'undefined' || !google.maps || !google.maps.places) {
                Logger.error("Cannot initialize Autocomplete: dependencies missing or element not found.");
                return;
            }

            // Options for the autocomplete.
            const options = {
                // types: ['(cities)'], // Restrict results - example
                types: ['establishment', 'geocode'], // Broad types including hotels, landmarks, cities, addresses.
                 fields: ['place_id', 'name', 'geometry', 'address_components', 'formatted_address'], // Fields to retrieve upon selection.
                 strictBounds: false // Set to true to bias results to current map bounds (if you had a map).
            };

            this.#autocomplete = new google.maps.places.Autocomplete(this._element, options);
             Logger.debug("Google Autocomplete object created.");

            // Listen for the 'place_changed' event - fires when a user selects a place from the dropdown.
            // This listener is attached to the Autocomplete object, not the input element directly.
            // Use .bind(this) to ensure 'this' context is the component instance inside the handler.
            this.#autocomplete.addListener('place_changed', this._handlePlaceChanged.bind(this));
            Logger.debug(`Attached 'place_changed' listener to Autocomplete object for ${this.name}`);


            // Add a blur listener with a delay. This is crucial because the 'place_changed' event
            // might fire *after* the blur event if the user clicks a suggestion. The delay
            // allows place_changed to complete and update this.#placeDetails before validation runs.
            this._addEventListener('blur', this._handleBlurWithDelay);
             Logger.debug(`Attached 'blur' listener with delay handler to input element for ${this.name}`);


             // Also handle 'input' event explicitly to clear place details and flag if user starts typing again.
             this._addEventListener('input', this._handleDestinationInput);
              Logger.debug(`Attached 'input' listener to input element for ${this.name}`);

        } catch (error) {
            Logger.error(`Error in _initializeAutocomplete for ${this.name}:`, error);
        }
    }

     /**
      * Handler for Google Autocomplete 'place_changed' event.
      * Fired when a user selects a place from the autocomplete dropdown.
      * Updates internal place details and triggers validation.
      */
     _handlePlaceChanged() {
         try {
             Logger.debug(`${this.name} place_changed event fired.`);
             // Get the selected place's details object from the autocomplete service.
             this.#placeDetails = this.#autocomplete.getPlace();
             this.#isPlaceSelected = false; // Reset flag initially

             if (!this.#placeDetails || !this.#placeDetails.geometry) {
                 // This happens if the user enters text and presses Enter without selecting from dropdown,
                 // or if the place details request failed after selection.
                 Logger.warn(`${this.name}: No place details available for input: "${this.getValue()}". User might have typed text without selecting.`);
                 this.#placeDetails = null; // Ensure details are null if selection failed.
                 // The input value remains the user's typed text.
                 // We rely on Expedia's site search to interpret the text in this redirect scenario.
             } else {
                  Logger.info(`${this.name}: Place selected from autocomplete: "${this.#placeDetails.name}"`, this.#placeDetails);
                  this.#isPlaceSelected = true; // Set flag indicating a place was selected
                  // The input value is automatically updated by Google Autocomplete's handling of the input element.
                  this._value = this._element.value; // Ensure our internal value is in sync.
                  // Store or use place_id or coordinates if needed for a different API,
                  // but for the Expedia redirect, the text name is usually enough.
                  // Example: document.getElementById('destination-place-details').value = this.#placeDetails.place_id;
             }
              // Trigger validation after a potential place selection.
             // Use setTimeout with 0 delay to push validation to the end of the current event loop,
             // allowing the DOM input value update to fully settle in some browsers before validation reads it.
             setTimeout(() => {
                  try {
                     this.validate(); // Call the public validate method
                  } catch (error) {
                      Logger.error(`Error in delayed validate after place_changed for ${this.name}:`, error);
                  }
             }, 0); // 0ms delay schedules it for the next event loop tick

         } catch (error) {
             Logger.error(`Error in _handlePlaceChanged for ${this.name}:`, error);
         }
     }

     /**
      * Handler for blur event on the destination input with a small delay.
      * Necessary to allow the 'place_changed' event (if a selection occurred)
      * to fire and update state *before* validation runs on blur.
      */
     _handleBlurWithDelay() {
         try {
             Logger.debug(`${this.name} blur event fired. Scheduling delayed validation...`);
             // Give a small delay to allow place_changed to fire before validation runs.
             // This prevents the 'required' validation from incorrectly triggering
             // before the selected place's value updates the input field.
             setTimeout(() => {
                  try {
                     Logger.debug(`${this.name} executing delayed blur validation. Place selected flag: ${this.#isPlaceSelected}. Current value: "${this.getValue()}".`);
                      // If blur happened and no place was selected from dropdown, and text is present,
                      // you might want to warn the user or rely on backend interpretation.
                      // For this demo, we rely on Expedia's interpretation of the text,
                      // so base InputComponent 'required' check is sufficient.
                     this.validate(); // Perform validation after the delay.
                      // After validation, reset the flag for the next interaction cycle
                     this.#isPlaceSelected = false;
                  } catch (error) {
                      Logger.error(`Error during delayed blur validation execution for ${this.name}:`, error);
                  }
             }, AppConfig.VALIDATION_DELAY_MS); // Configurable delay

         } catch (error) {
             Logger.error(`Error setting up _handleBlurWithDelay for ${this.name}:`, error);
         }
     }

      /**
       * Handler for input event on the destination field.
       * Updates the internal value and clears previous place details/selection flag if user starts typing again.
       */
      _handleDestinationInput() {
        try {
             this._value = this._element.value; // Keep internal value in sync with DOM value
             // If the user starts typing again, any previous place selection is invalidated.
             // Clear stored place details and the selected flag.
             if (this.#placeDetails || this.#isPlaceSelected) {
                 Logger.debug(`${this.name}: Input detected, clearing previous place details/selection flag.`);
                 this.#placeDetails = null;
                 this.#isPlaceSelected = false;
             }
             // Optional: Re-validate or provide instant feedback here as user types.
         } catch (error) {
             Logger.error(`Error in _handleDestinationInput for ${this.name}:`, error);
         }
      }


    /**
     * Polymorphism: Overriding the validation method from InputComponent.
     * Primarily relies on the base InputComponent validation (e.g., required).
     * Can optionally add logic to check if a place was explicitly selected from the dropdown.
     * @returns {boolean} - True if validation passes, false otherwise.
     */
    _validate() {
        try {
            Logger.debug(`_validate called for ${this.name} (DestinationInput specific validation).`);
             // Call parent validation first (e.g., required check using _value).
             // This handles the case where the field is required and left empty.
            let isValid = super._validate();

             if (!isValid) {
                 Logger.debug(`${this.name} failed base validation (e.g., required).`);
                 return false;
             }

             // --- Optional Validation: Require selecting a place from the Autocomplete dropdown ---
             // For this demo redirect, allowing raw text is fine, as Expedia's site search
             // can usually interpret it. Uncomment this section if you need to force selection.
             /*
             if (this._element.value && !this.#isPlaceSelected) {
                  const message = AppConfig.MESSAGES.AUTOCOMPLETE_NO_DETAILS(this._element.value);
                  this._setErrorMessage(message);
                  Logger.warn(`Validation failed for ${this.name}: ${message}`);
                  isValid = false;
             } else {
                  // Clear this specific error if it was previously set and is now valid.
                  // Check if the current error message matches the one we set for 'no details'.
                  if (this._errorMessageElement && this._errorMessageElement.textContent.includes("Could not get details")) {
                      this._clearErrorMessage();
                  }
                  // If not required, and value is empty, super._validate returns true.
                  // If not required, and value is present but not selected, we set error above.
                  // If required and value is present AND selected (or not forcing selection), super._validate returns true.
                  // So, isValid is already correctly set by the logic above.
             }
             */
             // --- End Optional Validation ---


            this._isValid = isValid; // Update component's internal state
            Logger.debug(`${this.name} validation result: ${this._isValid}`);
            return this._isValid;
        } catch (error) {
            Logger.error(`Error in _validate for ${this.name}:`, error);
             this._isValid = false; // Validation failed due to error
             this._setErrorMessage(`Validation error in destination validate: ${error.message}`);
             return false;
        }
    }

    /**
     * Public method to get the stored Google Place details object.
     * This object is populated when a user selects a place from the autocomplete dropdown.
     * @returns {object|null} - The place details object or null if no place has been selected or an error occurred.
     */
    getPlaceDetails() {
        try {
            return this.#placeDetails;
        } catch (error) {
             Logger.error(`Error getting place details for ${this.name}:`, error);
             return null;
        }
    }

     /**
       * Override dispose method to clean up Google Autocomplete instance.
       * While the real Autocomplete object doesn't have a formal public dispose,
       * removing event listeners and nullifying the reference is good practice.
       */
     dispose() {
         try {
             super.dispose(); // Call parent dispose (removes input element event listeners)
             // Real Google Autocomplete objects created via 'new' don't have a public .remove() or .dispose() method.
             // Listeners attached directly to the input element are handled by super.dispose().
             // Listeners attached to the Autocomplete object itself (like 'place_changed') are harder to remove
             // unless you stored the ListenerHandle objects. For this scale demo, nullifying the reference is often sufficient
             // as the component is usually disposed when the page unloads.
             this.#autocomplete = null; // Clear reference
             this.#placeDetails = null; // Clear details
             Logger.debug(`Disposed ${this.name}.`);
         } catch (error) {
             Logger.error(`Error disposing ${this.name}:`, error);
         }
     }
}

// --- Helper Class for Collecting Search Parameters ---
// Encapsulates the logic for extracting values from input components.
class SearchParamCollector {
     #inputComponents; // Private member to hold references to input components (map: id -> instance).

    /**
     * Constructor for SearchParamCollector.
     * @param {object} inputComponents - An object mapping input IDs to their component instances.
     *                                  Expected to be the `_inputs` map from the SearchForm.
     */
    constructor(inputComponents) {
         try {
            Logger.debug('SearchParamCollector constructor called.');
            if (!inputComponents || typeof inputComponents !== 'object') {
                 Logger.error("Input components object not provided or is invalid to SearchParamCollector.");
                 throw new Error("Input components map is required for SearchParamCollector initialization.");
            }
            // Store a reference to the map of input component instances.
            this.#inputComponents = inputComponents;
            Logger.debug('SearchParamCollector initialized.');
         } catch (error) {
            Logger.error("Error initializing SearchParamCollector:", error);
            // Ensure #inputComponents is an empty object if initialization failed
            this.#inputComponents = {};
            throw error; // Re-throw initialization error
         }
    }

    /**
     * Public method to collect values from all managed input components.
     * Iterates through the map of component instances and calls their `getValue()` method.
     * @returns {object} An object containing collected parameters, keyed by input ID.
     *                   Values will be strings or numbers depending on the component's getValue().
     * @throws {Error} If a critical error occurs during collection (e.g., input map is null unexpectedly).
     */
    collect() {
        try {
            Logger.debug('Collecting search parameters...');
             // Ensure the input map is valid before iterating
             if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                 const errorMsg = "Input components map is missing or invalid during collection.";
                 Logger.error(errorMsg);
                 throw new Error(errorMsg);
             }

            const params = {};
            let hasErrors = false;

            // Iterate through the stored input component instances.
            // Using Object.keys and hasOwnProperty is robust.
            Object.keys(this.#inputComponents).forEach(inputId => {
                 try {
                    const component = this.#inputComponents[inputId];
                    // Check if the component instance and its getValue method exist
                    if (component && typeof component.getValue === 'function') {
                         params[inputId] = component.getValue();
                         Logger.debug(`Collected "${inputId}": "${params[inputId]}"`);
                     } else {
                         Logger.warn(`Input component "${inputId}" not found or missing getValue method during collection.`);
                         params[inputId] = null; // Set to null or undefined if component is missing/invalid
                         hasErrors = true;
                     }
                 } catch (error) {
                    Logger.error(`Error collecting value for input "${inputId}" in collector:`, error);
                     params[inputId] = null; // Set to null on error
                     hasErrors = true; // Mark that collection had errors
                 }
            });

            if (hasErrors) {
                Logger.warn("Search parameter collection completed with some errors/missing components.");
                // Decide how critical this is - can we still build a URL?
                // For this demo, we return the partial params.
            }

            Logger.info("Collected Params (JSON example):\n", JSON.stringify(params, null, 2));
            return params; // Return parameters as a simple object.
        } catch (error) {
            Logger.error("Critical error during search parameter collection:", error);
            // Re-throw or return an empty object on critical failure
            throw new Error(`Failed to collect search parameters: ${error.message}`);
        }
    }

     /**
      * Public method to get a specific collected parameter value by its input ID.
      * @param {string} inputId - The ID of the input element/component.
      * @returns {*} The value of the parameter, or null/undefined if not found or error.
      */
     getParam(inputId) {
         try {
             if (!this.#inputComponents) {
                 Logger.warn("Input components map is missing in collector.");
                 return null;
             }
             const component = this.#inputComponents[inputId];
             if (component && typeof component.getValue === 'function') {
                 return component.getValue();
             }
             Logger.warn(`Input component "${inputId}" not found or does not have getValue method in collector.`);
             return null; // Or undefined, depending on desired behavior
         } catch (error) {
             Logger.error(`Error getting specific parameter "${inputId}" from collector:`, error);
             return null;
         }
     }

     /**
      * Public method to get all managed input components.
      * @returns {object} - The map of input components.
      */
     getAllComponents() {
         try {
             return this.#inputComponents; // Return the internal map
         } catch (error) {
             Logger.error("Error getting all components from collector:", error);
             return {}; // Return empty object on error
         }
     }

     /**
       * Dispose method.
       */
     dispose() {
         try {
             Logger.debug("Disposing SearchParamCollector.");
             this.#inputComponents = {}; // Clear the map reference
             Logger.debug("SearchParamCollector disposed.");
         } catch (error) {
             Logger.error("Error disposing SearchParamCollector:", error);
         }
     }
}

// --- Helper Class for Building the Expedia URL ---
// Demonstrates static methods and constants. Pure static class.
class ExpediaUrlBuilder {
    // Static members accessed directly on the class.
    static BASE_URL = AppConfig.BASE_SEARCH_URL;
    static AFFILIATE_ID = AppConfig.AFFILIATE_ID;

    // Private constructor to prevent instantiation (optional, but good practice for pure static class)
    // private constructor() {} // Requires TypeScript or JS private class features if strictly enforced

    /**
     * Static method to build the Expedia search results URL from collected parameters.
     * Handles necessary parameters and adds affiliate ID.
     * @param {object} params - An object containing search parameters (destination, checkInDate, etc.).
     * @returns {string|null} The constructed URL string, or null if essential parameters are missing or invalid.
     */
    static buildUrl(params) {
        try {
            Logger.debug("Building Expedia URL...");

            if (!params || typeof params !== 'object') {
                 Logger.error("Cannot build URL: Invalid or empty parameters object provided.");
                 return null;
            }

            // Essential parameters required to build a meaningful URL for Expedia.
            const requiredParams = ['destination', 'checkInDate', 'checkOutDate', 'adults'];
            let missingOrInvalidParams = [];

            requiredParams.forEach(param => {
                 try {
                    // Check if parameter exists and is not empty string/null/undefined.
                    // Allow 0 for children, but adults must be >= 1.
                     const value = params[param];
                     if (value === undefined || value === null || (typeof value === 'string' && value.trim() === '')) {
                          // Special check for adults: ensure it's at least 1 as per Expedia's likely requirement for a search.
                         if (param === 'adults') {
                              const adultsCount = parseInt(value, 10);
                             if (isNaN(adultsCount) || adultsCount < 1) {
                                 missingOrInvalidParams.push(`${param} (must be at least 1)`);
                             } // Else if it's '0' or empty string but not required, this check passes (though form validation should handle it)
                         } else { // Other required params just need a non-empty value
                            missingOrInvalidParams.push(param);
                         }
                     }
                 } catch (error) {
                     Logger.error(`Error checking required parameter "${param}" during URL build:`, error);
                      missingOrInvalidParams.push(`${param} (check error)`);
                 }
            });

            // Perform cross-parameter validation needed for URL building specifically.
            try {
                if (params.checkInDate && params.checkOutDate) {
                     const checkIn = new Date(params.checkInDate);
                     const checkOut = new Date(params.checkOutDate);
                     // Simple comparison based on Date objects. More robust validation in DateInput and Form validator.
                     if (isNaN(checkIn.getTime()) || isNaN(checkOut.getTime())) {
                         // This should ideally be caught by input validation, but check defensively.
                         missingOrInvalidParams.push('checkInDate/checkOutDate (invalid date format)');
                     } else if (checkOut <= checkIn) {
                         // This should also be caught by form validation, but confirm for URL building.
                         missingOrInvalidParams.push('checkOutDate (must be after checkInDate)');
                     }
                } else {
                     // If one or both dates are missing here, it's already in missingOrInvalidParams from the first loop.
                }
            } catch (e) {
                 Logger.error("Error parsing dates for URL builder cross-check:", e);
                  missingOrInvalidParams.push('checkInDate/checkOutDate (parsing error)');
            }


            if (missingOrInvalidParams.length > 0) {
                const errorMsg = `Cannot build URL: Missing or invalid required parameters: ${missingOrInvalidParams.join(', ')}.`;
                Logger.error(errorMsg);
                // Don't set message display here, the calling code should handle it after getting null.
                return null; // Indicate failure to build URL
            }

            // Construct URLSearchParams object for building the query string safely.
            const urlParams = new URLSearchParams();

            // Add required parameters.
            urlParams.append('destination', params.destination);
            urlParams.append('checkin', params.checkInDate); // Expedia expects YYYY-MM-DD format
            urlParams.append('checkout', params.checkOutDate); // Expedia expects YYYY-MM-DD format

            // Ensure adults is a number >= 1 before appending (already checked above, but re-parse safely)
            const adultsCount = parseInt(params.adults, 10);
            if (isNaN(adultsCount) || adultsCount < 1) {
                 Logger.error(`Internal error: Invalid final adults count (${params.adults}) reached URL builder.`);
                 return null;
            }
            urlParams.append('adults', adultsCount);


             // Add children if greater than 0.
            const childrenCount = parseInt(params.children, 10) || 0; // Default to 0 if missing or invalid
            if (childrenCount > 0) {
                urlParams.append('children', childrenCount);
                 // Note: Expedia's API/frontend might require child ages ('childages' parameter),
                 // but we don't have inputs for that here. This is a simple example.
                 // urlParams.append('childages', '5,10'); // Example if you collected ages.
                 Logger.debug(`Added ${childrenCount} children to URL params.`);
             } else {
                  // Explicitly add children=0 if there are none, might be needed by Expedia
                  urlParams.append('children', 0);
                  Logger.debug("Added 0 children to URL params.");
             }


            // Add the affiliate ID parameter (mcid).
            if (ExpediaUrlBuilder.AFFILIATE_ID && ExpediaUrlBuilder.AFFILIATE_ID !== AppConfig.AFFILIATE_ID) { // Check against placeholder too
                 urlParams.append('mcid', ExpediaUrlBuilder.AFFILIATE_ID);
                 Logger.debug(`Added affiliate ID: ${ExpediaUrlBuilder.AFFILIATE_ID}`);
            } else {
                 Logger.warn("ExpediaUrlBuilder.AFFILIATE_ID is not set or is the placeholder. URL will not include affiliate tracking.");
                 // Decide if missing affiliate ID should prevent URL building. For a demo, maybe not critical.
                 // If it were critical, 'return null;' here.
            }

            // Add other fixed or common parameters often seen in Expedia URLs.
            urlParams.append('rfrr', 'true'); // Example referrer parameter.
            urlParams.append('langid', '1033'); // Language ID (e.g., 1033 for English-US)
            urlParams.append('stid', '0'); // Example Site ID (often 0 or partner specific)
            urlParams.append('semdtl', '^'); // Unknown Expedia parameter, sometimes seen in links. Include defensively.
            urlParams.append('sort', 'RECOMMENDED'); // Default sort order, could make configurable.
            urlParams.append('top_dp', '1'); // Sometimes seen, related to top deal properties?
            urlParams.append('top_rsid', '1'); // Similar to top_dp?
            urlParams.append('pwa_ts', Date.now()); // Add a timestamp (might help with caching or uniqueness)

            // Example of adding a room parameter based on adults/children.
            // A simple rule: assume 1 room unless total travelers > 4.
            let numberOfRooms = 1;
             const totalTravelers = adultsCount + childrenCount;
             if (totalTravelers > 4) {
                 numberOfRooms = Math.ceil(totalTravelers / 2); // Rough estimate (e.g., 5 travelers -> 3 rooms)
             } else if (totalTravelers >= 1) {
                 numberOfRooms = 1; // At least one room if there's at least one traveler
             } else { // Total travelers is 0 or less (should be caught by validation, but defensive)
                 numberOfRooms = 1; // Default to 1 room even if no travelers (unlikely scenario)
             }

            urlParams.append('rooms', numberOfRooms);
             Logger.debug(`Assumed ${numberOfRooms} room(s) based on ${adultsCount} adults and ${childrenCount} children (total ${totalTravelers}).`);


            // Combine base URL with query string.
            const finalUrl = `${ExpediaUrlBuilder.BASE_URL}?${urlParams.toString()}`;

            Logger.info("Generated URL:", finalUrl);
            return finalUrl;

        } catch (error) {
            Logger.error("Critical error during Expedia URL building:", error);
            // Indicate URL building failed due to an internal error.
            return null;
        }
    }
}

// --- Class for Managing UI Messages ---
// Handles displaying temporary or persistent messages in a designated UI element.
class MessageDisplay {
     #messageElement; // Private member for the message display element.
     #timerId = null; // Private member to store the timer ID for auto-hiding.

    /**
     * Constructor for MessageDisplay.
     * @param {string} elementSelector - CSS selector for the message container element.
     */
    constructor(elementSelector) {
        try {
            Logger.debug(`MessageDisplay constructor called with selector: ${elementSelector}`);
            this.#messageElement = document.querySelector(elementSelector);
            if (!this.#messageElement) {
                Logger.error(`Message display element not found with selector: ${elementSelector}. UI messages will be logged to console.`);
            } else {
                 // Ensure element is initially hidden and has base classes
                 // Use W3CSS utility classes for styling and hiding
                 this.#messageElement.classList.add('w3-panel', 'w3-hide');
            }
            Logger.debug('MessageDisplay initialized.');
        } catch (error) {
            Logger.error("Error initializing MessageDisplay:", error);
            this.#messageElement = null; // Ensure element is null if constructor fails
        }
    }

    /**
     * Private method to clear the auto-hide timer.
     */
    #clearTimer() {
        try {
            if (this.#timerId) {
                clearTimeout(this.#timerId);
                this.#timerId = null;
                 Logger.debug("Message auto-hide timer cleared.");
            }
        } catch (error) {
            Logger.error("Error clearing message timer:", error);
        }
    }

    /**
     * Public method to display a message in the designated area.
     * @param {string} message - The message text.
     * @param {string} type - Type of message ('info', 'success', 'warning', 'error'). Maps to W3CSS classes.
     * @param {number} [duration] - Duration in MS to show message (0 for infinite). Defaults to config.
     */
    showMessage(message, type = 'info', duration = AppConfig.MESSAGE_DISPLAY_DURATION_MS) {
        try {
            if (!this.#messageElement) {
                Logger.warn(`Cannot display message, element not found for MessageDisplay. Logging instead: "${message}" (Type: ${type})`);
                // Fallback to console log if UI element is missing.
                switch(type) {
                    case 'error': Logger.error(`UI Message (Error): ${message}`); break;
                    case 'warning': Logger.warn(`UI Message (Warning): ${message}`); break;
                    case 'success': Logger.info(`UI Message (Success): ${message}`); break;
                    default: Logger.info(`UI Message (Info): ${message}`); break;
                }
                return;
            }

            // Clear any previous messages and timers before showing a new one.
            this.clearMessage();
            this.#messageElement.textContent = message;

            // Apply W3CSS style based on type.
            this.#messageElement.classList.add('w3-panel'); // Ensure base class is present
            // Remove all color classes first to avoid multiple background colors
             this.#messageElement.classList.remove('w3-pale-green', 'w3-pale-yellow', 'w3-pale-red', 'w3-pale-blue');
            switch(type) {
                case 'success': this.#messageElement.classList.add('w3-pale-green'); break;
                case 'warning': this.#messageElement.classList.add('w3-pale-yellow'); break;
                case 'error': this.#messageElement.classList.add('w3-pale-red'); break;
                case 'info':
                default: this.#messageElement.classList.add('w3-pale-blue'); break;
            }

            // Show the message element by removing the 'hide' class.
            this.#messageElement.classList.remove('w3-hide');
            Logger.debug(`Displayed message (${type}): "${message}" for ${duration === 0 ? 'infinite' : duration + 'ms'}.`);

            // Set a timer to hide the message if duration is not 0.
            if (duration > 0) {
                this.#timerId = setTimeout(() => {
                    try {
                       this.clearMessage(); // Call clearMessage to hide and reset timer
                       Logger.debug('Message auto-hidden after timeout.');
                    } catch (error) {
                        Logger.error("Error during message auto-hide timeout execution:", error);
                    }
                }, duration);
            }
        } catch (error) {
            Logger.error(`Error displaying message "${message}" (type: ${type}):`, error);
        }
    }

    /**
     * Public method to clear/hide the currently displayed message.
     * Clears the text content, removes type classes, and adds the 'hide' class.
     */
    clearMessage() {
        try {
            if (this.#messageElement) {
                this.#clearTimer(); // Clear any pending auto-hide timer.
                this.#messageElement.textContent = '';
                // Remove type-specific classes.
                this.#messageElement.classList.remove('w3-pale-green', 'w3-pale-yellow', 'w3-pale-red', 'w3-pale-blue');
                 // this.#messageElement.classList.remove('w3-panel'); // Keep w3-panel class unless explicitly removing base styles
                // Hide the element.
                this.#messageElement.classList.add('w3-hide');
                Logger.debug('Message cleared.');
            }
        } catch (error) {
             Logger.error("Error clearing message:", error);
        }
    }

     /**
       * Dispose method.
       * Clears any pending timer and nullifies the element reference.
       */
     dispose() {
         try {
             Logger.debug("Disposing MessageDisplay.");
             this.#clearTimer(); // Ensure timer is stopped
             if (this.#messageElement) {
                 this.clearMessage(); // Clear the message from UI on dispose
             }
             this.#messageElement = null; // Clear reference
             Logger.debug("MessageDisplay disposed.");
         } catch (error) {
             Logger.error("Error disposing MessageDisplay:", error);
         }
     }
}


// --- Class representing the entire search form and application logic ---
// Inherits from TravelComponent as it manages a section of the UI.
// Orchestrates input components, validation, search process, GA tracking,
// and simulated Google services (Auth, Calendar, Email, Pay).
class SearchForm extends TravelComponent {
    // Protected property for input components managed by the form (map: id -> instance).
    _inputs = {};

    // Private members for helper classes and UI elements.
    #paramCollector;
    #urlBuilder;
    #messageDisplay;
    #gaTracker;
    #googleAuthService; // Google Identity Service wrapper instance
    #calendarService; // Simulated Google Calendar service instance
    #emailService; // Simulated Google Email service instance
    #googlePayService; // Simulated Google Pay service wrapper instance

    #searchButton;
    #searchTextSpan;
    #loadingSpinnerSpan;
    #googleServicesSection; // The div containing the Google service buttons
    #addToCalendarButton;
    #emailSearchDetailsButton;
    #googlePayButton; // Google Pay button element
    #googleAuthArea; // Area for Sign-In elements
    #googleSignInButton; // Button to trigger Sign-In
    #googleAuthStatusElement; // Element showing auth status
    #googleAuthTextElement; // Text inside Sign-In button

    // Protected property to store the most recently collected search parameters
    _lastCollectedParams = null;

    /**
     * Constructor for SearchForm.
     * Initializes the form component, input components, helper classes, and Google services.
     * @param {string} elementId - The ID of the form element.
     * @param {string} gaMeasurementId - The Google Analytics Measurement ID.
     * @param {string} googleClientId - The Google OAuth 2.0 Client ID (placeholder for simulation).
     */
    constructor(elementId, gaMeasurementId, googleClientId) {
        try {
            Logger.debug(`SearchForm constructor called for ID "${elementId}"`);
            super(elementId, 'SearchForm'); // Call parent constructor first

            // Initialize MessageDisplay early, even if the main form element is missing,
            // so fatal errors during initialization can be displayed.
            this.#messageDisplay = new MessageDisplay(AppConfig.SELECTORS.MESSAGE_AREA);

            // Check if the main form element was found by the parent constructor.
            if (!this._element) {
                Logger.error(`${this.name} element not found during construction. Form functionality disabled.`);
                 this.#messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Form element "${elementId}" not found.`, 'error', 0); // Display critical error
                // Initialize dummy services/trackers to prevent errors in later calls.
                 this.#gaTracker = { trackEvent: () => { Logger.debug("Dummy GA Track"); }, trackFunnelStep: () => { Logger.debug("Dummy GA Funnel"); } };
                 // Dummy auth/service objects that always return false or reject
                 this.#googleAuthService = { signIn: async () => { throw new Error("Auth disabled"); }, signOut: async () => {}, isSignedIn: () => false, getUserEmail: () => null, handleAuthToggleClick: async () => {} };
                 this.#calendarService = { createEvent: async () => { throw new Error("Calendar disabled"); } };
                 this.#emailService = { sendEmail: async () => { throw new Error("Email disabled"); } };
                 this.#googlePayService = { isReady: () => false, loadPaymentData: async () => { throw new Error("Google Pay disabled"); }, _createPaymentDataRequest: () => null };

                 // Ensure UI elements are null if parent failed to find the form element
                 this.#searchButton = null; this.#searchTextSpan = null; this.#loadingSpinnerSpan = null;
                 this.#googleServicesSection = null; this.#addToCalendarButton = null; this.#emailSearchDetailsButton = null;
                 this.#googlePayButton = null; this.#googleAuthArea = null; this.#googleSignInButton = null;
                 this.#googleAuthStatusElement = null; this.#googleAuthTextElement = null;

                 return; // Stop initialization if form element is missing
            }


             // Initialize Google Analytics tracker if Measurement ID is configured.
             this.#gaTracker = GoogleAnalyticsTracker.isConfigured(gaMeasurementId)
                ? new GoogleAnalyticsTracker(gaMeasurementId)
                : { trackEvent: (name, params) => { Logger.debug(`GA tracking disabled (not configured). Event: ${name}`, params); }, trackFunnelStep: (step, params) => { Logger.debug(`GA tracking disabled (not configured). Funnel Step: ${step}`, params); } }; // Dummy tracker if not configured

             if (!GoogleAnalyticsTracker.isConfigured(gaMeasurementId)) {
                 this.#messageDisplay.showMessage("Note: Google Analytics tracking is not configured.", 'info', 8000);
             }


             // Initialize Simulated Google Authentication and Service classes.
             // Pass required selectors to the Auth wrapper so it can manage its UI elements.
             this.#googleAuthService = new GoogleIdentityServiceWrapper(
                 googleClientId,
                 AppConfig.SELECTORS.GOOGLE_AUTH_STATUS,
                 AppConfig.SELECTORS.GOOGLE_SIGN_IN_BUTTON,
                 AppConfig.SELECTORS.GOOGLE_AUTH_TEXT
             );
             this.#calendarService = new SimulatedGoogleCalendarService(this.#googleAuthService, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS); // Pass auth service
             this.#emailService = new SimulatedGoogleEmailService(this.#googleAuthService, AppConfig.SIMULATED_GOOGLE_SERVICE_DELAY_MS); // Pass auth service
             this.#googlePayService = new GooglePayServiceWrapper(AppConfig.GOOGLE_PAY, AppConfig.GOOGLE_PAY.SIMULATED_SUCCESS_RATE); // Pass config and success rate
             Logger.info("Simulated Google services initialized.");


             this._collectAndInitializeInputs(); // Collect and instantiate input components within the form element.

             // Initialize collector and builder *after* inputs are collected.
             // Pass the input map to the collector.
             this.#paramCollector = new SearchParamCollector(this._inputs);
             this.#urlBuilder = ExpediaUrlBuilder; // Use the static class directly

             // Get references to UI elements *within or related to* the form.
             this.#searchButton = this._element.querySelector(AppConfig.SELECTORS.SEARCH_BUTTON);
             this.#searchTextSpan = this._element.querySelector(AppConfig.SELECTORS.SEARCH_TEXT);
             this.#loadingSpinnerSpan = this._element.querySelector(AppConfig.SELECTORS.LOADING_SPINNER);
             // Google Services section and buttons are NOT inside the form element in HTML
             this.#googleServicesSection = document.querySelector(AppConfig.SELECTORS.GOOGLE_SERVICES_SECTION);
             this.#addToCalendarButton = document.querySelector(AppConfig.SELECTORS.ADD_TO_CALENDAR_BUTTON);
             this.#emailSearchDetailsButton = document.querySelector(AppConfig.SELECTORS.EMAIL_SEARCH_DETAILS_BUTTON);
             this.#googlePayButton = document.querySelector(AppConfig.SELECTORS.GOOGLE_PAY_BUTTON);
             this.#googleAuthArea = document.querySelector(AppConfig.SELECTORS.GOOGLE_AUTH_AREA);
             this.#googleSignInButton = document.querySelector(AppConfig.SELECTORS.GOOGLE_SIGN_IN_BUTTON); // Reference held by GIS wrapper too
             this.#googleAuthStatusElement = document.querySelector(AppConfig.SELECTORS.GOOGLE_AUTH_STATUS); // Reference held by GIS wrapper too
             this.#googleAuthTextElement = document.querySelector(AppConfig.SELECTORS.GOOGLE_AUTH_TEXT); // Reference held by GIS wrapper too


             // Log warnings if critical UI elements are missing outside the form too.
             if (!this.#searchButton) Logger.warn(`Search button element not found with selector "${AppConfig.SELECTORS.SEARCH_BUTTON}".`);
             if (!this.#searchTextSpan) Logger.warn(`Search text span element not found with selector "${AppConfig.SELECTORS.SEARCH_TEXT}".`);
             if (!this.#loadingSpinnerSpan) Logger.warn(`Loading spinner span element not found with selector "${AppConfig.SELECTORS.LOADING_SPINNER}".`);
             if (!this.#googleServicesSection) Logger.warn(`Google Services section element not found with selector "${AppConfig.SELECTORS.GOOGLE_SERVICES_SECTION}".`);
             if (!this.#addToCalendarButton) Logger.warn(`Add to Calendar button element not found with selector "${AppConfig.SELECTORS.ADD_TO_CALENDAR_BUTTON}".`);
             if (!this.#emailSearchDetailsButton) Logger.warn(`Email Search Details button element not found with selector "${AppConfig.SELECTORS.EMAIL_SEARCH_DETAILS_BUTTON}".`);
             if (!this.#googlePayButton) Logger.warn(`Google Pay button element not found with selector "${AppConfig.SELECTORS.GOOGLE_PAY_BUTTON}".`);
             if (!this.#googleAuthArea) Logger.warn(`Google Auth Area element not found with selector "${AppConfig.SELECTORS.GOOGLE_AUTH_AREA}".`);
             if (!this.#googleSignInButton) Logger.warn(`Google Sign-In button element not found with selector "${AppConfig.SELECTORS.GOOGLE_SIGN_IN_BUTTON}".`);
             if (!this.#googleAuthStatusElement) Logger.warn(`Google Auth Status element not found with selector "${AppConfig.SELECTORS.GOOGLE_AUTH_STATUS}".`);
             if (!this.#googleAuthTextElement) Logger.warn(`Google Auth Text element not found with selector "${AppConfig.SELECTORS.GOOGLE_AUTH_TEXT}".`);


             this._attachSubmitHandler(); // Attach form submit listener.
             this._attachButtonListeners(); // Attach button listeners for Google services and Google Pay.

             TravelComponent.logAppVersion(); // Call a static method from the parent class.
             Logger.info(`${this.name} fully initialized.`);

             // Optional: Track a GA event indicating the form is ready/viewed.
             this.#gaTracker.trackEvent('form_ready', { form_id: this.id });

             // Initial update of Google service buttons state based on auth and search data (none initially).
             this._updateGoogleServiceButtonState();


        } catch (error) {
            Logger.error(`Fatal error in SearchForm constructor for ID "${elementId}":`, error);
             // Attempt to display a fatal error message if MessageDisplay was initialized.
            if (this.#messageDisplay) {
                this.#messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + error.message, 'error', 0);
            }
             // Track fatal error in GA if tracker was initialized early enough.
             if (this.#gaTracker && typeof this.#gaTracker.trackEvent === 'function') {
                  this.#gaTracker.trackEvent('fatal_error', { error_code: 'app_init_exception', message: error.message });
             }
             // Ensure component state is invalid if constructor failed.
             this._element = null; // Ensure element is null if it wasn't found or error occurred
             this._isValid = false;
        }
    }

    /**
     * Protected method - called during initialization by the parent constructor.
     */
    _initialize() {
        try {
            super._initialize(); // Call parent initialization logic first.
            Logger.debug(`${this.name} specific initialization logic.`);
            // Any form-specific setup beyond element collection.
            // For example, setting initial state or reading form data on page load.
        } catch (error) {
            Logger.error(`Error in _initialize for ${this.name}:`, error);
        }
    }

    /**
     * Protected method to iterate HTML nodes within the form and initialize corresponding input components.
     * Uses `querySelectorAll` and iterates over elements to create instances of specific InputComponent subclasses.
     */
    _collectAndInitializeInputs() {
         try {
            Logger.debug(`Collecting and initializing form inputs for ${this.name}...`);
             if (!this._element) {
                 Logger.warn("Cannot collect inputs: Form element is missing during collection.");
                 return; // Cannot proceed if form element is null
             }

            // Demonstrate iterating through HTML nodes using querySelectorAll and forEach.
            // Select relevant form elements within the form element.
            const formElements = this._element.querySelectorAll(AppConfig.SELECTORS.INPUT);

            if (formElements.length === 0) {
                Logger.warn(`No input elements found within form ${this.id} using selector "${AppConfig.SELECTORS.INPUT}".`);
            }

            formElements.forEach(element => {
                 try {
                    const inputId = element.id;
                    // Use data attribute to determine component type, fallback to input type if needed.
                    const dataInputType = element.getAttribute('data-input-type');
                    // Using data-component-name could also be an option, but data-input-type is more specific for mapping.

                    if (!inputId) {
                        Logger.warn("Input element found without an ID. Skipping initialization:", element.tagName, element);
                        return; // Skip elements without an ID as we key components by ID.
                    }

                    let inputComponent = null;
                    // Use data-input-type to map to specific component classes.
                    switch (dataInputType) {
                        case 'destination':
                            inputComponent = new DestinationInput(inputId);
                            break;
                        case 'date':
                            // Pass additional data attributes if needed, like date-type.
                             const dateType = element.getAttribute('data-date-type');
                            inputComponent = new DateInput(inputId, dateType);
                            break;
                         case 'number':
                             inputComponent = new NumberInput(inputId);
                             break;
                        // Add cases for other specific input types if needed (select, checkbox, etc.)
                        // case 'select': inputComponent = new SelectInput(inputId); break;
                        default:
                            // For this demo, we'll skip elements without a specific data-input-type
                             // that we have a class for, but log them.
                            Logger.debug(`Skipping element with ID "${inputId}" and data-input-type "${dataInputType || 'none'}" as it doesn't have a recognized specific component class.`);
                            // If you uncommented the below, it would handle any input element with an ID using the generic InputComponent:
                            // inputComponent = new InputComponent(inputId, element.type || element.tagName);
                            return; // Skip if no specific or generic component is created.
                    }

                    // Store the created component instance if successfully created and its element was found by its constructor.
                     // Check if inputComponent was successfully instantiated AND if its internal _element reference is not null.
                     if (inputComponent && inputComponent.getElement()) {
                         this._inputs[inputId] = inputComponent;
                          Logger.debug(`Initialized component "${inputComponent.name}" for ID "${inputId}".`);
                     } else {
                         // If the element was supposed to be there but the component couldn't wrap it
                         Logger.error(`Failed to initialize component for ID "${inputId}" (data-input-type: "${dataInputType || 'none'}"). Check HTML element and component constructor.`);
                         // This input will not be part of this._inputs map, affecting validation/collection.
                     }
                 } catch (error) {
                     Logger.error(`Error processing input element with ID "${element.id || 'N/A'}" during collection:`, error);
                      // Continue to the next element in the loop even if one fails
                 }
            });
             Logger.info(`${Object.keys(this._inputs).length} input components initialized successfully out of ${formElements.length} elements checked.`);
              Logger.debug(`Initialized inputs map:`, this._inputs);
         } catch (error) {
             Logger.error(`Critical error during _collectAndInitializeInputs for ${this.name}:`, error);
             // Clear inputs map in case of critical error during collection process itself
             this._inputs = {};
             throw error; // Re-throw critical error
         }
    }

    /**
     * Protected method to attach the form submit handler to the form element.
     * Uses the protected _addEventListener helper.
     */
    _attachSubmitHandler() {
        try {
            Logger.debug(`Attaching submit handler for ${this.name}.`);
             if (!this._element) {
                 Logger.warn("Cannot attach submit handler: Form element is missing.");
                 return; // Don't attach if element is missing
             }

            // Use the protected _addEventListener helper to attach handler to the form element.
            this._addEventListener('submit', this._handleSubmit);
             Logger.debug("Form submit handler attached.");
        } catch (error) {
            Logger.error(`Error attaching submit handler for ${this.name}:`, error);
             throw error; // Re-throw error
        }
    }

    /**
     * Protected handler for the form submit event. Marked async.
     * Prevents default submission and calls the main async search method.
     * @param {Event} event - The submit event object.
     */
    async _handleSubmit(event) {
         try {
             event.preventDefault(); // Prevent default form submission (page reload).
             Logger.info(`${this.name} submit event intercepted. Calling searchHotels().`);
             // Use await because searchHotels is an async method.
             await this.searchHotels();
         } catch (error) {
             // This catch block is for errors thrown directly by searchHotels or awaits within it.
             Logger.error(`Error in _handleSubmit for ${this.name}:`, error);
             // searchHotels should handle most errors internally, but defensive catch here.
              this.#messageDisplay.showMessage(AppConfig.MESSAGES.SEARCH_ERROR + ' ' + 'An error occurred during form submission handling.', 'error', 0);
             this._hideLoadingState(); // Ensure loading state is hidden on error
         }
    }

    /**
     * Protected method to attach click listeners to the Google service buttons
     * and the Google Sign-In area/button.
     * Uses the protected _addEventListener helper, specifying the target element.
     */
    _attachButtonListeners() {
        try {
            Logger.debug(`Attaching Google service and auth button listeners for ${this.name}.`);

             // Add listener for the main Google Sign-In button
             if (this.#googleSignInButton) {
                  this._addEventListener('click', this._handleGoogleSignInClick, { element: this.#googleSignInButton });
                   Logger.debug("Google Sign-In button listener attached.");
             } else {
                  Logger.warn("Google Sign-In button element not found, listener not attached.");
             }

            // Add listener for the Add to Calendar button
            if (this.#addToCalendarButton) {
                this._addEventListener('click', this._handleAddToCalendarClick, { element: this.#addToCalendarButton });
                 Logger.debug("Add to Calendar button listener attached.");
            } else {
                 Logger.warn("Add to Calendar button not found, listener not attached.");
            }

             // Add listener for the Email Search Details button
            if (this.#emailSearchDetailsButton) {
                this._addEventListener('click', this._handleEmailSearchDetailsClick, { element: this.#emailSearchDetailsButton });
                 Logger.debug("Email Search Details button listener attached.");
            } else {
                 Logger.warn("Email Search Details button not found, listener not attached.");
            }

             // Add listener for the Google Pay button
             if (this.#googlePayButton) {
                 this._addEventListener('click', this._handleGooglePayClick, { element: this.#googlePayButton });
                  Logger.debug("Google Pay button listener attached.");
             } else {
                  Logger.warn("Google Pay button element not found, listener not attached.");
             }


        } catch (error) {
             Logger.error(`Error in _attachButtonListeners for ${this.name}:`, error);
             throw error; // Re-throw error
        }
    }

     /**
      * Handler for clicking the Google Sign-In button. Marked async.
      * Calls the simulate auth service's sign-in/out toggle.
      */
     async _handleGoogleSignInClick() {
         try {
             Logger.info("Google Sign-In button clicked. Calling auth service toggle.");
             this.#gaTracker.trackEvent('auth_button_click', { form_id: this.id }); // GA Event

             // Call the auth service's method to handle the sign-in/out logic.
             // The auth service itself updates its UI and state.
             await this.#googleAuthService.handleAuthToggleClick();

             // Update the state of other Google service buttons after auth state changes.
             this._updateGoogleServiceButtonState();

         } catch (error) {
             Logger.error("Error handling Google Sign-In button click:", error);
             // Specific error message handled by auth service, but update button state defensively.
             this._updateGoogleServiceButtonState();
         }
     }


     /**
      * Protected method to update the state (enabled/disabled, visibility) of Google service buttons
      * based on the authentication status and the availability of search data.
      */
     _updateGoogleServiceButtonState() {
         try {
             // Check dependencies
             if (!this.#googleServicesSection || !this.#addToCalendarButton || !this.#emailSearchDetailsButton || !this.#googlePayButton || !this.#googleAuthService) {
                  Logger.warn("Google service button elements or auth service not available, skipping state update.");
                  return; // Cannot update state if elements or auth service are missing
             }

             const isSignedIn = this.#googleAuthService.isSignedIn();
             // Check if valid search parameters are available (meaning a search was successful)
             const hasSearchParams = this._lastCollectedParams !== null;
             // Check if Google Pay is simulated ready
             const isGooglePayReady = this.#googlePayService ? this.#googlePayService.isReady() : false;

             Logger.debug(`Updating Google service button state. Signed in: ${isSignedIn}, Has search params: ${hasSearchParams}, Google Pay Ready: ${isGooglePayReady}`);

             // Show/hide the entire Google Services section based on whether search params are available.
             // We only show these options *after* a successful search.
             if (hasSearchParams) {
                 this.#googleServicesSection.classList.remove('w3-hide');
                 Logger.debug("Showing Google Services section.");
             } else {
                  this.#googleServicesSection.classList.add('w3-hide');
                 Logger.debug("Hiding Google Services section.");
             }

             // Enable Calendar and Email buttons only if signed in AND search params are available.
             const calendarEmailEnabled = isSignedIn && hasSearchParams;
             if (this.#addToCalendarButton.disabled !== !calendarEmailEnabled) {
                  this.#addToCalendarButton.disabled = !calendarEmailEnabled;
                  Logger.debug(`Add to Calendar button disabled: ${!calendarEmailEnabled}`);
             }
             if (this.#emailSearchDetailsButton.disabled !== !calendarEmailEnabled) {
                  this.#emailSearchDetailsButton.disabled = !calendarEmailEnabled;
                  Logger.debug(`Email Search Details button disabled: ${!calendarEmailEnabled}`);
             }

             // Enable Google Pay button only if it's ready AND search params are available.
             // Google Pay typically doesn't require sign-in with your *website's* Google Auth,
             // but it requires the user to be signed into their Google account in the browser.
             // The simulated Google Pay readiness check accounts for this in a real scenario.
             const googlePayEnabled = isGooglePayReady && hasSearchParams;
             if (this.#googlePayButton.disabled !== !googlePayEnabled) {
                  this.#googlePayButton.disabled = !googlePayEnabled;
                  Logger.debug(`Google Pay button disabled: ${!googlePayEnabled}`);
             }

             // The auth status text and sign-in button state are managed by the GoogleIdentityServiceWrapper itself.

             Logger.debug("Google service button state update finished.");

         } catch (error) {
              Logger.error(`Error in _updateGoogleServiceButtonState for ${this.name}:`, error);
              // Defensive disable of buttons if error occurred during state update logic
              if (this.#addToCalendarButton) this.#addToCalendarButton.disabled = true;
              if (this.#emailSearchDetailsButton) this.#emailSearchDetailsButton.disabled = true;
              if (this.#googlePayButton) this.#googlePayButton.disabled = true;
         }
     }

     /**
      * Handler for the "Add to Calendar" button click. Marked async.
      * Extracts search details and calls the simulated Calendar service.
      */
     async _handleAddToCalendarClick() {
         try {
             Logger.info("Add to Calendar button clicked. Attempting to add event.");
              this.#gaTracker.trackEvent('calendar_add_click', { form_id: this.id }); // GA Event

             this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_INIT, 'info');

             // Double-check dependencies and state (redundant with button state, but safe)
              if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                   const message = AppConfig.MESSAGES.GOOGLE_AUTH_NEEDED;
                  Logger.warn(message);
                  this.#messageDisplay.showMessage(message, 'warning');
                  this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'not_signed_in' });
                  return; // Stop if auth service is missing or user is not signed in
              }
              if (!this._lastCollectedParams) {
                   const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION;
                   Logger.warn(message);
                   this.#messageDisplay.showMessage(message, 'warning');
                    this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'no_search_data' });
                   return; // Stop if no search data
              }
             if (!this.#calendarService) {
                  const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Calendar service is not available.';
                  Logger.error(message);
                  this.#messageDisplay.showMessage(message, 'error');
                  this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'service_not_available' });
                  return;
             }


             // Extract and format necessary details from the last collected parameters for the calendar event.
             const eventDetails = this._getCalendarEventDetails(this._lastCollectedParams);
              if (!eventDetails) {
                  const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Failed to format calendar event details from search data.';
                  Logger.error(message);
                  this.#messageDisplay.showMessage(message, 'error');
                   this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'format_error' });
                  return;
              }

             this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING, 'info', 0); // Persistent message during simulated API call

             // Simulate calling the Google Calendar API via the service class. Await the promise result.
             Logger.debug("Calling simulated Google Calendar service to create event...");
             const result = await this.#calendarService.createEvent(eventDetails);
             Logger.debug("Simulated createEvent result:", result);

             // Process the result of the simulated API call
             if (result && result.success) {
                 this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_SUCCESS, 'success');
                  this.#gaTracker.trackEvent('calendar_add_success', { form_id: this.id }); // GA Success Event
             } else {
                  // This case might be reached if the promise resolved but indicated failure within the result object.
                  // The simulated service is designed to reject on failure, so this block might not be hit,
                  // but it's defensive programming.
                 const message = AppConfig.MESSAGES.CALENDAR_ADD_FAILED(result ? (result.message || 'Unknown response.') : "Empty response.");
                 this.#messageDisplay.showMessage(message, 'error');
                 this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'simulated_api_failure_response' });
             }

         } catch (error) {
             // Catch any errors thrown during the async process (including promise rejections from service)
             Logger.error("Error during _handleAddToCalendarClick:", error);
              const errorMessage = error.message || "An unexpected error occurred adding to calendar.";
             this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_FAILED(errorMessage), 'error');
              // Track specific error if it wasn't already tracked in the try block or service simulation
              const reason = error.message.includes('simulated sign-in') ? 'not_signed_in' :
                             error.message.includes('search data') ? 'no_search_data' :
                             error.message.includes('format') ? 'format_error' :
                             error.message.includes('service is not available') ? 'service_not_available' :
                             error.message.includes('Simulated calendar API error') ? 'simulated_api_error' :
                             'exception';
             this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: reason, error_message: error.message });
         } finally {
             // Ensure any persistent message is cleared or updated after the process finishes.
             // Success message has a duration, error message stays persistent.
              if (this.#messageDisplay && typeof this.#messageDisplay.clearMessage === 'function') {
                   // Let success message auto-clear. Do nothing for persistent error messages.
                   // If the current message element has the error class, don't auto-clear it here.
                  if (this.#messageDisplay.getElement() && !this.#messageDisplay.getElement().classList.contains('w3-pale-red')) {
                     // this.#messageDisplay.clearMessage(); // Only clear non-error messages here
                  }
              }
              Logger.debug("_handleAddToCalendarClick finished.");
         }
     }

     /**
      * Protected helper method to format calendar event details from collected search parameters.
      * Creates an object structure resembling what the Google Calendar API expects.
      * @param {object} params - The collected search parameters.
      * @returns {object|null} - The calendar event object or null if required params are missing or invalid.
      */
     _getCalendarEventDetails(params) {
         try {
              Logger.debug("Formatting calendar event details from params...", params);
             if (!params || typeof params !== 'object' || !params.destination || !params.checkInDate || !params.checkOutDate) {
                 Logger.warn("Missing required params for calendar event formatting.");
                 return null; // Cannot create event without essential details
             }

             const checkInDateString = params.checkInDate; // Expected YYYY-MM-DD format
             const checkOutDateString = params.checkOutDate; // Expected YYYY-MM-DD format

             // Basic validation of date strings
             if (typeof checkInDateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(checkInDateString) ||
                 typeof checkOutDateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(checkOutDateString)) {
                 Logger.error("Invalid date string format for calendar event:", checkInDateString, checkOutDateString);
                 return null;
             }

              // In Google Calendar API, for multi-day events that are "all-day" like a hotel stay,
              // the 'end' date is the day *after* the last day of the event.
              // If check-in is Oct 27 and check-out is Oct 30, the stay is 3 nights (27, 28, 29).
              // The event should start on 2023-10-27 and end on 2023-10-30.
              // If it's a 1-night stay (checkin=2023-10-27, checkout=2023-10-28), the event ends on 2023-10-28.
              // The API requires YYYY-MM-DD for 'date' property.
              const eventStartDate = checkInDateString;
              const eventEndDate = checkOutDateString; // The checkout date is the end date for the calendar event duration

             const event = {
                'summary': `Hotel Stay: ${params.destination}`, // Concise summary
                'location': params.destination, // Destination as location
                'description': `Details for your hotel search:\n\n` +
                               `Destination: ${params.destination}\n` +
                               `Check-in: ${params.checkInDate}\n` +
                               `Check-out: ${params.checkOutDate}\n` +
                               `Adults: ${params.adults}\n` +
                               `Children: ${params.children}\n\n` +
                               `Book or view search results via: ${this.#urlBuilder ? this.#urlBuilder.buildUrl(params) : 'Expedia.com'}`, // Include URL if built
                'start': {
                  'date': eventStartDate, // YYYY-MM-DD format for all-day type event start
                  // For a specific time: 'dateTime': `${startDate}T14:00:00`, requires time inputs
                  // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone, // Use user's timezone
                },
                'end': {
                  'date': eventEndDate, // YYYY-MM-DD format for all-day type event end (day after last night)
                   // 'dateTime': `${endDate}T11:00:00`, // Example check-out time
                   // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                },
                 'alldayEvent': true, // Set to true for multi-day hotel stays (simulated)
                 // Add other optional properties as needed based on Calendar API docs:
                 // 'attendees': [{'email': this.#googleAuthService ? this.#googleAuthService.getUserEmail() : ''}], // Add signed-in user
                 // 'reminders': { 'useDefault': true },
             };

             Logger.debug("Formatted calendar event object:", event);
             return event;

         } catch (error) {
             Logger.error("Error formatting calendar event details:", error);
             return null; // Return null if formatting fails
         }
     }


     /**
      * Handler for the "Email Search Details" button click. Marked async.
      * Extracts search details and calls the simulated Email service.
      */
     async _handleEmailSearchDetailsClick() {
         try {
             Logger.info("Email Search Details button clicked. Attempting to send email.");
              this.#gaTracker.trackEvent('email_details_click', { form_id: this.id }); // GA Event

             this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_INIT, 'info');

             // Double-check dependencies and state (redundant with button state, but safe)
              if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                   const message = AppConfig.MESSAGES.GOOGLE_AUTH_NEEDED;
                  Logger.warn(message);
                  this.#messageDisplay.showMessage(message, 'warning');
                  this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'not_signed_in' });
                  return; // Stop if auth service is missing or user is not signed in
              }
              if (!this._lastCollectedParams) {
                   const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION;
                   Logger.warn(message);
                   this.#messageDisplay.showMessage(message, 'warning');
                    this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'no_search_data' });
                   return; // Stop if no search data
              }
              if (!this.#emailService) {
                  const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Email service is not available.';
                  Logger.error(message);
                  this.#messageDisplay.showMessage(message, 'error');
                  this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'service_not_available' });
                  return;
             }


             // --- Real Email Integration Note ---
             // For a *real* Gmail API integration, you would typically:
             // 1. Get the user's email address (requires 'profile' or 'email' scope during sign-in).
             // 2. Use gapi.client.gmail.users.messages.send to construct and send the email.
             // 3. The 'to' address would often be the user's own email, or they might specify another.
             //    Sending to an arbitrary address requires broader permissions and might be blocked by Google.
             //    For simplicity and security, this simulation assumes sending TO THE SIGNED-IN USER's email.
             //    A production app might use a backend to send emails from *your* server, not the user's account.
             // -------------------------------------

             // Get the simulated signed-in user's email address.
             const userEmail = this.#googleAuthService.getUserEmail();
             if (!userEmail) {
                  const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Cannot determine signed-in user email.';
                  Logger.error(message);
                  this.#messageDisplay.showMessage(message, 'error');
                   this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'user_email_missing' });
                  return;
             }


             // Format the email details object.
             const emailDetails = this._getEmailDetails(this._lastCollectedParams, userEmail);
              if (!emailDetails) {
                   const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Failed to format email details from search data.';
                  Logger.error(message);
                  this.#messageDisplay.showMessage(message, 'error');
                   this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'format_error' });
                 return;
              }


             this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING, 'info', 0); // Persistent message during simulated API call

             // Simulate calling the Google Email API via the service class. Await the promise result.
             Logger.debug("Calling simulated Google Email service to send email...");
             const result = await this.#emailService.sendEmail(emailDetails);
             Logger.debug("Simulated sendEmail result:", result);

             // Process the result of the simulated API call
             if (result && result.success) {
                 this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_SUCCESS, 'success');
                  this.#gaTracker.trackEvent('email_details_success', { form_id: this.id }); // GA Success Event
             } else {
                  // This case might be reached if the promise resolved but indicated failure within the result object.
                  // The simulated service is designed to reject on failure, so this block might not be hit.
                 const message = AppConfig.MESSAGES.EMAIL_SEND_FAILED(result ? (result.message || 'Unknown response.') : "Empty response.");
                 this.#messageDisplay.showMessage(message, 'error');
                 this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'simulated_api_failure_response' });
             }


         } catch (error) {
             // Catch any errors thrown during the async process (including promise rejections from service)
             Logger.error("Error during _handleEmailSearchDetailsClick:", error);
              const errorMessage = error.message || "An unexpected error occurred emailing details.";
             this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_FAILED(errorMessage), 'error');
             // Track specific error if it wasn't already tracked in the try block or service simulation
             const reason = error.message.includes('simulated sign-in') ? 'not_signed_in' :
                            error.message.includes('search data') ? 'no_search_data' :
                            error.message.includes('format') ? 'format_error' :
                            error.message.includes('service is not available') ? 'service_not_available' :
                            error.message.includes('Simulated Gmail API error') ? 'simulated_api_error' :
                            error.message.includes('user email missing') ? 'user_email_missing' :
                            'exception';
             this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: reason, error_message: error.message });
         } finally {
             // Ensure any persistent message is cleared or updated after the process finishes.
              if (this.#messageDisplay && typeof this.#messageDisplay.clearMessage === 'function') {
                   // Let success message auto-clear. Do nothing for persistent error messages.
                  if (this.#messageDisplay.getElement() && !this.#messageDisplay.getElement().classList.contains('w3-pale-red')) {
                     // this.#messageDisplay.clearMessage(); // Only clear non-error messages here
                  }
              }
              Logger.debug("_handleEmailSearchDetailsClick finished.");
         }
     }


     /**
      * Protected helper method to format email details from collected search parameters.
      * Creates an object structure resembling what might be used to send an email.
      * @param {object} params - The collected search parameters.
      * @param {string} recipientEmail - The email address to send the details to (e.g., the signed-in user's email).
      * @returns {object|null} - The email details object or null if required params are missing or invalid.
      */
     _getEmailDetails(params, recipientEmail) {
         try {
             Logger.debug("Formatting email details from params...", params, "Recipient:", recipientEmail);
              if (!params || typeof params !== 'object' || !params.destination || !params.checkInDate || !params.checkOutDate || !recipientEmail || typeof recipientEmail !== 'string' || recipientEmail.trim() === '') {
                  Logger.warn("Missing required params for email formatting.");
                  return null; // Cannot create email without essential details
              }

              // Basic email format validation
             if (!/\S+@\S+\.\S+/.test(recipientEmail.trim())) {
                 Logger.error(`Invalid recipient email format provided: "${recipientEmail}".`);
                 return null;
             }

             const subject = `Hotel Search: ${params.destination} (${params.checkInDate} to ${params.checkOutDate})`;

             const searchLink = this.#urlBuilder ? this.#urlBuilder.buildUrl(params) : 'Expedia.com (URL not built)';
             // Create a plain text body for simplicity in this simulation
             const body = `
                 Dear User,

                 Here are the details for your recent hotel search:

                 Destination: ${params.destination}
                 Check-in Date: ${params.checkInDate}
                 Check-out Date: ${params.checkOutDate}
                 Adults: ${params.adults}
                 Children: ${params.children}

                 You can view the search results by clicking the link below:
                 ${searchLink}

                 Thank you for using our service!

                 Best regards,
                 Expedia Affiliate Demo App
             `.trim(); // Trim leading/trailing whitespace from the template literal

             const email = {
                'to': recipientEmail.trim(),
                'subject': subject,
                'body': body, // Could be HTML body as well in a real API call
                // In a real Gmail API call, you often build a raw MIME message string
                // This object structure is simplified for the simulation.
             };
             Logger.debug("Formatted email object:", email);
             return email;

         } catch (error) {
             Logger.error("Error formatting email details:", error);
             return null; // Return null if formatting fails
         }
     }


     /**
      * Handler for the "Simulated Google Pay" button click. Marked async.
      * Extracts search details and calls the simulated Google Pay service.
      */
     async _handleGooglePayClick() {
         try {
             Logger.info("Simulated Google Pay button clicked.");
              this.#gaTracker.trackEvent('google_pay_click', { form_id: this.id }); // GA Event

             this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_CLICKED, 'info');

             // Double-check dependencies and state (redundant with button state, but safe)
              if (!this.#googlePayService || !this.#googlePayService.isReady()) {
                   const message = AppConfig.MESSAGES.GOOGLE_PAY_NOT_READY;
                  Logger.warn(message);
                  this.#messageDisplay.showMessage(message, 'warning');
                  this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'not_ready' });
                  return; // Stop if Pay service is missing or not ready
              }
              if (!this._lastCollectedParams) {
                   const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION;
                   Logger.warn(message);
                   this.#messageDisplay.showMessage(message, 'warning');
                    this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'no_search_data' });
                   return; // Stop if no search data
              }

             // --- Real Google Pay Flow Note ---
             // 1. You would get search results and select a specific hotel/deal.
             // 2. The price from that selected result would be used for the transactionInfo.totalPrice.
             // 3. You'd construct the PaymentDataRequest dynamically based on the selected item and config.
             // 4. Call paymentsClient.loadPaymentData(paymentDataRequest).
             // 5. Handle the returned PaymentData object. This object contains the encrypted payment token.
             // 6. **Crucially, the payment token MUST be sent to your backend server for processing with your payment gateway.**
             //    You *never* process the payment directly client-side.
             // -------------------------------------

             // For this simulation, use the default transaction info from config,
             // as we don't have actual search results to select a price from.
             const transactionInfo = AppConfig.GOOGLE_PAY.TRANSACTION_INFO;

             // Create the simulated PaymentDataRequest object.
             const paymentDataRequest = this.#googlePayService._createPaymentDataRequest(transactionInfo);
             if (!paymentDataRequest) {
                  const message = AppConfig.MESSAGES.SEARCH_ERROR + ' Failed to create Google Pay request object.';
                 Logger.error(message);
                 this.#messageDisplay.showMessage(message, 'error');
                 this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'request_format_error' });
                 return;
             }

             this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_PROCESSING, 'info', 0); // Persistent message during simulated API call

             // Simulate calling the Google Pay API to load payment data. Await the promise result.
             // In a real app, this would trigger the Google Pay sheet/popup.
             Logger.debug("Calling simulated Google Pay service loadPaymentData...");
             const simulatedPaymentData = await this.#googlePayService.loadPaymentData(paymentDataRequest);
             Logger.debug("Simulated loadPaymentData result:", simulatedPaymentData);

             // Process the result of the simulated API call
             if (simulatedPaymentData && simulatedPaymentData.paymentMethodData) {
                 Logger.info("Simulated Google Pay process successful. Simulated token received.");
                 // --- Real Backend Integration Note ---
                 // Here is where you would send `simulatedPaymentData.paymentMethodData.tokenizationData.token`
                 // to your backend for processing with your payment gateway (e.g., Stripe, Square, etc.).
                 // This simulation stops here.
                 // -------------------------------------

                 this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_SUCCESS, 'success');
                  this.#gaTracker.trackEvent('google_pay_success', { form_id: this.id, totalPrice: transactionInfo.totalPrice, currency: transactionInfo.currencyCode }); // GA Success Event (include price)

             } else {
                  // This case might be reached if the promise resolved but didn't return expected data.
                  // The simulated service is designed to reject on failure, so this might not be hit.
                 const message = AppConfig.MESSAGES.GOOGLE_PAY_FAILED("Unexpected response structure.");
                 Logger.error(message, simulatedPaymentData);
                 this.#messageDisplay.showMessage(message, 'error');
                 this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'simulated_api_invalid_response' });
             }

         } catch (error) {
             // Catch any errors thrown during the async process (including promise rejections from service)
             Logger.error("Error during _handleGooglePayClick:", error);
              const errorMessage = error.message || "An unexpected error occurred during Google Pay.";
             this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_FAILED(errorMessage), 'error');
             // Track specific error if it wasn't already tracked in the try block or service simulation
             const reason = error.message.includes('not ready') ? 'not_ready' :
                            error.message.includes('search data') ? 'no_search_data' :
                            error.message.includes('request object') ? 'request_format_error' :
                            error.message.includes('Simulated Google Pay error') ? 'simulated_api_error' :
                            'exception';
             this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: reason, error_message: error.message });
         } finally {
             // Ensure any persistent message is cleared or updated after the process finishes.
              if (this.#messageDisplay && typeof this.#messageDisplay.clearMessage === 'function') {
                   // Let success message auto-clear. Do nothing for persistent error messages.
                  if (this.#messageDisplay.getElement() && !this.#messageDisplay.getElement().classList.contains('w3-pale-red')) {
                     // this.#messageDisplay.clearMessage(); // Only clear non-error messages here
                  }
              }
              Logger.debug("_handleGooglePayClick finished.");
         }
     }


    /**
     * Public method to trigger the hotel search process. Marked async.
     * Orchestrates validation, parameter collection, simulated async process,
     * URL building, GA tracking, and finally redirects the user.
     * Updates UI state (loading, messages, Google services button state) throughout the process.
     */
    async searchHotels() {
        try {
            Logger.info("Initiating hotel search process (async)...");
            this.#gaTracker.trackFunnelStep('search_initiated', { form_id: this.id }); // GA Funnel Step 1 (Start)
            this._showLoadingState(); // Indicate loading to the user

            this.#messageDisplay.clearMessage(); // Clear previous messages before starting.
            this.#messageDisplay.showMessage(AppConfig.MESSAGES.SEARCH_INITIATED, 'info', AppConfig.MESSAGE_DISPLAY_DURATION_MS);

            // --- Step 1: Validate the form inputs ---
            // Validation is synchronous, but we wrap it in try/catch for robustness.
            let isFormValid = false;
            try {
                Logger.debug("Executing form validation (_validateForm)...");
                isFormValid = this._validateForm();
                Logger.debug(`Form validation result: ${isFormValid}`);
            } catch (validationError) {
                // Catch unexpected errors *during* the validation process itself.
                Logger.error("Exception during _validateForm:", validationError);
                 isFormValid = false; // Ensure valid state is false if validation threw an error
                 const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Validation process failed unexpectedly: ${validationError.message}`;
                 this.#messageDisplay.showMessage(errorMessage, 'error', 0); // Persistent error message
                 this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'validation_exception', error_message: validationError.message });
            }

            // Check validation result. If invalid, stop the process.
            if (!isFormValid) {
                Logger.warn("Form validation failed. Stopping search process.");
                // The _validateForm method should have displayed specific errors on inputs.
                const errorMessage = AppConfig.MESSAGES.FORM_INVALID; // Generic form invalid message
                // Only show this generic message if a more specific error message isn't already persistent.
                if (!this.#messageDisplay.getElement() || !this.#messageDisplay.getElement().classList.contains('w3-pale-red')) {
                     this.#messageDisplay.showMessage(errorMessage, 'warning');
                }
                this.#gaTracker.trackFunnelStep('validation_failed', { form_id: this.id }); // GA Funnel Step: Validation Failed
                this._hideLoadingState(); // Hide loading state if validation fails.
                 // Ensure Google services section is hidden/disabled as form is invalid
                 this._lastCollectedParams = null; // Clear stored params
                 this._updateGoogleServiceButtonState();
                return; // Exit the async function
            }

            // --- Step 2: Simulated Asynchronous Process ---
            // This simulates waiting for an API response or other async operation.
            Logger.info("Form is valid. Proceeding with search execution steps.");
            this.#gaTracker.trackFunnelStep('validation_success', { form_id: this.id }); // GA Funnel Step 2 (Validation Success)
            this.#messageDisplay.showMessage(AppConfig.MESSAGES.SEARCH_PROCESSING, 'info', 0); // Show persistent message during async step

            try {
                Logger.debug("Awaiting simulated async process (_simulateAsyncProcess)...");
                const simulatedResult = await this._simulateAsyncProcess();
                Logger.debug("Simulated async process complete. Result:", simulatedResult);
                this.#gaTracker.trackFunnelStep('async_process_complete', { form_id: this.id, delay: AppConfig.SIMULATED_ASYNC_DELAY_MS }); // GA Funnel Step 3 (Async Complete)
            } catch (asyncError) {
                // Catch errors thrown by the simulated async process (promise rejection).
                Logger.error("Error during simulated async process:", asyncError);
                const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Processing step failed: ${asyncError.message}`;
                this.#messageDisplay.showMessage(errorMessage, 'error'); // Show error message
                this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'async_process_exception', error_message: asyncError.message }); // GA Error Event
                this._hideLoadingState(); // Hide loading state
                // Ensure Google services section is hidden/disabled on error
                 this._lastCollectedParams = null; // Clear stored params
                 this._updateGoogleServiceButtonState();
                return; // Exit the async function
            }
            // --- End Simulation ---


            // --- Step 3: Collect Search Parameters ---
            // Collect parameters using the helper class *after* the async step.
            let searchParams = null;
            try {
                Logger.debug("Collecting parameters after async step using #paramCollector...");
                searchParams = this.#paramCollector.collect();
                this._lastCollectedParams = searchParams; // Store the collected parameters for Google services section
                Logger.debug("Parameters collected after async step.");
                this.#gaTracker.trackEvent('search_params_collected', { form_id: this.id, params: Object.keys(searchParams).length }); // GA Event
            } catch (collectionError) {
                 // Catch errors during parameter collection.
                 Logger.error("Error during parameter collection after async step:", collectionError);
                 const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Parameter collection failed: ${collectionError.message}`;
                 this.#messageDisplay.showMessage(errorMessage, 'error'); // Show error message
                 this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'param_collection_exception', error_message: collectionError.message }); // GA Error Event
                 this._hideLoadingState(); // Hide loading state
                 // Ensure Google services section is hidden/disabled on error
                 this._lastCollectedParams = null; // Clear stored params
                 this._updateGoogleServiceButtonState();
                 return; // Exit the async function
            }


            // --- Step 4: Build the Expedia URL ---
            // Build the redirect URL using the static helper class.
            let expediaUrl = null;
            try {
                Logger.debug("Building Expedia URL using #urlBuilder...");
                expediaUrl = this.#urlBuilder.buildUrl(searchParams);
                Logger.debug("Expedia URL building attempt complete.");
            } catch (urlBuildError) {
                // Catch unexpected errors during URL building.
                Logger.error("Error during URL building:", urlBuildError);
                 // The buildUrl method (or its catch block) might log its specific error internally.
                 const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Failed to construct Expedia URL: ${urlBuildError.message}`;
                 this.#messageDisplay.showMessage(errorMessage, 'error'); // Show error message
                 this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'url_build_exception', error_message: urlBuildError.message }); // GA Error Event
                 expediaUrl = null; // Ensure URL is null if building threw an error
            }


            // --- Step 5: Handle Result (Redirect or API Call) ---
            // If the URL was successfully built, proceed with redirection.
            if (expediaUrl) {
                Logger.info("Expedia URL successfully built. Preparing for redirect.");
                this.#gaTracker.trackFunnelStep('url_built', { form_id: this.id }); // GA Funnel Step 4 (URL Built)

                 this.#messageDisplay.showMessage(AppConfig.MESSAGES.SEARCH_REDIRECT, 'success', 3000); // Inform user before redirect (temporary success message)

                // Show/update Google Services section now that we have valid search data and the search completed.
                 this._updateGoogleServiceButtonState();

                // Perform the redirect after a small delay to allow the success message to be seen
                // and any final GA tracking events to potentially send before the page unloads.
                 setTimeout(() => {
                     try {
                         Logger.info("Redirecting browser to:", expediaUrl);
                         this.#gaTracker.trackFunnelStep('redirect_initiated', { form_id: this.id, url: expediaUrl }); // GA Funnel Step 5 (Redirect)
                         // Add a small final delay after tracking to allow the GA hit to send
                          // before redirecting. This is best practice.
                          setTimeout(() => {
                              window.location.href = expediaUrl; // Perform the redirect.
                               // Note: Code after this line might not execute reliably in some browsers
                               // as the page is unloading.
                          }, AppConfig.GA_REDIRECT_DELAY_MS); // Short delay for GA send

                     } catch (redirectError) {
                         // Catch errors that might occur *inside* the timeout function just before redirecting.
                         Logger.error("Error during redirection timeout:", redirectError);
                          const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Redirection failed: ${redirectError.message}`;
                         this.#messageDisplay.showMessage(errorMessage, 'error', 0); // Persistent error
                         this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'redirect_exception', error_message: redirectError.message }); // GA Error
                         this._hideLoadingState(); // Hide loading if redirect failed unexpectedly
                     }
                 }, 500); // Initial delay before starting redirect process


                // If using API instead of redirect, would make Ajax call here using async/await:
                // try {
                //    const apiResults = await this._performAjaxSearch(searchParams);
                //    // Process and display apiResults here instead of redirecting
                //    this._displaySearchResults(apiResults);
                // } catch (apiError) {
                //    // Handle API errors
                //    Logger.error("API search failed:", apiError);
                //    this.#messageDisplay.showMessage(AppConfig.MESSAGES.SEARCH_ERROR + ' API search failed.', 'error');
                //    this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'api_search_exception', error_message: apiError.message });
                // }


            } else {
                // If URL building failed (e.g., due to missing/invalid parameters not caught by validation).
                // The URL builder (or its catch block) should have logged the specific reason.
                const errorMessage = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + 'Failed to build search URL.';
                // Only display this generic message if the URL builder didn't set a more specific one
                // or if there wasn't a validation error message already.
                 if (!this.#messageDisplay.getElement() || (this.#messageDisplay.getElement().textContent === '' || !this.#messageDisplay.getElement().classList.contains('w3-pale-red'))) {
                     this.#messageDisplay.showMessage(errorMessage, 'error'); // Show error message
                 }
                this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'url_build_failed' }); // GA Error Event
                this._hideLoadingState(); // Hide loading on failure
                 // Ensure Google services section is hidden/disabled on failure
                this._lastCollectedParams = null; // Clear stored params
                this._updateGoogleServiceButtonState();
            }

        } catch (overallError) {
            // Catch any unexpected errors that occur during the *overall* search process flow
            // that were not caught by the specific try/catch blocks within the steps.
            const errorMessage = AppConfig.MESSAGES.FATAL_ERROR + ' ' + 'An unexpected error occurred during the search process.';
            Logger.error(errorMessage, overallError);
            this.#gaTracker.trackEvent('fatal_error', { form_id: this.id, error_code: 'search_process_exception', error_message: overallError.message }); // GA Error Event
            this.#messageDisplay.showMessage(`${errorMessage} Details: ${overallError.message}`, 'error', 0); // Show persistent error
            this._hideLoadingState(); // Hide loading on error.
             // Ensure Google services section is hidden/disabled on fatal error
            this._lastCollectedParams = null; // Clear stored params
            this._updateGoogleServiceButtonState();
        } finally {
            // This block always executes after try/catch, but before async function returns.
            // It's a good place for cleanup that must happen whether successful or not.
            // In this case, loading state hiding is already handled in catch blocks or before redirect.
            // The MessageDisplay is also handled elsewhere.
            Logger.debug("Search process finally block executed.");
        }
    }

    /**
     * Protected method to perform a simulated asynchronous operation.
     * Used to demonstrate `async`/`await` flow.
     * Returns a Promise that resolves or rejects after a delay.
     * @returns {Promise<string>} A Promise that resolves with simulated data or rejects with an error.
     */
    _simulateAsyncProcess() {
        try {
            Logger.debug(`Starting simulated async process for ${AppConfig.SIMULATED_ASYNC_DELAY_MS}ms...`);
            return new Promise((resolve, reject) => {
                setTimeout(() => {
                    try {
                        // Simulate success or failure randomly.
                         const simulateSuccess = Math.random() > 0.1; // 90% success rate for this step

                         if (simulateSuccess) {
                             Logger.debug("Simulated async process finished successfully.");
                             resolve('Simulated data payload'); // Resolve the promise with some dummy data
                         } else {
                             Logger.warn("Simulated async process failed randomly.");
                             reject(new Error("Simulated processing failure."));
                         }
                    } catch (timeoutError) {
                        // Catch errors that might occur *inside* the setTimeout callback function
                         Logger.error("Error within simulated async timeout function:", timeoutError);
                         reject(new Error(`Internal simulated async error: ${timeoutError.message}`)); // Reject the promise
                    }
                }, AppConfig.SIMULATED_ASYNC_DELAY_MS); // Use configured delay
            });
        } catch (error) {
            // Catch errors that occur *before* the promise is created (e.g., bad config)
            Logger.error("Error setting up simulated async process promise:", error);
            // Return a promise that immediately rejects to signal failure
            return Promise.reject(new Error(`Failed to start simulated async process: ${error.message}`));
        }
    }


    /**
     * Protected method to validate all input components and perform cross-field validation logic.
     * Iterates through input components calling their individual `validate()` methods (polymorphism)
     * and then performs checks involving multiple input values.
     * @returns {boolean} - True if all validation passes, false otherwise.
     * @throws {Error} If a critical error occurs during the validation process itself.
     */
    _validateForm() {
         try {
             Logger.debug("Validating form (synchronous step)...");
            let isFormValid = true;
            let firstInvalidInputId = null;

            // --- Step 1: Validate individual inputs (polymorphism) ---
            Logger.debug("Step 1: Validating individual inputs...");
            // Iterate through initialized input components and call their public `validate()` method.
            // Using Object.values is a clean way to iterate component instances.
            Object.values(this._inputs).forEach(component => {
                 try {
                    // Call the public validate() method on each component.
                    // This method in turn calls the component-specific _validate(),
                    // updates the component's internal _isValid state, and sets native custom validity.
                    if (!component.validate()) {
                        isFormValid = false; // If any input is invalid, the overall form is invalid.
                         // Keep track of the ID of the first input that failed validation.
                         if (firstInvalidInputId === null) { // Only set if it's the first one
                             firstInvalidInputId = component.id;
                         }
                         Logger.debug(`Input "${component.name}" failed validation.`);
                    } else {
                         Logger.debug(`Input "${component.name}" passed validation.`);
                         // If an input passes validation, ensure any previous custom validity message
                         // set by cross-field validation is cleared *if* that message is the only issue now.
                         // This is handled somewhat by individual input's _clearErrorMessage,
                         // but can be defensive here too.
                          if (component._element) {
                               // Clear native validity if it passed its own checks.
                               // Cross-field validation might re-set it later.
                              component._element.setCustomValidity('');
                          }
                    }
                 } catch (error) {
                     // Catch unexpected errors *during* an individual component's validate method.
                     Logger.error(`Error validating input "${component.id}" during iteration:`, error);
                     isFormValid = false; // An error in validation itself makes the form invalid.
                      // Set a generic error message on the input if possible, fallback to form message.
                      const errorMsg = `Error validating input "${component.id}".`;
                     if (component && typeof component._setErrorMessage === 'function') {
                          component._setErrorMessage(errorMsg);
                      } else {
                           // Use a short duration as other errors might appear
                          this.#messageDisplay.showMessage(errorMsg, 'error', 5000);
                      }
                     if (firstInvalidInputId === null) { // If this is the first error encountered
                         firstInvalidInputId = component.id;
                     }
                 }
            });
             Logger.debug(`Individual input validation complete. Form is valid so far: ${isFormValid}`);


             // --- Step 2: Perform form-level (cross-field) validation ---
             // These checks involve relationships between multiple inputs.
             // Only proceed with cross-field checks if inputs passed individual validation so far,
             // as dependent checks might fail if individual inputs are invalid.
             if (isFormValid) { // Only proceed if all inputs passed individual checks
                 Logger.debug("Step 2: Performing form-level validation (cross-field checks)...");
                 try {
                     // Get component instances for cross-field checks. Use the _inputs map.
                     const checkInInput = this._inputs['checkInDate'];
                     const checkOutInput = this._inputs['checkOutDate'];
                     const adultsInput = this._inputs['adults'];
                     const childrenInput = this._inputs['children']; // Assuming children input exists

                     // Cross-field validation 1: Check-out date must be strictly after check-in date.
                     if (checkInInput && checkOutInput) {
                         const checkInDate = checkInInput.DateObject; // Use DateObject getter
                         const checkOutDate = checkOutInput.DateObject;

                         // Only perform date comparison if both date inputs provided valid Date objects.
                         // Their individual validation already checked format and required status.
                         if (checkInDate && checkOutDate) {
                             Logger.debug("Performing check-out vs check-in date comparison.");
                             if (checkOutDate <= checkInDate) {
                                  const message = AppConfig.MESSAGES.CHECKOUT_BEFORE_CHECKIN;
                                 // Set error on the check-out date field component using its protected method.
                                 checkOutInput._setErrorMessage(message);
                                 Logger.warn(`Form validation failed (cross-field): ${message}`);
                                 isFormValid = false; // Overall form is now invalid
                                  if (firstInvalidInputId === null) firstInvalidInputId = checkOutInput.id; // If this is the very first error
                             } else {
                                 // If dates are valid and in correct order, clear the cross-field error specifically *from the check-out input*.
                                 // This doesn't clear individual date format errors etc., only this specific check's message.
                                  // We need to check if the *current* error message on the element is the one *we* set for this specific check.
                                 if (checkOutInput._errorMessageElement && checkOutInput._errorMessageElement.textContent === AppConfig.MESSAGES.CHECKOUT_BEFORE_CHECKIN) {
                                      checkOutInput._clearErrorMessage();
                                       Logger.debug("Cleared cross-field date error message from check-out input.");
                                 }
                             }
                         } else {
                             // If one or both DateObjects are null here, it means individual DateInput validation failed
                             // (e.g. required missing or invalid format). The individual input error message handles this,
                             // and isFormValid is already false from Step 1. No cross-field check needed.
                             Logger.debug("DateObjects not valid for cross-field check. Relying on input validation results.");
                         }
                     } else {
                         Logger.warn("Date input components not found for cross-validation (checkInDate/checkOutDate). Check IDs or initialization logic.");
                         // If critical inputs are missing, the form validation might not be fully reliable.
                         // Consider setting isFormValid = false here if these inputs are essential.
                         // For this demo, rely on individual input validation catching missing elements.
                     }

                     // Cross-field validation 2: Adults + Children total count (optional business logic)
                     // Example: Expedia searches might have a max total per room or per search.
                     if (adultsInput && childrenInput) {
                         const adultsCount = adultsInput.getValueAsNumber();
                         const childrenCount = childrenInput.getValueAsNumber();
                         const totalTravelers = adultsCount + childrenCount;
                         const maxTravelersPerRoom = 8; // Example max travelers per room

                         // Only perform this check if individual number inputs are considered valid numbers.
                         if (!isNaN(adultsCount) && !isNaN(childrenCount)) {
                              Logger.debug(`Performing total travelers check: Adults=${adultsCount}, Children=${childrenCount}, Total=${totalTravelers}. Max=${maxTravelersPerRoom}.`);
                             if (totalTravelers > maxTravelersPerRoom) {
                                 const message = `Total travelers (${totalTravelers}) exceeds maximum allowed per room (${maxTravelersPerRoom}).`;
                                 // Decide where to show this error - maybe form level, or on the adults input.
                                 // Showing on adults field for simplicity:
                                  adultsInput._setErrorMessage(message);
                                 Logger.warn(`Form validation failed (cross-field): ${message}`);
                                 isFormValid = false; // Overall form is invalid
                                  if (firstInvalidInputId === null) firstInvalidInputId = adultsInput.id;
                             } else {
                                 // Clear this specific error if it was previously set on the adults input.
                                  if (adultsInput._errorMessageElement && adultsInput._errorMessageElement.textContent.includes("Total travelers")) {
                                       adultsInput._clearErrorMessage();
                                        Logger.debug("Cleared total travelers error message from adults input.");
                                  }
                             }
                         } else {
                             // Individual number input validation already failed (e.g., not a number or required missing).
                             // isFormValid is already false from Step 1. No need to check total.
                             Logger.debug("Skipping total travelers check as individual number inputs are invalid (NaN).");
                         }
                     } else {
                         Logger.warn("Adults or Children input components not found for total traveler validation. Check IDs or initialization logic.");
                     }

                    // Add more sophisticated form-level checks here if needed...
                     // Example 3: Check min/max stay duration (e.g., min 1 night, max 30 nights).
                     if (checkInInput && checkOutInput) { // Only if components exist
                          try {
                              const checkInDate = checkInInput.DateObject;
                              const checkOutDate = checkOutInput.DateObject;
                               // Check only if both are valid Date objects
                               if (checkInDate && checkOutDate) {
                                  Logger.debug("Performing min/max stay duration check.");
                                  const oneDay = 24 * 60 * 60 * 1000; // hours*minutes*seconds*milliseconds
                                  // Calculate difference in days, accounting for potential timezone issues by rounding
                                  const diffTime = checkOutDate.getTime() - checkInDate.getTime();
                                  const diffDays = Math.round(diffTime / oneDay); // Use round to handle daylight savings time edge cases

                                  const minStay = 1; // Minimum 1 night stay
                                  const maxStay = 30; // Example max stay 30 nights

                                  if (diffTime < 0) { // Check if checkout is before checkin (redundant with cross-field date check, but defensive)
                                       // Message already handled by cross-field date check.
                                  } else if (diffDays < minStay) {
                                      const message = `Minimum stay is ${minStay} night(s).`;
                                      checkOutInput._setErrorMessage(message); // Show error on check-out field
                                      Logger.warn(`Form validation failed (min stay): ${message}`);
                                       isFormValid = false; // Overall form is invalid
                                       if (firstInvalidInputId === null) firstInvalidInputId = checkOutInput.id;
                                  } else if (diffDays > maxStay) {
                                       const message = `Maximum stay is ${maxStay} nights.`;
                                      checkOutInput._setErrorMessage(message); // Show error on check-out field
                                       Logger.warn(`Form validation failed (max stay): ${message}`);
                                       isFormValid = false; // Overall form is invalid
                                       if (firstInvalidInputId === null) firstInvalidInputId = checkOutInput.id;
                                  } else {
                                       // Clear min/max stay error message if previously set on the check-out input.
                                       if (checkOutInput._errorMessageElement && (checkOutInput._errorMessageElement.textContent.includes("Minimum stay") || checkOutInput._errorMessageElement.textContent.includes("Maximum stay"))) {
                                             checkOutInput._clearErrorMessage();
                                              Logger.debug("Cleared min/max stay error from check-out input.");
                                       }
                                  }
                               } else {
                                    Logger.debug("DateObjects not valid for min/max stay check. Relying on input validation results.");
                               }
                          } catch (dateCheckError) {
                               // Catch errors during min/max stay calculation or messaging.
                               Logger.error("Error during min/max stay date check:", dateCheckError);
                               // Don't necessarily invalidate the form for this calculation error, but log it.
                               // Or set a generic error message on the form message area if preferred.
                          }
                     }


                 } catch (crossFieldError) {
                      // Catch unexpected errors during the cross-field validation process itself.
                      Logger.error("Error during form-level validation:", crossFieldError);
                      isFormValid = false; // Overall form is invalid due to this error
                       const errorMsg = AppConfig.MESSAGES.SEARCH_ERROR + ' ' + `Error during form-level validation: ${crossFieldError.message}`;
                       this.#messageDisplay.showMessage(errorMsg, 'error', 0); // Show persistent error
                       this.#gaTracker.trackEvent('search_error', { form_id: this.id, error_type: 'form_level_validation_exception', error_message: crossFieldError.message }); // GA Error Event
                 }
             } else {
                 // If individual input validation already failed (isFormValid is false from Step 1),
                 // cross-field checks are often skipped or their results ignored for the overall form validity,
                 // as fixing individual inputs is the first priority.
                 Logger.debug("Skipping form-level cross-field validation because individual input validation failed.");
             }

            // --- Step 3: Report overall validity and potentially focus the first invalid input ---
            this._isValid = isFormValid; // Update form's overall validity state based on combined checks.
            Logger.info(`Form validation finished. Overall validity: ${this._isValid}`);

            // Use native form checkValidity() which aggregates individual input validities set by setCustomValidity.
            // Calling this method also has the side effect of triggering native browser validation UI (popups)
            // if setCustomValidity has been called with a non-empty message on any element, and reportValidity()
            // is either called here or implicitly by the browser (e.g., on submit click).
            if (this._element) {
                 const nativeFormValid = this._element.checkValidity();
                 if (!nativeFormValid) {
                     Logger.debug("Native form checkValidity() returned false.");
                     // You could optionally call this._element.reportValidity() here
                     // to show the first native validation popup immediately on explicit validate().
                     // This is often less desirable than showing custom messages below inputs.
                 } else {
                     Logger.debug("Native form checkValidity() returned true.");
                 }
                 // Ensure our internal state aligns with native checkValidity if possible,
                 // although our custom checks (like cross-field) might make our isFormValid stricter
                 // than native checkValidity (which only checks standard HTML5 validation).
                 // We will stick to our `isFormValid` result as the source of truth for the app logic.
            }


            // Optional: Focus the first invalid input for better user experience.
            if (!this._isValid && firstInvalidInputId) {
                const firstInvalidElement = document.getElementById(firstInvalidInputId);
                if (firstInvalidElement) {
                    Logger.debug(`Focusing first invalid element: ${firstInvalidInputId}`);
                    // Use setTimeout to ensure focus happens after any potential DOM updates or message displays.
                     setTimeout(() => {
                         try {
                           firstInvalidElement.focus();
                           // Optionally, trigger reportValidity() on the element to show its specific native message immediately.
                           // firstInvalidElement.reportValidity();
                         } catch (focusError) {
                              Logger.error(`Error focusing element ${firstInvalidInputId}:`, focusError);
                         }
                     }, 50); // Small delay
                } else {
                     Logger.warn(`First invalid element with ID "${firstInvalidInputId}" not found in the DOM for focusing.`);
                }
            }

            return this._isValid; // Return the final combined validation result.

         } catch (error) {
             // Catch any critical errors during the overall _validateForm process itself
             Logger.error(`Critical error in _validateForm for ${this.name}:`, error);
             this._isValid = false; // Form validation failed due to critical error
              const errorMessage = AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Critical error during validation process: ${error.message}`;
              this.#messageDisplay.showMessage(errorMessage, 'error', 0); // Show persistent fatal error
             this.#gaTracker.trackEvent('fatal_error', { form_id: this.id, error_code: 'validation_critical_exception', message: error.message }); // GA Fatal Error
             return false; // Return false on critical error
         }
    }

    /**
     * Protected method to toggle the loading state of the search button and spinner.
     */
    _showLoadingState() {
        try {
            if (this.#searchButton) {
                this.#searchButton.disabled = true; // Disable button during search
                if (this.#searchTextSpan) this.#searchTextSpan.classList.add('w3-hide'); // Hide text
                if (this.#loadingSpinnerSpan) this.#loadingSpinnerSpan.classList.remove('w3-hide'); // Show spinner
                // Add a class to the form or button for styling loading state if needed
                // this.#searchButton.classList.add('loading');
                Logger.debug("Showing loading state.");
            } else {
                 Logger.warn("Cannot show loading state: Search button element missing.");
            }
        } catch (error) {
            Logger.error("Error showing loading state:", error);
        }
    }

    /**
     * Protected method to hide the loading state of the search button and spinner.
     */
     _hideLoadingState() {
         try {
             if (this.#searchButton) {
                 this.#searchButton.disabled = false; // Re-enable button
                 if (this.#searchTextSpan) this.#searchTextSpan.classList.remove('w3-hide'); // Show text
                 if (this.#loadingSpinnerSpan) this.#loadingSpinnerSpan.classList.add('w3-hide'); // Hide spinner
                  // this.#searchButton.classList.remove('loading');
                 Logger.debug("Hiding loading state.");
             } else {
                 Logger.warn("Cannot hide loading state: Search button element missing.");
             }
         } catch (error) {
             Logger.error("Error hiding loading state:", error);
         }
     }

     /**
      * Public method to dispose of the SearchForm instance and all its managed components and services.
      * Should be called when the application section is unloaded or destroyed.
      */
     dispose() {
         try {
             Logger.info(`Disposing SearchForm instance: ${this.name}`);
             super.dispose(); // Call parent dispose (removes form submit listener and element-based handlers)

             // Dispose of all managed input components if they have a dispose method
             Object.values(this._inputs).forEach(component => {
                  try {
                       if (component && typeof component.dispose === 'function') {
                           component.dispose(); // Call dispose on each input component
                       } else if (component) {
                            Logger.debug(`Input component "${component.id}" does not have a dispose method.`);
                       }
                  } catch (compDisposeError) {
                       Logger.error(`Error disposing input component "${component ? component.id : 'unknown'}":`, compDisposeError);
                  }
             });
             this._inputs = {}; // Clear the inputs map reference

              // Dispose of helper services if they have a dispose method
              try { if (this.#paramCollector && typeof this.#paramCollector.dispose === 'function') this.#paramCollector.dispose(); } catch(e) { Logger.error("Error disposing param collector:", e); }
              try { if (this.#messageDisplay && typeof this.#messageDisplay.dispose === 'function') this.#messageDisplay.dispose(); } catch(e) { Logger.error("Error disposing message display:", e); }
              // GA tracker typically doesn't need explicit dispose client-side
              // try { if (this.#gaTracker && typeof this.#gaTracker.dispose === 'function') this.#gaTracker.dispose(); } catch(e) { Logger.error("Error disposing GA tracker:", e); }
              try { if (this.#googleAuthService && typeof this.#googleAuthService.dispose === 'function') this.#googleAuthService.dispose(); } catch(e) { Logger.error("Error disposing auth service:", e); }
              try { if (this.#calendarService && typeof this.#calendarService.dispose === 'function') this.#calendarService.dispose(); } catch(e) { Logger.error("Error disposing calendar service:", e); }
              try { if (this.#emailService && typeof this.#emailService.dispose === 'function') this.#emailService.dispose(); } catch(e) { Logger.error("Error disposing email service:", e); }
              try { if (this.#googlePayService && typeof this.#googlePayService.dispose === 'function') this.#googlePayService.dispose(); } catch(e) { Logger.error("Error disposing Google Pay service:", e); }


             // Clear references to helper classes and UI elements
             this.#paramCollector = null;
             this.#urlBuilder = null; // Static class, no need to nullify instance variable
             this.#messageDisplay = null;
             this.#gaTracker = null;
             this.#googleAuthService = null;
             this.#calendarService = null;
             this.#emailService = null;
             this.#googlePayService = null;

             // Clear element references (optional but good practice)
             this.#searchButton = null;
             this.#searchTextSpan = null;
             this.#loadingSpinnerSpan = null;
             this.#googleServicesSection = null;
             this.#addToCalendarButton = null;
             this.#emailSearchDetailsButton = null;
             this.#googlePayButton = null;
             this.#googleAuthArea = null;
             this.#googleSignInButton = null;
             this.#googleAuthStatusElement = null;
             this.#googleAuthTextElement = null;

             this._lastCollectedParams = null; // Clear last search data

             Logger.info(`${this.name} instance fully disposed.`);
         } catch (error) {
             Logger.error(`Critical error during disposal of ${this.name}:`, error);
         }
     }

    // Example of a protected method for performing Ajax search (NOT used for Expedia direct).
    // This is just to demonstrate how you *would* structure an Ajax call using async/await
    // if you were interacting with YOUR OWN backend proxy or a different API.
    /*
    async _performAjaxSearch(searchParams) {
        try {
            Logger.info("Attempting simulated Ajax search using async/await...");
            this.#messageDisplay.showMessage('Searching (simulated Ajax)...', 'info', 0); // Show persistent searching message
             this.#gaTracker.trackEvent('ajax_search_attempt', { form_id: this.id }); // GA Event

            // This Ajax call will fail due to Same-Origin Policy if pointed at expedia.com.
            // It would work if pointed at your backend server or a public API that allows CORS.
            // Replace with your actual backend endpoint.
            const proxyUrl = '/your-backend-proxy/expedia-search'; // Example URL to your server-side proxy

            try {
                // Using jQuery's Promise interface with await
                const response = await $.ajax({
                    url: proxyUrl,
                    method: 'GET', // Or POST, depending on your proxy API
                    data: searchParams, // Send search parameters
                    dataType: 'json', // Expect JSON response
                    timeout: 20000, // Example timeout (increased)
                });

                // If we reach here, the promise resolved (success)
                Logger.info("Simulated Ajax Success:", response);
                this.#gaTracker.trackEvent('ajax_search_success', { form_id: this.id }); // GA Success Event
                this.#messageDisplay.showMessage('Search complete!', 'success'); // Show success message

                // Process and display results in the #resultsArea div.
                const resultsArea = document.getElementById('resultsArea');
                if(resultsArea) {
                    resultsArea.innerHTML = '<h3>Simulated Search Results:</h3><pre>' + JSON.stringify(response, null, 2) + '</pre>';
                } else {
                     Logger.warn("#resultsArea element not found to display results.");
                }

                 // Optional: After displaying results, you might update the Google service buttons
                 // state if the results provide data needed for those actions (e.g., price for Google Pay).
                 // In this simulation, we only update after the initial form search/redirect.

            } catch (jqXHR) {
                // If the promise was rejected (error)
                const textStatus = jqXHR.statusText || 'Unknown Error';
                const errorThrown = jqXHR.status || 'N/A';
                const responseText = jqXHR.responseText;

                Logger.error("Simulated Ajax Error:", textStatus, errorThrown, responseText);

                 let errorMsg = AppConfig.MESSAGES.SEARCH_ERROR + ' ';
                 if (textStatus === 'timeout') {
                     errorMsg += 'Search timed out.';
                 } else if (jqXHR.status >= 400 && jqXHR.status < 500) {
                     errorMsg += `Client error (${jqXHR.status}): ` + (jqXHR.responseJSON ? jqXHR.responseJSON.message : textStatus);
                 } else if (jqXHR.status >= 500) {
                      errorMsg += `Server error (${jqXHR.status}).`;
                 } else {
                     errorMsg += `Network or unknown error: ${textStatus}`;
                 }

                this.#gaTracker.trackEvent('ajax_search_error', {
                     form_id: this.id,
                     error_type: 'ajax_failed',
                     status: jqXHR.status,
                     status_text: textStatus,
                     response: responseText ? responseText.substring(0, 100) : '' // Limit response logging
                }); // GA Error Event


                this.#messageDisplay.showMessage(errorMsg, 'error', 0); // Show persistent error message
                 const resultsArea = document.getElementById('resultsArea');
                 if(resultsArea) {
                     resultsArea.innerHTML = '<p class="w3-text-red">Search failed. Please try again.</p>';
                 }

            } finally {
                 // This block executes whether the promise resolved or rejected.
                 this._hideLoadingState(); // Always hide loading state when request finishes.
                 Logger.info("Simulated Ajax request complete (async/await).");
            }
        } catch (overallError) {
             // Catch critical errors during the overall Ajax search process itself
             Logger.error("Critical error during simulated Ajax search process:", overallError);
              const errorMessage = AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Critical error during Ajax search: ${overallError.message}`;
              this.#messageDisplay.showMessage(errorMessage, 'error', 0);
             this.#gaTracker.trackEvent('fatal_error', { form_id: this.id, error_code: 'ajax_search_critical_exception', message: overallError.message });
              this._hideLoadingState(); // Ensure loading is hidden
        }
    }

     // Example method to display search results (placeholder for API search)
     _displaySearchResults(resultsData) {
         try {
             const resultsArea = document.getElementById('resultsArea');
             if (resultsArea) {
                 Logger.debug("Displaying simulated search results.");
                 // In a real app, format results nicely.
                 resultsArea.innerHTML = '<h3>Simulated Search Results:</h3><p>Results would be displayed here if using an API.</p><pre>' + JSON.stringify(resultsData, null, 2) + '</pre>';
             } else {
                 Logger.warn("#resultsArea element not found for displaying results.");
             }
         } catch (error) {
              Logger.error("Error displaying simulated search results:", error);
         }
     }

    */
}

// --- APP INITIALIZATION ---

// Use jQuery's ready function to ensure the DOM is fully loaded before initializing the application.
$(document).ready(function() {
    Logger.info("DOM fully loaded. Initializing application.");

     try {
        // --- Pre-Initialization Checks ---
        // Check if Google API key for Places Autocomplete is the placeholder.
        if (AppConfig.GOOGLE_API_KEY_PLACEHOLDER === 'YOUR_GOOGLE_API_KEY') {
             Logger.warn("Google API Key is a placeholder ('YOUR_GOOGLE_API_KEY'). Google Autocomplete will not work.");
             // Attempt to use MessageDisplay early to show warnings/errors.
              const messageDisplay = new MessageDisplay(AppConfig.SELECTORS.MESSAGE_AREA);
             messageDisplay.showMessage("Warning: Google API Key for Places API is not set. Destination autocomplete may not function.", 'warning', 10000); // Show for 10 seconds
        }

         // Check if GA Measurement ID is the placeholder.
         if (AppConfig.GOOGLE_ANALYTICS_ID_PLACEHOLDER === 'G-XXXXXXXXXX') {
              Logger.warn("Google Analytics Measurement ID is a placeholder ('G-XXXXXXXXXX'). GA tracking will not send data.");
              const messageDisplay = new MessageDisplay(AppConfig.SELECTORS.MESSAGE_AREA);
              messageDisplay.showMessage("Note: Google Analytics tracking is not configured.", 'info', 8000); // Show for 8 seconds
         }

         // Check if Google Client ID is the placeholder (for simulated services).
          if (AppConfig.GOOGLE_CLIENT_ID_PLACEHOLDER === 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com') {
              Logger.warn("Google OAuth Client ID is a placeholder ('YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com'). Simulated Google services may log warnings.");
               // No user message needed for this simulation detail unless explicitly desired.
          }

         // Check if Google Pay Merchant ID is the placeholder (part of the simulated config).
          if (AppConfig.GOOGLE_PAY.MERCHANT_INFO.merchantId === 'BCR2DN6SA234GS23') {
              Logger.warn("Google Pay Merchant ID is a placeholder ('BCR2DN6SA234GS23'). Simulated Google Pay may log warnings or fail if real integration was attempted.");
          }
           // Check if Google Pay Gateway is the placeholder
          try {
               const gateway = AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0]?.tokenizationSpecification?.parameters?.gateway;
               if (gateway === 'example') {
                   Logger.warn("Google Pay Tokenization Gateway is a placeholder ('example'). Simulated Google Pay may log warnings.");
               }
           } catch (e) {
                Logger.warn("Could not check Google Pay Tokenization Gateway placeholder:", e);
           }


        // --- Application Initialization ---
        // Get the main form element that the SearchForm component will wrap.
        const formElement = document.querySelector(AppConfig.SELECTORS.FORM);

        if (formElement) {
             // Get the component name from the data attribute if available, fallback to 'SearchForm'.
             // const formComponentName = formElement.getAttribute('data-component-name') || 'SearchForm';

            // Create the main application instance (the SearchForm component).
            // Pass the element ID and relevant Google configuration values.
            const hotelSearchApp = new SearchForm(
                formElement.id,
                AppConfig.GOOGLE_ANALYTICS_ID_PLACEHOLDER, // Pass GA ID from config
                AppConfig.GOOGLE_CLIENT_ID_PLACEHOLDER // Pass Client ID from config
            );

            // Store the app instance globally for easy access in developer tools (optional, primarily for debugging).
             // window.hotelSearchApp = hotelSearchApp;
            Logger.info("Application initialized successfully. SearchForm instance created.");


            // --- Post-Initialization Demo/Logging ---
            // Demonstrate iteration through HTML nodes using pure JS *after* our components are initialized.
            // This loop iterates the actual HTML elements within the form, not the component instances map directly.
            const inputsInForm = document.querySelectorAll(`${AppConfig.SELECTORS.FORM} ${AppConfig.SELECTORS.INPUT}`);
            Logger.info(`Iterating through all relevant HTML nodes inside the form (${inputsInForm.length} found) using pure JS after component initialization:`);
            inputsInForm.forEach((node, index) => {
                try {
                    // Find the corresponding JS component instance in the form's internal map by element ID.
                    // Accessing the protected `_inputs` map directly for this demo; in a real app,
                    // you might provide a public getter method in `SearchForm` if this access pattern is needed externally.
                    const component = hotelSearchApp._inputs ? hotelSearchApp._inputs[node.id] : null;

                    Logger.debug(`Node ${index}: ID=${node.id || 'N/A'}, Type=${node.type || node.tagName}`);
                    if (component) {
                         // Log properties of the associated JS component instance.
                         Logger.debug(`  -> Associated JS Component: ${component.name}, Value: "${component.getValue()}", Valid: ${component.isValid}`);
                         // Example: Add a class to elements that have been successfully initialized as components.
                         // node.classList.add('component-initialized');
                    } else {
                         // Log if an element was found in the DOM but no corresponding component was created for it.
                         Logger.debug(`  -> No associated JS Component found for this node.`);
                    }
                } catch (nodeIterError) {
                     Logger.error(`Error processing node ${index} during iteration:`, nodeIterError);
                }
            });

             // Example of calling a static method on the base component class.
             TravelComponent.logAppVersion();


             // --- Cleanup on Page Unload (Important for SPAs) ---
             // Optional: Set up a listener for the browser's `beforeunload` event to dispose of the app cleanly.
             // This can help prevent memory leaks in complex Single Page Applications (SPAs) where components
             // might be dynamically added/removed. Less critical for a simple page that just reloads.
             window.addEventListener('beforeunload', () => {
                 try {
                     if (hotelSearchApp && typeof hotelSearchApp.dispose === 'function') {
                          Logger.info("Page is unloading. Attempting to dispose application instance.");
                          hotelSearchApp.dispose(); // Call the top-level dispose method
                     }
                 } catch (disposeError) {
                      Logger.error("Error during app disposal on unload:", disposeError);
                 }
             });


        } else {
             // --- Fatal Error: Main Form Element Not Found ---
             // Handle the critical case where the main form element required to bootstrap the app is not found.
             Logger.error(`FATAL ERROR: Form element with selector "${AppConfig.SELECTORS.FORM}" not found. Application cannot start.`);
             // Attempt to initialize MessageDisplay anyway so we can show a fatal error message to the user.
             const messageDisplay = new MessageDisplay(AppConfig.SELECTORS.MESSAGE_AREA);
             messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Application startup failed. The required form element "${AppConfig.SELECTORS.FORM}" was not found in the HTML.`, 'error', 0); // Show persistent critical error message


             // Also attempt to track this fatal error in Google Analytics if the GA script loaded.
             try {
                  if (typeof gtag === 'function') {
                       gtag('event', 'fatal_error', {
                           'error_code': 'app_bootstrap_failed', // Custom error code
                           'element_selector': AppConfig.SELECTORS.FORM,
                           'message': AppConfig.MESSAGES.FATAL_ERROR,
                           'detail': `Missing element ${AppConfig.SELECTORS.FORM}`
                       });
                       Logger.info("Fatal error tracked in GA.");
                  }
             } catch (gaTrackError) {
                 Logger.error("Error tracking fatal error in GA:", gaTrackError);
             }
        }

     } catch (initError) {
          // --- Critical Error: Unexpected Exception During DOM Ready Initialization ---
          // Catch any unexpected errors that occur during the overall DOM ready initialization process itself.
          Logger.error("CRITICAL ERROR during DOM ready initialization:", initError);
          // Attempt to display a fatal error if MessageDisplay is available or can be initialized.
          try {
              const messageDisplay = new MessageDisplay(AppConfig.SELECTORS.MESSAGE_AREA);
               messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `An unexpected error occurred during application startup: ${initError.message}`, 'error', 0);
          } catch (msgInitError) {
               Logger.error("Failed to display fatal error message (MessageDisplay initialization failed):", msgInitError);
          }
           // Attempt to track fatal error in GA.
           try {
                if (typeof gtag === 'function') {
                     gtag('event', 'fatal_error', {
                         'error_code': 'dom_ready_exception', // Custom error code
                         'message': initError.message,
                         'stack': initError.stack // Include stack trace for debugging
                     });
                     Logger.info("Fatal error tracked in GA.");
                }
           } catch (gaTrackError2) {
               Logger.error("Error tracking fatal error in GA (second attempt):", gaTrackError2);
           }
     }
}); // End of jQuery ready function
```
