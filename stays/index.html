Okay, this is a monumental request involving weaving together many concepts and technologies into a single HTML file, pushing the JavaScript over 10,000 lines with extensive detail, comments, and simulated services.

**FILE STRUCTURE (Implicit in Single File):**

*   `index.html` (contains everything)

**`index.html` (Containing HTML, CSS, and JavaScript)**

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Expedia Affiliate Search - Grand Unified Demo</title>

    <!-- Required CDNs -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <!-- Google Places Autocomplete API -->
    <!-- Replace 'YOUR_GOOGLE_API_KEY_PLACEHOLDER' with your actual Google API Key -->
    <!-- Ensure you have enabled the Places API in your Google Cloud Console -->
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_GOOGLE_API_KEY_PLACEHOLDER&libraries=places" defer></script>

    <!-- Google tag (gtag.js) - Google Analytics -->
    <!-- Replace G-XXXXXXXXXX_PLACEHOLDER with your actual GA4 Measurement ID -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX_PLACEHOLDER"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      gtag('config', 'G-XXXXXXXXXX_PLACEHOLDER', {
        'page_title': 'Expedia Demo Landing',
        'page_path': window.location.pathname + window.location.search,
        // Add consent parameters based on user consent state in a real app
      });
      // Note: Full GDPR/CCPA compliance requires explicit user consent before loading/firing GA and other services.
      // This demo code does not implement a consent management platform.
    </script>

    <!-- Optional: Real Google Identity Services Library for real Google Sign-In (COMMENTED OUT - USING SIMULATION STRUCTURE) -->
    <!-- <script src="https://accounts.google.com/gsi/client" async defer></script> -->

    <!-- Optional: Real Google Pay API Library for real Google Pay (COMMENTED OUT - USING SIMULATION STRUCTURE) -->
    <!-- <script async defer src="https://pay.google.com/gp/p/js/pay.js"></script> -->

    <!-- Font Awesome for icons (optional, but adds visual flair) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


    <!-- Inline CSS (based on W3CSS for quick styling + custom additions) -->
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <style>
        body {
            font-family: "Segoe UI", Arial, sans-serif;
            background-color: #f1f1f1;
            padding-top: 64px; /* Space for fixed header if you added one */
        }

        .w3-card-4 {
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
        }

        input[type="date"] {
            padding: 8px;
            box-sizing: border-box;
        }

        /* Custom styles for error messages below inputs */
        .w3-text-red.w3-small {
            margin-top: 4px;
            min-height: 1em;
            display: block;
        }

        /* Style for the main message panel */
        #mainMessageDisplay {
            margin-bottom: 16px;
            padding: 12px;
            border-radius: 8px;
            transition: opacity 0.5s ease-in-out; /* Smooth fade */
        }
        #mainMessageDisplay.w3-pale-red { border-left: 6px solid #f44336; }
        #mainMessageDisplay.w3-pale-yellow { border-left: 6px solid #ffeb3b; }
        #mainMessageDisplay.w3-pale-blue { border-left: 6px solid #2196f3; }
        #mainMessageDisplay.w3-pale-green { border-left: 6px solid #4CAF50; }

        /* Spinner animation */
        .w3-spin {
          animation: w3-spin 2s infinite linear;
          vertical-align: middle;
          margin-left: 8px;
        }
        @keyframes w3-spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(359deg); }
        }

        /* Utility class to hide elements */
        .app-hide {
            display: none !important;
        }

        /* Styles for disabled buttons */
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Specific section styles */
        .app-section {
             margin-top: 32px;
             padding: 16px;
             background-color: white;
             border-radius: 8px;
             box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        #googleServicesSection {
             border-color: #ddd !important;
             background-color: #f9f9f9;
        }

        #googleAuthStatus {
            cursor: pointer; /* Indicate clickable for simulation */
             text-decoration: underline;
        }
        #googleAuthStatus:hover {
            text-decoration: none;
        }

        #googleSignInButton {
            vertical-align: middle;
             display: inline-flex;
             align-items: center;
             justify-content: center;
        }
        #googleSignInButton img {
             vertical-align: middle;
             width: 18px; /* Standard Google button logo size */
        }

        #googlePayButton svg {
            vertical-align: middle;
             margin-right: 8px;
             fill: white; /* Fill the Google Pay logo */
        }
        #googlePayButton {
             color: white;
             background-color: #000 !important; /* Google Pay button color */
        }

        /* Optional: Add hover/active states */
        #googlePayButton:hover:not(:disabled) { background-color: #222 !important; }
        #googlePayButton:active:not(:disabled) { background-color: #444 !important; }

        #aiTipsSection {
             border-color: #e0f7fa; /* Light blue for AI */
             background-color: #e0f2f7;
        }
        #aiTipContent {
             font-style: italic;
             color: #555;
        }

        #searchHistorySection {
             border-color: #fff9c4; /* Light yellow for history */
             background-color: #fffde7;
        }
         #searchHistoryList {
             list-style: none;
             padding: 0;
             margin: 0;
             text-align: left;
         }
        #searchHistoryList li {
            border-bottom: 1px solid #eee;
            padding: 8px 0;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        #searchHistoryList li:last-child {
             border-bottom: none;
        }
         #searchHistoryList li:hover {
             background-color: #f0f0f0;
         }
         #clearHistoryButton {
             margin-top: 16px;
         }

        footer {
             margin-top: 48px;
        }

         /* Specific styles for app initialization messages if element found */
         #mainMessageDisplay:empty {
              display: none; /* Hide if empty */
         }

    </style>
</head>
<body class="w3-light-grey">

    <header class="w3-container w3-teal w3-center w3-padding-32">
        <h1>Expedia Affiliate Demo: Unified & Extended</h1>
        <p>Featuring Google Autocomplete, Analytics, Simulated Services (Auth, Pay, Calendar, Email, Apps Script, GenAI) & IndexedDB History</p>
         <p class="w3-small w3-text-light-grey">Note: Most Google/AI/Apps Script integrations are **simulated** for demonstration. Secure integrations require a backend.</p>
    </header>

    <div class="w3-container w3-padding-32" id="mainAppContainer" style="max-width:800px; margin:auto;">

         <!-- Main Application Message Display Area -->
        <div id="mainMessageDisplay" class="w3-panel app-hide">
            <!-- App-level messages and status updates appear here -->
        </div>

        <!-- Search Form Section -->
        <div class="w3-card-4 w3-round-large w3-light-grey w3-padding app-section">

            <h2>Find Your Destination</h2>

            <!-- Data attribute to identify this form component -->
            <form id="hotelSearchForm" class="w3-container" data-component-name="SearchForm">

                <div class="w3-section">
                    <label class="w3-text-teal" for="destination"><b>Destination (City, Landmark, or Hotel)</b></label>
                    <input class="w3-input w3-border w3-round" type="text" id="destination" placeholder="e.g., London, Statue of Liberty" required data-input-type="destination" data-component-name="DestinationInput">
                    <div class="w3-text-red w3-small" id="destination-error"></div>
                </div>

                <div class="w3-row-padding">
                    <div class="w3-half">
                         <label class="w3-text-teal" for="checkInDate"><b>Check-in Date</b></label>
                         <input class="w3-input w3-border w3-round" type="date" id="checkInDate" required data-input-type="date" data-component-name="DateInput" data-date-type="check-in">
                         <div class="w3-text-red w3-small" id="checkInDate-error"></div>
                    </div>
                     <div class="w3-half">
                         <label class="w3-text-teal" for="checkOutDate"><b>Check-out Date</b></label>
                         <input class="w3-input w3-border w3-round" type="date" id="checkOutDate" required data-input-type="date" data-component-name="DateInput" data-date-type="check-out">
                          <div class="w3-text-red w3-small" id="checkOutDate-error"></div>
                    </div>
                </div>

                <div class="w3-row-padding w3-section">
                    <div class="w3-half">
                         <label class="w3-text-teal" for="adults"><b>Adults</b></label>
                         <input class="w3-input w3-border w3-round" type="number" id="adults" value="2" min="1" required data-input-type="number" data-component-name="NumberInput">
                         <div class="w3-text-red w3-small" id="adults-error"></div>
                    </div>
                     <div class="w3-half">
                         <label class="w3-text-teal" for="children"><b>Children</b></label>
                         <input class="w3-input w3-border w3-round" type="number" id="children" value="0" min="0" required data-input-type="number" data-component-name="NumberInput">
                          <div class="w3-text-red w3-small" id="children-error"></div>
                    </div>
                </div>

                <button class="w3-button w3-teal w3-margin-top w3-round-large" type="submit" id="searchButton">
                     <span id="searchText">Search Hotels</span>
                     <i id="loadingSpinner" class="fa fa-spinner w3-spin app-hide"></i>
                </button>

            </form>
             <!-- Results display area - less relevant for redirect demo -->
            <div id="resultsArea" class="w3-container w3-margin-top w3-text-grey w3-center">
                 <p>Search results would appear here if using a direct API, but this demo redirects to Expedia.</p>
                 <p>Actions enabled below after a successful search.</p>
            </div>
        </div>

         <!-- Search History Section (IndexedDB) -->
         <div id="searchHistorySection" class="app-section app-hide">
             <h3>Recent Searches (IndexedDB)</h3>
              <ul id="searchHistoryList">
                 <!-- History items will be loaded here -->
                 <li class="w3-text-grey">Loading history...</li>
              </ul>
              <button class="w3-button w3-red w3-round-large w3-small w3-border" id="clearHistoryButton">Clear History</button>
              <div class="w3-small w3-margin-top w3-text-grey" id="historyStatus"></div>
         </div>

         <!-- GenAI Tip Section -->
         <div id="aiTipsSection" class="app-section app-hide">
             <h3>Destination Tip (Simulated GenAI)</h3>
             <div id="aiTipContent" class="w3-text-grey">
                 Loading tip... <i class="fa fa-spinner w3-spin"></i>
             </div>
         </div>


         <!-- Google Service Integrations Section -->
         <div id="googleServicesSection" class="app-section app-hide">
             <h3>Google Service Integrations (**Simulated**)</h3>
              <p class="w3-small w3-text-grey">Integrate search details with your Google services.</p>

              <!-- Google Sign-In/Auth Area -->
              <div id="googleAuthArea" class="w3-center w3-margin-bottom">
                   <button class="w3-button w3-white w3-border w3-round-large" id="googleSignInButton">
                        <!-- Using a generic icon or you can use a Google logo image path -->
                       <i class="fa fa-google" style="color:#4285F4; margin-right: 8px;"></i>
                       <span id="googleAuthText">Sign in with Google (Simulated)</span>
                   </button>
                   <div id="googleAuthStatus" class="w3-small w3-margin-top w3-text-grey" title="Click to simulate sign in/out">Status: Not attempted</div>
              </div>

             <p class="w3-text-grey w3-small w3-center">Actions available after searching and signing in:</p>
             <div class="w3-row-padding w3-center w3-margin-top">
                 <div class="w3-col m6 s12 w3-padding">
                     <button class="w3-button w3-blue w3-round-large w3-block" id="addToCalendarButton" disabled>
                         <i class="fa fa-calendar"></i> Add to Calendar
                     </button>
                 </div>
                 <div class="w3-col m6 s12 w3-padding">
                      <button class="w3-button w3-red w3-round-large w3-block" id="emailSearchDetailsButton" disabled>
                         <i class="fa fa-envelope"></i> Email Details
                     </button>
                 </div>
                 <div class="w3-col m6 s12 w3-padding">
                     <button class="w3-button w3-green w3-round-large w3-block" id="sendToAppsScriptButton" disabled>
                          <i class="fa fa-code"></i> Send to Apps Script
                      </button>
                  </div>
                 <div class="w3-col m6 s12 w3-padding">
                      <!-- Google Pay Button Placeholder -->
                     <button class="w3-button w3-black w3-round-large w3-block" id="googlePayButton" disabled>
                         <svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
                              <path fill="#ffffff" d="M12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12s5.373 12 12 12zm-1.883-9.883L10.87 11l-2.05-2.05L7.44 10.3l3.43 3.43 6.27-6.26L15.72 6.44 10.117 12.044l-1.49-1.49-.707-.707L9.41 8.172z"/>
                         </svg>
                         Simulated Google Pay
                     </button>
                 </div>
             </div>
         </div>

    </div>

    <footer class="w3-container w3-teal w3-center w3-padding-32">
        <p>&copy; 2023 Expedia Affiliate Demo.</p>
         <p class="w3-small w3-text-light-grey">Linking via: <a href="https://expedia.com/affiliates/expedia-home.XDIh5Nk" target="_blank" class="w3-text-white w3-hover-text-light-grey">Expedia Affiliate Link</a></p>
         <p class="w3-small w3-text-light-grey">Warning: This is a **simulated** client-side demo. Real Google integrations (Auth, Pay, Calendar, Email, Apps Script) require backend components, secure handling of API keys/secrets, and user consent. **GitHub Secrets are for backend use, not exposed client-side.**</p>
    </footer>

    <!-- Inline JavaScript -->
    <script>
        // Ensure the code runs after the DOM is fully loaded.
        // Use a robust check, jQuery.ready or vanilla JS DOMContentLoaded.
        (function() {
            // --- START: Google API Key & Secrets Management Disclaimer ---
            // IMPORTANT SECURITY NOTE:
            // In a real production application, sensitive API keys, client IDs,
            // and merchant secrets should *NEVER* be embedded directly in client-side
            // JavaScript or HTML. This exposes them to anyone who views your source code.
            //
            // For services requiring API keys (like Google Places) or Client IDs (like Google Identity Services),
            // these are often used by a SECURE BACKEND SERVICE (an API proxy or serverless function).
            // The backend accesses sensitive credentials securely (e.g., from Environment Variables, Vaults,
            // or Configuration Managers).
            //
            // Your client-side JavaScript then makes requests to *your backend*, and the backend
            // makes the actual authenticated/authorized calls to the external APIs (Google, etc.).
            //
            // GITHUB SECRETS:
            // GitHub Secrets are environment variables used during your build or deployment
            // pipeline *on your GitHub infrastructure*. They are suitable for providing
            // sensitive information to build scripts or backend services.
            //
            // CLIENT-SIDE JAVASCRIPT *CANNOT* DIRECTLY ACCESS GITHUB SECRETS AT RUNTIME.
            //
            // In this DEMO code, placeholders like `YOUR_GOOGLE_API_KEY_PLACEHOLDER` are used
            // directly in the HTML/JS for simplicity and to show *where* such keys/IDs
            // would be referenced if they were hardcoded (which again, is insecure).
            //
            // For the requested structure demonstrating GIS integration etc. client-side,
            // we are **simulating** the APIs and the secure handling. The simulated services
            // will still reference placeholders in the configuration, but they will NOT
            // connect to real Google APIs.
            //
            // A REAL, SECURE APP WOULD:
            // 1. Have backend endpoints for sensitive operations (e.g., send email, process payment, talk to Apps Script/GenAI).
            // 2. The backend would read API keys/secrets from secure sources (like GitHub Secrets).
            // 3. Client-side JS uses Google Identity Services (GIS) for *user sign-in* (client ID is less sensitive than a server API key).
            // 4. GIS provides an ID token (JWT). Client-side JS sends this ID token to the backend.
            // 5. Backend verifies the ID token, authenticates the user, and uses *its* securely stored credentials
            //    (or tokens exchanged on the backend using refresh tokens) to call Google APIs (Gmail, Calendar, GenAI, Apps Script, Payment Gateways)
            //    *on behalf of the authenticated user*.
            // 6. The client-side Google Pay API handles UI and tokenization, but sends the resulting payment token to the backend for secure processing.
            //
            // THIS DEMO FOCUSES ON CLIENT-SIDE ARCHITECTURE AND ERROR HANDLING, SIMULATING
            // THE ASYNCHRONOUS INTERACTION WITH SERVICES THAT *SHOULD* BE BACKEND-PROTECTED.
            //
            // The placeholders below represent where configuration values *would* live client-side
            // in a (less secure) basic setup, or where they are needed for the structure of
            // these client-side simulations.
            // --- END: Google API Key & Secrets Management Disclaimer ---


            // --- Configuration Object ---
            // Centralized configuration for constants, messages, selectors, and service details.
            // Includes placeholder values for illustration.
            const AppConfig = {
                APP_NAME: 'ExpediaAffiliateDemoApp',
                APP_VERSION: '5.1.0', // Incremented version number

                // Expedia Affiliate Config
                AFFILIATE_ID: 'XDIh5Nk', // Example affiliate ID
                BASE_SEARCH_URL: 'https://www.expedia.com/Hotel-Search',

                // API & Service Placeholders (INSECURE IF REAL IN PRODUCTION CLIENT-SIDE)
                // These are used by the simulated services for structure.
                GOOGLE_API_KEY: 'YOUR_GOOGLE_API_KEY_PLACEHOLDER', // For Google Places (relatively less sensitive)
                GOOGLE_ANALYTICS_ID: 'G-XXXXXXXXXX_PLACEHOLDER', // For GA4
                // OAuth 2.0 Client ID for Google Identity Services (less sensitive, often visible client-side)
                GOOGLE_CLIENT_ID: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER',
                 // Dummy / Placeholder ID for Simulated Google Pay Merchant
                GOOGLE_PAY_MERCHANT_ID: 'BCR2DN6SA234GS23_PLACEHOLDER', // In production, use your actual merchant ID
                GOOGLE_PAY_GATEWAY: 'example_PLACEHOLDER', // Placeholder gateway name
                GOOGLE_PAY_GATEWAY_MERCHANT_ID: 'exampleGatewayMerchantId_PLACEHOLDER', // Placeholder gateway merchant ID

                // Simulated Google Apps Script Endpoint (In a real app, this is a backend endpoint)
                GOOGLE_APPS_SCRIPT_ENDPOINT: 'https://script.google.com/macros/s/YOUR_APPS_SCRIPT_DEPLOYMENT_ID/exec_PLACEHOLDER', // Example URL structure

                // Simulated GenAI Endpoint (In a real app, this is a backend endpoint calling GenAI API)
                GENAI_ENDPOINT: '/api/generate-tip_PLACEHOLDER', // Example URL to your backend proxy


                // IndexedDB Configuration
                INDEXEDDB: {
                    DB_NAME: 'ExpediaDemoDB',
                    DB_VERSION: 1,
                    STORE_NAME: 'searchHistory'
                },

                // Selectors for UI elements
                SELECTORS: {
                    APP_CONTAINER: '#mainAppContainer',
                    MAIN_MESSAGE_AREA: '#mainMessageDisplay',
                    FORM: '#hotelSearchForm',
                    INPUT: 'input, select, textarea', // Generic selector for form elements
                    ERROR_MESSAGE_SUFFIX: '-error', // Used to find error message divs below inputs

                    // Search Button and Loader
                    SEARCH_BUTTON: '#searchButton',
                    SEARCH_TEXT: '#searchText',
                    LOADING_SPINNER: '#loadingSpinner',

                    // Google Services Section & Buttons
                    GOOGLE_SERVICES_SECTION: '#googleServicesSection',
                    GOOGLE_AUTH_AREA: '#googleAuthArea',
                    GOOGLE_SIGN_IN_BUTTON: '#googleSignInButton',
                    GOOGLE_AUTH_STATUS: '#googleAuthStatus', // Status text element
                    GOOGLE_AUTH_TEXT: '#googleAuthText', // Text within Sign-In button
                    ADD_TO_CALENDAR_BUTTON: '#addToCalendarButton',
                    EMAIL_SEARCH_DETAILS_BUTTON: '#emailSearchDetailsButton',
                    SEND_TO_APPS_SCRIPT_BUTTON: '#sendToAppsScriptButton',
                    GOOGLE_PAY_BUTTON: '#googlePayButton',
                     GOOGLE_PAY_AREA: '#googlePayArea', // Area potentially containing the button (useful for rendering real Pay button)

                    // IndexedDB Search History Section
                    SEARCH_HISTORY_SECTION: '#searchHistorySection',
                    SEARCH_HISTORY_LIST: '#searchHistoryList', // UL element
                    CLEAR_HISTORY_BUTTON: '#clearHistoryButton',
                    HISTORY_STATUS: '#historyStatus', // Status text element

                    // GenAI Tip Section
                    AI_TIPS_SECTION: '#aiTipsSection',
                    AI_TIP_CONTENT: '#aiTipContent', // Div for tip text
                },

                // UI Messages for various statuses and errors
                MESSAGES: {
                    APP_INIT_ERROR: 'Application failed to initialize properly.',
                    FATAL_ERROR: 'A critical application error occurred.',

                    // General Status/Process Messages
                    PROCESSING: (task) => `Processing ${task}...`,
                    SUCCESS: (task) => `${task} completed successfully.`,
                    FAILED: (task, err) => `${task} failed: ${err}`,
                    VALIDATION_ERROR: 'Please fix the errors in the form.',

                    // Search Process Messages
                    SEARCH_INITIATED: 'Validating search details and preparing search...',
                    SEARCH_PROCESSING: 'Executing search and fetching destination tip...',
                    SEARCH_REDIRECT: 'Search processed. Redirecting to Expedia...',
                    NO_SEARCH_DATA_FOR_ACTION: 'Please perform a search first to enable actions.',

                    // Google Auth Messages
                    AUTH_INIT: 'Initializing Google Authentication...',
                    AUTH_NEEDED: 'Sign in with Google to use these features.',
                    AUTH_SIGNING_IN: 'Signing in with Google...',
                    AUTH_SUCCESS: (email) => `Signed in as ${email}.`,
                    AUTH_FAILED: (err) => `Google Sign-In failed: ${err}`,
                    AUTH_SIGNED_OUT: 'Signed out.',

                    // Google Pay Messages
                    GOOGLE_PAY_INIT: 'Initializing Google Pay...',
                    GOOGLE_PAY_READY_CHECK: 'Checking Google Pay availability...',
                    GOOGLE_PAY_READY: 'Google Pay is available.',
                    GOOGLE_PAY_NOT_READY: 'Google Pay is not available on this device or browser.',
                    GOOGLE_PAY_CLICKED: 'Opening Google Pay...',
                    GOOGLE_PAY_PROCESSING: 'Processing payment with Google Pay...',
                    GOOGLE_PAY_SUCCESS: 'Payment processed successfully!',
                    GOOGLE_PAY_FAILED: (err) => `Google Pay failed: ${err}`,
                    GOOGLE_PAY_CANCELLED: 'Google Pay process cancelled by user.',
                    GOOGLE_PAY_DISABLED_MESSAGE: 'Google Pay button is disabled because it\'s not available or search results are not loaded.', // Use {reason}

                    // Calendar Messages
                    CALENDAR_ADD_INIT: 'Preparing to add event...',
                    CALENDAR_ADD_PROCESSING: 'Adding event to Google Calendar...',
                    CALENDAR_ADD_SUCCESS: 'Event added successfully!',
                    CALENDAR_ADD_FAILED: (err) => `Failed to add event: ${err}`,

                    // Email Messages
                    EMAIL_SEND_INIT: 'Preparing email...',
                    EMAIL_SEND_PROCESSING: 'Sending email...',
                    EMAIL_SEND_SUCCESS: 'Email sent successfully!',
                    EMAIL_SEND_FAILED: (err) => `Failed to send email: ${err}`,
                    EMAIL_SEND_NOT_ALLOWED: 'Emailing details is not available for simulated users.', // Specific for simulation constraint

                    // Google Apps Script Messages
                    APPS_SCRIPT_SEND_INIT: 'Preparing data for Apps Script...',
                    APPS_SCRIPT_SEND_PROCESSING: 'Sending data to Apps Script...',
                    APPS_SCRIPT_SEND_SUCCESS: 'Data sent to Apps Script successfully!',
                    APPS_SCRIPT_SEND_FAILED: (err) => `Failed to send data to Apps Script: ${err}`,
                    APPS_SCRIPT_ENDPOINT_MISSING: 'Google Apps Script endpoint is not configured.',

                    // GenAI Messages
                    GENAI_TIP_INIT: (dest) => `Fetching AI tip for ${dest || 'your destination'}...`,
                    GENAI_TIP_LOADING: 'Loading destination tip...',
                    GENAI_TIP_SUCCESS: (tip) => tip || 'No specific tip available, but enjoy your trip!', // Handle empty response
                    GENAI_TIP_FAILED: 'Failed to load AI tip. Please try searching again.', // Generic error message

                    // IndexedDB History Messages
                    HISTORY_LOAD_FAILED: 'Failed to load search history from local storage.',
                    HISTORY_SAVED_SUCCESS: 'Search history saved locally.',
                    HISTORY_SAVED_FAILED: 'Failed to save search history locally.',
                    HISTORY_CLEARED_SUCCESS: 'Search history cleared.',
                    HISTORY_CLEARED_FAILED: 'Failed to clear search history.',
                    HISTORY_EMPTY: 'No recent searches found.',
                },

                // Timers & Delays (in milliseconds)
                DEBOUNCE_DELAY_MS: 300, // Delay for debouncing input events if needed
                VALIDATION_DELAY_MS: 150, // Delay before blur validation, especially for autocomplete
                MESSAGE_DISPLAY_DURATION_MS: 6000, // How long messages stay visible (0 for infinite)
                SIMULATED_ASYNC_PROCESS_DELAY_MS: 800, // Delay for the main simulated async step (e.g., API call)
                SIMULATED_SERVICE_DELAY_MS: 600, // General delay for simulated Google service calls
                GA_REDIRECT_DELAY_MS: 300 // Short delay before redirecting after GA tracking attempts

                // Error Handling Configuration
                // SIMULATED_SERVICE_ERROR_RATE: 0.15 // 15% chance of simulated service calls failing (can be per service config)
            };

            // --- Error Reporter Class ---
            // Centralizes error logging, UI message display, and GA error tracking.
            class ErrorReporter {
                 #messageDisplay;
                 #gaTracker;

                /**
                 * @param {MessageDisplay} messageDisplay - Instance of the MessageDisplay class.
                 * @param {GoogleAnalyticsTracker} gaTracker - Instance of the GoogleAnalyticsTracker class.
                 */
                 constructor(messageDisplay, gaTracker) {
                     if (!messageDisplay) Logger.error("MessageDisplay instance not provided to ErrorReporter.");
                     if (!gaTracker) Logger.error("GoogleAnalyticsTracker instance not provided to ErrorReporter.");
                     this.#messageDisplay = messageDisplay;
                     this.#gaTracker = gaTracker;
                     Logger.debug("ErrorReporter initialized.");
                 }

                /**
                 * Reports an error by logging, displaying a UI message, and tracking in GA.
                 * @param {string} source - A string identifying where the error occurred (e.g., 'SearchForm._handleSubmit').
                 * @param {*} error - The error object or value caught in the catch block.
                 * @param {object} [context={}] - Additional context to log/track.
                 * @param {string} [uiMessage="An unexpected error occurred."] - User-friendly message to display.
                 * @param {string} [gaErrorCode="unexpected_error"] - A short code for GA event parameter.
                 * @param {number} [uiDuration=0] - Duration for the UI message (0 for infinite). Defaults to persistent.
                 */
                 reportError(source, error, context = {}, uiMessage = AppConfig.MESSAGES.SEARCH_ERROR, gaErrorCode = "unexpected_error", uiDuration = 0) {
                     try {
                         // 1. Log the detailed error
                         Logger.error(`Error in ${source}:`, error, context);

                         // 2. Determine display message (use error message if available, otherwise fallback)
                         const displayMsg = `${uiMessage} Details: ${error instanceof Error ? error.message : String(error)}`;

                         // 3. Display error message to the user
                         if (this.#messageDisplay) {
                              this.#messageDisplay.showMessage(displayMsg, 'error', uiDuration);
                         } else {
                             Logger.warn("ErrorReporter: MessageDisplay not available to show error message.", displayMsg);
                         }

                         // 4. Track error in Google Analytics
                         if (this.#gaTracker && typeof this.#gaTracker.trackEvent === 'function') {
                             try {
                                  const gaParams = {
                                     'error_source': source,
                                     'error_code': gaErrorCode, // Use a specific code for the error type
                                     'error_message': error instanceof Error ? error.message : String(error),
                                     // Include stack trace if available (be mindful of data volume)
                                     // 'error_stack': error instanceof Error && error.stack ? error.stack.substring(0, 500) : undefined,
                                     // Include relevant context parameters
                                     ...context
                                  };
                                  this.#gaTracker.trackEvent('app_error', gaParams); // Use a general event name for errors
                                  Logger.debug("Error tracked in GA:", gaParams);
                             } catch (gaTrackError) {
                                 Logger.error("ErrorReporter: Failed to track error in Google Analytics:", gaTrackError);
                             }
                         } else {
                             Logger.debug("ErrorReporter: GA Tracker not available to track error.", error);
                         }

                     } catch (reporterError) {
                          // Catch errors *within* the error reporting logic itself (rare but possible)
                         Logger.error("ErrorReporter encountered an error while reporting an error!", reporterError, { originalSource: source, originalError: error });
                         // At this point, fallback to console logging as much as possible
                         console.error("FATAL: Error in ErrorReporter:", reporterError);
                         console.error("Original Error:", error);
                     }
                 }
            }


            // --- Google Analytics Tracker ---
            // Class to handle sending events to Google Analytics (GA4).
            class GoogleAnalyticsTracker {
                #measurementId;

                 constructor(measurementId) {
                    try {
                        Logger.debug(`GoogleAnalyticsTracker constructor called with ID: ${measurementId}`);
                        this.#measurementId = measurementId;
                        this.#checkGA(); // Initial check
                        Logger.debug(`GoogleAnalyticsTracker initialized.`);
                    } catch (error) {
                         Logger.error(`Error initializing GoogleAnalyticsTracker:`, error);
                         this.#measurementId = null; // Ensure tracker is disabled on error
                         throw error;
                    }
                }

                // Private method to check if gtag is available and Measurement ID is set.
                #checkGA() {
                    try {
                        const isConfigured = this.#measurementId && this.#measurementId !== AppConfig.GOOGLE_ANALYTICS_ID;
                         if (!isConfigured) {
                             Logger.warn(`Google Analytics Measurement ID is not configured or is placeholder. Tracking calls will not send data.`);
                            return false;
                        }
                        if (typeof gtag !== 'function') {
                            Logger.warn(`Google Analytics gtag function not found globally. Ensure gtag.js is loaded. Tracking calls will not send data.`);
                            return false;
                        }
                        // Logger.debug("Google Analytics gtag function found and Measurement ID is set."); // Too noisy
                        return true;
                    } catch (error) {
                        Logger.error("Error checking Google Analytics availability:", error);
                        return false; // Assume GA is not available if check fails
                    }
                }

                /**
                 * Public method to track a generic GA event.
                 * @param {string} eventName - The name of the event (e.g., 'button_click', 'search_error').
                 * @param {object} [eventParams] - Optional parameters for the event.
                 */
                trackEvent(eventName, eventParams = {}) {
                    try {
                        if (this.#checkGA()) {
                             // Logger.debug(`Tracking GA Event: "${eventName}"`, eventParams); // Too noisy
                             const params = typeof eventParams === 'object' && eventParams !== null ? eventParams : {};
                            // Send event using gtag.
                            gtag('event', eventName, {
                                 'non_interaction': false, // Generally, user actions are interactive
                                ...params
                            });
                        } else {
                             // Logger.debug(`GA not available or configured, skipping event tracking: "${eventName}"`); // Too noisy
                        }
                    } catch (error) {
                        Logger.error(`Error tracking GA event "${eventName}":`, error, { params: eventParams });
                    }
                }

                /**
                 * Public method to track a specific step in a custom funnel (e.g., a search flow funnel).
                 * Uses a custom event 'funnel_step' with 'step_name' parameter.
                 * @param {string} stepName - The name of the funnel step (e.g., 'search_started', 'validation_success').
                 * @param {object} [additionalParams] - Additional parameters specific to the step.
                 */
                trackFunnelStep(stepName, additionalParams = {}) {
                     try {
                         if (typeof stepName !== 'string' || stepName.trim() === '') {
                             Logger.warn("Invalid stepName provided for GA funnel tracking.");
                             return;
                         }
                         const eventName = 'funnel_step';
                         const params = typeof additionalParams === 'object' && additionalParams !== null ? additionalParams : {};
                         const eventParams = {
                            'step_name': stepName,
                             ...params
                         };
                         this.trackEvent(eventName, eventParams);
                         Logger.debug(`Tracked GA funnel step: "${stepName}"`);
                     } catch (error) {
                         Logger.error(`Error tracking GA funnel step "${stepName}":`, error, { additionalParams: additionalParams });
                     }
                }

                // Static method check (relies on config)
                static isConfigured(measurementId) {
                     try {
                        return measurementId && measurementId !== AppConfig.GOOGLE_ANALYTICS_ID;
                    } catch (error) {
                        Logger.error("Error checking GoogleAnalyticsTracker.isConfigured:", error);
                        return false;
                    }
                }
            }


            // --- IndexedDB Service ---
            // Handles client-side storage and retrieval of search history using IndexedDB.
            // This is a REAL browser API integration (unlike most other Google services in this demo).
            class IndexedDBService {
                 #db = null; // Private variable to hold the IndexedDB database connection.
                 #dbName;
                 #dbVersion;
                 #storeName;
                 #isOpening = false; // Flag to prevent multiple open attempts simultaneously
                 #openRequest = null; // Hold reference to the DB open request

                /**
                 * @param {string} dbName - The name of the IndexedDB database.
                 * @param {number} dbVersion - The version of the database schema.
                 * @param {string} storeName - The name of the object store for search history.
                 */
                 constructor(dbName, dbVersion, storeName) {
                     try {
                        Logger.debug(`IndexedDBService constructor called. DB: "${dbName}", Version: ${dbVersion}, Store: "${storeName}".`);
                         if (!dbName || !storeName || !dbVersion) {
                            const errorMsg = "IndexedDB configuration missing name, version, or store name.";
                            Logger.error(errorMsg);
                            throw new Error(errorMsg);
                         }
                        this.#dbName = dbName;
                        this.#dbVersion = dbVersion;
                        this.#storeName = storeName;
                         Logger.debug(`IndexedDBService initialized with config.`);
                     } catch (error) {
                         Logger.error("Error initializing IndexedDBService configuration:", error);
                         // Cannot proceed if config is invalid, throw or handle gracefully.
                         // The rest of the methods will check #db state.
                         throw error; // Re-throw critical initialization error
                     }
                }

                /**
                 * Opens the IndexedDB database. Returns a Promise that resolves when the database is open.
                 * Handles schema upgrades. Designed to be called internally by other methods as needed.
                 * @returns {Promise<IDBDatabase>} A Promise resolving with the IDBDatabase instance.
                 */
                 #openDatabase() {
                     return new Promise((resolve, reject) => {
                         try {
                            if (this.#db) {
                                Logger.debug("IndexedDB is already open.");
                                resolve(this.#db); // Resolve immediately if already open
                                return;
                            }
                             if (this.#isOpening) {
                                Logger.debug("IndexedDB is already opening, waiting for existing request.");
                                // If an open request is already pending, attach to its completion.
                                // This requires the first request to be stored and accessible.
                                if (this.#openRequest) {
                                    this.#openRequest.onsuccess = (event) => {
                                         this.#db = event.target.result;
                                         this.#isOpening = false;
                                         Logger.info("IndexedDB opened (existing request).");
                                         resolve(this.#db);
                                     };
                                    this.#openRequest.onerror = (event) => {
                                         this.#isOpening = false;
                                         Logger.error("IndexedDB open failed (existing request):", event.target.error);
                                         reject(event.target.error);
                                     };
                                    return; // Attached to existing request
                                } else {
                                     // Should not happen if #isOpening is true but #openRequest is null, handle defensively.
                                     Logger.error("IndexedDB #isOpening is true, but #openRequest is null!");
                                     this.#isOpening = false; // Reset state
                                     reject(new Error("IndexedDB state error during open.")).catch(()=>{}); // Reject and prevent unhandled rejection
                                     return;
                                }
                            }

                             Logger.debug(`Opening IndexedDB database "${this.#dbName}" version ${this.#dbVersion}...`);
                             this.#isOpening = true; // Set flag

                            // IndexedDB Open Request
                            this.#openRequest = indexedDB.open(this.#dbName, this.#dbVersion);

                            // Handles database schema upgrades or creation
                            this.#openRequest.onupgradeneeded = (event) => {
                                try {
                                    this.#db = event.target.result; // Get the database connection during upgrade
                                    Logger.info(`IndexedDB upgrade needed from version ${event.oldVersion} to ${event.newVersion}.`);

                                    // Create object stores if they don't exist
                                     // Note: UpgradeNeeded is the *only* place you can create/delete object stores and indices.
                                     if (!this.#db.objectStoreNames.contains(this.#storeName)) {
                                         Logger.debug(`Creating object store: "${this.#storeName}"`);
                                        // Create an object store with auto-incrementing keys.
                                        // Search history items won't have unique IDs beforehand, so autoincrement is suitable.
                                         const objectStore = this.#db.createObjectStore(this.#storeName, { keyPath: 'id', autoIncrement: true });
                                        // Create an index on the 'timestamp' property for sorting history (optional but good practice)
                                         objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                                         Logger.debug(`Object store "${this.#storeName}" and "timestamp" index created.`);
                                     } else {
                                         Logger.debug(`Object store "${this.#storeName}" already exists.`);
                                         // If store exists, check its indexes and potentially add/remove if version changed significantly.
                                         // Example: let objectStore = openRequest.transaction.objectStore(this.#storeName);
                                         // if (!objectStore.indexNames.contains('newIndex')) { ... }
                                     }

                                    // Add logic for future versions here (e.g., switch based on event.oldVersion)
                                    // Example: if (event.oldVersion < 2) { /* migrate schema from version 1 to 2 */ }


                                } catch (upgradeError) {
                                     Logger.error("Error during IndexedDB upgradeNeeded:", upgradeError);
                                    // Abort the transaction manually if an error occurs during upgrade.
                                     // This will prevent the database from being opened in a potentially broken state.
                                     if (event.target.transaction) {
                                         try {
                                             event.target.transaction.abort();
                                             Logger.debug("IndexedDB upgrade transaction aborted due to error.");
                                         } catch (abortError) {
                                             Logger.error("Error aborting IndexedDB transaction:", abortError);
                                         }
                                     }
                                }
                            };

                            // Handles successful database opening
                            this.#openRequest.onsuccess = (event) => {
                                try {
                                    this.#db = event.target.result; // Get the final database connection
                                    this.#isOpening = false;
                                    Logger.info("IndexedDB opened successfully.");

                                    // Handle unexpected closings (e.g., by other tabs) - recommended
                                    this.#db.onversionchange = () => {
                                        Logger.warn("IndexedDB onversionchange detected. Database will close.");
                                        try { this.#db.close(); } catch (e) { Logger.error("Error closing DB on version change:", e); }
                                        this.#db = null; // Clear the connection
                                        // You might want to notify the user here that the database was closed.
                                         this.#messageDisplay.showMessage("Local history database updated. Please reload page if issues occur.", 'info', 8000);
                                    };
                                     // Add error handler for the DB itself - recommended
                                     this.#db.onerror = (dbError) => {
                                        Logger.error("IndexedDB database error:", dbError);
                                        // This is a generic DB error handler, more specific errors are handled by request onerror.
                                     };


                                    resolve(this.#db); // Resolve the promise with the database instance
                                } catch (successError) {
                                     Logger.error("Error during IndexedDB onsuccess handler:", successError);
                                     // Ensure the DB state is clean if there was an error in the success handler itself
                                     if (this.#db) {
                                          try { this.#db.close(); } catch (e) { Logger.error("Error closing DB during success handler error:", e); }
                                     }
                                     this.#db = null;
                                     this.#isOpening = false;
                                     reject(successError); // Reject the promise
                                }
                            };

                            // Handles errors during opening or upgrade
                            this.#openRequest.onerror = (event) => {
                                try {
                                     this.#isOpening = false;
                                     const error = event.target.error; // Get the specific error object
                                    Logger.error("IndexedDB open failed:", error);
                                     reject(error); // Reject the promise with the error
                                } catch (errorHandleError) {
                                     Logger.error("Error handling IndexedDB open error:", errorHandleError);
                                    // Re-reject with a general error if handling failed
                                     reject(new Error("IndexedDB open error handling failed."));
                                }
                            };

                        } catch (setupError) {
                            // Catch synchronous errors during the setup of the request
                             Logger.error("Synchronous error setting up IndexedDB open request:", setupError);
                             this.#isOpening = false;
                             reject(setupError); // Reject the promise
                        }
                    });
                }

                 /**
                  * Ensures a transaction is created with the correct mode and store(s).
                  * @param {string|string[]} storeNames - The name(s) of the object store(s) to use in the transaction.
                  * @param {"readonly"|"readwrite"} mode - The transaction mode.
                  * @returns {Promise<IDBTransaction>} A Promise resolving with the transaction object.
                  */
                 async #getTransaction(storeNames, mode) {
                     try {
                         // Ensure database is open before creating a transaction
                         const db = await this.#openDatabase();
                         if (!db) {
                             throw new Error("IndexedDB database connection is not available.");
                         }

                         // Ensure store name(s) are valid
                         const storesArray = Array.isArray(storeNames) ? storeNames : [storeNames];
                         for (const storeName of storesArray) {
                              if (!db.objectStoreNames.contains(storeName)) {
                                  const errorMsg = `IndexedDB object store "${storeName}" not found. Database schema mismatch?`;
                                 Logger.error(errorMsg);
                                 throw new Error(errorMsg);
                              }
                         }

                         Logger.debug(`Creating IndexedDB transaction for store(s): "${storesArray.join(',')}" in mode: "${mode}"`);
                         const transaction = db.transaction(storesArray, mode);

                         // Attach global transaction error handler
                         transaction.onerror = (event) => {
                             Logger.error(`IndexedDB transaction error for store(s) "${storesArray.join(',')}" in mode "${mode}":`, event.target.error);
                             // Specific request errors might also be caught by request.onerror.
                             // This catches errors that occur on the transaction itself (e.g., during commit).
                         };
                         // Attach global transaction abort handler
                         transaction.onabort = (event) => {
                             Logger.warn(`IndexedDB transaction aborted for store(s) "${storesArray.join(',')}" in mode "${mode}":`, event.target.error || event.target.transaction.error);
                              // The rejection logic in the promise will likely capture this via request.onerror or transaction.onerror.
                         };
                          // Optional: Attach transaction complete handler
                          transaction.oncomplete = () => {
                             Logger.debug(`IndexedDB transaction complete for store(s) "${storesArray.join(',')}" in mode "${mode}".`);
                          };


                         return transaction; // Return the transaction object
                     } catch (error) {
                         Logger.error(`Error getting IndexedDB transaction for store(s) "${Array.isArray(storeNames) ? storeNames.join(',') : storeNames}" in mode "${mode}":`, error);
                         throw error; // Re-throw the error
                     }
                 }

                 /**
                  * Adds a search history item to the IndexedDB object store.
                  * @param {object} searchDetails - The details of the search to save. Should be serializable JSON.
                  * @returns {Promise<number>} A Promise resolving with the auto-generated key for the added item.
                  */
                 async addSearchHistoryItem(searchDetails) {
                     try {
                         if (!searchDetails || typeof searchDetails !== 'object') {
                             Logger.warn("Invalid search details provided for saving history.");
                              // Simulate rejection for invalid data input
                              throw new Error("Invalid search details.");
                         }

                         Logger.debug("Attempting to add search history item to IndexedDB...", searchDetails);
                         const transaction = await this.#getTransaction(this.#storeName, 'readwrite');
                         const objectStore = transaction.objectStore(this.#storeName);

                         // Create the item to store. Add a timestamp and any other useful metadata.
                         const historyItem = {
                             timestamp: new Date().toISOString(), // Use ISO string for reliable date/time
                             destination: searchDetails.destination,
                             checkInDate: searchDetails.checkInDate,
                             checkOutDate: searchDetails.checkOutDate,
                             adults: searchDetails.adults,
                             children: searchDetails.children,
                             // Optionally add other details like IP address (from backend) or URL (from client-side)
                             expediaUrl: searchDetails.expediaUrl || null // Store the generated URL
                         };

                         // IndexedDB Add Request
                         const request = objectStore.add(historyItem);

                         return new Promise((resolve, reject) => {
                             request.onsuccess = (event) => {
                                 const addedKey = event.target.result; // The auto-generated key
                                 Logger.debug(`Search history item added successfully with key: ${addedKey}`);
                                 resolve(addedKey); // Resolve with the key
                             };
                             request.onerror = (event) => {
                                 const error = event.target.error;
                                 Logger.error("IndexedDB add request failed:", error);
                                 reject(error); // Reject with the error
                             };
                             // Note: Transaction errors or aborts will also propagate and might trigger
                             // request.onerror or subsequent catch blocks depending on how handled.
                         });
                         // The transaction automatically commits when all requests complete successfully.
                         // You can also manually commit with transaction.commit() but it's often unnecessary.

                     } catch (error) {
                         Logger.error("Error adding search history item to IndexedDB:", error);
                         // Ensure the transaction is aborted if it wasn't already due to a request error.
                         // If the error happened before request creation, this is less relevant.
                          // No manual abort here, rely on #getTransaction throwing and letting the outer handler deal with it.
                         throw error; // Re-throw the error
                     }
                 }

                 /**
                  * Retrieves all search history items from the IndexedDB object store, ordered by timestamp.
                  * @param {number} [limit] - Optional limit for the number of items to retrieve.
                  * @returns {Promise<object[]>} A Promise resolving with an array of search history objects.
                  */
                 async getSearchHistory(limit) {
                     try {
                         Logger.debug("Attempting to get search history items from IndexedDB...", { limit: limit });
                         const transaction = await this.#getTransaction(this.#storeName, 'readonly');
                         const objectStore = transaction.objectStore(this.#storeName);

                         // Get items using the 'timestamp' index to retrieve them in order.
                         // Use 'prev' direction to get most recent first.
                         const index = objectStore.index('timestamp');
                         const request = index.openCursor(null, 'prev'); // Start from the beginning (latest), going backwards

                         const historyItems = [];

                         return new Promise((resolve, reject) => {
                             request.onsuccess = (event) => {
                                 const cursor = event.target.result;
                                 if (cursor) {
                                     try {
                                         // Add the current item's value to the results array
                                         historyItems.push(cursor.value);
                                         // Check if we've reached the limit
                                         if (limit && historyItems.length >= limit) {
                                             Logger.debug(`Reached history limit of ${limit}. Stopping cursor iteration.`);
                                              // Stopping the cursor iteration prevents onsuccess from firing again for this request.
                                              // The transaction will eventually complete.
                                             resolve(historyItems);
                                         } else {
                                             // Move to the next record in the index
                                             cursor.continue();
                                         }
                                     } catch (cursorError) {
                                          Logger.error("Error processing cursor value in getSearchHistory:", cursorError);
                                         // Decide how to handle errors during iteration: skip the item, reject the whole process?
                                         // For this demo, log and continue to try and get other items.
                                          cursor.continue();
                                     }
                                 } else {
                                     // No more entries, or limit was reached and resolve was called above.
                                     Logger.debug(`IndexedDB cursor iteration finished. Collected ${historyItems.length} items.`);
                                     resolve(historyItems); // Resolve with the collected items
                                 }
                             };
                             request.onerror = (event) => {
                                 const error = event.target.error;
                                 Logger.error("IndexedDB get request failed:", error);
                                 reject(error); // Reject with the error
                             };
                             // Transaction errors will also propagate.
                         });
                         // Transaction automatically commits when cursor iteration is done or limit reached and resolved.

                     } catch (error) {
                         Logger.error("Error getting search history from IndexedDB:", error);
                         throw error; // Re-throw the error
                     }
                 }

                 /**
                  * Clears all search history items from the IndexedDB object store.
                  * @returns {Promise<void>} A Promise that resolves when the store is cleared.
                  */
                 async clearSearchHistory() {
                     try {
                         Logger.debug("Attempting to clear search history from IndexedDB...");
                         const transaction = await this.#getTransaction(this.#storeName, 'readwrite');
                         const objectStore = transaction.objectStore(this.#storeName);

                         // IndexedDB Clear Request (deletes all records in the store)
                         const request = objectStore.clear();

                         return new Promise((resolve, reject) => {
                             request.onsuccess = (event) => {
                                 Logger.info("IndexedDB search history cleared successfully.");
                                 resolve(); // Resolve when clear is successful
                             };
                             request.onerror = (event) => {
                                 const error = event.target.error;
                                 Logger.error("IndexedDB clear request failed:", error);
                                 reject(error); // Reject with the error
                             };
                             // Transaction errors also propagate.
                         });
                         // Transaction automatically commits when clear request completes.

                     } catch (error) {
                         Logger.error("Error clearing search history from IndexedDB:", error);
                         throw error; // Re-throw the error
                     }
                 }

                /**
                 * Closes the IndexedDB database connection.
                 * Useful for cleanup, though browser often handles on page close.
                 */
                closeDatabase() {
                    try {
                        if (this.#db) {
                             // Remove versionchange listener before closing if possible, or be prepared for it firing.
                             if (this.#db.onversionchange) {
                                 this.#db.onversionchange = null; // Remove listener
                             }
                            this.#db.close();
                            this.#db = null; // Clear reference
                            this.#isOpening = false;
                            this.#openRequest = null;
                            Logger.info("IndexedDB database connection closed.");
                        } else {
                             Logger.debug("IndexedDB database is not open, close skipped.");
                        }
                    } catch (error) {
                        Logger.error("Error closing IndexedDB database:", error);
                    }
                }

                /**
                 * Dispose method for cleanup on application shutdown.
                 * Ensures the database connection is closed.
                 */
                 dispose() {
                     try {
                        Logger.debug("Disposing IndexedDBService.");
                        this.closeDatabase(); // Close the DB connection
                        Logger.debug("IndexedDBService disposed.");
                     } catch (error) {
                         Logger.error("Error disposing IndexedDBService:", error);
                     }
                 }
            }


            // --- SIMULATED Google Identity Service (GIS) Wrapper ---
            // This class simulates the structure of interacting with the real Google Identity Services library.
            // It uses Promises and delays, but does NOT interact with actual Google servers or handle real tokens.
            // It manages its associated UI elements directly.
            class GoogleIdentityServiceWrapper {
                 #clientId;
                 #isSignedIn = false;
                 #userEmail = null;
                 #userGivenName = null; // Simulate getting more user info
                 #userFamilyName = null;
                 #authStatusElement = null; // Reference to the UI element showing status
                 #signInButtonElement = null; // Reference to the sign-in button element
                 #signInButtonTextElement = null; // Reference to the text inside the sign-in button
                 #authStatusClickHandler = null; // Store bound handler for status element click
                 #errorReporter; // Inject ErrorReporter

                /**
                 * @param {string} clientId - The Google OAuth 2.0 Client ID (placeholder).
                 * @param {object} selectors - Map of selectors for related UI elements.
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(clientId, selectors, errorReporter) {
                    try {
                        Logger.debug(`GoogleIdentityServiceWrapper constructor called.`);
                        if (!clientId || clientId === AppConfig.GOOGLE_CLIENT_ID) { // Check against placeholder
                            Logger.warn("Google OAuth Client ID is missing or placeholder. Simulated GIS will not appear configured.");
                            this.#clientId = null; // Treat as unconfigured
                        } else {
                             this.#clientId = clientId;
                             Logger.debug(`Simulated GIS configured with Client ID: ${this.#clientId}`);
                        }

                        if (!errorReporter) {
                           Logger.error("ErrorReporter instance not provided to GoogleIdentityServiceWrapper.");
                           // Use console.error if ErrorReporter is missing
                           this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[GIS ERROR] ${src}: ${msg}`, err, ctx) };
                        } else {
                           this.#errorReporter = errorReporter;
                        }


                        // Find and store references to UI elements
                        this.#authStatusElement = document.querySelector(selectors.GOOGLE_AUTH_STATUS);
                        this.#signInButtonElement = document.querySelector(selectors.GOOGLE_SIGN_IN_BUTTON);
                        this.#signInButtonTextElement = document.querySelector(selectors.GOOGLE_AUTH_TEXT);
                        const authArea = document.querySelector(selectors.GOOGLE_AUTH_AREA); // Get containing area


                        // Check if essential UI elements are found
                        if (!authArea || !this.#authStatusElement || !this.#signInButtonElement || !this.#signInButtonTextElement) {
                             const missing = [];
                             if (!authArea) missing.push(selectors.GOOGLE_AUTH_AREA);
                             if (!this.#authStatusElement) missing.push(selectors.GOOGLE_AUTH_STATUS);
                             if (!this.#signInButtonElement) missing.push(selectors.GOOGLE_SIGN_IN_BUTTON);
                             if (!this.#signInButtonTextElement) missing.push(selectors.GOOGLE_AUTH_TEXT);

                             this.#errorReporter.reportError(
                                 'GoogleIdentityServiceWrapper.constructor',
                                 new Error("Essential UI elements not found for GIS."),
                                 { selectorsMissing: missing.join(', ') },
                                 'Sign-In area or button elements are missing.',
                                 'gis_ui_missing',
                                 0 // Persistent error
                             );
                             // Mark service as unusable if UI is missing
                             this.#clientId = null; // Effectively disable simulation if UI is gone
                        } else {
                             // Attach click listener to the Sign-In button to trigger simulation
                             // We can add a listener to the button itself.
                             this.#signInButtonElement.addEventListener('click', this.#handleAuthToggleClick.bind(this));
                             Logger.debug("Attached click listener to Google Sign-In button.");

                             // Add a placeholder/hint that status text is clickable in simulation
                             if (this.#authStatusElement) {
                                 this.#authStatusElement.style.cursor = 'pointer';
                                 this.#authStatusElement.title = 'Click status text to simulate Sign-In/Out (Demo)';
                                 // Keep track of the bound handler to remove it later if needed
                                  this.#authStatusClickHandler = this.#handleAuthToggleClick.bind(this);
                                  this.#authStatusElement.addEventListener('click', this.#authStatusClickHandler);
                                  Logger.debug("Attached click listener to Google Auth Status element for simulation toggle.");
                             }
                        }


                        // In a real app, you'd initialize the GIS client here:
                        // if (typeof google !== 'undefined' && google.accounts && google.accounts.id && this.#clientId) {
                        //    google.accounts.id.initialize({ client_id: this.#clientId, callback: this.#handleCredentialResponse.bind(this), auto_select: false, cancel_on_tap_outside: true });
                        //    // You would then likely render a button or trigger google.accounts.id.prompt()
                        //    Logger.info("Real Google Identity Services initialized (simulated).");
                        // } else {
                        //    Logger.warn("Real Google Identity Services library not loaded or Client ID missing.");
                        //    // Simulate behavior when GIS library isn't available - users cannot sign in.
                        // }


                        this.#updateUI(); // Initial UI update based on simulation state (starts signed out)

                        Logger.debug(`GoogleIdentityServiceWrapper initialized.`);
                    } catch (error) {
                         this.#errorReporter.reportError(
                             'GoogleIdentityServiceWrapper.constructor',
                             error,
                             { clientId: clientId, selectors: selectors },
                             'Failed to initialize Google Sign-In simulation.',
                             'gis_init_exception',
                             0
                         );
                         // Ensure state indicates not signed in and cleanup references on critical construction error
                         this.#isSignedIn = false;
                         this.#userEmail = null;
                         this.#userGivenName = null;
                         this.#userFamilyName = null;
                          this.#authStatusElement = null; // Clear references if setup failed
                          this.#signInButtonElement = null;
                          this.#signInButtonTextElement = null;
                          this.#authStatusClickHandler = null;

                         throw error; // Re-throw initialization error
                    }
                }

                // Private method to simulate handling a credential response (like the GIS callback)
                #handleCredentialResponse(credentialResponse) {
                     try {
                        Logger.debug("Simulated credential response received:", credentialResponse);
                        // In a real app, you'd send credentialResponse.credential (the ID token)
                        // to your backend for verification and user authentication.

                        // Simulate parsing user info from the credential (ID token payload structure).
                        // This is highly simplified; real ID token parsing involves decoding JWT.
                        const simulatedPayload = {
                            email: credentialResponse.email || 'simulated.user@gmail.com',
                            given_name: credentialResponse.given_name || 'Simulated',
                            family_name: credentialResponse.family_name || 'User',
                            name: credentialResponse.name || 'Simulated User', // Full name
                            picture: credentialResponse.picture || null, // User profile picture URL
                            // Add other standard claims like sub (user ID), aud, iss, exp etc.
                        };
                        Logger.debug("Simulated token payload:", simulatedPayload);

                        this.#isSignedIn = true;
                        this.#userEmail = simulatedPayload.email;
                        this.#userGivenName = simulatedPayload.given_name;
                        this.#userFamilyName = simulatedPayload.family_name;
                        Logger.info(`Simulated Google Sign-In successful for user: "${this.#userEmail}" ("${this.#userGivenName}").`);

                        this.#updateUI(); // Update UI after sign-in state change

                        // In a real app, you would typically store some session info client-side (e.g., cookies, local storage)
                        // and maybe trigger a custom event for other parts of the app to react to the sign-in.
                        // Example: CustomEvent 'auth:signed_in' with detail { email: this.#userEmail }

                     } catch (error) {
                         this.#errorReporter.reportError(
                             'GoogleIdentityServiceWrapper.#handleCredentialResponse',
                             error,
                             { response: credentialResponse },
                             'Failed to process simulated Sign-In response.',
                             'gis_response_handling_exception'
                         );
                         // Ensure state is false on error
                         this.#isSignedIn = false;
                         this.#userEmail = null;
                         this.#userGivenName = null;
                         this.#userFamilyName = null;
                         this.#updateUI(); // Update UI for failed state
                     }
                }

                /**
                 * Public method to simulate triggering the sign-in flow. Returns a Promise.
                 * @returns {Promise<object>} A promise that resolves with success details or rejects with an error.
                 */
                async signIn() {
                    try {
                        if (this.#isSignedIn) {
                            Logger.debug("Already signed in, skipping simulated Google Sign-In.");
                             this.#updateUI(); // Ensure UI is correct
                             return { success: true, message: 'Already signed in.', userEmail: this.#userEmail, userGivenName: this.#userGivenName };
                        }

                        Logger.debug("Attempting simulated Google Sign-In...");
                         if (!this.#clientId) {
                              const errorMsg = "Simulated GIS is not configured (Client ID missing or placeholder). Cannot sign in.";
                             Logger.warn(errorMsg);
                             this.#updateUI();
                              // Reject with an error indicating configuration issue
                              throw new Error(errorMsg);
                         }


                        // In a real app, you'd call the GIS library functions here based on the user's action (e.g., button click):
                        // google.accounts.id.prompt(); // For One Tap
                        // OR google.accounts.id.renderButton(document.getElementById('googleSignInButton'), { type: 'standard', theme: 'outline', size: 'large' });
                        // OR handle a popup/redirect flow via google.accounts.oauth2.initCodeFlow or .initTokenFlow


                        this.#updateUI('signing-in'); // Update UI to indicate signing in

                        return new Promise((resolve, reject) => {
                            // Simulate async sign-in process with a delay
                            setTimeout(() => {
                                try {
                                    // Simulate a random success/failure
                                    const success = Math.random() > 0.1; // 90% chance of success

                                    if (success) {
                                        // Simulate receiving a successful credential response after a simulated user interaction (popup/redirect).
                                        // The structure mimics the response from a successful Google Identity Services callback.
                                        this.#handleCredentialResponse({
                                            credential: 'simulated_id_token_' + Date.now(), // Placeholder token
                                            select_by: 'auto', // Simulate how the credential was selected
                                            client_id: this.#clientId,
                                            email: 'simulated.user.' + Date.now() + '@gmail.com',
                                            email_verified: true,
                                            given_name: 'Simulated',
                                            family_name: 'User',
                                            name: 'Simulated User',
                                            picture: 'https://example.com/sim_user_pic.jpg', // Placeholder picture URL
                                            locale: 'en',
                                            iss: 'accounts.google.com',
                                            sub: 'simulated_user_id_' + Math.random().toString(36).substring(2, 15), // Placeholder unique ID
                                            aud: this.#clientId,
                                            iat: Math.floor(Date.now() / 1000), // Issued at timestamp
                                            exp: Math.floor(Date.now() / 1000) + 3600, // Expiration timestamp (e.g., 1 hour)
                                            jti: 'simulated_jti_' + Date.now() // JWT ID
                                        });
                                        resolve({ success: true, message: 'Simulated sign-in successful.', userEmail: this.#userEmail, userGivenName: this.#userGivenName });
                                    } else {
                                        // Simulate a failed sign-in (e.g., user cancelled the dialog, network issue specific to auth).
                                        Logger.warn("Simulated Google Sign-In failed randomly.");
                                         this.#isSignedIn = false; // Ensure state is false on simulated failure
                                         this.#userEmail = null;
                                         this.#userGivenName = null;
                                         this.#userFamilyName = null;
                                         this.#updateUI(); // Update UI for failed state (signed out)
                                        // Reject with a simulated error reflecting the failure cause.
                                        reject(new Error('Simulated sign-in failed (e.g., user cancelled dialog or network issue).'));
                                    }
                                } catch (timeoutError) {
                                     // Catch unexpected errors *inside* the setTimeout callback.
                                    this.#errorReporter.reportError(
                                        'GoogleIdentityServiceWrapper.signIn.timeout',
                                        timeoutError,
                                        {},
                                        'Internal error during simulated sign-in.',
                                        'gis_sim_timeout_exception'
                                    );
                                     this.#isSignedIn = false;
                                     this.#userEmail = null;
                                     this.#userGivenName = null;
                                     this.#userFamilyName = null;
                                     this.#updateUI();
                                     reject(timeoutError); // Re-reject with the original error
                                }
                            }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use configured delay for simulated service
                        });
                    } catch (error) {
                         // Catch errors *before* the async part (Promise setup, initial checks).
                         this.#errorReporter.reportError(
                             'GoogleIdentityServiceWrapper.signIn',
                             error,
                             {},
                             'Simulated Sign-In setup failed.',
                             'gis_sim_setup_exception'
                         );
                         this.#updateUI(); // Ensure UI reflects current (likely signed out) state
                         throw error; // Re-throw the original error
                    }
                }

                /**
                 * Public method to simulate signing out. Returns a Promise.
                 * @returns {Promise<object>} A promise that resolves with success details or rejects with an error.
                 */
                async signOut() {
                    try {
                        Logger.debug("Attempting simulated Google Sign-Out...");
                         if (!this.#isSignedIn) {
                             Logger.debug("Not signed in, simulated sign-out skipped.");
                             this.#updateUI(); // Ensure UI is correct
                             return Promise.resolve({ success: true, message: 'Already signed out.' });
                         }

                        // In a real app, you might call:
                        // google.accounts.id.disableAutoSelect(); // If One Tap was enabled
                        // OR clear client-side tokens/sessions established after verification on backend.

                         this.#updateUI('signing-out'); // Indicate signing out immediately

                        return new Promise((resolve, reject) => {
                            setTimeout(() => {
                                try {
                                     // Simulate a random success/failure
                                     const success = Math.random() > 0.05; // 95% chance of success

                                     if (success) {
                                         this.#isSignedIn = false;
                                         this.#userEmail = null; // Clear user info on sign-out
                                         this.#userGivenName = null;
                                         this.#userFamilyName = null;
                                         Logger.info("Simulated Google Sign-Out successful.");
                                         this.#updateUI(); // Update UI after state change
                                         // You might trigger a custom event here like 'auth:signed_out'
                                        resolve({ success: true, message: 'Simulated signed out.' });
                                    } else {
                                         Logger.warn("Simulated Google Sign-Out failed randomly.");
                                        this.#updateUI(); // Attempt to update UI to current state on failure
                                         reject(new Error('Simulated sign-out failed (network issue).'));
                                     }
                                } catch (timeoutError) {
                                     // Catch unexpected errors inside the timeout callback.
                                     this.#errorReporter.reportError(
                                         'GoogleIdentityServiceWrapper.signOut.timeout',
                                         timeoutError,
                                         {},
                                         'Internal error during simulated sign-out.',
                                         'gis_signout_timeout_exception'
                                     );
                                     // Attempt to reset state if sign-out logic failed internally
                                     this.#isSignedIn = false;
                                     this.#userEmail = null;
                                     this.#userGivenName = null;
                                     this.#userFamilyName = null;
                                     this.#updateUI();
                                     reject(timeoutError);
                                }
                            }, AppConfig.SIMULATED_SERVICE_DELAY_MS / 2); // Shorter delay for sign out simulation
                        });
                    } catch (error) {
                         // Catch errors before the async part (Promise setup).
                         this.#errorReporter.reportError(
                            'GoogleIdentityServiceWrapper.signOut',
                            error,
                            {},
                            'Simulated Sign-Out setup failed.',
                            'gis_signout_setup_exception'
                         );
                         this.#updateUI();
                         throw error;
                    }
                }

                // Private method to update the UI elements related to authentication status.
                #updateUI(state = 'idle') {
                     try {
                        const statusElement = this.#authStatusElement;
                        const signInButton = this.#signInButtonElement;
                        const signInButtonText = this.#signInButtonTextElement;
                        const googleAuthArea = document.querySelector(AppConfig.SELECTORS.GOOGLE_AUTH_AREA);


                        // Defensive check for elements
                        if (!googleAuthArea || !statusElement || !signInButton || !signInButtonText) {
                             Logger.debug("Auth UI elements missing, skipping UI update.");
                             // ErrorReporter already logged this in constructor if elements are missing.
                             return;
                        }

                         // Show the entire auth area if GIS is configured, hide otherwise (or handle in SearchForm visibility)
                         if (this.#clientId) { // Only show if Client ID is set (even placeholder)
                             googleAuthArea.classList.remove('app-hide');
                         } else {
                              googleAuthArea.classList.add('app-hide');
                              Logger.debug("Hiding auth UI because GIS not configured.");
                         }


                        // Update status text
                        if (state === 'signing-in') {
                             statusElement.textContent = AppConfig.MESSAGES.AUTH_SIGNING_IN;
                             signInButtonText.textContent = 'Processing...'; // Indicate button is busy
                        } else if (state === 'signing-out') {
                             statusElement.textContent = 'Signing out...';
                             signInButtonText.textContent = 'Processing...';
                        } else { // idle state (signed in or signed out)
                            // Show detailed status based on the internal signed-in flag.
                             statusElement.textContent = this.#isSignedIn
                                ? AppConfig.MESSAGES.AUTH_SUCCESS(this.#userEmail || 'Unknown User') // Use email if available
                                : AppConfig.MESSAGES.AUTH_SIGNED_OUT;

                             // Update button text and title based on sign-in state.
                             signInButtonText.textContent = this.#isSignedIn ? 'Sign out (Simulated)' : 'Sign in with Google (Simulated)';
                             signInButton.title = this.#isSignedIn ? 'Click to simulate signing out' : 'Click to simulate signing in with Google';
                        }

                        // Update button state (enable/disable)
                        // Button is disabled during signing in/out process states.
                        const buttonDisabled = state === 'signing-in' || state === 'signing-out';
                         // Avoid unnecessary DOM manipulation if the state hasn't changed.
                        if (signInButton.disabled !== buttonDisabled) {
                             signInButton.disabled = buttonDisabled;
                             Logger.debug(`Sign-in button disabled: ${buttonDisabled}`);
                        }

                        // Add/remove a custom class to the button to indicate signed-in state for styling
                         if (this.#isSignedIn) {
                             signInButton.classList.add('signed-in'); // Add class when signed in
                         } else {
                             signInButton.classList.remove('signed-in'); // Remove class when signed out
                         }

                         Logger.debug("Auth UI updated to state:", state, `(Signed in: ${this.#isSignedIn}, Email: ${this.#userEmail})`);

                     } catch (error) {
                         this.#errorReporter.reportError(
                             'GoogleIdentityServiceWrapper.#updateUI',
                             error,
                             { uiState: state, isSignedIn: this.#isSignedIn, email: this.#userEmail },
                             'Error updating Google Sign-In UI.',
                             'gis_ui_update_exception'
                         );
                         // Defensive attempt to reset button state if UI update fails
                         if (this.#signInButtonElement) {
                              this.#signInButtonElement.disabled = false; // Re-enable to prevent being stuck
                             if (this.#signInButtonTextElement) this.#signInButtonTextElement.textContent = 'Sign-In Error';
                             if (this.#authStatusElement) this.#authStatusElement.textContent = 'Status Update Error';
                         }
                     }
                }

                /**
                 * Public method to check the simulated sign-in status.
                 * @returns {boolean} - True if user is simulated signed in, false otherwise or if service unconfigured/errored.
                 */
                isSignedIn() {
                     try {
                        // Return false if the service wasn't configured/initialized properly.
                         if (!this.#clientId) return false;
                        return this.#isSignedIn;
                     } catch (error) {
                         this.#errorReporter.reportError(
                            'GoogleIdentityServiceWrapper.isSignedIn',
                            error, {},
                            'Error checking Sign-In status.', 'gis_check_status_exception'
                         );
                         return false; // Assume not signed in if error occurs
                     }
                }

                /**
                 * Public method to get the simulated signed-in user's email.
                 * @returns {string|null} - The user's email if signed in, null otherwise or if service unconfigured/errored.
                 */
                getUserEmail() {
                    try {
                        // Return null if not signed in or service unconfigured.
                         if (!this.#clientId || !this.#isSignedIn) return null;
                        return this.#userEmail;
                    } catch (error) {
                         this.#errorReporter.reportError(
                            'GoogleIdentityServiceWrapper.getUserEmail',
                            error, {},
                            'Error getting signed-in user email.', 'gis_get_email_exception'
                         );
                        return null; // Return null on error
                    }
                }

                /**
                 * Public method to get some basic simulated user info if signed in.
                 * @returns {{email: string|null, givenName: string|null, familyName: string|null}|null}
                 * Returns an object with user info or null if not signed in or service unconfigured/errored.
                 */
                getUserInfo() {
                     try {
                          if (!this.#clientId || !this.#isSignedIn) {
                              Logger.debug("getUserInfo: User not signed in.");
                              return null;
                          }
                          // Return a new object containing the current simulated user info.
                          const userInfo = {
                             email: this.#userEmail,
                             givenName: this.#userGivenName,
                             familyName: this.#userFamilyName
                             // Could add picture URL etc. if simulated
                          };
                          Logger.debug("getUserInfo: Returning simulated user info.", userInfo);
                          return userInfo;
                     } catch (error) {
                          this.#errorReporter.reportError(
                             'GoogleIdentityServiceWrapper.getUserInfo',
                             error, {},
                             'Error getting signed-in user info.', 'gis_get_userinfo_exception'
                          );
                          return null; // Return null on error
                     }
                }

                 /**
                  * Public method to trigger the sign-in/out toggle via clicking the UI elements.
                  * Called by event listeners. Marked async as signIn/signOut are async.
                  */
                 async handleAuthToggleClick() {
                     try {
                         Logger.debug("Auth toggle clicked via handleAuthToggleClick. Checking current state.");
                          // Use the internal #isSignedIn flag to decide whether to sign out or sign in.
                         if (this.#isSignedIn) {
                             Logger.debug("User is signed in. Attempting sign out.");
                              // Call the public signOut method and await its completion.
                             await this.signOut();
                             Logger.debug("Simulated sign out process finished.");
                         } else {
                             Logger.debug("User is signed out. Attempting sign in.");
                              // Call the public signIn method and await its completion.
                             await this.signIn();
                             Logger.debug("Simulated sign in process finished.");
                         }
                         // The UI update (_updateUI) is called automatically within signIn/signOut methods
                         // and #handleCredentialResponse handler.
                     } catch (error) {
                         // Errors specific to signIn/signOut setup or timeout handling are caught within those methods.
                         // This catch block handles errors thrown if calling signIn/signOut itself failed synchronously.
                          this.#errorReporter.reportError(
                              'GoogleIdentityServiceWrapper.handleAuthToggleClick',
                              error,
                              { currentState: this.#isSignedIn ? 'signed_in' : 'signed_out' },
                              'Error handling Google Sign-In/Out click.',
                              'gis_toggle_click_exception'
                          );
                         // Ensure UI state is updated to reflect potential error or unexpected state.
                         this.#updateUI();
                     }
                 }

                 /**
                  * Dispose method for cleanup on application shutdown.
                  * Removes event listeners and clears references.
                  */
                 dispose() {
                     try {
                         Logger.debug("Disposing GoogleIdentityServiceWrapper.");
                         // Remove the click listener from the auth status element if it was attached.
                         if (this.#authStatusElement && this.#authStatusClickHandler) {
                              try {
                                  this.#authStatusElement.removeEventListener('click', this.#authStatusClickHandler);
                                  Logger.debug("Removed auth status element click listener.");
                              } catch (e) { Logger.error("Error removing auth status listener:", e); }
                         }
                         // Event listener on the signInButtonElement is attached via _addEventListener in SearchForm
                         // or could be managed here if attached directly. Assuming SearchForm manages button handlers via _addEventListener.

                         // Clear references to UI elements
                         this.#authStatusElement = null;
                         this.#signInButtonElement = null;
                         this.#signInButtonTextElement = null;
                         this.#authStatusClickHandler = null; // Clear handler reference

                         // No need to dispose ErrorReporter instance here, it's shared.

                         Logger.debug("GoogleIdentityServiceWrapper disposed.");
                     } catch (error) {
                          this.#errorReporter.reportError(
                              'GoogleIdentityServiceWrapper.dispose',
                              error, {},
                              'Error disposing Google Identity Service wrapper.',
                              'gis_dispose_exception'
                          );
                     }
                 }
            }

            // --- SIMULATED Google Pay Service Wrapper ---
            // This class simulates the structure of interacting with the real Google Pay API.
            // It uses Promises and delays, but does NOT interact with actual Google servers or handle real payments.
            // It manages the Google Pay button's readiness state.
            class GooglePayServiceWrapper {
                #paymentsClient; // Placeholder for the real PaymentsClient object (or a simulated one)
                #isReady = false; // Private flag to simulate readiness
                #simulatedSuccessRate;
                #googlePayButtonElement; // Reference to the Google Pay button
                #errorReporter; // Inject ErrorReporter

                /**
                 * @param {object} googlePayConfig - Configuration object for Google Pay (from AppConfig).
                 * @param {string} googlePayButtonSelector - Selector for the Google Pay button element.
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(googlePayConfig, googlePayButtonSelector, errorReporter) {
                    try {
                        Logger.debug(`GooglePayServiceWrapper constructor called with success rate: ${googlePayConfig?.SIMULATED_SUCCESS_RATE || 'default'}`);

                         if (!errorReporter) {
                            Logger.error("ErrorReporter instance not provided to GooglePayServiceWrapper.");
                            this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[GPay ERROR] ${src}: ${msg}`, err, ctx) };
                         } else {
                            this.#errorReporter = errorReporter;
                         }

                        // Validate required configuration for the simulation structure
                         if (!googlePayConfig?.API_VERSION || !googlePayConfig?.API_VERSION_MINOR || !googlePayConfig?.ALLOWED_PAYMENT_METHODS || googlePayConfig.ALLOWED_PAYMENT_METHODS.length === 0 || !googlePayConfig?.MERCHANT_INFO || !googlePayConfig?.TRANSACTION_INFO) {
                            const errorMsg = "Essential Google Pay configuration missing or invalid.";
                            this.#errorReporter.reportError('GooglePayServiceWrapper.constructor', new Error(errorMsg), { config: googlePayConfig }, errorMsg, 'gpay_config_missing', 0);
                            this.#simulatedSuccessRate = 0; // Effectively disable if config is bad
                            this.#isReady = false; // Mark as not ready
                         } else {
                             this.#simulatedSuccessRate = googlePayConfig.SIMULATED_SUCCESS_RATE ?? 0.9; // Use provided rate or default
                             // Store full config (could be useful if simulating different methods)
                             this._config = googlePayConfig; // Use protected for access in internal helpers

                              // Find the Google Pay button element
                             this.#googlePayButtonElement = document.querySelector(googlePayButtonSelector);
                              if (!this.#googlePayButtonElement) {
                                   const errorMsg = `Google Pay button element not found with selector "${googlePayButtonSelector}".`;
                                  this.#errorReporter.reportError('GooglePayServiceWrapper.constructor', new Error(errorMsg), { selector: googlePayButtonSelector }, errorMsg, 'gpay_button_missing', 0);
                                  this.#isReady = false; // Mark as not ready if button missing
                              } else {
                                  // Disable button initially until readiness check is complete
                                  this.#googlePayButtonElement.disabled = true;
                              }


                             // In a real app, you would initialize the PaymentsClient here:
                             // if (typeof google !== 'undefined' && google.payments && google.payments.api) {
                             //    this.#paymentsClient = new google.payments.api.PaymentsClient({ environment: 'TEST' }); // Or 'PRODUCTION'
                             //    Logger.info("Real Google Pay PaymentsClient initialized (simulated).");
                             // } else {
                             //     Logger.warn("Real Google Pay API library not loaded. Google Pay will not be available.");
                             // }


                             // Simulate the isReadyToPay check asynchronously soon after initialization.
                             this.#simulateIsReadyToPayCheck(); // Call private async method immediately


                             Logger.debug(`GooglePayServiceWrapper initialized.`);
                         }
                    } catch (error) {
                         // Catch errors specifically during the constructor execution itself.
                         this.#errorReporter.reportError(
                             'GooglePayServiceWrapper.constructor',
                             error,
                             { selector: googlePayButtonSelector, config: googlePayConfig },
                             'Failed to initialize Google Pay simulation.',
                             'gpay_init_exception',
                             0
                         );
                         // Ensure state indicates not ready on construction error
                         this.#isReady = false;
                          this.#googlePayButtonElement = null; // Clear ref
                         throw error; // Re-throw initialization error
                    }
                }

                /**
                 * Private async method to simulate checking if Google Pay is ready to accept payments.
                 * In a real integration, this calls `paymentsClient.isReadyToPay(request)`.
                 * Updates the internal #isReady flag and potentially the UI button state.
                 */
                async #simulateIsReadyToPayCheck() {
                    try {
                         // Only proceed if config is valid and button element exists.
                        if (!this._config || !this.#googlePayButtonElement) {
                            Logger.warn("Skipping simulated isReadyToPay check: config or button missing.");
                             this.#isReady = false; // Explicitly ensure state is false
                             return;
                        }

                         Logger.debug("Simulating isReadyToPay check...");
                         // Update UI state for readiness check start (optional, but good UX)
                         if (this.#googlePayButtonElement) {
                              this.#googlePayButtonElement.textContent = 'Checking availability...'; // Update button text
                         }


                        // Simulate async check with a delay.
                         // In a real app, you'd construct a IsReadyToPayRequest (simpler than PaymentDataRequest).
                         // const isReadyRequest = { apiVersion: this._config.API_VERSION, apiVersionMinor: this._config.API_VERSION_MINOR, allowedPaymentMethods: this._config.ALLOWED_PAYMENT_METHODS };
                         // return this.#paymentsClient.isReadyToPay(isReadyRequest); // Real call

                         await new Promise(resolve => setTimeout(resolve, AppConfig.SIMULATED_SERVICE_DELAY_MS / 2)); // Simulate async delay


                        // Simulate the result of the readiness check (e.g., based on browser support, user having cards)
                         const simulateReady = Math.random() > 0.1; // 90% chance of being ready in simulation


                        this.#isReady = simulateReady; // Update the internal readiness state


                        if (this.#isReady) {
                            Logger.info("Simulated Google Pay ready status: TRUE.");
                             // The SearchForm parent manages overall button state (ready AND has search data).
                             // We'll just update the button text to the default Google Pay button text style.
                              this.#updateGooglePayButtonUI('ready');
                             // You might trigger a custom event like 'googlepay:ready' for other parts of the app.

                        } else {
                            Logger.warn("Simulated Google Pay ready status: FALSE. Google Pay may not be available on this device/browser.");
                            // Disable the button here explicitly if the check determined it's not available.
                            // SearchForm will keep it disabled if there's no search data anyway.
                            if (this.#googlePayButtonElement) {
                                this.#googlePayButtonElement.disabled = true; // Disable the button if check failed
                            }
                            this.#updateGooglePayButtonUI('not-ready');
                            // You might trigger 'googlepay:notready' event.
                             this.#errorReporter.reportError(
                                 'GooglePayServiceWrapper.#simulateIsReadyToPayCheck',
                                 new Error("Simulated readiness check returned false."), {},
                                 AppConfig.MESSAGES.GOOGLE_PAY_NOT_READY,
                                 'gpay_not_ready',
                                 8000 // Show message temporarily
                             );
                        }


                    } catch (error) {
                         // Catch errors during the simulation or actual API call setup.
                         this.#errorReporter.reportError(
                            'GooglePayServiceWrapper.#simulateIsReadyToPayCheck',
                            error, {},
                            'Error during Google Pay availability check simulation.',
                            'gpay_readiness_check_exception',
                            0 // Persistent error if check fails fundamentally
                         );
                         this.#isReady = false; // Ensure state is false on error
                          // Ensure the button is disabled and UI reflects failure
                         if (this.#googlePayButtonElement) {
                             this.#googlePayButtonElement.disabled = true;
                         }
                          this.#updateGooglePayButtonUI('error'); // Show error text on button
                    }
                }

                 /**
                  * Private helper to update the Google Pay button text and state based on readiness.
                  * @param {'checking'|'ready'|'not-ready'|'error'} state - The state to reflect in the UI.
                  */
                 #updateGooglePayButtonUI(state) {
                     try {
                        const button = this.#googlePayButtonElement;
                        if (!button) {
                             Logger.debug("Google Pay button element not found, skipping UI update.");
                             return;
                        }

                        // Remove any temporary text/spinners
                        const spinner = button.querySelector('.w3-spin');
                        if(spinner) spinner.classList.add('app-hide');
                        const textSpan = button.querySelector('#googlePayButton text'); // Using selector for possible text element within SVG or span
                        if(textSpan) textSpan.textContent = ''; // Clear dynamic text

                        // Update based on state
                         switch (state) {
                            case 'checking':
                                button.textContent = 'Checking availability...';
                                 // Add spinner back? Or use the main app spinner?
                                break;
                            case 'ready':
                                // Real Google Pay button has a specific appearance managed by their library.
                                // For simulation, just revert to standard text and rely on SearchForm to enable/disable.
                                 button.innerHTML = '<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#ffffff" d="M12 24c6.627 0 12-5.373 12-12S18.627 0 12 0 0 5.373 0 12s5.373 12 12 12zm-1.883-9.883L10.87 11l-2.05-2.05L7.44 10.3l3.43 3.43 6.27-6.26L15.72 6.44 10.117 12.044l-1.49-1.49-.707-.707L9.41 8.172z"/></svg> Simulated Google Pay';
                                button.disabled = false; // Will be re-disabled by SearchForm if no search data
                                 // Check config for merchant name or use generic
                                if(this._config?.MERCHANT_INFO?.merchantName) {
                                     // Could add "Pay with Google"
                                     // button.textContent = `Pay with Google (${this._config.MERCHANT_INFO.merchantName})`;
                                }
                                break;
                            case 'not-ready':
                                button.textContent = 'Google Pay Unavailable';
                                button.disabled = true;
                                break;
                             case 'error':
                                button.textContent = 'Error Initializing Pay';
                                button.disabled = true;
                                break;
                            default:
                                 button.textContent = 'Simulated Google Pay'; // Default/initial state
                                 button.disabled = true;
                                 break;
                        }

                     } catch (error) {
                         this.#errorReporter.reportError(
                            'GooglePayServiceWrapper.#updateGooglePayButtonUI',
                            error, { buttonState: state },
                            'Error updating Google Pay button UI.', 'gpay_ui_update_exception'
                         );
                         // Attempt a raw text update as fallback if structured update failed
                         if (this.#googlePayButtonElement) this.#googlePayButtonElement.textContent = 'GPay UI Error';
                     }
                 }


                /**
                 * Public method to check the simulated readiness status.
                 * @returns {boolean} - True if Google Pay is simulated ready, false otherwise or if service unconfigured/errored.
                 */
                isReady() {
                     try {
                         // Check if core config is valid as a primary readiness indicator for simulation
                         if (!this._config?.API_VERSION || !this._config.ALLOWED_PAYMENT_METHODS.find(m => m.type === 'CARD')?.tokenizationSpecification) {
                             Logger.debug("isReady: Google Pay config missing, returning false.");
                             return false; // Cannot be ready if essential config is missing
                         }
                         // Return the internal flag determined by the async readiness check.
                         return this.#isReady;
                     } catch (error) {
                         this.#errorReporter.reportError(
                            'GooglePayServiceWrapper.isReady',
                            error, {},
                            'Error checking simulated Google Pay ready status.', 'gpay_check_ready_exception'
                         );
                         return false; // Assume not ready if error occurs
                     }
                }

                /**
                 * Public method to simulate triggering the Google Pay payment flow and getting payment data.
                 * Requires readiness. Returns a Promise that resolves with simulated PaymentData or rejects.
                 * In a real integration, this is where the Google Pay UI sheet would appear for the user.
                 * @param {object} searchParams - Collected search parameters needed to construct the transaction details.
                 * @returns {Promise<object>} A promise that resolves with simulated PaymentData or rejects with an error.
                 */
                async loadPaymentData(searchParams) {
                    try {
                        Logger.debug("Attempting to simulate loadPaymentData...", searchParams);

                        if (!this.isReady()) { // Use public isReady check
                            Logger.warn("Simulated Google Pay is not ready. Cannot simulate payment flow.");
                             // Provide specific message if button was somehow clicked when not ready.
                             if (!this._config?.API_VERSION) { // Check config validity again
                                throw new Error("Google Pay service not configured.");
                            } else {
                                throw new Error(AppConfig.MESSAGES.GOOGLE_PAY_NOT_READY); // Service initialized but check failed
                            }
                        }
                        // Also check if search params are available, as they are needed for the request.
                        if (!searchParams || typeof searchParams !== 'object') {
                             const errorMsg = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION;
                             Logger.warn(errorMsg);
                             throw new Error(errorMsg);
                        }


                        // --- Construct Payment Data Request ---
                        // In a real app, you'd get the final price after a user selects
                        // a specific hotel deal based on the search results.
                        // For this simulation, we use a placeholder price from config
                        // combined with dynamic details from search params (destination, dates).
                        const transactionDetails = this._createSimulatedTransactionDetails(searchParams);
                         if (!transactionDetails) {
                             const errorMsg = 'Failed to create simulated transaction details for Google Pay.';
                            Logger.error(errorMsg, { searchParams: searchParams });
                             throw new Error(errorMsg);
                         }

                        // Construct the simulated PaymentDataRequest object using a helper.
                        // This object structure is based on the real Google Pay API documentation.
                        const paymentDataRequest = this._createPaymentDataRequest(transactionDetails);
                         if (!paymentDataRequest) {
                              const errorMsg = AppConfig.MESSAGES.SEARCH_ERROR + ' Failed to create simulated Google Pay request object.';
                             Logger.error(errorMsg);
                             throw new Error(errorMsg);
                         }


                        // In a real app, you'd call:
                        // return this.#paymentsClient.loadPaymentData(paymentDataRequest);
                        // This real call would trigger the Google Pay sheet/popup.


                        Logger.debug("Simulating async payment process...");
                        this.#updateGooglePayButtonUI('checking'); // Indicate processing on the button? Or use main loader? Main loader is better.


                        // Simulate async payment process using a Promise and timeout
                        return new Promise((resolve, reject) => {
                            setTimeout(() => {
                                try {
                                     // Simulate success or failure based on the configured rate.
                                     const success = Math.random() < this.#simulatedSuccessRate;

                                     if (success) {
                                         Logger.info("Simulated Google Pay payment processed successfully.");
                                         // Simulate returning a PaymentData object with encrypted token (structure based on real API).
                                         const simulatedPaymentData = {
                                             apiVersion: AppConfig.GOOGLE_PAY.API_VERSION,
                                             apiVersionMinor: AppConfig.GOOGLE_PAY.API_VERSION_MINOR,
                                             paymentMethodData: {
                                                 description: 'Simulated Visa ending in 1234', // Example description from a real response
                                                 tokenizationData: {
                                                     type: 'PAYMENT_GATEWAY', // Type indicates how the token is structured
                                                     // The token itself is a string, structure defined by gateway and Google Pay API
                                                     token: `{"signature":"simulated_signature","protocolVersion":"ECv2","signedMessage":"..."}_simulated_for_${paymentDataRequest.transactionInfo.totalPrice}_${paymentDataRequest.transactionInfo.currencyCode}` // Simulated token content
                                                 },
                                                 type: 'CARD', // Payment method type
                                                 info: { // Additional card info
                                                     cardNetwork: 'VISA', // Card network
                                                     cardDetails: '1234', // Last 4 digits
                                                 }
                                             },
                                             // Include billing/shipping/email if they were requested in the request and provided by user
                                             billingData: paymentDataRequest.allowedPaymentMethods[0]?.parameters?.billingAddressRequired ? { name: 'Simulated Billing', address1: '123 Simulated St', locality: 'Simulated City', administrativeArea: 'SC', postalCode: '12345', countryCode: 'US' } : undefined,
                                              email: paymentDataRequest.emailRequired ? 'simulated.buyer@example.com' : undefined,
                                              shippingAddress: paymentDataRequest.shippingAddressRequired ? { name: 'Simulated Shipping', address1: '456 Sim Blvd', locality: 'SimCity', administrativeArea: 'SB', postalCode: '67890', countryCode: 'US' } : undefined,

                                         };
                                         resolve(simulatedPaymentData); // Resolve with the simulated payment data object

                                     } else {
                                         // Simulate payment failure (user cancelled, card declined, etc.)
                                         // Distinguish user cancellation from hard errors if needed.
                                         const isCancelled = Math.random() < 0.3; // 30% chance it's a user cancel
                                         if (isCancelled) {
                                              Logger.warn("Simulated Google Pay payment cancelled by user.");
                                             // Real API often throws an error with a specific code or status for cancellation.
                                              // Simulate rejecting with a dedicated 'cancelled' error message.
                                              const cancelError = new Error(AppConfig.MESSAGES.GOOGLE_PAY_CANCELLED);
                                              cancelError.isCancelled = true; // Custom flag for handling
                                             reject(cancelError);

                                         } else {
                                             Logger.warn("Simulated Google Pay payment failed randomly (not cancelled).");
                                             // Simulate different types of non-cancel API errors
                                              const paymentErrors = [
                                                  'Simulated card processing declined.',
                                                  'Simulated insufficient funds.',
                                                  'Simulated authentication failure (3DS).',
                                                  'Simulated network error during payment processing.',
                                                  'Simulated processor internal error.'
                                              ];
                                               const randomErrorMsg = paymentErrors[Math.floor(Math.random() * paymentErrors.length)];
                                              // Real API error objects are more complex (e.g., code, message, transactionState).
                                             reject(new Error(`Simulated Google Pay API error: ${randomErrorMsg}`));
                                         }
                                     }
                                } catch (timeoutError) {
                                     // Catch unexpected errors *inside* the timeout callback.
                                    this.#errorReporter.reportError(
                                         'GooglePayServiceWrapper.loadPaymentData.timeout',
                                         timeoutError,
                                         { request: paymentDataRequest },
                                         'Internal error during simulated Google Pay processing.',
                                         'gpay_sim_timeout_exception'
                                     );
                                     reject(timeoutError); // Re-reject with the original error
                                }
                            }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use configured delay for simulated service
                        });

                    } catch (error) {
                         // Catch errors that occur *before* the async part (Promise setup, initial checks, request creation).
                         this.#errorReporter.reportError(
                            'GooglePayServiceWrapper.loadPaymentData',
                            error,
                            { searchParams: searchParams },
                            'Simulated Google Pay setup failed.',
                            'gpay_sim_setup_exception'
                         );
                         // Re-throw the error. The caller (_handleGooglePayClick) needs to catch and handle it.
                         throw error;
                    }
                }

                 /**
                  * Protected method to construct simulated transaction details based on search parameters.
                  * In a real app, this would come from a specific hotel/deal selection after search.
                  * @param {object} searchParams - The collected search parameters.
                  * @returns {object|null} - Simulated transaction details object or null if essential params are missing.
                  */
                 _createSimulatedTransactionDetails(searchParams) {
                     try {
                          Logger.debug("Creating simulated transaction details for Google Pay...", searchParams);
                         if (!searchParams || typeof searchParams !== 'object' || !searchParams.checkInDate || !searchParams.checkOutDate) {
                             Logger.warn("Missing dates for simulated transaction details.");
                              // Cannot create realistic transaction details without dates.
                             return null;
                         }

                          // Calculate number of nights based on check-in/out dates.
                          // Use DateObjects for calculation robustness (already handled in DateInput/Form validation).
                          // Assume Dates are YYYY-MM-DD format strings in searchParams.
                         let numNights = 1;
                         try {
                            const checkIn = new Date(searchParams.checkInDate);
                            const checkOut = new Date(searchParams.checkOutDate);
                            if (!isNaN(checkIn.getTime()) && !isNaN(checkOut.getTime()) && checkOut > checkIn) {
                                const diffTime = checkOut.getTime() - checkIn.getTime();
                                const oneDay = 24 * 60 * 60 * 1000;
                                numNights = Math.max(1, Math.round(diffTime / oneDay)); // Ensure at least 1 night
                            } else if (!isNaN(checkIn.getTime()) && !isNaN(checkOut.getTime()) && checkOut <= checkIn) {
                                // Checkout <= Checkin should be caught by validation, but defensively: 1 night if dates are valid.
                                numNights = 1;
                                 Logger.warn("Checkout date is not after checkin date for simulated transaction details.");
                            } else {
                                 Logger.warn("Invalid date objects for calculating number of nights in simulated transaction details.");
                                numNights = 1; // Default to 1 night if dates are invalid
                            }
                         } catch (dateError) {
                              Logger.error("Error calculating number of nights for simulated transaction:", dateError);
                             numNights = 1; // Default on error
                         }

                         // Use the base price from config and scale it by number of nights.
                         // This is a simplified calculation. Real price comes from selected hotel/deal.
                         const basePrice = parseFloat(AppConfig.GOOGLE_PAY.TRANSACTION_INFO.totalPrice) || 100.00;
                         const totalPrice = (basePrice * numNights).toFixed(2); // Calculate price per stay, format to 2 decimal places

                         const transactionInfo = {
                             // Structure based on Google Pay API TransactionInfo
                            totalPriceStatus: 'FINAL',
                             // Use calculated price and currency from config.
                            totalPrice: totalPrice,
                            currencyCode: AppConfig.GOOGLE_PAY.TRANSACTION_INFO.currencyCode,
                            countryCode: AppConfig.GOOGLE_PAY.TRANSACTION_INFO.countryCode,
                             // Add description (optional but good practice)
                            displayItems: [ // Breakdown of total (optional)
                                 {
                                     type: 'SUBTOTAL',
                                     price: basePrice.toFixed(2),
                                     label: 'Price Per Night',
                                 },
                                  {
                                     type: 'LINE_ITEM',
                                     price: totalPrice,
                                     label: `${numNights} Night${numNights > 1 ? 's' : ''}`,
                                     status: 'FINAL'
                                  }
                                 // Could add taxes, fees if known
                            ]
                         };
                         Logger.debug("Created simulated transaction info:", transactionInfo);
                         return transactionInfo;

                     } catch (error) {
                          this.#errorReporter.reportError(
                              'GooglePayServiceWrapper._createSimulatedTransactionDetails',
                              error,
                              { searchParams: searchParams },
                              'Error creating simulated transaction details.', 'gpay_transaction_details_exception'
                          );
                          return null; // Return null if formatting fails
                     }
                 }


                 /**
                  * Protected method to construct a simulated PaymentDataRequest object.
                  * Structure based on Google Pay API documentation (https://developers.google.com/pay/api/web/reference/request-objects#PaymentDataRequest).
                  * Uses config and dynamic transaction info.
                  * @param {object} transactionInfo - Dynamic details about the transaction (price, currency, etc.).
                  * @returns {object|null} - The simulated PaymentDataRequest object or null if configuration or inputs are invalid.
                  */
                 _createPaymentDataRequest(transactionInfo) {
                     try {
                          Logger.debug("Creating simulated PaymentDataRequest...", { transactionInfo: transactionInfo });

                        // Basic check for valid transaction info
                        if (!transactionInfo || typeof transactionInfo !== 'object' || !transactionInfo.totalPrice || !transactionInfo.currencyCode) {
                            Logger.error("Invalid transaction info provided for creating PaymentDataRequest.");
                             // This should be caught by _createSimulatedTransactionDetails or its caller.
                             // Fail early if it somehow reached here with bad info.
                             throw new Error("Invalid transaction details.");
                        }

                        // Get the required components from config (assuming the first CARD type method)
                        const cardPaymentMethodConfig = this._config.ALLOWED_PAYMENT_METHODS.find(method => method.type === 'CARD');
                        if (!cardPaymentMethodConfig || !cardPaymentMethodConfig.tokenizationSpecification || !cardPaymentMethodConfig.parameters) {
                             const errorMsg = "Card payment method, tokenization spec, or parameters missing in AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS.";
                             Logger.error(errorMsg, { config: this._config });
                             throw new Error(errorMsg);
                        }
                        const tokenizationSpecification = cardPaymentMethodConfig.tokenizationSpecification;
                        const cardParameters = cardPaymentMethodConfig.parameters;


                         // Construct the PaymentDataRequest object structure based on Google Pay API Spec
                         const paymentDataRequest = {
                             apiVersion: this._config.API_VERSION,
                             apiVersionMinor: this._config.API_VERSION_MINOR,
                             // allowedPaymentMethods is an array, supporting multiple types (CARD, TOKENIZED_CARD, etc.)
                             // We'll add only the CARD method using the config parameters.
                             allowedPaymentMethods: [{
                                 type: 'CARD', // Requesting card payments
                                 parameters: {
                                     allowedAuthMethods: cardParameters.allowedAuthMethods,
                                     allowedCardNetworks: cardParameters.allowedCardNetworks,
                                     // Request billing address if configured
                                     billingAddressRequired: this._config.BILLING_ADDRESS_REQUIRED,
                                     billingAddressParameters: {
                                         format: 'FULL' // Request full billing address
                                     }
                                 },
                                 // Tokenization specification for sending payment data to your gateway via Google Pay
                                 tokenizationSpecification: tokenizationSpecification
                             }],
                             // Information about the transaction itself (total price, currency, country, display items)
                             transactionInfo: transactionInfo, // Use the dynamically created transaction info

                             // Information about your business / merchant
                             merchantInfo: this._config.MERCHANT_INFO, // Includes merchantId (for prod) and merchantName

                             // Optional fields to request from the user
                             emailRequired: this._config.EMAIL_REQUIRED, // Request user's email
                             shippingAddressRequired: this._config.SHIPPING_ADDRESS_REQUIRED, // Not typically for hotels
                             // shippingAddressParameters: this._config.SHIPPING_ADDRESS_REQUIRED ? { supportedCountries: this._config.SHIPPING_SUPPORTED_COUNTRIES } : undefined,

                             // Enable dynamic update support if needed (more advanced)
                             // callbackIntents: ["PRICE_STATUS", "PAYMENT_METHOD", "SHIPPING_ADDRESS"]

                         };

                        Logger.debug("Created simulated PaymentDataRequest:", paymentDataRequest);
                        return paymentDataRequest;

                     } catch (error) {
                          this.#errorReporter.reportError(
                              'GooglePayServiceWrapper._createPaymentDataRequest',
                              error,
                              { transactionInfo: transactionInfo, config: this._config },
                              'Error creating simulated PaymentDataRequest object.', 'gpay_request_build_exception'
                          );
                         return null; // Return null on error
                     }
                }


                 /**
                  * Dispose method for cleanup on application shutdown.
                  * In a real app, might involve cleaning up the PaymentsClient instance.
                  */
                 dispose() {
                     try {
                         Logger.debug("Disposing GooglePayServiceWrapper.");
                         // In a real app, you might need to clean up the paymentsClient instance if it had a method for that.
                         this.#paymentsClient = null; // Clear reference
                         this.#googlePayButtonElement = null; // Clear button reference
                         this._config = null; // Clear config reference
                         // ErrorReporter reference is not disposed here as it's shared.
                         Logger.debug("GooglePayServiceWrapper disposed.");
                     } catch (error) {
                          this.#errorReporter.reportError(
                              'GooglePayServiceWrapper.dispose',
                              error, {},
                              'Error disposing Google Pay Service wrapper.',
                              'gpay_dispose_exception'
                          );
                     }
                 }
            }

            // --- SIMULATED Google Apps Script Service ---
            // This class simulates sending data to a Google Apps Script endpoint.
            // In a real application, this would involve a backend proxy securely calling the Apps Script deployment URL.
            class SimulatedGoogleAppsScriptService {
                #endpointUrl;
                 #errorReporter;

                /**
                 * @param {string} endpointUrl - The URL of the deployed Google Apps Script Web App (placeholder).
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(endpointUrl, errorReporter) {
                    try {
                        Logger.debug(`SimulatedGoogleAppsScriptService constructor called with endpoint: "${endpointUrl}"`);
                        if (!endpointUrl || endpointUrl === AppConfig.GOOGLE_APPS_SCRIPT_ENDPOINT) {
                            Logger.warn("Google Apps Script endpoint is missing or placeholder. Simulated service will not appear configured.");
                             this.#endpointUrl = null; // Treat as unconfigured
                        } else {
                            // Basic URL format check
                            if (!/^https?:\/\//i.test(endpointUrl)) {
                                const errorMsg = `Invalid format for Apps Script endpoint URL: "${endpointUrl}".`;
                                Logger.error(errorMsg);
                                throw new Error(errorMsg);
                            }
                            this.#endpointUrl = endpointUrl;
                            Logger.debug(`Simulated Apps Script service configured with endpoint: "${this.#endpointUrl}"`);
                        }

                         if (!errorReporter) {
                            Logger.error("ErrorReporter instance not provided to SimulatedGoogleAppsScriptService.");
                            this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[GS Error] ${src}: ${msg}`, err, ctx) };
                         } else {
                            this.#errorReporter = errorReporter;
                         }
                        Logger.debug(`SimulatedGoogleAppsScriptService initialized.`);

                    } catch (error) {
                         this.#errorReporter.reportError(
                             'SimulatedGoogleAppsScriptService.constructor',
                             error,
                             { endpoint: endpointUrl },
                             'Failed to initialize Simulated Google Apps Script service.',
                             'gs_init_exception',
                             0 // Persistent error
                         );
                         this.#endpointUrl = null; // Ensure service is unusable
                         throw error; // Re-throw initialization error
                    }
                }

                 /**
                  * Public method to check if the service is configured (has an endpoint).
                  * @returns {boolean}
                  */
                 isConfigured() {
                     try {
                        return this.#endpointUrl !== null;
                    } catch (error) {
                         this.#errorReporter.reportError(
                            'SimulatedGoogleAppsScriptService.isConfigured',
                            error, {},
                            'Error checking Apps Script service configuration status.', 'gs_check_config_exception'
                         );
                         return false;
                    }
                 }


                /**
                 * Public method to simulate sending data to a Google Apps Script endpoint.
                 * In a real app, this would use `fetch` or `XMLHttpRequest` to post data to the endpoint URL.
                 * @param {object} data - The data payload to send (must be serializable to JSON).
                 * @returns {Promise<object>} A Promise resolving with a simulated response from the Apps Script.
                 */
                async runScriptFunction(data) {
                    try {
                        Logger.debug("Attempting to simulate sending data to Apps Script...", data);

                        if (!this.isConfigured()) { // Check configuration first
                            const errorMsg = AppConfig.MESSAGES.APPS_SCRIPT_ENDPOINT_MISSING;
                             Logger.warn(errorMsg);
                             throw new Error(errorMsg);
                        }

                         if (!data || typeof data !== 'object') {
                            const errorMsg = "Invalid data payload provided for Apps Script simulation.";
                            Logger.warn(errorMsg, { data: data });
                             throw new Error(errorMsg);
                         }

                        // --- Real Apps Script Note ---
                        // A real call would likely use `fetch`:
                        // fetch(this.#endpointUrl, { method: 'POST', body: JSON.stringify(data), headers: { 'Content-Type': 'application/json' } })
                        // .then(response => response.json())
                        // .then(result => resolve(result))
                        // .catch(error => reject(error));
                        // Apps Script endpoints have security configurations (anyone, specific user, etc.). Authentication might be needed.
                        // Sending sensitive data directly from client-side to Apps Script is risky.
                        // A backend proxy is often safer for authentication and data handling.
                        // -----------------------------


                        Logger.debug(`Simulating async call to Apps Script endpoint "${this.#endpointUrl}"...`);

                        // Simulate async process with a delay.
                        return new Promise((resolve, reject) => {
                            setTimeout(() => {
                                try {
                                     // Simulate a random success/failure.
                                     const success = Math.random() > 0.1; // 90% success

                                     if (success) {
                                         Logger.info("Simulated data sent to Apps Script successfully.");
                                         // Simulate a typical successful response format from Apps Script (e.g., { result: 'success', data: {...} })
                                         const simulatedResponse = {
                                            result: 'success',
                                            message: 'Data received and processed by simulated Apps Script.',
                                             receivedData: data, // Echo back received data for confirmation
                                             simulatedProcessingTime: AppConfig.SIMULATED_SERVICE_DELAY_MS
                                         };
                                         resolve(simulatedResponse); // Resolve with the simulated response
                                     } else {
                                         // Simulate API error
                                         Logger.warn("Simulated Apps Script call failed randomly.");
                                          const apiErrors = [
                                              'Simulated Apps Script execution error.',
                                              'Simulated invalid data format received by script.',
                                              'Simulated script permission error.'
                                          ];
                                           const randomErrorMsg = apiErrors[Math.floor(Math.random() * apiErrors.length)];
                                         reject(new Error(`Simulated Apps Script error: ${randomErrorMsg}`));
                                     }
                                } catch (timeoutError) {
                                     this.#errorReporter.reportError(
                                          'SimulatedGoogleAppsScriptService.runScriptFunction.timeout',
                                          timeoutError, { sentData: data },
                                          'Internal error during simulated Apps Script execution.',
                                          'gs_sim_timeout_exception'
                                     );
                                    reject(timeoutError); // Re-reject with internal error
                                }
                            }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use configured delay
                        });

                    } catch (error) {
                         // Catch errors before the async part (Promise setup, config check, data validation).
                         this.#errorReporter.reportError(
                            'SimulatedGoogleAppsScriptService.runScriptFunction',
                            error,
                            { data: data },
                            'Simulated Apps Script call setup failed.',
                            'gs_sim_setup_exception'
                         );
                         throw error; // Re-throw the original error
                    }
                }

                /**
                 * Dispose method for cleanup.
                 */
                 dispose() {
                     try {
                        Logger.debug("Disposing SimulatedGoogleAppsScriptService.");
                        this.#endpointUrl = null; // Clear reference
                         // ErrorReporter is not disposed here.
                        Logger.debug("SimulatedGoogleAppsScriptService disposed.");
                     } catch (error) {
                         this.#errorReporter.reportError(
                            'SimulatedGoogleAppsScriptService.dispose',
                            error, {},
                            'Error disposing Simulated Google Apps Script service.',
                            'gs_dispose_exception'
                         );
                     }
                 }
            }


             // --- SIMULATED Generative AI Service ---
             // This class simulates calling a backend endpoint to get an AI-generated tip.
             // In a real app, this endpoint would securely call a GenAI API (like Google's Vertex AI, OpenAI, etc.).
            class SimulatedGenAIService {
                 #endpointUrl;
                 #errorReporter;

                 /**
                  * @param {string} endpointUrl - The URL of the backend endpoint for AI tips (placeholder).
                  * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                  */
                constructor(endpointUrl, errorReporter) {
                    try {
                         Logger.debug(`SimulatedGenAIService constructor called with endpoint: "${endpointUrl}"`);
                         if (!endpointUrl || endpointUrl === AppConfig.GENAI_ENDPOINT) {
                             Logger.warn("GenAI endpoint is missing or placeholder. Simulated service will not appear configured.");
                              this.#endpointUrl = null; // Treat as unconfigured
                         } else {
                            // Basic URL format check (can be relative URL to the same origin backend)
                             if (!/^https?:\/\//i.test(endpointUrl) && !/^\//.test(endpointUrl)) {
                                const errorMsg = `Invalid format for GenAI endpoint URL: "${endpointUrl}". Must be http(s) or a relative path starting with /.`;
                                Logger.error(errorMsg);
                                throw new Error(errorMsg);
                            }
                             this.#endpointUrl = endpointUrl;
                            Logger.debug(`Simulated GenAI service configured with endpoint: "${this.#endpointUrl}"`);
                         }

                         if (!errorReporter) {
                            Logger.error("ErrorReporter instance not provided to SimulatedGenAIService.");
                            this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[GenAI Error] ${src}: ${msg}`, err, ctx) };
                         } else {
                            this.#errorReporter = errorReporter;
                         }

                         Logger.debug(`SimulatedGenAIService initialized.`);
                    } catch (error) {
                          this.#errorReporter.reportError(
                              'SimulatedGenAIService.constructor',
                              error, { endpoint: endpointUrl },
                              'Failed to initialize Simulated GenAI service.', 'genai_init_exception', 0
                          );
                         this.#endpointUrl = null; // Ensure service unusable
                         throw error; // Re-throw
                    }
                 }

                 /**
                  * Public method to check if the service is configured (has an endpoint).
                  * @returns {boolean}
                  */
                 isConfigured() {
                     try {
                        return this.#endpointUrl !== null;
                     } catch (error) {
                         this.#errorReporter.reportError(
                            'SimulatedGenAIService.isConfigured',
                            error, {},
                            'Error checking GenAI service configuration status.', 'genai_check_config_exception'
                         );
                         return false;
                     }
                 }

                 /**
                  * Public method to simulate getting a destination tip from a GenAI model via a backend.
                  * @param {string} destination - The destination name.
                  * @returns {Promise<string|null>} A Promise resolving with the AI-generated tip text, or null on failure/unconfigured.
                  */
                 async getDestinationTip(destination) {
                     try {
                          Logger.debug(`Attempting to simulate getting AI tip for destination: "${destination}"`);

                         if (!this.isConfigured()) {
                             const warningMsg = "Simulated GenAI service is not configured (endpoint missing or placeholder). Cannot get tip.";
                             Logger.warn(warningMsg);
                             // Don't throw a hard error here, just indicate it's not working via message or null return.
                             return null; // Return null if not configured
                         }

                         if (!destination || typeof destination !== 'string' || destination.trim() === '') {
                              const errorMsg = "Invalid destination provided for GenAI tip.";
                             Logger.warn(errorMsg, { destination: destination });
                             // Reject the promise as it's invalid input for the service.
                             throw new Error(errorMsg);
                         }

                        // --- Real GenAI Integration Note ---
                        // A real call would likely use `fetch` to post to your backend endpoint:
                        // fetch(this.#endpointUrl, { method: 'POST', body: JSON.stringify({ prompt: `Give a travel tip for visiting ${destination}` }), headers: { 'Content-Type': 'application/json' } })
                        // .then(response => response.json())
                        // .then(result => resolve(result.tip || result.text || null)) // Depends on backend response structure
                        // .catch(error => reject(error));
                        // The backend is where you securely call the GenAI model API using your API keys.
                        // -----------------------------------


                         Logger.debug(`Simulating async call to GenAI endpoint "${this.#endpointUrl}" for destination "${destination}"...`);

                        // Simulate async process with a delay.
                         return new Promise((resolve, reject) => {
                             setTimeout(() => {
                                 try {
                                      // Simulate a random success/failure.
                                      const success = Math.random() > 0.15; // 85% success

                                      if (success) {
                                          Logger.info(`Simulated AI tip fetched for "${destination}".`);
                                           // Simulate different tip styles or indicate placeholder data
                                          const tips = [
                                             `Tip for ${destination}: Look for local food markets!`,
                                             `Consider visiting ${destination}'s lesser-known neighborhoods for a unique experience.`,
                                              `Check for local events or festivals happening during your stay in ${destination}.`,
                                              `Simulated tip: Research public transport options in ${destination} before you arrive.`
                                          ];
                                           const simulatedTip = tips[Math.floor(Math.random() * tips.length)];
                                          resolve(simulatedTip); // Resolve with a simulated tip string
                                      } else {
                                          // Simulate API error or no tip found.
                                          Logger.warn(`Simulated AI tip fetching failed for "${destination}".`);
                                          const apiErrors = [
                                              'Simulated GenAI API connection failed.',
                                              'Simulated prompt safety policy violation.', // Example from real AI models
                                              'Simulated GenAI internal server error.'
                                          ];
                                           const randomErrorMsg = apiErrors[Math.floor(Math.random() * apiErrors.length)];
                                          reject(new Error(`Simulated GenAI error: ${randomErrorMsg}`)); // Reject with error
                                      }
                                 } catch (timeoutError) {
                                      this.#errorReporter.reportError(
                                          'SimulatedGenAIService.getDestinationTip.timeout',
                                          timeoutError, { destination: destination },
                                          'Internal error during simulated GenAI tip fetching.', 'genai_sim_timeout_exception'
                                     );
                                    reject(timeoutError);
                                 }
                             }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use configured delay
                         });

                     } catch (error) {
                         // Catch errors before the async part (Promise setup, config check, input validation).
                         this.#errorReporter.reportError(
                            'SimulatedGenAIService.getDestinationTip',
                            error, { destination: destination },
                            'Simulated GenAI tip fetching setup failed.', 'genai_sim_setup_exception'
                         );
                          // Decide if setup errors should return null or propagate as error.
                          // For a non-critical feature like a tip, returning null might be okay after reporting.
                         return null;
                     }
                 }

                /**
                 * Dispose method for cleanup.
                 */
                dispose() {
                    try {
                       Logger.debug("Disposing SimulatedGenAIService.");
                       this.#endpointUrl = null; // Clear reference
                        // ErrorReporter is not disposed here.
                       Logger.debug("SimulatedGenAIService disposed.");
                    } catch (error) {
                         this.#errorReporter.reportError(
                            'SimulatedGenAIService.dispose',
                            error, {},
                            'Error disposing Simulated GenAI service.', 'genai_dispose_exception'
                         );
                    }
                }
            }


            // --- Base Class for any UI Component ---
            // Provides common functionality like getting the element, storing its ID and name,
            // basic validity state, event listener management, and disposal.
            class TravelComponent {
                // # prefix denotes a true private member (ES2022+) - cannot be accessed outside the class.
                #componentId;
                #componentName; // A descriptive name for logging/debugging

                // _ prefix denotes a protected member (convention, not enforced by JS) - intended for internal or subclass use.
                _element; // The DOM element wrapped by this component instance.
                _isValid = true; // Internal flag to track validation state (initialized to true).
                _eventHandlers = {}; // Map to store event listener references for cleanup (element ID -> event type -> list of handlers).
                 _errorReporter; // Injected ErrorReporter instance


                // Static property - belongs to the class itself, not an instance.
                static APP_VERSION = AppConfig.APP_VERSION;

                // Static method - belongs to the class itself.
                static logAppVersion() {
                    Logger.info(`App Version: ${TravelComponent.APP_VERSION}`);
                }

                /**
                 * Constructor for the base component. Finds and stores the wrapped HTML element.
                 * Initializes basic state and injects ErrorReporter.
                 * @param {string} elementId - The ID of the HTML element the component wraps.
                 * @param {string} componentName - A descriptive name for this component instance (e.g., 'SearchForm', 'DestinationInput').
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter for centralized error handling.
                 */
                constructor(elementId, componentName = 'TravelComponent', errorReporter) {
                     try {
                        Logger.debug(`TravelComponent constructor called for ID "${elementId}" as "${componentName}"`);

                        if (!errorReporter) {
                           Logger.error("ErrorReporter instance not provided to TravelComponent.");
                           // Provide a dummy reporter if missing to prevent errors in internal error handling calls.
                           this._errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[Component ERROR] ${src}: ${msg}`, err, ctx) };
                        } else {
                           this._errorReporter = errorReporter;
                        }


                        // Private members initialized in the constructor.
                        if (typeof elementId !== 'string' || elementId.trim() === '') {
                           // Treat empty/invalid ID as an error during construction.
                            const errorMsg = `Invalid or empty element ID provided for component "${componentName}".`;
                            Logger.error(errorMsg, { id: elementId });
                            // Throw an error if ID is invalid - indicates a programming mistake.
                           throw new Error(errorMsg);
                        }
                        this.#componentId = elementId;
                        this.#componentName = componentName;

                        // Protected member initialization: Find the DOM element.
                        this._element = document.getElementById(this.#componentId);

                        if (!this._element) {
                             // If the element is not found, this is a critical error for the component instance.
                             const errorMsg = `Element with ID "${this.#componentId}" not found for component "${this.#componentName}". Component functionality will be limited/disabled.`;
                            Logger.error(errorMsg); // Log the error
                             // Mark component as invalid if element is missing
                             this._isValid = false;
                            // Do not throw here, allow component to exist but in a non-functional state.
                             // The caller (e.g., SearchForm's collector) should check `getElement()` and handle null.
                        } else {
                             Logger.debug(`Component "${this.#componentName}" wrapped element ID: "${this.#componentId}".`);
                            // Call a protected initialization method after element is found.
                             this._initialize();
                        }
                         Logger.debug(`TravelComponent constructor finished for "${this.#componentName}".`);

                     } catch (error) {
                         // Catch errors that occur *during* the constructor logic itself (e.g., invalid ID, ErrorReporter missing).
                         // Report this error using the (potentially dummy) error reporter.
                         this._errorReporter.reportError(
                             'TravelComponent.constructor',
                             error,
                             { elementId: elementId, componentName: componentName },
                             `Failed to construct component "${componentName}".`,
                             'comp_init_exception',
                             0 // Persistent error message if initialization fails critically
                         );
                         // Ensure element is null and isValid is false if constructor failed
                         this._element = null;
                         this._isValid = false;
                         throw error; // Re-throw the initialization error
                     }
                }

                // Private method - only accessible within this class instance.
                // Provides a consistent string for logging and debugging.
                #getComponentInfo() {
                     try {
                         // Defensive access to private members.
                         const id = this.#componentId ?? 'ID_MISSING';
                         const name = this.#componentName ?? 'Name_MISSING';
                        return `Name: ${name}, ID: ${id}`;
                     } catch (error) {
                         Logger.error("Error accessing private members in #getComponentInfo:", error);
                         return "Component Info Error";
                     }
                }

                /**
                 * Protected method (convention) - Intended for internal setup after the element is found.
                 * Can be overridden by subclasses to add their specific initialization logic (polymorphism).
                 */
                _initialize() {
                    try {
                        Logger.debug(`_initialize called for ${this.#getComponentInfo()}. (Base class)`);
                        // Common initialization logic can go here in subclasses, like attaching element-specific listeners.
                    } catch (error) {
                         // Report errors occurring within the _initialize method.
                         this._errorReporter.reportError(
                             'TravelComponent._initialize',
                             error,
                             { component: this.#getComponentInfo() },
                             `Error during initialization for component "${this.name}".`,
                             'comp_initialize_exception'
                         );
                         // Do not re-throw, allow component construction to complete, but component state might be off.
                    }
                }

                /**
                 * Protected method (convention) - Placeholder for validation logic specific to the component.
                 * This method must be overridden by subclasses to provide their concrete validation rules (polymorphism).
                 * Should update the internal `_isValid` state.
                 * @returns {boolean} - True if validation passes for this component, false otherwise.
                 */
                _validate() {
                    try {
                        Logger.debug(`_validate called for ${this.#getComponentInfo()} (Base class). No specific validation implemented here.`);
                         // Base class validation does nothing, assumes valid by default.
                        this._isValid = true;
                        return this._isValid;
                    } catch (error) {
                         // Report errors occurring within the _validate method implementation.
                        this._errorReporter.reportError(
                            'TravelComponent._validate',
                            error,
                            { component: this.#getComponentInfo() },
                            `Error during validation for component "${this.name}".`,
                            'comp_validate_exception'
                        );
                         // If validation itself throws an error, the component is considered invalid.
                         this._isValid = false;
                         return false;
                    }
                }

                /**
                 * Protected method to add an event listener and store its reference for cleanup.
                 * Can attach to the component's `_element` or a specific `targetElement` provided in options.
                 * Binds `this` to the component instance in the handler.
                 * @param {string} eventType - The type of event (e.g., 'click', 'change').
                 * @param {function} handler - The event handler function. `this` will be bound to the component instance.
                 * @param {object} [options={}] - Event listener options (e.g., `{ capture: true, once: true, passive: true }`).
                 * @param {HTMLElement} [options.element] - Specific element to attach the listener to (defaults to component's `_element`).
                 */
                _addEventListener(eventType, handler, options = {}) {
                    try {
                        const targetElement = options.element || this._element; // Use provided element or component's element
                        if (!targetElement) {
                            Logger.warn(`Cannot add "${eventType}" listener: Target element not found for ${this.#getComponentInfo()}.`);
                            return;
                        }

                        // Ensure handler is a function before attempting to attach
                        if (typeof handler !== 'function') {
                             const errorMsg = `Cannot add "${eventType}" listener: Handler is not a function.`;
                             this._errorReporter.reportError(
                                'TravelComponent._addEventListener', new Error(errorMsg),
                                { component: this.#getComponentInfo(), eventType: eventType, handlerType: typeof handler, targetId: targetElement.id },
                                errorMsg, 'comp_add_listener_invalid_handler'
                             );
                             return;
                        }

                        // Bind 'this' context of the handler to the component instance
                        const boundHandler = handler.bind(this);
                        targetElement.addEventListener(eventType, boundHandler, options);

                        // Store the handler reference for cleanup in a nested map: { elementId -> eventType -> [handlers] }
                        // Use element ID or a generic identifier if ID is missing.
                        const elementIdentifier = targetElement.id || `element-${targetElement.tagName}`;
                        if (!this._eventHandlers[elementIdentifier]) {
                             this._eventHandlers[elementIdentifier] = {};
                        }
                        if (!this._eventHandlers[elementIdentifier][eventType]) {
                             this._eventHandlers[elementIdentifier][eventType] = [];
                        }
                        // Store the original handler too (optional, for advanced debugging/introspection)
                        this._eventHandlers[elementIdentifier][eventType].push({ handler: boundHandler, originalHandler: handler, options: options, targetElement: targetElement });

                         // Logger.debug(`Added "${eventType}" listener for ${this.#getComponentInfo()} on element ID "${elementIdentifier}".`); // Too noisy

                    } catch (error) {
                         // Report errors occurring during the process of adding the event listener.
                        this._errorReporter.reportError(
                            'TravelComponent._addEventListener',
                            error,
                            { component: this.#getComponentInfo(), eventType: eventType, targetElementId: options.element?.id || this._element?.id, handler: handler?.name || typeof handler },
                            `Error adding event listener for component "${this.name}".`,
                            'comp_add_listener_exception'
                        );
                    }
                }

                 /**
                  * Protected method to remove all stored event listeners managed by this component instance.
                  * Iterates through the `_eventHandlers` map and calls `removeEventListener`.
                  * Useful during component disposal to prevent memory leaks.
                  */
                 _removeEventListeners() {
                     try {
                         Logger.debug(`Removing all event listeners for ${this.#getComponentInfo()}...`);
                         // Iterate through the nested map of stored handlers.
                         for (const elementIdentifier in this._eventHandlers) {
                             // Use Object.prototype.hasOwnProperty.call for safety.
                             if (Object.prototype.hasOwnProperty.call(this._eventHandlers, elementIdentifier)) {
                                 const elementEventTypes = this._eventHandlers[elementIdentifier];
                                 for (const eventType in elementEventTypes) {
                                     if (Object.prototype.hasOwnProperty.call(elementEventTypes, eventType)) {
                                         elementEventTypes[eventType].forEach(({ handler, options, targetElement }) => {
                                             try {
                                                  // Ensure the target element still exists in the DOM before attempting to remove.
                                                 if (targetElement && typeof targetElement.removeEventListener === 'function') {
                                                     targetElement.removeEventListener(eventType, handler, options);
                                                     // Logger.debug(`Removed "${eventType}" listener for ${this.#getComponentInfo()} from element ID "${elementIdentifier}".`); // Too noisy
                                                 } else {
                                                      // This might happen if the element was removed from the DOM before disposal.
                                                     Logger.warn(`Cannot remove listener for ${this.#getComponentInfo()} (type "${eventType}", element ID "${elementIdentifier}"): Target element no longer exists or cannot remove listener.`);
                                                 }
                                             } catch (removeError) {
                                                  // Report errors encountered while removing a specific listener.
                                                  this._errorReporter.reportError(
                                                      'TravelComponent._removeEventListeners', removeError,
                                                      { component: this.#getComponentInfo(), eventType: eventType, targetId: elementIdentifier },
                                                      `Error removing specific listener for component "${this.name}".`,
                                                      'comp_remove_single_listener_exception'
                                                  );
                                             }
                                         });
                                     }
                                 }
                             }
                         }
                         this._eventHandlers = {}; // Clear the map of stored handlers after removal attempts.
                         Logger.debug(`All event listeners removal process finished for ${this.#getComponentInfo()}.`);
                     } catch (error) {
                          // Report errors during the overall listener removal process.
                         this._errorReporter.reportError(
                             'TravelComponent._removeEventListeners',
                             error,
                             { component: this.#getComponentInfo() },
                             `Error during event listeners removal process for component "${this.name}".`,
                             'comp_remove_listeners_exception'
                         );
                     }
                 }


                /**
                 * Public method to get the wrapped HTML element.
                 * @returns {HTMLElement|null} - The element instance or null if it was not found during construction or disposed.
                 */
                getElement() {
                    try {
                        return this._element;
                    } catch (error) {
                        this._errorReporter.reportError(
                           'TravelComponent.getElement',
                           error,
                           { component: this.#getComponentInfo() },
                           `Error getting element for component "${this.name}".`,
                           'comp_get_element_exception'
                        );
                        return null; // Return null on error
                    }
                }

                /**
                 * Public getter for the component ID.
                 * @returns {string|null} - The ID string or null if an error occurred accessing it.
                 */
                get id() {
                    try {
                         // Direct access to private member `#componentId`.
                        return this.#componentId;
                    } catch (error) {
                         this._errorReporter.reportError(
                            'TravelComponent.id',
                            error,
                            { component: this.#getComponentInfo() },
                            'Error getting component ID.', 'comp_get_id_exception'
                         );
                        return null; // Return null on error
                    }
                }

                /**
                 * Public getter for the component name.
                 * @returns {string} - The name string or 'UnknownComponent' if an error occurred accessing it.
                 */
                get name() {
                     try {
                         // Direct access to private member `#componentName`.
                         // Provide a fallback string in case of error.
                         return this.#componentName ?? 'UnknownComponent';
                     } catch (error) {
                          this._errorReporter.reportError(
                              'TravelComponent.name',
                              error,
                              { component: this.#getComponentInfo() },
                              'Error getting component name.', 'comp_get_name_exception'
                          );
                         return 'UnknownComponent'; // Return fallback name on error
                     }
                }

                /**
                 * Public getter for the component's internal validation status (`_isValid`).
                 * @returns {boolean} - True if the component is currently considered valid, false otherwise or if the wrapped element is missing.
                 */
                get isValid() {
                    try {
                        // If the wrapped HTML element was never found during initialization, the component cannot be valid.
                        if (!this._element) return false;
                        // Otherwise, return the internal validation state determined by `_validate()` or `validate()`.
                        return this._isValid;
                    } catch (error) {
                         this._errorReporter.reportError(
                            'TravelComponent.isValid',
                            error,
                            { component: this.#getComponentInfo() },
                            `Error getting isValid status for component "${this.name}".`,
                            'comp_get_isvalid_exception'
                         );
                         return false; // Assume invalid if an error occurs
                    }
                }

                /**
                 * Public method to trigger the component's validation logic.
                 * Calls the protected `_validate` method and updates the public `isValid` state.
                 * It is often called in response to user input events (`blur`, `change`) or form submission.
                 * @returns {boolean} - True if validation passes after running `_validate()`, false otherwise.
                 */
                validate() {
                    try {
                        // Validation cannot be performed if the wrapped element is missing.
                        if (!this._element) {
                            this._isValid = false; // Ensure state is false
                            Logger.warn(`Validation called on ${this.name} but element is null.`);
                            return false;
                        }
                        Logger.debug(`Public validate() called for ${this.name}.`);

                        // Call the protected (or overridden) validation method for component-specific rules.
                        // Update the protected `_isValid` property based on the result of `_validate()`.
                        // Errors inside `_validate()` are caught and handled within that method, also setting `_isValid` to false.
                        this._isValid = this._validate();

                         // After validation, subclasses may need to explicitly call `_setErrorMessage` or `_clearErrorMessage`,
                         // which manage the element's `setCustomValidity` for native validation features.
                         // The SearchForm will later aggregate these `setCustomValidity` states via `form.checkValidity()`.
                         // Optional: Call `reportValidity()` here to show native tooltips immediately on explicit `validate()`,
                         // but often it's better to only trigger native tooltips on specific user actions like form submit attempt or element blur.
                         // if (this._element && !this._isValid) {
                         //      this._element.reportValidity();
                         // }


                        Logger.debug(`${this.name} public validate() finished. Result: ${this._isValid}.`);
                        return this._isValid; // Return the final validation result.

                    } catch (error) {
                         // Catch unexpected errors during the public `validate` execution (e.g., if `_validate` threw uncaught).
                         this._errorReporter.reportError(
                             'TravelComponent.validate',
                             error,
                             { component: this.#getComponentInfo() },
                             `Error executing public validate() for component "${this.name}".`,
                             'comp_public_validate_exception'
                         );
                         // If public validate itself fails, mark the component as invalid.
                         this._isValid = false;
                         // Attempt to set a generic error message if the component type supports it.
                         if (typeof this._setErrorMessage === 'function') {
                              this._setErrorMessage(`Validation error: ${error.message}`);
                         }
                         return false; // Always return false if validation failed due to error.
                    }
                }

                 /**
                  * Public method to dispose of the component instance.
                  * Cleans up event listeners and clears references to prevent memory leaks.
                  * Subclasses should override this method to add their specific cleanup logic,
                  * ensuring they call `super.dispose()` first.
                  */
                 dispose() {
                     try {
                         Logger.debug(`Disposing component: ${this.name}`);
                         // Remove all event listeners attached via `_addEventListener` by this component instance.
                         this._removeEventListeners();

                         // Clear the reference to the wrapped DOM element.
                         this._element = null;

                         // No need to explicitly clear `#componentId` or `#componentName` private members
                         // as the object itself is being disposed.
                         // Clearing the `_eventHandlers` map reference is handled in `_removeEventListeners`.
                         // The `_isValid` flag will naturally become irrelevant.
                         // No need to dispose `_errorReporter` as it's a shared instance.

                         Logger.debug(`Disposed component: ${this.name}.`);

                     } catch (error) {
                         // Report errors during the disposal process.
                          // Cannot use injected _errorReporter reliably during dispose cleanup if it was nullified.
                         Logger.error(`CRITICAL ERROR during disposal of component "${this.name}" (ID: ${this.id}):`, error);
                         // This error will be logged, but UI message/GA tracking might fail if reporter is gone.
                     }
                 }
            }

            // --- Class for Input Fields, inheriting from TravelComponent ---
            // Extends the base component with input-specific properties (_value, _errorMessageElement)
            // and methods for handling input events and validation specific to HTML input elements.
            class InputComponent extends TravelComponent {
                // Protected property for the internal representation of the input value.
                _value = '';
                // Protected property to hold the reference to the associated element for displaying error messages.
                _errorMessageElement = null;

                /**
                 * Constructor for InputComponent.
                 * Finds and stores the input element and its associated error message element.
                 * @param {string} elementId - The ID of the HTML input element.
                 * @param {string} componentName - A descriptive name (e.g., 'DestinationInput', 'DateInput').
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(elementId, componentName = 'InputComponent', errorReporter) {
                     try {
                        Logger.debug(`${componentName} constructor called for ID "${elementId}"`);
                        // Call the parent constructor, which finds the DOM element and sets up base state.
                        // Pass the ErrorReporter instance.
                        super(elementId, componentName, errorReporter);

                        // Check if the parent constructor successfully found the wrapped HTML element.
                        if (this._element) {
                            // Get the initial value from the DOM element.
                            this._value = this._element.value;
                            // Find the element dedicated to displaying error messages for this input.
                            // Assumes the error element ID follows the pattern: inputId + AppConfig.SELECTORS.ERROR_MESSAGE_SUFFIX.
                            this._errorMessageElement = document.getElementById(`${this.id}${AppConfig.SELECTORS.ERROR_MESSAGE_SUFFIX}`);
                            if (!this._errorMessageElement) {
                                Logger.debug(`No error message element found for input ${this.id} (looking for ID "${this.id}${AppConfig.SELECTORS.ERROR_MESSAGE_SUFFIX}"). Validation messages will not appear below input.`);
                            }

                            // Attach common input-related event listeners to the wrapped element.
                            this._attachInputEventListeners();

                            Logger.debug(`${this.name} initialized with initial value: "${this._value}".`);
                        } else {
                            // If the parent couldn't find the element, log a warning specific to the input type.
                            Logger.warn(`${this.name} element not found by parent constructor. Input component will not be fully functional.`);
                            // The parent constructor already set `_isValid` to false in this case.
                        }
                         Logger.debug(`${this.name} constructor finished.`);

                     } catch (error) {
                          // Report errors specifically occurring *within* the InputComponent constructor.
                          // Use the injected _errorReporter (which was potentially a dummy from parent).
                         this._errorReporter.reportError(
                             `${componentName}.constructor`,
                             error,
                             { elementId: elementId, componentName: componentName },
                             `Failed to construct Input component "${componentName}".`,
                             'input_init_exception'
                             // Keep as persistent error if element was expected but missing during collection/init.
                             // Duration 0 or handle in caller.
                         );
                          // Ensure state is consistent if constructor failed after super() call.
                          // The parent constructor might have set _element, but we should be defensive.
                         this._element = this._element || null; // Keep parent's result or set to null
                         this._isValid = false; // Mark as invalid if constructor failed.
                         throw error; // Re-throw the initialization error.
                     }
                }

                /**
                 * Protected method to attach standard event listeners for input elements:
                 * `input`, `change`, `blur`, and `focus`. Uses the protected `_addEventListener` helper.
                 */
                _attachInputEventListeners() {
                    try {
                        Logger.debug(`_attachInputEventListeners called for ${this.name}.`);
                        // Cannot attach listeners if the wrapped element is missing.
                        if (!this._element) {
                            Logger.warn(`Cannot attach listeners: element is missing for ${this.name}.`);
                            return;
                        }

                        // Attach handlers using the parent's `_addEventListener` method, which handles `this` binding and storage.
                        this._addEventListener('input', this._handleInput); // Fires immediately as user types
                        this._addEventListener('change', this._handleChange); // Fires when value changes and element loses focus
                        this._addEventListener('blur', this._handleBlur); // Fires when element loses focus
                        this._addEventListener('focus', this._handleFocus); // Fires when element gains focus

                        // Optionally, handle the `invalid` event for browsers that support HTML5 validation UI.
                        // Using `setCustomValidity('')` on focus or input can prevent the default browser popup messages
                        // if you prefer to show custom messages below the inputs instead.
                        // This can be complex to get right across browsers.
                        // this._addEventListener('invalid', this._handleInvalid, { passive: true });

                        Logger.debug(`Input event listeners attached for ${this.name}.`);

                    } catch (error) {
                         // Report errors during the process of attaching input event listeners.
                        this._errorReporter.reportError(
                            `${this.name}._attachInputEventListeners`,
                            error,
                            { component: this.#getComponentInfo() },
                            `Error attaching input event listeners for component "${this.name}".`,
                            'input_attach_listeners_exception'
                        );
                         // Do not re-throw, let constructor finish, but listeners might be missing.
                    }
                }

                // Protected event handlers (bound to the component instance via `_addEventListener`)

                /** Handler for the 'input' event. Updates internal `_value` and clears error messages. */
                _handleInput() {
                    try {
                         // Update the internal `_value` to match the current DOM element value.
                        this._value = this._element.value;
                        Logger.debug(`${this.name} input event, value updated to: "${this._value}".`);
                        // Clear error messages immediately as the user starts typing again.
                        this._clearErrorMessage();
                        // Optional: Add real-time validation feedback here, but often too noisy.
                        // Optional: If this is a destination input, clear autocomplete-specific flags/data here.
                    } catch (error) {
                         this._errorReporter.reportError(
                             `${this.name}._handleInput`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error handling input event for component "${this.name}".`,
                             'input_handle_input_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }

                /** Handler for the 'change' event. Ensures `_value` is up-to-date and triggers validation. */
                _handleChange() {
                    try {
                        // Ensure `_value` reflects the final value after the element loses focus and value changed.
                        this._value = this._element.value;
                        Logger.debug(`${this.name} change event, value updated to: "${this._value}". Triggering validation.`);
                        // Trigger the component's validation logic.
                        this.validate(); // Calls public validate() method.
                    } catch (error) {
                         this._errorReporter.reportError(
                             `${this.name}._handleChange`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value },
                             `Error handling change event for component "${this.name}".`,
                             'input_handle_change_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }

                /** Handler for the 'blur' event. Triggers validation, often with a small delay. */
                _handleBlur() {
                    try {
                        Logger.debug(`${this.name} blur event. Scheduling delayed validation.`);
                         // Add a small delay before validation on blur. This is crucial, especially with
                         // autocomplete inputs (like DestinationInput) where the `place_changed` event
                         // might fire *just after* the blur event if the user clicks a suggestion.
                         // The delay allows the `place_changed` handler to potentially complete and update
                         // the input value and related state *before* validation reads them.
                         setTimeout(() => {
                            try {
                                Logger.debug(`${this.name} executing delayed blur validation.`);
                                this.validate(); // Perform validation after the delay.
                            } catch (error) {
                                // Report errors specifically within the delayed validation callback.
                                 this._errorReporter.reportError(
                                     `${this.name}._handleBlur.delayedValidate`,
                                     error,
                                     { component: this.#getComponentInfo(), value: this._value },
                                     `Error during delayed blur validation for component "${this.name}".`,
                                     'input_delayed_blur_validate_exception'
                                 );
                                // Errors here might not be immediately visible depending on where caught.
                            }
                        }, AppConfig.VALIDATION_DELAY_MS); // Use a configurable delay.

                    } catch (error) {
                         this._errorReporter.reportError(
                             `${this.name}._handleBlur`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value },
                             `Error handling blur event or scheduling delayed validation for component "${this.name}".`,
                             'input_handle_blur_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }

                /** Handler for the 'focus' event. Clears error messages on focus. */
                _handleFocus() {
                    try {
                        Logger.debug(`${this.name} focus event.`);
                        // Clear error messages when the user focuses the input, as a common UX pattern.
                        this._clearErrorMessage();
                        // Optional: Highlight the input or provide help text.
                    } catch (error) {
                         this._errorReporter.reportError(
                            `${this.name}._handleFocus`,
                            error,
                            { component: this.#getComponentInfo() },
                            `Error handling focus event for component "${this.name}".`,
                            'input_handle_focus_exception'
                         );
                         // Do not re-throw.
                    }
                }

                /** Handler for the native 'invalid' event (if not preventing default). */
                _handleInvalid(event) {
                   try {
                       // This handler fires when the browser's built-in HTML5 validation
                       // determines the input is invalid (e.g., required field is empty on submit).
                       Logger.debug(`${this.name} invalid event fired.`);
                       // event.preventDefault(); // Often used to suppress native browser validation popups.
                       // if (!event.defaultPrevented) { // Check if prevention worked
                            // Browser's default validation message/UI might appear here.
                            // We might re-trigger our own validation to show our custom message below the input.
                           // this.validate(); // This would set `_customValidity` and show our UI message.
                       // }
                        // Report the occurrence of the native invalid event.
                       this._errorReporter.reportError(
                           `${this.name}._handleInvalid`,
                           new Error(`Native 'invalid' event fired.`), // Create a specific error object
                           { component: this.#getComponentInfo(), value: this._value, validity: this._getValidityState() },
                           `Input "${this.name}" failed native validation check.`, // User-friendly message
                           'input_native_invalid_event', // GA error code
                           2000 // Temporary message if desired
                       );

                   } catch (error) {
                        this._errorReporter.reportError(
                            `${this.name}._handleInvalid`,
                            error,
                            { component: this.#getComponentInfo() },
                            `Error handling native 'invalid' event for component "${this.name}".`,
                            'input_handle_invalid_exception'
                        );
                       // Do not re-throw.
                   }
                }


                /**
                 * Protected method (convention) for validation specific to InputComponent basics.
                 * Checks the HTML5 `required` attribute and updates native custom validity.
                 * This is the base validation logic, intended to be called by subclass overrides.
                 * @returns {boolean} - True if basic validation (like 'required') passes, false otherwise.
                 */
                _validate() {
                    try {
                        Logger.debug(`_validate called for ${this.name}. (InputComponent base validation: check 'required' attribute)`);
                        let isValid = true;
                        this._clearErrorMessage(); // Clear previous custom error message and native validity before re-validating.

                        // Manually check the HTML5 `required` attribute.
                        if (this._element && this._element.required) {
                             // Get the trimmed value for checking emptiness.
                            const valueToCheck = typeof this._value === 'string' ? this._value.trim() : '';
                             if (valueToCheck === '') {
                                 const message = AppConfig.MESSAGES.REQUIRED;
                                 // Set our custom error message below the input and also update native custom validity.
                                 this._setErrorMessage(message);
                                 isValid = false; // Component is invalid.
                                 Logger.debug(`${this.name} failed 'required' validation (empty).`);
                             } else {
                                 // If required and value is present, clear the error message related to required.
                                 // `_clearErrorMessage()` handles clearing the message element and native validity.
                                 // Need to be careful not to clear error messages set by subclass validation.
                                 // A more sophisticated approach would track validation sources.
                                  // For now, _clearErrorMessage clears *all* custom messages.
                                 // If other validation issues exist, subclass _validate() must set a new message.
                                 this._clearErrorMessage();
                                 isValid = true; // Required check passes.
                                 Logger.debug(`${this.name} passed 'required' validation (value present).`);
                             }
                         } else {
                             // If the input is not required, base validation passes as long as no other rule fails.
                             // No action needed here unless there's a base rule for non-required fields.
                            this._clearErrorMessage(); // Ensure message is clear if not required.
                             isValid = true;
                             Logger.debug(`${this.name} is not required, base validation passed.`);
                         }


                        // Update component's internal validation state based on this base validation.
                        this._isValid = isValid;
                        Logger.debug(`${this.name} base validation result: ${this._isValid}.`);
                        return this._isValid;

                    } catch (error) {
                         // Report errors occurring *within* this specific base validation logic.
                         this._errorReporter.reportError(
                            `${this.name}._validate`,
                            error,
                            { component: this.#getComponentInfo(), value: this._value },
                            `Error during base validation for component "${this.name}".`,
                            'input_base_validate_exception'
                        );
                         // If validation process itself fails, the component is considered invalid.
                         this._isValid = false;
                         this._setErrorMessage(`Validation error: ${error.message}`); // Set a generic message for the user.
                         return false; // Return false on error.
                    }
                }

                /**
                 * Protected method to set and display an error message in the designated element below the input.
                 * Also sets the native custom validity on the input element so `form.checkValidity()` works.
                 * @param {string} message - The error message text to display.
                 */
                _setErrorMessage(message) {
                    try {
                        // Set the text content of the dedicated error message element.
                        if (this._errorMessageElement) {
                            this._errorMessageElement.textContent = message;
                            // You could add a class here to visibly style the error message (e.g., making text bold).
                            // this._errorMessageElement.classList.add('active-error-message');
                            Logger.debug(`Setting error message element text for ${this.name}: "${message}".`);
                        } else {
                            // Fallback to logging if the error message element was not found.
                            Logger.debug(`No error message element found for ${this.id}. Logging message: "${message}".`);
                            this._errorReporter.reportError(
                                `${this.name}._setErrorMessage`,
                                new Error("Error message element missing."), // Specific error object for missing element
                                { component: this.#getComponentInfo(), message: message },
                                `Cannot display validation message for input "${this.name}".`,
                                'input_error_element_missing',
                                5000 // Temporary message in the main area, as the specific element is missing.
                            );
                        }

                         // Set the custom validity message on the input element itself.
                         // A non-empty string here makes `element.checkValidity()` return false.
                         // This is essential for `form.checkValidity()` to detect the invalid state.
                         if (this._element) {
                             this._element.setCustomValidity(message);
                              Logger.debug(`Set native custom validity for ${this.name}: "${message}".`);
                             // Optional: Call `reportValidity()` here if you want the native browser validation tooltip
                             // to appear immediately whenever `_setErrorMessage` is called. This can be annoying.
                             // It's often better to trigger `reportValidity()` on the form submit or element blur/focus in `SearchForm`.
                             // this._element.reportValidity();
                         } else {
                              Logger.warn(`Cannot set native custom validity for ${this.name}: Element is null.`);
                         }
                    } catch (error) {
                         // Report errors encountered during the process of setting the error message.
                         this._errorReporter.reportError(
                             `${this.name}._setErrorMessage`,
                             error,
                             { component: this.#getComponentInfo(), messageToSet: message },
                             `Error setting error message for component "${this.name}".`,
                             'input_set_error_message_exception'
                         );
                         // Do not re-throw.
                    }
                }

                /**
                 * Protected method to clear the error message from the designated element and the native custom validity.
                 * Call this when the input becomes valid or loses focus.
                 */
                _clearErrorMessage() {
                    try {
                        // Clear the text content of the error message element.
                        if (this._errorMessageElement) {
                            this._errorMessageElement.textContent = '';
                             // this._errorMessageElement.classList.remove('active-error-message'); // Remove styling class
                             // Logger.debug(`Cleared error message element text for ${this.name}.`); // Too noisy
                        }
                         // Clear the native custom validity message on the input element.
                         // An empty string means the element is valid according to `setCustomValidity`.
                         if (this._element) {
                             this._element.setCustomValidity('');
                             // Logger.debug(`Cleared native custom validity for ${this.name}.`); // Too noisy
                         }
                    } catch (error) {
                         // Report errors during the process of clearing the error message.
                         this._errorReporter.reportError(
                            `${this.name}._clearErrorMessage`,
                            error,
                            { component: this.#getComponentInfo() },
                            `Error clearing error message for component "${this.name}".`,
                            'input_clear_error_message_exception'
                         );
                         // Do not re-throw.
                    }
                }

                /**
                 * Protected helper to get HTML element's ValidityState object.
                 * Useful for checking standard HTML5 validation states (valid, valueMissing, badInput, rangeOverflow/Underflow, etc.).
                 * @returns {ValidityState|null} - The ValidityState object or null if the element or property is missing/inaccessible.
                 */
                 _getValidityState() {
                     try {
                          // Access the ValidityState property of the input element.
                         if (this._element && this._element.validity) {
                             return this._element.validity;
                         }
                         // If the element or validity property is missing, log a warning and return null.
                         Logger.warn(`Cannot get ValidityState for ${this.name}: element or validity property missing.`);
                         return null;
                     } catch (error) {
                          this._errorReporter.reportError(
                              `${this.name}._getValidityState`,
                              error,
                              { component: this.#getComponentInfo() },
                              `Error getting ValidityState for component "${this.name}".`,
                              'input_get_validity_state_exception'
                          );
                         return null; // Return null on error.
                     }
                 }

                /**
                 * Public method to get the current value of the input element.
                 * Retrieves the value from the internal `_value` property, ensuring it stays in sync with the DOM value
                 * via event handlers (`_handleInput`, `_handleChange`). Trims whitespace for text-based inputs.
                 * @returns {string} - The input value, trimmed for text-based types. Returns an empty string on error.
                 */
                getValue() {
                    try {
                         // Check if the wrapped element exists and is of a text-like type.
                         // Trimming is typically only applicable and desired for string-based inputs.
                        if (this._element && (this._element.type === 'text' || this._element.type === 'search' || this._element.type === 'url' || this._element.type === 'tel' || this._element.type === 'password' || this._element.tagName === 'TEXTAREA')) {
                             // Ensure the value is treated as a string before trimming.
                             return typeof this._value === 'string' ? this._value.trim() : String(this._value).trim(); // Ensure string conversion before trim
                         }
                        // For other input types (date, number, checkbox, radio, select), return the value directly.
                        // Note: Number input `_value` might be string even if element type is number.
                        // Subclasses like `NumberInput` should use specific getters (`getValueAsNumber`).
                        return this._value;

                    } catch (error) {
                         this._errorReporter.reportError(
                             `${this.name}.getValue`,
                             error,
                             { component: this.#getComponentInfo(), rawValue: this._value },
                             `Error getting value for component "${this.name}".`,
                             'input_get_value_exception'
                         );
                         return ''; // Return a default empty value on error.
                    }
                }

                /**
                 * Override dispose method. Calls the parent's dispose to remove element listeners,
                 * and clears the reference to the error message element.
                 */
                dispose() {
                     try {
                         Logger.debug(`Disposing InputComponent: ${this.name}`);
                         super.dispose(); // Call parent dispose to remove element-based listeners and clear _element.

                         // Clear the reference to the error message element.
                         this._errorMessageElement = null;
                         // The _value property will naturally become stale/irrelevant.
                         // _eventHandlers map is cleared by super.dispose().
                         // _isValid flag becomes irrelevant.
                         // _errorReporter reference is not cleared here as it's shared.

                         Logger.debug(`InputComponent disposed: ${this.name}.`);

                     } catch (error) {
                          // Report errors during disposal.
                          // Use console.error if _errorReporter might be nullified by super.dispose.
                         console.error(`CRITICAL ERROR during disposal of InputComponent "${this.name}" (ID: ${this.id}):`, error);
                     }
                }
            }

            // --- Class for Date Input, inheriting from InputComponent ---
            // Extends the InputComponent with date-specific validation logic and date parsing.
            class DateInput extends InputComponent {
                 #dateType; // Private member: 'check-in' or 'check-out'.

                /**
                 * Constructor for DateInput.
                 * @param {string} elementId - The ID of the HTML date input element.
                 * @param {string} dateType - The type of date ('check-in' or 'check-out'). Expected via `data-date-type` attribute.
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(elementId, dateType, errorReporter) {
                     try {
                        Logger.debug(`DateInput constructor called for ID "${elementId}" (Type: ${dateType})`);
                        // Call parent constructor.
                        super(elementId, 'DateInput', errorReporter); // Set component name and pass reporter.

                        // Store the date type (check-in or check-out).
                        this.#dateType = dateType || 'unknown';

                        // Check if the wrapped element exists and is indeed a date input type.
                        if (this._element && this._element.type === 'date') {
                             Logger.debug(`${this.name} initialized as type "${this.#dateType}". Element is type="${this._element.type}".`);
                             // Set min date dynamically using the HTML5 `min` attribute.
                             this._setMinDate();
                        } else if (this._element) {
                           Logger.warn(`${this.name} wrapped element is not a date input type "${this._element.type}". Date-specific features will not work.`);
                        } else {
                           // Element was not found by parent, warning logged by parent.
                        }

                         Logger.debug(`${this.name} constructor finished.`);

                     } catch (error) {
                          // Report errors during DateInput constructor logic.
                          this._errorReporter.reportError(
                              `DateInput.constructor`,
                              error,
                              { elementId: elementId, dateType: dateType },
                              `Failed to construct DateInput component "${elementId}".`,
                              'dateinput_init_exception'
                          );
                          // Propagate initialization error.
                         throw error;
                     }
                }

                /**
                 * Protected method to set the `min` attribute on the date input element dynamically.
                 * Typically sets the minimum date allowed to today's date to prevent selecting past dates.
                 * Leverages the HTML5 `min` attribute for built-in browser validation UI (although custom UI messages are preferred).
                 */
                _setMinDate() {
                    try {
                        // Ensure element exists and is a date input type before setting the attribute.
                        if (this._element && this._element.type === 'date') {
                            const today = new Date();
                            // Format the date as YYYY-MM-DD string required by the HTML input 'min' attribute.
                            const year = today.getFullYear();
                            // Month is 0-indexed (0-11) in JS Date, but 1-indexed (1-12) for YYYY-MM-DD format.
                            const month = (today.getMonth() + 1).toString().padStart(2, '0');
                            const day = today.getDate().toString().padStart(2, '0');
                            const todayString = `${year}-${month}-${day}`;

                            // Set the min attribute on the DOM element.
                            this._element.min = todayString;
                            Logger.debug(`${this.name}: Set min date attribute to "${todayString}".`);
                        } else {
                             Logger.debug(`${this.name}: Skipping _setMinDate - element not found or not type 'date'.`);
                        }
                    } catch (error) {
                         // Report errors during the _setMinDate process.
                         this._errorReporter.reportError(
                             `${this.name}._setMinDate`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error setting min date for component "${this.name}".`,
                             'dateinput_set_min_date_exception'
                         );
                         // Do not re-throw.
                    }
                }

                /**
                 * Polymorphism: Overriding the validation method from `InputComponent`.
                 * Adds date-specific validation rules, primarily leveraging the native HTML5 `ValidityState` object
                 * which reflects issues like `required`, `badInput`, `rangeUnderflow` based on attributes (`min`).
                 * It also clears/sets specific error messages below the input.
                 * Cross-field date validation (check-out after check-in) is typically handled in the `SearchForm`.
                 * @returns {boolean} - True if validation passes, false otherwise.
                 */
                _validate() {
                    try {
                        Logger.debug(`_validate called for ${this.name}. (DateInput specific validation)`);
                        // Call parent validation first. This handles the `required` check.
                        let isValid = super._validate();

                        // If base validation (e.g., required and empty) already failed, no need for date-specific checks yet.
                        if (!isValid) {
                             Logger.debug(`${this.name} failed base validation ('required'). Skipping date-specific checks.`);
                             return false;
                        }

                        // Get the native HTML5 ValidityState object from the input element.
                        const validity = this._getValidityState();
                        // If ValidityState is not available (e.g., element not found or browser doesn't support),
                        // rely only on the base validation (`required` check).
                        if (!validity) {
                            Logger.warn(`${this.name}: Cannot get ValidityState. Skipping detailed date validation.`);
                            return isValid; // Return result from `super._validate()` (which should be true here).
                        }

                        // Check the input element's overall validity using the browser's built-in checks
                        // based on attributes like `required`, `type="date"`, and `min`.
                        isValid = this._element.checkValidity(); // Aggregates native validity states.

                        // If the element is NOT valid according to native checks:
                        if (!isValid) {
                            Logger.debug(`${this.name} failed native date validation. ValidityState:`, validity);
                            // Examine the specific native validity states to determine the error message.
                             if (validity.rangeUnderflow) {
                                 // Date is before the `min` date set by `_setMinDate` (typically today).
                                 const message = AppConfig.MESSAGES.DATE_PAST;
                                 this._setErrorMessage(message); // Set our custom message for past dates.
                                 // `isValid` is already false, no need to set it again.
                             } else if (validity.badInput) {
                                 // The user input could not be parsed as a date (e.g., "abc", "2023-13-40").
                                 const message = 'Invalid date format.'; // Standard message for format issues.
                                 this._setErrorMessage(message);
                                 // `isValid` is false.
                             } else if (validity.valueMissing) {
                                 // The input is required but empty. This should theoretically be caught by `super._validate()` first.
                                 // Include defensively, using the required message.
                                  const message = AppConfig.MESSAGES.REQUIRED;
                                 this._setErrorMessage(message);
                                 // `isValid` is false.
                             } else {
                                 // Handle any other potential native date-related validity issues.
                                 // Use the native browser's validation message as a fallback if no specific custom message is defined.
                                 const message = this._element.validationMessage || 'Invalid date.';
                                 this._setErrorMessage(message);
                                 // `isValid` is false.
                             }
                        } else {
                            // If native validation passed, clear any specific date-related error messages that might have been set.
                             // `_clearErrorMessage()` clears both the text and the native custom validity.
                            this._clearErrorMessage();
                             // `isValid` is already true.
                            Logger.debug(`${this.name} passed native date validation.`);
                        }

                        // Update component's internal validation state based on the final `isValid` result from native checks.
                        this._isValid = isValid;
                        Logger.debug(`${this.name} date validation result: ${this._isValid}.`);
                        return this._isValid; // Return the result.

                    } catch (error) {
                         // Report errors occurring *within* the DateInput specific validation logic.
                         this._errorReporter.reportError(
                             `${this.name}._validate`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value },
                             `Error during date validation for component "${this.name}".`,
                             'dateinput_validate_exception'
                         );
                         // If the validation process itself fails, the component is considered invalid.
                         this._isValid = false;
                         this._setErrorMessage(`Validation error: ${error.message}`); // Set a generic message for the user.
                         return false; // Always return false if validation failed due to error.
                    }
                }

                /**
                 * Public getter to retrieve the date value from the input element as a JavaScript `Date` object.
                 * Parses the value string (expected YYYY-MM-DD) into a `Date` object, treating it as local time.
                 * @returns {Date|null} - The `Date` object if the value is valid and parsable, or `null` if the value is empty or parsing fails.
                 */
                get DateObject() {
                    try {
                         // Get the string value from the input using the parent's getValue method.
                        const value = this.getValue();
                        // If the value is empty, return null as there's no date to parse.
                        if (!value) {
                            // Logger.debug(`${this.name}.DateObject: Value is empty.`); // Too noisy
                            return null;
                        }

                        // Attempt to parse the YYYY-MM-DD string into year, month, and day parts.
                        const parts = value.split('-');
                        // Check if there are 3 parts and if they are all valid numbers.
                        // Using parseInt with radix 10 is crucial for reliable number parsing.
                        if (parts.length === 3 && !isNaN(parseInt(parts[0], 10)) && !isNaN(parseInt(parts[1], 10)) && !isNaN(parseInt(parts[2], 10))) {

                             const year = parseInt(parts[0], 10);
                             const month = parseInt(parts[1], 10) - 1; // JS Date month is 0-indexed (0=Jan, 11=Dec).
                             const day = parseInt(parts[2], 10);

                             // Basic sanity checks on parsed month/day ranges. Date constructor handles many range errors,
                             // but these explicit checks can catch some issues earlier or prevent errors if inputs are very wild.
                             if (month < 0 || month > 11 || day < 1 || day > 31) {
                                  Logger.warn(`Date parts out of expected range for ${this.name} value: "${value}". Month: ${month}, Day: ${day}.`);
                                 // If parts are out of range, it's likely not a valid date. Return null.
                                  return null;
                             }

                             // Create a Date object using the parsed parts. This constructor (year, monthIndex, day)
                             // treats the date as local time, which aligns with typical date picker behavior.
                            const dateObj = new Date(year, month, day);

                             // The Date constructor can create a Date object even for invalid dates (e.g., Date(2023, 1, 30) for Feb 30).
                             // An invalid Date object's `getTime()` method returns `NaN`. Check for this case.
                            if (isNaN(dateObj.getTime())) {
                                 Logger.warn(`Date object is Invalid Date after parsing "${value}" for ${this.name}. (e.g. Feb 30).`);
                                return null; // Return null if the resulting Date object is invalid.
                            }

                            Logger.debug(`${this.name}.DateObject: Parsed "${value}" successfully.`);
                            return dateObj; // Return the valid Date object.

                        }
                         // If parsing into parts fails or parts are not valid numbers, the string is not in the expected YYYY-MM-DD format.
                        Logger.warn(`Failed to parse date string "${value}" into DateObject for ${this.name}: Incorrect format.`);
                        return null; // Return null if parsing fails.

                    } catch (error) {
                         // Report errors occurring *within* the DateObject getter.
                         this._errorReporter.reportError(
                             `${this.name}.DateObject`,
                             error,
                             { component: this.#getComponentInfo(), value: this.getValue() },
                             `Error parsing date value for component "${this.name}".`,
                             'dateinput_get_date_object_exception'
                         );
                        return null; // Return null on error.
                    }
                }

                 /**
                  * Public getter for the date type ('check-in' or 'check-out').
                  * @returns {string} - The stored date type or 'unknown'.
                  */
                 get dateType() {
                     try {
                         return this.#dateType;
                     } catch (error) {
                          this._errorReporter.reportError(
                              `${this.name}.dateType`,
                              error,
                              { component: this.#getComponentInfo() },
                              `Error getting date type for component "${this.name}".`,
                              'dateinput_get_datetype_exception'
                          );
                          return 'unknown'; // Return default on error.
                     }
                 }

                /**
                 * Override dispose method. Calls the parent's dispose.
                 */
                dispose() {
                    try {
                         Logger.debug(`Disposing DateInput: ${this.name}`);
                         super.dispose(); // Call parent dispose to remove element listeners and clear _element, _errorMessageElement.
                        // Specific DateInput members (`#dateType`) do not need explicit cleanup beyond object disposal.
                        Logger.debug(`DateInput disposed: ${this.name}.`);
                    } catch (error) {
                         // Report errors during disposal.
                         console.error(`CRITICAL ERROR during disposal of DateInput "${this.name}" (ID: ${this.id}):`, error);
                    }
                }
            }


            // --- Class for Number Input, inheriting from InputComponent ---
            // Extends the InputComponent with number-specific validation logic and number parsing.
             class NumberInput extends InputComponent {

                /**
                 * Constructor for NumberInput.
                 * @param {string} elementId - The ID of the HTML number input element.
                 * @param {string} componentName - A descriptive name (e.g., 'AdultsInput', 'ChildrenInput').
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(elementId, componentName = 'NumberInput', errorReporter) {
                     try {
                        Logger.debug(`${componentName} constructor called for ID "${elementId}"`);
                        // Call parent constructor.
                        super(elementId, componentName, errorReporter); // Pass component name and reporter.

                        // Check if the wrapped element exists and is indeed a number input type.
                        if (this._element && this._element.type !== 'number') {
                           Logger.warn(`${this.name} wrapped element is not a number input type "${this._element.type}". Number-specific validation/parsing may not work correctly.`);
                        }

                        Logger.debug(`${this.name} initialized.`);
                        Logger.debug(`${this.name} constructor finished.`);

                     } catch (error) {
                          // Report errors specifically within the NumberInput constructor.
                          this._errorReporter.reportError(
                              `${componentName}.constructor`,
                              error,
                              { elementId: elementId, componentName: componentName },
                              `Failed to construct Number input component "${elementId}".`,
                              'numberinput_init_exception'
                          );
                          // Propagate initialization error.
                         throw error;
                     }
                 }

                /**
                 * Polymorphism: Overriding the validation method from `InputComponent`.
                 * Adds number-specific validation rules, leveraging the native HTML5 `ValidityState` object
                 * which reflects issues like `required`, `badInput`, `rangeOverflow`/`Underflow`, `stepMismatch` based on attributes (`min`, `max`, `step`).
                 * Clears/sets specific error messages below the input.
                 * @returns {boolean} - True if validation passes, false otherwise.
                 */
                 _validate() {
                    try {
                        Logger.debug(`_validate called for ${this.name}. (NumberInput specific validation)`);
                        // Call parent validation first. This handles the `required` check based on the string value.
                        let isValid = super._validate();

                         // If base validation failed (e.g., required and empty), no need for number-specific checks yet.
                         if (!isValid) {
                              Logger.debug(`${this.name} failed base validation ('required'). Skipping number-specific checks.`);
                             return false;
                         }

                        // Get the native HTML5 ValidityState object from the input element.
                        const validity = this._getValidityState();
                         // If ValidityState is not available, rely only on the base validation (`required` check).
                         if (!validity) {
                             Logger.warn(`${this.name}: Cannot get ValidityState. Skipping detailed number validation.`);
                             return isValid; // Return result from `super._validate()`.
                         }

                        // Check the input element's overall validity using the browser's built-in checks
                        // based on attributes like `required`, `type="number"`, `min`, `max`, and `step`.
                        isValid = this._element.checkValidity(); // Aggregates native validity states.

                        // If the element is NOT valid according to native checks:
                         if (!isValid) {
                              Logger.debug(`${this.name} failed native number validation. ValidityState:`, validity);
                              // Examine the specific native validity states to determine the appropriate error message.
                             let customMessage = 'Invalid number input.'; // Default fallback message

                             if (validity.badInput) {
                                  // The user entered something that cannot be parsed as a number.
                                  // Or the input is empty string and required (covered by super, but validity will flag valueMissing/badInput).
                                 customMessage = AppConfig.MESSAGES.INVALID_NUMBER;
                             } else if (validity.rangeUnderflow) {
                                  // The number is less than the `min` attribute.
                                  const min = parseFloat(this._element.min); // Get the min value from the DOM attribute.
                                  // Use the attribute value string in the message if parsing to float failed.
                                 customMessage = AppConfig.MESSAGES.NUMBER_MIN(isNaN(min) ? this._element.min : min);
                             } else if (validity.rangeOverflow) {
                                  // The number is more than the `max` attribute.
                                  const max = parseFloat(this._element.max); // Get the max value from the DOM attribute.
                                 customMessage = AppConfig.MESSAGES.NUMBER_MAX(isNaN(max) ? this._element.max : max);
                             } else if (validity.stepMismatch) {
                                  // The number does not match the `step` attribute (e.g., 1.5 when step is 1).
                                 customMessage = 'Value must be a valid step.'; // Can customize to include step value if needed.
                             } else if (validity.valueMissing) {
                                  // The input is required but empty (again, should be handled by super, but defensive).
                                 customMessage = AppConfig.MESSAGES.REQUIRED;
                             } else {
                                  // Fallback for any unexpected validity states.
                                  // Use the browser's default validation message if available.
                                 customMessage = this._element.validationMessage || customMessage;
                             }

                            // Set our determined custom error message below the input and update native validity.
                            this._setErrorMessage(customMessage);
                             // `isValid` is already false from `this._element.checkValidity()`.

                         } else {
                             // If native validation passed, clear any specific number-related error messages.
                             this._clearErrorMessage();
                             // `isValid` is already true.
                             Logger.debug(`${this.name} passed native number validation.`);
                         }

                        // Update component's internal validation state based on the final `isValid` result from native checks.
                        this._isValid = isValid;
                        Logger.debug(`${this.name} number validation result: ${this._isValid}.`);
                        return this._isValid; // Return the result.

                    } catch (error) {
                         // Report errors occurring *within* the NumberInput specific validation logic.
                         this._errorReporter.reportError(
                             `${this.name}._validate`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value },
                             `Error during number validation for component "${this.name}".`,
                             'numberinput_validate_exception'
                         );
                         // If validation process itself fails, the component is considered invalid.
                         this._isValid = false;
                         this._setErrorMessage(`Validation error: ${error.message}`); // Set a generic message for the user.
                         return false; // Always return false on error.
                    }
                 }

                 /**
                  * Public method to get the value of the number input element as a number.
                  * Parses the value string using `parseFloat`. Handles `NaN` and returns `NaN` if parsing fails.
                  * @returns {number} - The numerical value or `NaN` if the value is not a valid number string.
                  */
                 getValueAsNumber() {
                     try {
                         // Get the string value using the parent's getValue method.
                          const valueString = this.getValue();
                         // Use `parseFloat` to handle potentially non-integer inputs if the step attribute allows decimals.
                          // `parseFloat('')` results in `NaN`, which is desired for empty inputs here.
                         const numericValue = parseFloat(valueString);

                         // Check if the parsing result is `NaN`.
                         if (isNaN(numericValue)) {
                             Logger.debug(`${this.name}.getValueAsNumber: Parsed value is NaN from string "${valueString}".`);
                             // Return NaN if parsing failed.
                             return NaN;
                         }

                         Logger.debug(`${this.name}.getValueAsNumber: Parsed "${valueString}" to number ${numericValue}.`);
                         return numericValue; // Return the parsed number.

                     } catch (error) {
                          // Report errors occurring *within* the getValueAsNumber method.
                          this._errorReporter.reportError(
                              `${this.name}.getValueAsNumber`,
                              error,
                              { component: this.#getComponentInfo(), value: this.getValue() },
                              `Error getting number value for component "${this.name}".`,
                              'numberinput_get_value_exception'
                          );
                         return NaN; // Return NaN on error.
                     }
                 }

                /**
                 * Override dispose method. Calls the parent's dispose.
                 */
                 dispose() {
                     try {
                          Logger.debug(`Disposing NumberInput: ${this.name}`);
                         super.dispose(); // Call parent dispose.
                         // Specific NumberInput members do not need explicit cleanup.
                         Logger.debug(`NumberInput disposed: ${this.name}.`);
                     } catch (error) {
                          // Report errors during disposal.
                          console.error(`CRITICAL ERROR during disposal of NumberInput "${this.name}" (ID: ${this.id}):`, error);
                     }
                 }
             }

            // --- Class for Destination Input with Google Autocomplete ---
            // Extends the InputComponent to integrate with Google Places Autocomplete API.
            class DestinationInput extends InputComponent {
                #autocomplete; // Private member to hold the Google Autocomplete object instance.
                #placeDetails = null; // Private member to store the Google Place details of the selected suggestion.
                #isPlaceSelected = false; // Private flag: true if user explicitly selected a place from the dropdown.

                /**
                 * Constructor for DestinationInput.
                 * Initializes the input and attempts to set up Google Autocomplete.
                 * @param {string} elementId - The ID of the HTML text input element.
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(elementId, errorReporter) {
                    try {
                        Logger.debug(`DestinationInput constructor called for ID "${elementId}"`);
                        // Call parent constructor.
                        super(elementId, 'DestinationInput', errorReporter); // Set component name and pass reporter.

                        // Initialize private members.
                        this.#placeDetails = null;
                        this.#isPlaceSelected = false;

                        // Check if the Google Maps Places API and the wrapped element are available.
                        // The API is loaded via a <script> tag with `defer`.
                        // Check if the global `google.maps.places` object exists and the input element exists.
                        if (typeof google !== 'undefined' && google.maps && google.maps.places && this._element) {
                             Logger.debug("Google Maps Places API and element are available. Initializing Autocomplete.");
                             // Initialize Google Autocomplete. This will happen only if the API is loaded.
                            this._initializeAutocomplete();
                            Logger.debug(`${this.name} initialized with Google Autocomplete support.`);
                        } else {
                            Logger.warn(`Google Maps Places API (${typeof google?.maps?.places}), or element ID "${elementId}" (${!!this._element}) not available. Google Autocomplete will not be functional for ${this.name}.`);
                            // The component can still function as a basic text input, but autocomplete won't work.
                            // The parent constructor logs if the element is completely missing.
                        }

                        Logger.debug(`${this.name} constructor finished.`);

                    } catch (error) {
                         // Report errors during the DestinationInput constructor logic.
                         this._errorReporter.reportError(
                             `DestinationInput.constructor`,
                             error,
                             { elementId: elementId },
                             `Failed to construct DestinationInput component "${elementId}".`,
                             'destinput_init_exception'
                         );
                         // Propagate initialization error.
                        throw error;
                    }
                }

                /**
                 * Protected method to initialize Google Autocomplete and attach relevant listeners.
                 * Requires `google.maps.places.Autocomplete` to be available.
                 */
                _initializeAutocomplete() {
                    try {
                        Logger.debug(`_initializeAutocomplete called for ${this.name}.`);
                        // Double-check dependencies.
                        if (!this._element || typeof google === 'undefined' || !google.maps || !google.maps.places || typeof google.maps.places.Autocomplete !== 'function') {
                            Logger.error("Cannot initialize Autocomplete: Dependencies missing at call time.");
                            return; // Do nothing if API or element is not ready.
                        }

                        // Configuration options for the Google Autocomplete service.
                        const options = {
                            // `types` restricts results to certain kinds of places (e.g., '(cities)', 'establishment', 'geocode').
                            // A combination like 'establishment' and 'geocode' is often good for travel search (hotels, landmarks, cities, regions).
                            types: ['establishment', 'geocode'],
                             // `fields` specifies which place details to retrieve when a suggestion is selected.
                             // Request only necessary fields to keep costs low (if using Pay-as-you-go pricing).
                             // 'place_id', 'name' are usually essential. 'geometry' might be useful for maps, 'address_components' for breaking down location.
                             // 'formatted_address' provides a clean, human-readable address string.
                            fields: ['place_id', 'name', 'geometry', 'address_components', 'formatted_address'],
                             // `strictBounds: true` would restrict results to the current map viewport, if a map was used. False allows broader results.
                            strictBounds: false,
                            // Other options like `bounds`, `componentRestrictions` (e.g., country filtering).
                            // componentRestrictions: { country: ['us'] }, // Example: Restrict to results in the US.
                        };

                        // Create a new Google Autocomplete instance, attached to the wrapped input element.
                        // This automatically provides the dropdown UI.
                        this.#autocomplete = new google.maps.places.Autocomplete(this._element, options);
                         Logger.debug("Google Autocomplete object created and attached to input element.");


                        // Attach listeners to the Autocomplete object itself.
                        // The `place_changed` event is the primary one - fires when a user selects a prediction from the dropdown.
                        // Use `.bind(this)` to ensure the handler runs with the component instance as `this`.
                        this.#autocomplete.addListener('place_changed', this._handlePlaceChanged.bind(this));
                        Logger.debug(`Attached 'place_changed' listener to Autocomplete object.`);

                        // Attach event listeners directly to the input element using the parent's `_addEventListener` helper.
                        // This ensures `this` context is correct and handlers are stored for disposal.
                        // We attach blur and input handlers to manage state and validation around autocomplete interactions.
                        this._addEventListener('blur', this._handleBlurWithDelay); // Special blur handler for autocomplete interaction
                        this._addEventListener('input', this._handleDestinationInput); // Handle raw text input changes


                        // No need to explicitly attach change/focus/invalid listeners here if parent `InputComponent` does it,
                        // but ensure those handlers account for autocomplete-specific state like `#isPlaceSelected`.
                         // The parent `InputComponent` calls `_handleInput`, `_handleChange`, `_handleBlur`, `_handleFocus`, `_handleInvalid`.
                         // We override `_handleBlur` to add a delay, and provide our own `_handleInput` and `_handlePlaceChanged`.
                         // `_handleChange`, `_handleFocus`, `_handleInvalid` from `InputComponent` are generally fine.

                         Logger.debug(`Destination input element event listeners attached via _addEventListener.`);


                    } catch (error) {
                         // Report errors encountered during the Autocomplete initialization process.
                         this._errorReporter.reportError(
                             `${this.name}._initializeAutocomplete`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error during Google Autocomplete initialization for component "${this.name}".`,
                             'destinput_autocomplete_init_exception'
                         );
                         // If init fails, the Autocomplete object won't be available, other methods will handle this via checks.
                    }
                }

                /**
                 * Handler for the Google Autocomplete `place_changed` event.
                 * This fires when a user selects a place from the dropdown list provided by Autocomplete.
                 * Retrieves the Place details, updates internal state (`#placeDetails`, `#isPlaceSelected`),
                 * and triggers validation for the input field.
                 */
                _handlePlaceChanged() {
                    try {
                        Logger.debug(`${this.name} place_changed event fired from Autocomplete.`);

                        // Get the place details object from the Autocomplete instance after a selection.
                        const place = this.#autocomplete ? this.#autocomplete.getPlace() : null;

                        this.#placeDetails = place; // Store the details object.
                        this.#isPlaceSelected = false; // Reset flag initially.

                        // Check if valid place details were retrieved (a real selection often has geometry).
                        if (!place || !place.geometry) {
                            // This case happens if the user typed text and pressed Enter without selecting a suggestion,
                            // or if the Place Details request failed for a selected place.
                            Logger.warn(`${this.name}: No valid place details available for input: "${this.getValue()}". User may have typed text without selecting, or details lookup failed.`);
                            this.#placeDetails = null; // Ensure stored details are null if the selection was invalid or failed.
                             // The input element's value will contain the text the user typed or selected before the details failed.
                        } else {
                            // A valid place was selected from the list and details were retrieved.
                             Logger.info(`${this.name}: Valid place selected from autocomplete: "${place.name}" (ID: ${place.place_id}).`, { placeDetails: place });
                             this.#isPlaceSelected = true; // Set flag to true, indicating a successful selection from dropdown.
                             // The input element's value is typically automatically updated by the Autocomplete service
                             // when a selection is made.
                            this._value = this._element.value; // Ensure our internal `_value` is synchronized with the DOM element value.

                            // Optional: Store the place_id or coordinates if needed for subsequent API calls (e.g., a search API that accepts place_id).
                            // For this demo which redirects to Expedia's site search, the destination name (the input's value) is usually sufficient.
                            // Example: document.getElementById('destination-place-details').value = place.place_id;
                        }

                        // Trigger validation for the input field after a potential place selection.
                        // Use `setTimeout(..., 0)` to defer validation slightly, ensuring that the DOM input
                        // value and browser internal state updates related to autocomplete selection
                        // are fully processed before validation reads the value and checks validity.
                         setTimeout(() => {
                             try {
                                Logger.debug(`${this.name} executing delayed validate after place_changed.`);
                                this.validate(); // Call the public validate method on the component.
                             } catch (error) {
                                  // Report errors specifically within the delayed validation after place_changed.
                                  this._errorReporter.reportError(
                                       `${this.name}._handlePlaceChanged.delayedValidate`,
                                       error,
                                       { component: this.#getComponentInfo(), value: this.getValue(), isPlaceSelected: this.#isPlaceSelected },
                                       `Error during delayed validation after place selection for "${this.name}".`,
                                       'destinput_delayed_validate_after_placechanged_exception'
                                  );
                             }
                         }, 0); // 0ms delay schedules the function for the next event loop tick.

                    } catch (error) {
                         // Report errors encountered during the `place_changed` event handler execution.
                         this._errorReporter.reportError(
                             `${this.name}._handlePlaceChanged`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error handling 'place_changed' event for component "${this.name}".`,
                             'destinput_handle_place_changed_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }

                /**
                 * Handler for the `blur` event on the destination input, with a small delay.
                 * This delayed handler is critical when using Google Autocomplete because the `place_changed`
                 * event (which signals a suggestion was clicked and value/state updated) might fire *after*
                 * the `blur` event in some browser/scenario combinations. The delay ensures that `place_changed`
                 * completes before validation triggered by the blur event runs, preventing validation from
                 * seeing an intermediate or incorrect state (e.g., seeing the field as empty before the Autocomplete fills it).
                 */
                _handleBlurWithDelay() {
                    try {
                        Logger.debug(`${this.name} blur event fired. Scheduling delayed validation.`);
                        // Schedule the actual validation logic to run after a short delay.
                        setTimeout(() => {
                            try {
                                 Logger.debug(`${this.name} executing delayed blur validation. Place selected flag: ${this.#isPlaceSelected}. Current value: "${this.getValue()}".`);
                                // Perform the validation after the delay.
                                this.validate(); // Calls the public validate method.
                                // After validation runs (which might set `#isPlaceSelected` to false if value changed after selection),
                                // reset the `#isPlaceSelected` flag for the *next* user interaction cycle.
                                this.#isPlaceSelected = false;

                                 // Optional: Add specific handling here if `!this.#isPlaceSelected` and `this.getValue()` is not empty.
                                 // This means the user typed text but didn't select a suggestion.
                                 // For this demo redirect, this is generally allowed by Expedia's site search.
                                 // If you wanted to *force* selection, you would set an error message here.
                                 // if (this.getValue() && !this.#isPlaceSelected) { ... set error ... }

                            } catch (error) {
                                 // Report errors specifically within the delayed blur validation execution.
                                 this._errorReporter.reportError(
                                     `${this.name}._handleBlurWithDelay.delayedValidate`,
                                     error,
                                     { component: this.#getComponentInfo(), value: this.getValue(), isPlaceSelected: this.#isPlaceSelected },
                                     `Error during delayed blur validation execution for "${this.name}".`,
                                     'destinput_delayed_blur_validation_execution_exception'
                                 );
                                // Errors here don't typically need re-throwing as they occur within a setTimeout callback.
                            }
                        }, AppConfig.VALIDATION_DELAY_MS); // Use a configurable delay.

                    } catch (error) {
                         // Report errors encountered *when setting up* the delayed blur timeout.
                         this._errorReporter.reportError(
                             `${this.name}._handleBlurWithDelay`,
                             error,
                             { component: this.#getComponentInfo(), value: this.getValue() },
                             `Error handling blur event or scheduling delayed validation for component "${this.name}".`,
                             'destinput_handle_blur_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }

                /**
                 * Handler for the `input` event on the destination field.
                 * Fired every time the user types or deletes characters.
                 * Updates the internal `_value` and clears autocomplete-specific state (`#placeDetails`, `#isPlaceSelected`)
                 * if the user starts typing after having previously selected a place.
                 */
                _handleDestinationInput() {
                    try {
                        // Update the internal `_value` property to stay synchronized with the DOM input value.
                        this._value = this._element.value;
                         // Logger.debug(`${this.name} input event, value updated to: "${this._value}".`); // Too noisy

                         // If the user types characters *after* having selected a place from the dropdown,
                         // this invalidates the previous selection. Clear the stored place details
                         // and the `#isPlaceSelected` flag.
                        if (this.#placeDetails !== null || this.#isPlaceSelected) {
                            Logger.debug(`${this.name}: Input detected, clearing previous place details and selection flag.`);
                             this.#placeDetails = null; // Clear stored details object.
                             this.#isPlaceSelected = false; // Reset the selection flag.
                        }

                        // The parent's `_handleInput` method (which is called if we didn't override it fully)
                        // also clears the generic error message here, which is generally desirable.
                        // Optional: Add real-time validation or feedback specific to destination input here.

                    } catch (error) {
                         // Report errors encountered within the `_handleDestinationInput` method.
                         this._errorReporter.reportError(
                             `${this.name}._handleDestinationInput`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value, prevPlaceSelected: this.#isPlaceSelected, hasPrevDetails: this.#placeDetails !== null },
                             `Error handling input event for component "${this.name}".`,
                             'destinput_handle_input_exception'
                         );
                         // Do not re-throw in an event handler.
                    }
                }


                /**
                 * Polymorphism: Overriding the `_validate` method from `InputComponent`.
                 * This method provides destination-specific validation. In this demo redirect scenario,
                 * it primarily relies on the base `InputComponent` validation (which checks the `required` attribute).
                 * It can optionally include logic to check if a place was specifically selected from the autocomplete list,
                 * if requiring a selection is a business rule.
                 * @returns {boolean} - True if validation passes, false otherwise.
                 */
                _validate() {
                    try {
                        Logger.debug(`_validate called for ${this.name}. (DestinationInput specific validation)`);
                        // Call the parent `InputComponent`'s `_validate` first. This handles the `required` check based on the `_value`.
                        let isValid = super._validate();

                        // If the base validation (e.g., required and empty) already failed, return false immediately.
                        if (!isValid) {
                             Logger.debug(`${this.name} failed base validation (e.g., 'required'). Skipping destination-specific checks.`);
                            return false;
                        }

                         // --- Optional Validation: Require selecting a place from the Autocomplete dropdown ---
                         // Uncomment and adapt this section if your application business logic *requires*
                         // the user to select a destination from the Google Autocomplete suggestions,
                         // rather than just typing arbitrary text. For the Expedia site redirect,
                         // allowing arbitrary text is often acceptable, as Expedia's own search
                         // engine attempts to interpret it.
                         /*
                         const currentValue = this.getValue(); // Get the trimmed value.
                         // If the input has a value, but `#isPlaceSelected` is false (meaning they typed but didn't select)
                         // OR if `#placeDetails` is null (meaning details lookup failed for a selection),
                         // then consider it invalid if you require a definitive place selection.
                         if (currentValue && !this.#isPlaceSelected) { // Also check if details lookup failed: || (currentValue && this.#isPlaceSelected && !this.#placeDetails)) {
                              const message = AppConfig.MESSAGES.AUTOCOMPLETE_NO_DETAILS(currentValue);
                             // Set the specific error message for not selecting from autocomplete.
                              this._setErrorMessage(message);
                             Logger.warn(`Validation failed for ${this.name}: ${message}. Value: "${currentValue}". Selected flag: ${this.#isPlaceSelected}.`);
                             isValid = false; // Component is invalid.

                         } else {
                             // If a value is present AND `#isPlaceSelected` is true (and details were obtained, if checked), or if the input is not required and empty,
                             // or if the value is empty and it's not required, validation passes.
                             // Clear any specific error message for 'no details' that might have been set previously.
                             // Check if the current error message content specifically matches the 'no details' message.
                             if (this._errorMessageElement && this._errorMessageElement.textContent === AppConfig.MESSAGES.AUTOCOMPLETE_NO_DETAILS(this.getValue())) {
                                  this._clearErrorMessage(); // Clear this specific error message and native validity.
                             }
                             // `isValid` is already true if it reached this 'else' block (passed super validation and wasn't flagged above).
                             // This could also be `isValid = super._validate();` if you wanted to explicitly re-validate base required state.
                         }
                         */
                         // --- End Optional Validation ---

                        // If the optional validation above isn't uncommented, `isValid` remains true here if `super._validate()` was true.

                        // Update component's internal validation state based on the final `isValid` result.
                        this._isValid = isValid;
                        Logger.debug(`${this.name} validation result: ${this._isValid}.`);
                        return this._isValid; // Return the final result.

                    } catch (error) {
                         // Report errors occurring *within* the DestinationInput specific validation logic.
                         this._errorReporter.reportError(
                             `${this.name}._validate`,
                             error,
                             { component: this.#getComponentInfo(), value: this._value, isPlaceSelected: this.#isPlaceSelected },
                             `Error during destination validation for component "${this.name}".`,
                             'destinput_validate_exception'
                         );
                         // If validation process itself fails, the component is considered invalid.
                         this._isValid = false;
                         this._setErrorMessage(`Validation error: ${error.message}`); // Set a generic error message for the user.
                         return false; // Always return false on error.
                    }
                }

                /**
                 * Public method to retrieve the stored Google Place details object.
                 * This object is populated when a user selects a suggestion from the autocomplete dropdown
                 * in the `_handlePlaceChanged` method.
                 * @returns {object|null} - The Google Place details object or `null` if no place has been selected yet,
                 *                          selection failed, or an error occurred accessing it.
                 */
                getPlaceDetails() {
                    try {
                         // Return the stored private place details object.
                        return this.#placeDetails;
                    } catch (error) {
                         // Report errors encountered accessing the private member.
                         this._errorReporter.reportError(
                             `${this.name}.getPlaceDetails`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error getting place details for component "${this.name}".`,
                             'destinput_get_place_details_exception'
                         );
                        return null; // Return null on error.
                    }
                }

                 /**
                   * Override dispose method to clean up Google Autocomplete instance references.
                   * Clears the reference to the Autocomplete object and any stored place details.
                   */
                 dispose() {
                     try {
                         Logger.debug(`Disposing DestinationInput: ${this.name}`);
                         super.dispose(); // Call parent dispose to remove element listeners and clear inherited members.

                         // Clear the reference to the Google Autocomplete object.
                         // Note: The real Google Autocomplete object (`google.maps.places.Autocomplete`)
                         // created via `new` does NOT have a public `remove()` or `dispose()` method to explicitly
                         // clean up its internal state or listeners managed by the Google Maps library.
                         // Removing listeners attached directly to the input element is handled by `super.dispose()`.
                         // For complex SPAs dynamically adding/removing these components, relying on browser Garbage Collection might be necessary for the Autocomplete instance itself.
                         // For this simple page that exists for the page's lifetime, clearing the reference is mainly for code clarity and preventing accidental reuse after logical disposal.
                         this.#autocomplete = null;

                         // Clear any stored place details.
                         this.#placeDetails = null;
                         this.#isPlaceSelected = false; // Reset flag.

                         Logger.debug(`DestinationInput disposed: ${this.name}.`);

                     } catch (error) {
                         // Report errors during disposal.
                         console.error(`CRITICAL ERROR during disposal of DestinationInput "${this.name}" (ID: ${this.id}):`, error);
                     }
                 }
            }


            // --- Helper Class for Collecting Search Parameters ---
            // Encapsulates the logic for extracting values from the map of input components.
            // This provides a layer of abstraction between the SearchForm and individual inputs.
            class SearchParamCollector {
                 // Private member to hold the map of input components (key: inputId, value: component instance).
                 #inputComponents;
                 #errorReporter; // Inject ErrorReporter

                /**
                 * Constructor for SearchParamCollector.
                 * @param {object} inputComponents - An object mapping input IDs to their component instances (expected to be the `_inputs` map from the SearchForm).
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter.
                 */
                constructor(inputComponents, errorReporter) {
                     try {
                        Logger.debug('SearchParamCollector constructor called.');

                         if (!errorReporter) {
                            Logger.error("ErrorReporter instance not provided to SearchParamCollector.");
                             this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[Collector ERROR] ${src}: ${msg}`, err, ctx) };
                         } else {
                            this.#errorReporter = errorReporter;
                         }

                        // Validate the inputComponents map provided during construction.
                        if (!inputComponents || typeof inputComponents !== 'object') {
                             const errorMsg = "Input components map is missing or invalid during SearchParamCollector initialization.";
                            this.#errorReporter.reportError('SearchParamCollector.constructor', new Error(errorMsg), { inputMapType: typeof inputComponents }, errorMsg, 'collector_init_invalid_map');
                             // Throw an error as the collector cannot function without the map.
                            throw new Error(errorMsg);
                        }
                        // Store a reference to the map of input component instances.
                        this.#inputComponents = inputComponents;
                        Logger.debug('SearchParamCollector initialized with input component map.');

                     } catch (error) {
                          // Report errors during the constructor itself.
                          // Use the injected _errorReporter (potentially dummy).
                          this.#errorReporter.reportError(
                              'SearchParamCollector.constructor',
                              error,
                              { inputMapType: typeof inputComponents },
                              'Failed to construct Search Parameter Collector.',
                              'collector_init_exception'
                          );
                         // Ensure `#inputComponents` is an empty object if initialization failed.
                         this.#inputComponents = {}; // Defensive assignment
                         throw error; // Re-throw initialization error.
                     }
                }

                /**
                 * Public method to collect values from all managed input components.
                 * Iterates through the stored map of component instances, calls their `getValue()` method,
                 * and compiles the results into a single parameters object.
                 * Includes robust error handling for accessing component values.
                 * @returns {object} An object containing collected parameters, keyed by input ID.
                 *                   Values will be strings or numbers based on the component's `getValue()`.
                 *                   Values might be `null` if collection for a specific input failed.
                 * @throws {Error} If a critical error occurs during the collection process itself (e.g., the input map is null unexpectedly).
                 */
                collect() {
                    try {
                        Logger.debug('Collecting search parameters using SearchParamCollector...');
                        // Ensure the input map is valid before iterating. This should be true if constructor succeeded.
                        if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                            const errorMsg = "Internal error: Input components map is missing or invalid during collection.";
                           this.#errorReporter.reportError('SearchParamCollector.collect', new Error(errorMsg), { mapType: typeof this.#inputComponents }, errorMsg, 'collector_map_missing');
                           throw new Error(errorMsg); // Indicate critical failure.
                        }

                        const params = {};
                        let hadIndividualCollectionErrors = false;

                        // Iterate through the stored input component instances.
                        // Use Object.keys().forEach() with `hasOwnProperty` check for safety and explicit looping.
                         Object.keys(this.#inputComponents).forEach(inputId => {
                             // Use `Object.prototype.hasOwnProperty.call` for iterating object properties robustly.
                            if (Object.prototype.hasOwnProperty.call(this.#inputComponents, inputId)) {
                                const component = this.#inputComponents[inputId];
                                try {
                                     // Check if the component instance and its `getValue` method exist.
                                    if (component && typeof component.getValue === 'function') {
                                         // Call the public `getValue()` method on the component.
                                        params[inputId] = component.getValue();
                                        // Logger.debug(`Collected "${inputId}": "${params[inputId]}".`); // Too noisy
                                    } else {
                                         // This warning indicates a component was added to the map but is invalid.
                                        Logger.warn(`Input component "${inputId}" not found or missing getValue method during collection. Setting value to null.`);
                                         params[inputId] = null; // Set to null if component is missing or invalid.
                                         hadIndividualCollectionErrors = true; // Flag that some items failed collection.
                                    }
                                } catch (error) {
                                    // Catch errors thrown by an individual component's `getValue()` method.
                                   this.#errorReporter.reportError(
                                       `SearchParamCollector.collect`,
                                       error,
                                       { inputId: inputId, componentName: component?.name, collectionAttempt: params[inputId] },
                                       `Error collecting value for input "${inputId}".`,
                                       'collector_get_value_exception'
                                   );
                                    params[inputId] = null; // Set to null on error for this specific input.
                                    hadIndividualCollectionErrors = true; // Flag collection failure.
                                }
                            }
                        });

                        // After iterating, report if there were errors collecting individual items.
                        if (hadIndividualCollectionErrors) {
                           Logger.warn("Search parameter collection completed with some errors/missing component values.");
                           // We return the potentially partial parameters object. The caller (`SearchForm`) must handle null/missing values if needed for URL building or other operations.
                        } else {
                             Logger.debug("Search parameter collection completed successfully for all managed inputs.");
                        }

                        Logger.info("Collected Params (JSON example):\n", JSON.stringify(params, null, 2));
                        return params; // Return the collected parameters object.

                    } catch (error) {
                         // Catch critical errors during the collection process itself (e.g., if the map iteration failed).
                         this.#errorReporter.reportError(
                             'SearchParamCollector.collect',
                             error,
                             {},
                             'Critical error during search parameter collection.',
                             'collector_critical_exception'
                         );
                         // Re-throw a specific error indicating collection failure.
                         throw new Error(`Failed to collect search parameters due to internal error: ${error.message}`);
                    }
                }

                 /**
                  * Public method to retrieve a specific collected parameter value by its input ID.
                  * Accesses the value directly from the component instance in the stored map.
                  * @param {string} inputId - The ID of the input element/component whose value is needed.
                  * @returns {*} The value of the parameter, or `null`/`undefined` if the component or its value is not found or an error occurs.
                  */
                 getParam(inputId) {
                     try {
                         // Check if the input map is valid.
                         if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                             Logger.warn("Input components map is missing in collector when trying to get specific param.");
                             return null;
                         }
                         // Find the component instance by ID.
                         const component = this.#inputComponents[inputId];
                         // Check if the component instance exists and has a `getValue` method.
                         if (component && typeof component.getValue === 'function') {
                             return component.getValue(); // Return the value from the component.
                         }
                         // If component or method is missing, log a warning and return null.
                         Logger.warn(`Input component "${inputId}" not found or does not have getValue method in collector. Cannot get parameter.`);
                         return null; // Or undefined, depending on desired behavior.
                     } catch (error) {
                          // Report errors during the process of getting a specific parameter.
                          this.#errorReporter.reportError(
                              'SearchParamCollector.getParam',
                              error,
                              { inputId: inputId },
                              `Error getting specific parameter "${inputId}" from collector.`,
                              'collector_get_param_exception'
                          );
                         return null; // Return null on error.
                     }
                 }

                 /**
                  * Public method to get all managed input components.
                  * @returns {object} - The internal map of input components (`id -> instance`). Returns an empty object on error or if the map is missing.
                  */
                 getAllComponents() {
                     try {
                         // Return the internal map. Provide an empty object as a safe fallback.
                         return this.#inputComponents || {};
                     } catch (error) {
                          this.#errorReporter.reportError(
                              'SearchParamCollector.getAllComponents',
                              error, {},
                              'Error getting all components from collector.',
                              'collector_get_all_components_exception'
                          );
                         return {}; // Return empty object on error.
                     }
                 }

                /**
                 * Dispose method for cleanup on application shutdown.
                 * Clears the reference to the input components map. Note that the components *themselves*
                 * should be disposed by the SearchForm (their creator/manager).
                 */
                dispose() {
                     try {
                         Logger.debug("Disposing SearchParamCollector.");
                         // Clear the reference to the input components map.
                         // This collector *doesn't own* the components, the SearchForm does,
                         // so it doesn't call component.dispose() here.
                         this.#inputComponents = {};
                         // ErrorReporter reference is not disposed here as it's shared.
                         Logger.debug("SearchParamCollector disposed.");
                     } catch (error) {
                          this.#errorReporter.reportError(
                              'SearchParamCollector.dispose',
                              error, {},
                              'Error disposing Search Parameter Collector.',
                              'collector_dispose_exception'
                          );
                     }
                 }
            }

            // --- Helper Class for Building the Expedia URL ---
            // Provides static methods to construct the Expedia search results URL from collected parameters.
            // Contains constants for the base URL and affiliate ID. Pure static class (no instances needed).
            class ExpediaUrlBuilder {
                // Static members accessed directly on the class (ExpediaUrlBuilder.BASE_URL, etc.).
                static BASE_URL = AppConfig.BASE_SEARCH_URL;
                static AFFILIATE_ID = AppConfig.AFFILIATE_ID;

                // Private constructor to prevent instantiation (optional, enforce if truly static).
                // private constructor() {}

                /**
                 * Static method to build the Expedia search results URL from collected parameters.
                 * Encodes parameters correctly for a URL query string using `URLSearchParams`.
                 * Includes required search parameters, the affiliate ID, and other common Expedia URL parameters.
                 * Performs basic checks for missing essential parameters needed *specifically for the URL structure*.
                 * @param {object} params - An object containing search parameters (keyed by input ID like 'destination', 'checkInDate', etc.), likely from a `SearchParamCollector`.
                 * @param {ErrorReporter} errorReporter - Instance of the ErrorReporter (passed as static parameter).
                 * @returns {string|null} The fully constructed Expedia search URL string, or `null` if essential parameters are missing or invalid for URL building.
                 */
                static buildUrl(params, errorReporter) {
                    try {
                        Logger.debug("Building Expedia URL...");

                        // Ensure ErrorReporter is available for this static method.
                         if (!errorReporter) {
                             console.error("ExpediaUrlBuilder.buildUrl: ErrorReporter instance not provided.");
                             // Fallback logging if reporter is missing
                             errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[URL Builder ERROR] ${src}: ${msg}`, err, ctx) };
                         }

                        // Basic check for a valid parameters object.
                        if (!params || typeof params !== 'object') {
                           const errorMsg = "Cannot build URL: Invalid or empty parameters object provided.";
                           errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(errorMsg), { params: params }, errorMsg, 'urlbuilder_invalid_params');
                           return null; // Indicate failure.
                        }

                        // Define the list of parameters essential for building a basic Expedia Hotel Search URL.
                        const requiredParams = ['destination', 'checkInDate', 'checkOutDate', 'adults'];
                        let missingOrInvalidParams = []; // Array to track issues found during this method's check.

                        // Iterate through the required parameters and check if they are present and non-empty.
                        requiredParams.forEach(param => {
                             try {
                                 // Get the value from the provided parameters object.
                                const value = params[param];
                                 // Check if the value is missing (`undefined` or `null`) or an empty string (after trimming for strings).
                                 // Use loose check (`== null`) to catch both `undefined` and `null`.
                                if (value == null || (typeof value === 'string' && value.trim() === '')) {
                                      // Special case: 'adults' parameter must have a value that parses to at least 1 for a valid search.
                                     if (param === 'adults') {
                                          const adultsCount = parseInt(value, 10);
                                         if (isNaN(adultsCount) || adultsCount < 1) {
                                             missingOrInvalidParams.push(`${param} (must be at least 1)`);
                                         } // If value is '0' string, parseInt is 0, fails check above. If empty, parseInt is NaN, fails check above.
                                     } else {
                                        // For other required parameters, any non-empty value is sufficient for URL building format.
                                         missingOrInvalidParams.push(param);
                                     }
                                }
                             } catch (error) {
                                 // Report errors encountered while checking a specific required parameter.
                                  errorReporter.reportError(
                                      'ExpediaUrlBuilder.buildUrl', error,
                                      { param: param, paramValue: params[param], params: params },
                                      `Error checking required parameter "${param}" during URL build.`, 'urlbuilder_param_check_exception'
                                  );
                               missingOrInvalidParams.push(`${param} (check error)`); // Add a note about the error for the user/log.
                             }
                        });

                        // Perform cross-parameter validation checks specifically relevant for the URL structure/logic.
                        try {
                            // Check if check-out date is strictly after check-in date. This should be validated by the form,
                            // but confirm for URL robustness.
                            if (params.checkInDate && params.checkOutDate) {
                                 // Attempt to parse date strings into Date objects for comparison.
                                 const checkIn = new Date(params.checkInDate);
                                 const checkOut = new Date(params.checkOutDate);

                                 // Check if date parsing resulted in Invalid Date objects.
                                 if (isNaN(checkIn.getTime()) || isNaN(checkOut.getTime())) {
                                     // This indicates a format issue (unless input type=date forces format), validation should catch it.
                                    missingOrInvalidParams.push('checkInDate/checkOutDate (invalid date format)');
                                 } else if (checkOut <= checkIn) {
                                     // Check if check-out is on or before check-in date.
                                    missingOrInvalidParams.push('checkOutDate (must be after checkInDate)');
                                 }
                            } else {
                                 // If one or both dates are missing here, it's already in `missingOrInvalidParams` from the first loop.
                            }
                        } catch (e) {
                             // Catch errors during the date parsing or comparison cross-check.
                             errorReporter.reportError(
                                 'ExpediaUrlBuilder.buildUrl', e,
                                 { checkIn: params.checkInDate, checkOut: params.checkOutDate },
                                 'Error during date cross-check for URL building.', 'urlbuilder_date_crosscheck_exception'
                             );
                             missingOrInvalidParams.push('checkInDate/checkOutDate (parsing/comparison error)');
                        }


                        // If any required or cross-validated parameters are missing or invalid, return null.
                        if (missingOrInvalidParams.length > 0) {
                            const errorMsg = `Cannot build URL: Missing or invalid essential parameters: ${missingOrInvalidParams.join(', ')}.`;
                            Logger.error(errorMsg); // Log the specific failure reason.
                            // Do not set message display here; the calling code (`SearchForm`) handles this after checking the return value.
                            return null; // Indicate failure to build the URL.
                        }

                        // --- Construct the URL Query String ---
                        // Use `URLSearchParams` to correctly encode parameter names and values for the URL query string.
                        const urlParams = new URLSearchParams();

                        // Add required parameters from the params object.
                        urlParams.append('destination', params.destination);
                        urlParams.append('checkin', params.checkInDate); // Expedia expects YYYY-MM-DD format
                        urlParams.append('checkout', params.checkOutDate); // Expedia expects YYYY-MM-DD format

                        // Ensure adults is a valid number >= 1 before appending (already checked, but re-parse safely).
                        const adultsCount = parseInt(params.adults, 10);
                        // Add a defensive check, although validation/required checks should prevent this state.
                        if (isNaN(adultsCount) || adultsCount < 1) {
                             const errorMsg = `Internal error: Invalid final adults count (${params.adults}) reached URL builder despite validation.`;
                            errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(errorMsg), { adultsValue: params.adults }, errorMsg, 'urlbuilder_invalid_final_adults');
                            return null; // Cannot build valid URL.
                        }
                        urlParams.append('adults', adultsCount);


                         // Add children if the count is greater than 0.
                         // Get children count, default to 0 if not a valid number.
                        const childrenCount = parseInt(params.children, 10) || 0;
                        if (childrenCount > 0) {
                             urlParams.append('children', childrenCount);
                             // Note: Expedia's API/frontend might require child ages ('childages' parameter).
                             // We don't have inputs for ages in this demo, so this is a simple implementation.
                             // Example: urlParams.append('childages', '5,10'); // If you collected ages as '5,10' string
                            Logger.debug(`Added ${childrenCount} children to URL params.`);
                        } else {
                              // Explicitly add children=0 if there are none. This might be required by the Expedia target page.
                              urlParams.append('children', 0);
                             Logger.debug("Added 0 children to URL params.");
                        }

                        // --- Add Affiliate Tracking Parameter ---
                        // Include the affiliate ID parameter (`mcid`).
                        if (ExpediaUrlBuilder.AFFILIATE_ID && ExpediaUrlBuilder.AFFILIATE_ID !== AppConfig.AFFILIATE_ID) { // Check against placeholder too
                             urlParams.append('mcid', ExpediaUrlBuilder.AFFILIATE_ID);
                             Logger.debug(`Added affiliate ID to URL: ${ExpediaUrlBuilder.AFFILIATE_ID}`);
                        } else {
                             Logger.warn("ExpediaUrlBuilder.AFFILIATE_ID is not set or is the placeholder. URL will not include affiliate tracking.");
                             // Decide if missing affiliate ID should prevent URL building. For a demo, maybe not critical.
                             // If it were critical for your use case, `return null;` here.
                        }

                        // --- Add Other Common/Optional Parameters ---
                        // Include other fixed or common parameters often seen in Expedia search URLs.
                        // These are based on observing browser traffic to expedia.com. Their exact meaning/necessity may vary.
                        urlParams.append('rfrr', 'true'); // Appears to be a referrer flag common in affiliate links.
                        urlParams.append('langid', '1033'); // Language ID (e.g., 1033 for English-US).
                        urlParams.append('stid', '0'); // Example Site ID (often 0 or a specific partner ID).
                        urlParams.append('semdtl', '^'); // An uncommon parameter sometimes seen; include defensively.
                        urlParams.append('sort', 'RECOMMENDED'); // Default sort order; could make this configurable with a select input.
                        // urlParams.append('top_dp', '1'); // Parameter sometimes seen, related to top deal properties?
                        // urlParams.append('top_rsid', '1'); // Similar to top_dp?
                        urlParams.append('pwa_ts', Date.now()); // Add a timestamp - can help with caching, uniqueness, or backend analytics.

                        // Example of adding a `rooms` parameter based on the number of travelers.
                        // A simplified rule: assume 1 room unless the total number of travelers is over 4.
                        let numberOfRooms = 1;
                         const totalTravelers = adultsCount + childrenCount;
                         if (totalTravelers > 4) {
                              // Roughly estimate rooms needed (e.g., 5 travelers might need 3 rooms based on typical max per room).
                             numberOfRooms = Math.max(1, Math.ceil(totalTravelers / 2)); // Ensure at least 1 room.
                         } else if (totalTravelers >= 1) {
                             numberOfRooms = 1; // At least one room if there's at least one traveler.
                         } else { // Total travelers is 0 or less (should be caught by validation, but defensive).
                              numberOfRooms = 1; // Default to 1 room even in this unlikely scenario.
                         }

                        urlParams.append('rooms', numberOfRooms);
                         Logger.debug(`Assumed ${numberOfRooms} room(s) based on ${adultsCount} adults and ${childrenCount} children (total ${totalTravelers}).`);


                        // Combine the base URL with the constructed query string.
                        const finalUrl = `${ExpediaUrlBuilder.BASE_URL}?${urlParams.toString()}`;

                        Logger.info("Generated Expedia URL:", finalUrl);
                        return finalUrl; // Return the successfully built URL string.

                    } catch (error) {
                        // Catch any critical errors that occurred during the URL building process itself.
                         errorReporter.reportError(
                             'ExpediaUrlBuilder.buildUrl',
                             error,
                             { params: params },
                             'Critical error during Expedia URL building process.',
                             'urlbuilder_critical_exception'
                         );
                         // Indicate URL building failed due to an internal error.
                         return null; // Return null on critical error.
                    }
                }
            }

             // --- Main Application Class: SearchForm ---
             // This is the central orchestrator of the application section.
             // It manages input components, handles the search process flow (including validation and async steps),
             // coordinates with Google Analytics and IndexedDB services,
             // and triggers actions for the simulated Google services (Auth, Pay, Calendar, Email, Apps Script, GenAI).
            class SearchForm extends TravelComponent {
                 // Protected property holding a map of input component instances managed by this form.
                 _inputs = {}; // key: inputId, value: component instance

                 // Private members holding references to various service instances.
                 #errorReporter; // Central error handling instance (already in parent, but keep ref)
                 #messageDisplay; // Instance for displaying UI messages.
                 #gaTracker; // Google Analytics tracker instance.
                 #idbService; // IndexedDB service instance.
                 #googleAuthService; // Simulated Google Identity Service wrapper.
                 #calendarService; // Simulated Google Calendar service.
                 #emailService; // Simulated Google Email service.
                 #googlePayService; // Simulated Google Pay service wrapper.
                 #appsScriptService; // Simulated Google Apps Script service.
                 #genAIService; // Simulated Generative AI service.


                 // Private members holding references to various UI elements outside input components but managed by the form logic.
                 #searchButton; // The main search submit button.
                 #searchTextSpan; // Span inside button showing "Search Hotels".
                 #loadingSpinnerSpan; // Spinner element inside the button.
                 #googleServicesSection; // The HTML section div containing all Google service buttons.
                 #googleAuthArea; // The area containing sign-in elements.
                 #googleSignInButton; // The button to trigger simulated sign-in.
                 #googleAuthStatusElement; // Element displaying sign-in status text.
                 #googleAuthTextElement; // Text inside the sign-in button.
                 #addToCalendarButton; // Button for Add to Calendar.
                 #emailSearchDetailsButton; // Button for Email Details.
                 #sendToAppsScriptButton; // Button for Send to Apps Script.
                 #googlePayButton; // Button for Simulated Google Pay.
                 #googlePayArea; // Area potentially containing the GPay button (useful for real GPay button rendering).
                 #searchHistorySection; // The HTML section div for search history.
                 #searchHistoryList; // The UL element for history list items.
                 #clearHistoryButton; // Button to clear history.
                 #historyStatusElement; // Element displaying history status text.
                 #aiTipsSection; // The HTML section div for AI tips.
                 #aiTipContentElement; // The div containing the AI tip text.


                 // Protected property to store the most recently collected valid search parameters
                 // Needed by the Google service buttons for their actions. Null initially.
                 _lastCollectedParams = null;


                 /**
                  * Constructor for SearchForm.
                  * Initializes the application's main components and services.
                  * @param {string} elementId - The ID of the main form element.
                  * @param {object} appSelectors - Map of CSS selectors for various UI elements (from AppConfig.SELECTORS).
                  * @param {object} appConfig - The main application configuration object (from AppConfig).
                  */
                 constructor(elementId, appSelectors, appConfig) {
                    try {
                        Logger.info(`SearchForm constructor called for ID "${elementId}" with AppConfig version ${appConfig?.APP_VERSION}.`);

                        // Initialize the ErrorReporter instance *before* calling the parent constructor,
                        // so it's available for reporting errors during constructor execution.
                         // The ErrorReporter needs a MessageDisplay (which we also initialize early).
                        const mainMessageDisplayElement = document.querySelector(appSelectors.MAIN_MESSAGE_AREA);
                         const messageDisplay = new MessageDisplay(appSelectors.MAIN_MESSAGE_AREA);
                         // The GA Tracker needs the GA ID.
                         const gaTracker = new GoogleAnalyticsTracker(appConfig.GOOGLE_ANALYTICS_ID);
                         // Now create the ErrorReporter with the message display and tracker instances.
                         const errorReporter = new ErrorReporter(messageDisplay, gaTracker);

                        // Inject these core services into the parent constructor.
                        super(elementId, 'SearchForm', errorReporter); // Set component name and pass error reporter.

                         // Store injected core services as private members.
                         this.#errorReporter = errorReporter; // Keep reference
                         this.#messageDisplay = messageDisplay;
                         this.#gaTracker = gaTracker;


                        // --- Check if the main form element was found by the parent constructor ---
                        if (!this._element) {
                            // If the main element is missing, log a fatal error and ensure services are dummy/safe.
                            // Parent constructor logs a warning and sets _isValid=false.
                            // Display a fatal error message to the user using the initialized message display.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Main form element "${elementId}" not found. Application cannot run.`, 'error', 0);
                            Logger.error(`${this.name} element not found. Application functionality disabled.`);

                             // Initialize dummy services/trackers to prevent errors in later calls.
                             // These dummy objects provide the expected public methods but do nothing, ensuring calls don't crash.
                             this.#idbService = { addSearchHistoryItem: async() => {}, getSearchHistory: async() => [], clearSearchHistory: async() => {}, dispose: () => {Logger.debug("Dummy IDB dispose");} };
                             this.#googleAuthService = { signIn: async() => { throw new Error("Simulated Auth not configured."); }, signOut: async() => {}, isSignedIn: () => false, getUserEmail: () => null, getUserInfo: () => null, handleAuthToggleClick: async() => {}, dispose: () => {Logger.debug("Dummy Auth dispose");} };
                             this.#calendarService = { createEvent: async() => { throw new Error("Simulated Calendar not available."); }, dispose: () => {Logger.debug("Dummy Calendar dispose");} };
                             this.#emailService = { sendEmail: async() => { throw new Error("Simulated Email not available."); }, dispose: () => {Logger.debug("Dummy Email dispose");} };
                             // GPay requires config validation; check it before creating a dummy
                             this.#googlePayService = { isReady: () => false, loadPaymentData: async() => { throw new Error("Simulated Google Pay not configured or not ready."); }, _createPaymentDataRequest: () => null, dispose: () => {Logger.debug("Dummy GPay dispose");} };
                             this.#appsScriptService = { runScriptFunction: async() => { throw new Error("Simulated Apps Script not configured."); }, isConfigured: () => false, dispose: () => {Logger.debug("Dummy Apps Script dispose");} };
                             this.#genAIService = { getDestinationTip: async() => { throw new Error("Simulated GenAI not configured."); }, isConfigured: () => false, dispose: () => {Logger.debug("Dummy GenAI dispose");} };

                             // Ensure all UI element references are null if the main form element is missing,
                             // as querySelector calls might fail or return unexpected results.
                             this.#searchButton = null; this.#searchTextSpan = null; this.#loadingSpinnerSpan = null;
                             this.#googleServicesSection = null; this.#googleAuthArea = null; this.#googleSignInButton = null;
                             this.#googleAuthStatusElement = null; this.#googleAuthTextElement = null;
                             this.#addToCalendarButton = null; this.#emailSearchDetailsButton = null; this.#sendToAppsScriptButton = null;
                             this.#googlePayButton = null; this.#googlePayArea = null;
                             this.#searchHistorySection = null; this.#searchHistoryList = null; this.#clearHistoryButton = null; this.#historyStatusElement = null;
                             this.#aiTipsSection = null; this.#aiTipContentElement = null;

                             // Track the fatal error in GA.
                             this.#gaTracker.trackEvent('fatal_error', { error_code: 'app_init_form_missing', element_id: elementId, message: AppConfig.MESSAGES.FATAL_ERROR });

                            return; // Stop initialization if form element is missing.
                        }

                        // --- Initialize Core Features & UI Elements (if form element found) ---

                         // Initialize IndexedDB Service. Use config from AppConfig.
                         // IndexedDB can function regardless of Google Auth/API configuration.
                        this.#idbService = new IndexedDBService(appConfig.INDEXEDDB.DB_NAME, appConfig.INDEXEDDB.DB_VERSION, appConfig.INDEXEDDB.STORE_NAME);
                        Logger.info("IndexedDB Service initialized.");


                         // Initialize Simulated Google Authentication Service. Requires Client ID from AppConfig and selectors.
                         this.#googleAuthService = new GoogleIdentityServiceWrapper(
                            appConfig.GOOGLE_CLIENT_ID, // Pass Client ID (placeholder)
                            appSelectors, // Pass selectors for UI elements it manages
                            this.#errorReporter // Pass the shared ErrorReporter
                         );
                         // Display warning message if GIS is using placeholder or not configured
                         if (!this.#googleAuthService.isConfigured() || appConfig.GOOGLE_CLIENT_ID === AppConfig.GOOGLE_CLIENT_ID) {
                             this.#messageDisplay.showMessage("Note: Google Sign-In is not configured or is using a placeholder Client ID. Google service simulations may be limited.", 'info', 8000);
                         }
                         Logger.info("Simulated Google Authentication Service initialized.");


                         // Initialize Other Simulated Google Services. They depend on the Auth Service for 'signed-in' state checks.
                         // Pass Auth Service instance and the shared ErrorReporter.
                         this.#calendarService = new SimulatedGoogleCalendarService(this.#googleAuthService, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Pass auth service and delay
                         Logger.info("Simulated Google Calendar Service initialized.");

                         this.#emailService = new SimulatedGoogleEmailService(this.#googleAuthService, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Pass auth service and delay
                         Logger.info("Simulated Google Email Service initialized.");

                         // Initialize Simulated Google Pay Service. Requires Google Pay config and button selector.
                         this.#googlePayService = new GooglePayServiceWrapper(appConfig.GOOGLE_PAY, appSelectors.GOOGLE_PAY_BUTTON, this.#errorReporter); // Pass config, button selector, reporter
                         Logger.info("Simulated Google Pay Service initialized.");

                         // Initialize Simulated Google Apps Script Service. Requires endpoint URL.
                         this.#appsScriptService = new SimulatedGoogleAppsScriptService(appConfig.GOOGLE_APPS_SCRIPT_ENDPOINT, this.#errorReporter); // Pass endpoint and reporter
                          // Display warning message if Apps Script endpoint is placeholder or not configured.
                         if (!this.#appsScriptService.isConfigured() || appConfig.GOOGLE_APPS_SCRIPT_ENDPOINT === AppConfig.GOOGLE_APPS_SCRIPT_ENDPOINT) {
                              this.#messageDisplay.showMessage("Note: Google Apps Script integration is not configured or is using a placeholder endpoint.", 'info', 8000);
                         }
                         Logger.info("Simulated Google Apps Script Service initialized.");

                         // Initialize Simulated GenAI Service. Requires endpoint URL.
                         this.#genAIService = new SimulatedGenAIService(appConfig.GENAI_ENDPOINT, this.#errorReporter); // Pass endpoint and reporter
                         // Display warning message if GenAI endpoint is placeholder or not configured.
                         if (!this.#genAIService.isConfigured() || appConfig.GENAI_ENDPOINT === AppConfig.GENAI_ENDPOINT) {
                              this.#messageDisplay.showMessage("Note: GenAI integration is not configured or is using a placeholder endpoint. Destination tips may not load.", 'info', 8000);
                         }
                         Logger.info("Simulated GenAI Service initialized.");


                        // Collect and initialize input components *within* the main form element.
                         // Pass the ErrorReporter to component constructors.
                         this._collectAndInitializeInputs(this.#errorReporter);

                         // Initialize helper classes that depend on the input map.
                         // Pass the created `_inputs` map and the ErrorReporter.
                         this.#paramCollector = new SearchParamCollector(this._inputs, this.#errorReporter);
                         // The URL Builder is a static class, reference it directly.
                         this.#urlBuilder = ExpediaUrlBuilder; // No need for 'new'


                        // --- Get References to Main UI Elements ---
                        // Query for main button and spinner *within* the form element (our _element).
                        this.#searchButton = this._element.querySelector(appSelectors.SEARCH_BUTTON);
                        this.#searchTextSpan = this._element.querySelector(appSelectors.SEARCH_TEXT);
                        this.#loadingSpinnerSpan = this._element.querySelector(appSelectors.LOADING_SPINNER);

                        // Query for other section/button elements *outside* the form, but related to app logic.
                        this.#googleServicesSection = document.querySelector(appSelectors.GOOGLE_SERVICES_SECTION);
                        this.#googleAuthArea = document.querySelector(appSelectors.GOOGLE_AUTH_AREA); // Auth area handled by GIS wrapper too
                         // Get specific button refs (these are also attached listeners to in _attachButtonListeners)
                         this.#addToCalendarButton = document.querySelector(appSelectors.ADD_TO_CALENDAR_BUTTON);
                         this.#emailSearchDetailsButton = document.querySelector(appSelectors.EMAIL_SEARCH_DETAILS_BUTTON);
                         this.#sendToAppsScriptButton = document.querySelector(appSelectors.SEND_TO_APPS_SCRIPT_BUTTON);
                         this.#googlePayButton = document.querySelector(appSelectors.GOOGLE_PAY_BUTTON); // Button handled by GPay wrapper state too
                         this.#googlePayArea = document.querySelector(appSelectors.GOOGLE_PAY_AREA);

                         // Get history section elements
                         this.#searchHistorySection = document.querySelector(appSelectors.SEARCH_HISTORY_SECTION);
                         this.#searchHistoryList = document.querySelector(appSelectors.SEARCH_HISTORY_LIST);
                         this.#clearHistoryButton = document.querySelector(appSelectors.CLEAR_HISTORY_BUTTON);
                         this.#historyStatusElement = document.querySelector(appSelectors.HISTORY_STATUS);

                         // Get AI tip section elements
                         this.#aiTipsSection = document.querySelector(appSelectors.AI_TIPS_SECTION);
                         this.#aiTipContentElement = document.querySelector(appSelectors.AI_TIP_CONTENT);


                         // Log warnings if any critical UI elements are missing (after query attempts).
                         // Components handle missing elements they wrap, but parent logic depends on these too.
                         if (!this.#searchButton) this.#errorReporter.reportError('SearchForm.constructor', new Error(`Search button missing with selector "${appSelectors.SEARCH_BUTTON}".`), { selector: appSelectors.SEARCH_BUTTON }, 'Search button not found.', 'ui_element_missing_search_button', 0);
                         if (!this.#searchTextSpan) this.#errorReporter.reportError('SearchForm.constructor', new Error(`Search text span missing with selector "${appSelectors.SEARCH_TEXT}".`), { selector: appSelectors.SEARCH_TEXT }, 'Search text span not found.', 'ui_element_missing'); // Less critical
                         if (!this.#loadingSpinnerSpan) this.#errorReporter.reportError('SearchForm.constructor', new Error(`Loading spinner missing with selector "${appSelectors.LOADING_SPINNER}".`), { selector: appSelectors.LOADING_SPINNER }, 'Loading spinner not found.', 'ui_element_missing'); // Less critical

                         // Check for service related UI containers and buttons, essential for features to be visible.
                         if (!this.#googleServicesSection) this.#errorReporter.reportError('SearchForm.constructor', new Error(`Google Services section missing with selector "${appSelectors.GOOGLE_SERVICES_SECTION}".`), { selector: appSelectors.GOOGLE_SERVICES_SECTION }, 'Google Services section not found.', 'ui_element_missing', 0);
                         if (!this.#searchHistorySection) this.#errorReporter.reportError('SearchForm.constructor', new Error(`Search History section missing with selector "${appSelectors.SEARCH_HISTORY_SECTION}".`), { selector: appSelectors.SEARCH_HISTORY_SECTION }, 'Search History section not found.', 'ui_element_missing', 0);
                         if (!this.#aiTipsSection) this.#errorReporter.reportError('SearchForm.constructor', new Error(`AI Tips section missing with selector "${appSelectors.AI_TIPS_SECTION}".`), { selector: appSelectors.AI_TIPS_SECTION }, 'AI Tips section not found.', 'ui_element_missing', 0);


                        // --- Attach Event Listeners ---
                        this._attachSubmitHandler(); // Attach form submit listener (uses parent's _addEventListener).
                        this._attachButtonListeners(); // Attach other UI button listeners (uses parent's _addEventListener).


                        // --- Initial Application State Setup ---
                         // Initial load of search history from IndexedDB. Marked async, called immediately.
                         this._loadAndDisplaySearchHistory();

                         // Initial update of Google service buttons state based on auth status and search data (none initially).
                         this._updateGoogleServiceButtonState();

                        // Call base class initialize logic.
                         super._initialize(); // Call parent initialize.

                        // Application fully initialized success logging.
                         TravelComponent.logAppVersion(); // Log app version using static parent method.
                         Logger.info(`${this.name} fully initialized and running.`);


                    } catch (error) {
                        // Catch any errors that occur *during* the main SearchForm constructor execution itself.
                        // The `errorReporter` might not be fully set up yet if the error happened very early,
                        // but it was initialized before the super() call.
                         if (this.#errorReporter) {
                             this.#errorReporter.reportError(
                                 'SearchForm.constructor',
                                 error,
                                 { elementId: elementId, config: appConfig },
                                 `FATAL ERROR: SearchForm constructor failed. Application cannot run.`,
                                 'app_init_exception',
                                 0 // Persistent fatal error message
                             );
                         } else {
                              // Fallback console log if even the ErrorReporter initialization failed.
                             console.error(`FATAL ERROR during SearchForm constructor for ID "${elementId}". ErrorReporter was not available.`, error);
                         }

                        // Ensure the main element reference is cleared and state is invalid on construction error.
                        this._element = null;
                        this._isValid = false;
                         // Attempt to hide loading state if button element was found early
                         if(this.#searchButton) {
                             try { this._hideLoadingState(); } catch(e) { console.error("Error hiding loader on fatal init:", e); }
                         }

                         // Crucial: Throw the error again to stop the application if the constructor failed critically.
                         throw error;
                    }
                }

                /**
                 * Protected method - called during initialization by the parent constructor after the element is found.
                 * Adds SearchForm-specific initialization steps.
                 */
                _initialize() {
                    try {
                         // Always call the parent's _initialize method first.
                        super._initialize();
                        Logger.debug(`${this.name} specific initialization logic.`);
                        // Add any SearchForm-specific setup beyond element collection and service initialization here.
                        // E.g., initial validation based on default form values, if any.
                    } catch (error) {
                         // Report errors within the _initialize method.
                         this.#errorReporter.reportError(
                             `${this.name}._initialize`,
                             error,
                             { component: this.#getComponentInfo() },
                             `Error during initialization logic for form "${this.name}".`,
                             'form_initialize_exception'
                         );
                         // Do not re-throw, allows constructor to complete.
                    }
                }

                /**
                 * Protected method to iterate through HTML nodes within the form element and initialize
                 * corresponding component instances (like `DateInput`, `NumberInput`, `DestinationInput`).
                 * Components are identified using `data-input-type` attributes on input elements.
                 * Stores the created component instances in the `_inputs` map.
                 * @param {ErrorReporter} errorReporter - The shared ErrorReporter instance to pass to component constructors.
                 */
                _collectAndInitializeInputs(errorReporter) {
                    try {
                         Logger.debug(`Collecting and initializing form inputs for ${this.name} within element ID "${this.id}"...`);
                         // Cannot collect inputs if the main form element (`_element`) is missing.
                         if (!this._element) {
                             Logger.warn(`Cannot collect inputs: Form element (${this.id}) is missing during collection phase.`);
                             // The parent constructor should have already flagged this as a fatal error and stopped.
                             // Defensive check here. Clear inputs map just in case.
                             this._inputs = {};
                             return;
                         }

                        // Query the DOM *within the form element* for all relevant input types.
                        const formElements = this._element.querySelectorAll(AppConfig.SELECTORS.INPUT);

                        // If no input elements are found, log a warning. The form might be empty or selector is wrong.
                        if (formElements.length === 0) {
                            Logger.warn(`No input elements found within form ${this.id} using selector "${AppConfig.SELECTORS.INPUT}". Check HTML structure.`);
                        } else {
                             Logger.debug(`Found ${formElements.length} potential input elements to process.`);
                        }


                        // Iterate through the found DOM elements.
                        formElements.forEach(element => {
                             try {
                                // Each input component is identified by its unique HTML `id`.
                                const inputId = element.id;

                                // Skip elements without an ID, as we use ID to key components in the `_inputs` map.
                                if (!inputId || inputId.trim() === '') {
                                    Logger.warn("Input element found without an ID. Skipping component initialization:", element.tagName, element);
                                    return; // Skip to the next element.
                                }

                                // Determine the specific type of input component to create based on a `data-input-type` attribute.
                                const dataInputType = element.getAttribute('data-input-type');
                                // A `data-component-name` attribute could also be used for mapping to class names directly.

                                let inputComponent = null; // Variable to hold the instantiated component.

                                // Use a switch statement on the `data-input-type` to select the correct class constructor.
                                switch (dataInputType) {
                                    case 'destination':
                                        // Instantiate a DestinationInput component. Pass element ID and the shared ErrorReporter.
                                        inputComponent = new DestinationInput(inputId, errorReporter);
                                        break;
                                    case 'date':
                                         // Get the date type attribute ('check-in' or 'check-out').
                                        const dateType = element.getAttribute('data-date-type');
                                         // Instantiate a DateInput component. Pass ID, date type, and reporter.
                                        inputComponent = new DateInput(inputId, dateType, errorReporter);
                                        break;
                                     case 'number':
                                          // Instantiate a NumberInput component. Pass ID and reporter.
                                         inputComponent = new NumberInput(inputId, errorReporter);
                                         break;
                                    // Add cases here for other specific input types (e.g., 'select', 'checkbox') if you create components for them.
                                    // case 'select': inputComponent = new SelectInput(inputId, errorReporter); break;

                                    default:
                                        // For any element with an ID and matching the INPUT selector but no recognized `data-input-type`,
                                        // you could choose to instantiate a generic `InputComponent` or skip it.
                                        // In this demo, we log and skip if it doesn't map to a specific class we've defined.
                                        Logger.debug(`Skipping initialization for element ID "${inputId}" with data-input-type "${dataInputType || 'none'}". No specific component class defined for this type.`);
                                        // If you want a generic InputComponent for all others:
                                        // inputComponent = new InputComponent(inputId, element.type || element.tagName, errorReporter);
                                        return; // Skip if no component was created.
                                }

                                // If a component instance was successfully created (`inputComponent` is not null)
                                // AND if its internal `_element` reference is not null (meaning the component's
                                // constructor successfully found and wrapped the DOM element):
                                if (inputComponent && inputComponent.getElement()) {
                                    // Store the created component instance in the `_inputs` map, keyed by its ID.
                                    this._inputs[inputId] = inputComponent;
                                     Logger.debug(`Initialized and stored component "${inputComponent.name}" for input ID "${inputId}".`);
                                } else {
                                    // If the component's constructor failed to find its target element,
                                    // or if construction failed critically *after* `super()`, the component instance
                                    // might still exist but be non-functional (`getElement()` would return null).
                                     // Report this failure. The component is not added to the `_inputs` map.
                                    const elementFoundByComponent = inputComponent ? !!inputComponent.getElement() : false;
                                     this.#errorReporter.reportError(
                                         `${this.name}._collectAndInitializeInputs`,
                                         new Error(`Component constructor failed to wrap element "${inputId}" or was null.`),
                                         { inputId: inputId, elementType: element.tagName, dataInputType: dataInputType, componentCreated: !!inputComponent, elementFoundByComponent: elementFoundByComponent },
                                         `Failed to initialize component for input "${inputId}". Check HTML element ID and type.`,
                                         'form_collect_input_component_failed',
                                         0 // Persistent error if a required input fails init
                                     );
                                }

                             } catch (error) {
                                 // Catch any unexpected errors that occur *while processing a specific element* within the forEach loop.
                                 // This prevents one bad element/component from stopping the entire collection process.
                                  const currentElementId = element?.id || 'N/A';
                                  const currentElementType = element?.tagName || 'N/A';
                                  this.#errorReporter.reportError(
                                      `${this.name}._collectAndInitializeInputs`,
                                      error,
                                      { elementId: currentElementId, elementType: currentElementType },
                                      `Error processing input element "${currentElementId}" during collection phase.`,
                                      'form_collect_input_element_exception'
                                  );
                                 // Continue to the next element in the loop.
                             }
                        });

                        // After the loop finishes, log the total number of components successfully initialized.
                        Logger.info(`Input component collection and initialization finished. ${Object.keys(this._inputs).length} components initialized.`);
                         Logger.debug(`Initialized inputs map state:`, this._inputs);

                    } catch (error) {
                         // Catch any critical errors that occur *during the overall collection and initialization process itself*.
                         this.#errorReporter.reportError(
                             `${this.name}._collectAndInitializeInputs`,
                             error,
                             {},
                             `Critical error during form input components collection.`,
                             'form_collect_inputs_critical_exception'
                         );
                         // Clear the inputs map in case a critical error
