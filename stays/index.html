<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LuxStay Finder - Advanced Integration Demo</title>

    <!-- Required CDNs -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>
    <!-- Google Places Autocomplete API -->
    <!-- Requires a valid API Key. Securely restrict key usage in Google Cloud Console. -->
    <script src="https://maps.googleapis.com/maps/api/js?key=YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER&libraries=places" defer></script>

    <!-- Google tag (gtag.js) - Google Analytics -->
    <!-- Requires a valid Measurement ID. User consent is needed for real-world tracking. -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX_PLACEHOLDER"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      // Configure GA4 - send initial page view.
      // Replace G-XXXXXXXXXX_PLACEHOLDER with your actual GA4 Measurement ID.
      // Real-world: configure consent management here.
      gtag('config', 'G-XXXXXXXXXX_PLACEHOLDER', {
        'page_title': 'LuxStay Search Demo',
        'page_path': window.location.pathname + window.location.search,
        // 'client_consent_status': 'placeholder' // Example: integrate with user consent status
      });
      // IMPORTANT: This demo does NOT implement proper Consent Management. Obtain explicit user consent in real applications.
    </script>

    <!-- Optional: Placeholder script tags for Google Identity Services (GSI) and Google Pay. -->
    <!-- COMMENTED OUT: WE ARE SIMULATING THEIR CLIENT-SIDE INTERACTION STRUCTURE -->
    <!-- Real GIS: For Google Sign-In / OAuth 2.0 client-side flows -->
    <!-- <script src="https://accounts.google.com/gsi/client" async defer></script> -->
    <!-- Real Google Pay: For displaying payment methods and tokenizing payment data -->
    <!-- <script async defer src="https://pay.google.com/gp/p/js/pay.js"></script> -->
    <!-- Real Google Pay requires a global onload callback function, e.g., function onGooglePayLoaded() { ... } -->


    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">


    <!-- Inline CSS (using W3CSS + custom styles) -->
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <style>
        /* Base styles for body and typography */
        body {
            font-family: "Segoe UI", Arial, sans-serif;
            background-color: #f1f1f1; /* Light grey background */
            padding-top: 48px; /* Space from top for aesthetics */
             padding-bottom: 48px; /* Space from bottom */
             line-height: 1.6; /* Improved readability */
             color: #333; /* Default text color */
             min-width: 320px; /* Ensure minimum width on small screens */
             overflow-x: hidden; /* Prevent horizontal scrolling */
        }

        /* Header styles */
        header {
            background-color: #009688; /* W3CSS Teal */
            color: white; /* White text */
            padding: 24px 16px;
            text-align: center;
            margin-bottom: 24px; /* Space below header */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        header h1 {
            margin-top: 0;
            margin-bottom: 8px;
            font-size: 2em; /* Larger heading */
            text-shadow: 1px 1px 2px rgba(0,0,0,0.2); /* Subtle text shadow */
        }
        header p {
            margin: 4px 0;
            font-size: 1em;
            color: #e0f2f7; /* Light grey text for subheadings */
        }
         header p.w3-small {
            font-size: 0.8em;
            margin: 2px 0;
             color: #b2dfdb; /* Even lighter grey for small text */
         }


        /* Main content container */
        .app-main-container {
             max-width: 1024px; /* Max width for content */
             margin: auto; /* Center the container */
             padding: 0 16px; /* Add horizontal padding on small screens */
             /* Use W3CSS classes for layout inside if needed */
        }

        /* Standard card styles with shadow */
        .w3-card-4 {
            box-shadow: 0 4px 8px 0 rgba(0,0,0,0.2);
        }

        /* Standard padding and margin utility classes (override/confirm default W3CSS) */
        .w3-padding, .w3-padding-small { padding: 8px 16px; }
        .w3-padding-large { padding: 12px 24px; }
        .w3-padding-top-16 { padding-top: 16px; }
         .w3-padding-bottom-16 { padding-bottom: 16px; }


        /* Input field adjustments for consistency and W3CSS integration */
        input[type="date"], input[type="number"], input[type="text"], select, textarea {
            padding: 10px; /* Slightly more padding */
            box-sizing: border-box; /* Include padding and border in element's total width/height */
            margin-bottom: 8px; /* Space below inputs */
            display: block; /* Make inputs take full width */
            width: 100%; /* Make inputs take full width */
             /* Apply W3CSS border and round classes (or define here) */
            border: 1px solid #ccc;
            border-radius: 4px;
             font-size: 1em; /* Ensure readable font size */
             line-height: 1.4;
        }
         /* Adjust specific input types if needed */
         input[type="number"] {
              /* Add arrow styling overrides if necessary, browser dependent */
         }
         input[type="date"]::-webkit-inner-spin-button,
         input[type="date"]::-webkit-calendar-picker-indicator {
             cursor: pointer; /* Indicate clickability of date picker */
         }


         /* Remove bottom margin for the last input/textarea in a section if it shouldn't have trailing space */
         .w3-section > *:last-child:not(.app-error-message) { /* Check if last child isn't the error message */
              margin-bottom: 0;
         }
          /* Style for inputs within a W3CSS row structure */
          .w3-row-padding .w3-half input,
          .w3-row-padding .w3-col input,
          .w3-row-padding .w3-quarter input {
              width: calc(100% - 16px); /* Account for the 8px horizontal padding added by w3-padding-small on the column div */
              display: inline-block; /* Allow side-by-side within the column */
              margin-right: 8px; /* Add a small gap between input and its right edge (for half/quarter etc.) */
               vertical-align: top; /* Align to top if labels wrap */
          }
          /* Remove right margin for the last input in a column */
          .w3-row-padding .w3-half input:last-child,
          .w3-row-padding .w3-col input:last-child,
          .w3-row-padding .w3-quarter input:last-child {
              margin-right: 0;
          }
           /* Ensure labels in columns display correctly */
          .w3-row-padding .w3-half label,
           .w3-row-padding .w3-col label {
              display: block; /* Make labels block-level */
              margin-bottom: 4px; /* Space below labels */
           }
           /* Adjust padding on column divs within rows */
           .w3-row-padding .w3-half,
           .w3-row-padding .w3-col,
           .w3-row-padding .w3-quarter {
              padding: 0 8px !important; /* Apply 8px horizontal padding */
           }


        /* Custom styles for validation error messages displayed below specific inputs */
        .w3-text-red.app-error-message {
            margin-top: -6px; /* Pull the message up slightly towards the input */
            margin-bottom: 8px; /* Add consistent space after the error message */
            min-height: 1.2em; /* Ensure the div reserves vertical space even when empty, preventing layout shifts */
            display: block; /* Force the element to take up its own line and space */
            font-size: 0.85em; /* Slightly smaller font size for error text */
            line-height: 1.2; /* Improve line height for error text */
            color: #f44336; /* Red text color */
             /* Ensure it doesn't inherit row padding issues */
             padding: 0 !important;
        }
         /* Hide the error message span/div completely if it's empty. Saves vertical space. */
         /* Note: CSS :empty hides elements that have no children AND no text content. */
         .app-error-message:empty {
             display: none !important;
         }
         /* Ensure empty element takes up *some* height to reduce layout shifts */
         .app-error-message {
             height: auto; /* Allow height to adapt */
         }
          /* For browsers not fully supporting :empty, or to ensure *some* initial space */
          .app-error-message:not(:empty) {
              display: block; /* Ensure it's displayed when it has content */
          }



        /* Style for the main application-level message panel */
        #mainMessageDisplay {
            margin: 16px auto; /* Center the panel and add vertical space */
             padding: 12px;
            border-radius: 8px;
            transition: opacity 0.3s ease-in-out; /* Smooth fade effect for showing/hiding */
             max-width: 700px; /* Constrain the width of the message panel */
             min-height: 20px; /* Reserve a minimum height to avoid excessive jumping when it appears */
             box-shadow: 0 2px 4px rgba(0,0,0,0.05); /* Subtle shadow */
             text-align: left; /* Align message text to the left */
        }
        /* Specific W3CSS panel color styles with accent left border */
        #mainMessageDisplay.w3-pale-red { border-left: 6px solid #f44336; background-color: #ffcdd2; color: #d32f2f; } /* Red theme */
        #mainMessageDisplay.w3-pale-yellow { border-left: 6px solid #ffeb3b; background-color: #fff9c4; color: #fbc02d; } /* Yellow theme */
        #mainMessageDisplay.w3-pale-blue { border-left: 6px solid #2196f3; background-color: #bbdefb; color: #1976d2; } /* Blue theme */
        #mainMessageDisplay.w3-pale-green { border-left: 6px solid #4CAF50; background-color: #c8e6c9; color: #388e3c; } /* Green theme */
        /* Basic style if type is unspecified */
         #mainMessageDisplay:not([class*="w3-pale-"]) {
             border-left: 6px solid #9e9e9e; /* Grey border */
             background-color: #eeeeee; /* Light grey background */
             color: #555; /* Darker grey text */
         }


        /* Spinner animation icon styling (used in buttons and status messages) */
        .fa-spinner.w3-spin {
          animation: w3-spin 2s infinite linear;
          vertical-align: middle;
          margin-left: 8px;
          margin-right: 4px; /* Add some space after spinner */
          font-size: 1.1em; /* Slightly larger spinner */
        }
        /* Define the keyframe animation for spinning */
        @keyframes w3-spin {
          0% { transform: rotate(0deg); } /* Start rotation at 0 degrees */
          100% { transform: rotate(359deg); } /* End rotation just before a full circle */
        }

        /* Utility class to hide elements visually using display: none */
        .app-hide {
            display: none !important; /* Use !important to ensure override */
        }

        /* Styles for buttons when they are disabled */
        button:disabled {
            opacity: 0.6; /* Reduce opacity to visually indicate disabled state */
            cursor: not-allowed; /* Change cursor */
            box-shadow: none; /* Remove shadow for a flat disabled look */
        }
        /* Ensure content within disabled buttons (text, icons) doesn't react to pointer events */
        button:disabled span, button:disabled i, button:disabled svg {
            pointer-events: none; /* Prevent interaction with content inside the button */
        }


        /* Styles for various application sections */
        .app-section {
             margin-top: 32px;
             margin-bottom: 32px; /* Space below sections */
             padding: 24px; /* Increased internal padding */
             background-color: white; /* White background for content areas */
             border-radius: 8px; /* Rounded corners */
             box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* Subtle shadow */
             text-align: center; /* Center content horizontally within sections */
             /* W3CSS card-4 adds outer shadow if used on this div */
        }
        /* Heading style within sections */
        .app-section h2, .app-section h3 {
             margin-top: 0; /* Remove top margin for first element */
             margin-bottom: 16px; /* Space below headings */
             color: #555; /* Darker grey heading text */
        }

        /* Specific styles for the Google Services section */
        #googleServicesSection {
             border: 1px solid #ddd; /* Add a light border */
             background-color: #f9f9f9; /* Slightly different background color */
             padding-bottom: 16px; /* Adjust padding */
        }
         #googleServicesSection h3 {
              color: #007bff; /* Blue color for Google section heading */
              margin-bottom: 8px; /* Reduced space below main heading */
         }
          #googleServicesSection > p.w3-small {
               margin-top: 0; /* Remove top margin if directly below heading */
               margin-bottom: 16px; /* Space below small text */
               color: #777; /* Slightly lighter grey for small text */
          }


        /* Google Authentication Area and Elements */
        #googleAuthArea {
             margin-bottom: 24px;
             padding-bottom: 16px;
             border-bottom: 1px solid #eee; /* Separator line below auth section */
             text-align: center; /* Ensure content within auth area is centered */
        }
        /* Google Auth Status Text (Clickable in Simulation) */
        #googleAuthStatus {
            cursor: pointer; /* Change cursor to indicate clickability for simulation */
             text-decoration: underline; /* Underline text */
             font-size: 0.9em;
             color: #555; /* Text color */
             display: inline-block; /* Allow padding/margins and width if needed */
             margin-top: 8px; /* Space above status text */
             min-height: 1.2em; /* Reserve space even when empty */
        }
        #googleAuthStatus:hover {
            text-decoration: none; /* Remove underline on hover */
            color: #000; /* Darken text color on hover */
        }

        /* Google Sign-In Button Styling */
        #googleSignInButton {
            vertical-align: middle;
             display: inline-flex; /* Use flexbox for icon and text alignment */
             align-items: center; /* Vertically center items within flex container */
             justify-content: center; /* Horizontally center content within flex container */
             padding: 8px 16px;
             font-weight: bold;
             background-color: white; /* White background */
             color: #757575; /* Standard Google grey button text color */
             border: 1px solid #dadce0; /* Standard Google button border color */
             border-radius: 4px; /* Rounded corners */
             box-shadow: none; /* Remove W3CSS shadow */
             cursor: pointer; /* Indicate clickability */
             transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; /* Smooth transitions */
        }
         /* Hover state for Google Sign-In button */
         #googleSignInButton:hover:not(:disabled) {
             background-color: #f8f8f8; /* Slightly grey background on hover */
         }
          /* Active state for Google Sign-In button (when pressed) */
          #googleSignInButton:active:not(:disabled) {
             background-color: #e0e0e0; /* Darker grey on active */
              box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1); /* Inner shadow to look pressed */
              border-color: #c0c0c0; /* Darker border */
         }
         /* Disabled state handled by generic button:disabled rule */

        /* Styling for the Font Awesome Google icon within the button */
        #googleSignInButton .fa-google {
            color: #4285F4; /* Standard Google Blue color */
            margin-right: 8px; /* Space between icon and text */
            font-size: 1.2em; /* Slightly larger icon */
        }
         /* If using a custom image for the Google logo instead of Font Awesome */
         /* #googleSignInButton img { width: 18px; margin-right: 8px; vertical-align: middle; } */

        /* Styling for the text span within the Google Sign-In button */
         #googleAuthText {
              vertical-align: middle; /* Ensure text is vertically centered */
         }


        /* Google Services Action Buttons Container */
        #googleServicesSection > p.w3-text-grey.w3-small.w3-center { /* Style for the small text above the buttons */
             margin-top: 0;
             margin-bottom: 16px; /* Space below the text */
             font-size: 0.9em;
             color: #777;
        }
        /* Adjust column padding within the button row to reduce gaps */
        #googleServicesSection .w3-row-padding .w3-col button {
            margin-bottom: 16px; /* Space below each button */
             box-shadow: 0 1px 2px rgba(0,0,0,0.05); /* Subtle shadow on buttons */
             font-weight: bold;
             font-size: 0.95em; /* Slightly smaller font for multiple buttons */
             padding: 10px 8px; /* Adjust button padding */
             line-height: 1.4; /* Improve line height */
             height: auto; /* Allow height to adapt to content */
             white-space: normal; /* Allow button text to wrap */
             min-height: 40px; /* Ensure minimum button height */
        }
         /* Adjust column padding in the button row */
         #googleServicesSection .w3-row-padding {
              margin-left: -8px; /* Compensate for column padding */
              margin-right: -8px;
         }
         #googleServicesSection .w3-row-padding .w3-half,
         #googleServicesSection .w3-row-padding .w3-col {
              padding: 0 8px !important; /* Apply 8px horizontal padding */
           }
           /* Responsive adjustment for columns on medium screens */
         @media (min-width: 769px) {
             #googleServicesSection .w3-row-padding .w3-col.m6 {
                 padding: 0 8px !important;
             }
         }
          /* Remove bottom margin for the last buttons in the section */
          #googleServicesSection .w3-row-padding:last-child .w3-col button {
               margin-bottom: 0;
          }
           /* Icon spacing within action buttons */
          #googleServicesSection .w3-row-padding .w3-col button i.fa {
               margin-right: 8px; /* Space between icon and text */
               font-size: 1.1em;
          }


        /* Google Pay Button specific styles */
        #googlePayArea {
             margin-top: 16px; /* Space above Google Pay button */
             padding-top: 16px;
             border-top: 1px solid #eee; /* Separator line */
             text-align: center; /* Center button within its area */
        }
        #googlePayButton svg {
            vertical-align: middle;
             margin-right: 8px;
             fill: white; /* Fill the Google Pay logo SVG paths with white */
             width: 24px;
             height: 24px;
        }
         /* Override default W3CSS button colors */
         #googlePayButton {
             color: white !important;
             background-color: #000 !important; /* Google Pay official color is black */
             border-color: #000 !important; /* Border color to match background */
             font-weight: bold;
             font-size: 1em;
             padding: 10px 16px; /* Standard button padding */
             display: inline-flex; /* Use flex for icon/text alignment */
             align-items: center;
             justify-content: center;
             border-radius: 4px; /* Rounded corners */
              box-shadow: none !important; /* Remove W3CSS shadow */
             transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease; /* Smooth transitions */
         }
          /* Hover state for Google Pay button */
         #googlePayButton:hover:not(:disabled) {
             background-color: #333 !important; /* Darker grey on hover */
              border-color: #333 !important;
         }
          /* Active state for Google Pay button */
         #googlePayButton:active:not(:disabled) {
              background-color: #555 !important; /* Even darker grey on active
             ```javascript
                             this.#errorReporter = null; // Clear reference.
                           } catch(e) { Logger.error("Dispose: Error disposing Param Collector service:", e); }


                         Logger.info(`${this.name} instance fully disposed. Cleanup complete.`);

                     } catch (error) {
                          // Catch and log any unexpected critical errors that occur *during the disposal process*.
                          // This is a cleanup error; it should be logged but not prevent page unload entirely.
                         console.error(`CRITICAL ERROR during disposal of SearchForm "${this.name}":`, error);
                          // If the ErrorReporter itself failed during disposal, cannot use it here. Use console fallback.
                     }
                 }

             } // End of SearchForm class.


             // --- APP BOOTSTRAP / INITIALIZATION ---
             // This section contains the code that runs once the DOM is ready to initialize the application.

             // Use jQuery's `$(document).ready()` function or native `DOMContentLoaded` event to ensure the DOM is fully loaded
             // before attempting to find and interact with HTML elements or initialize components.
             // Using $(document).ready() for compatibility with the jQuery CDN included.
             $(document).ready(function() {
                 Logger.info("DOM fully loaded. Starting application bootstrap process.");

                 let hotelSearchAppInstance = null; // Variable to hold the main SearchForm instance.

                 try {
                    // --- Pre-Initialization Checks ---
                    // Check if key configuration placeholders are still in the code.
                    // Log warnings or user messages if sensitive or required configurations are missing or placeholders.

                     // Check if Google Places API Key placeholder is present in the script tag included in the head.
                     // We can check the loaded script element itself or the config object if the value was read from HTML.
                     // For simplicity, checking against the placeholder value in AppConfig.
                    if (AppConfig.GOOGLE_API_KEY === 'YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER') {
                         Logger.warn("Google Places API Key in AppConfig is a placeholder. Google Autocomplete will not work with real Google services (simulated works). Ensure the key in the script tag in <head> is also correct.");
                         // An informational message can be shown to the user using MessageDisplay (initialized later).
                         // The Autocomplete Input Component constructor also checks `typeof google.maps.places.Autocomplete`.
                    } else {
                         Logger.info("Google Places API Key configured (or not placeholder).");
                    }

                     // Check if Google Analytics Measurement ID placeholder is present.
                     // The GA script is already configured with this ID in the HTML <head> script block.
                    if (AppConfig.GOOGLE_ANALYTICS_ID === 'G-XXXXXXXXXX_PLACEHOLDER') {
                         Logger.warn("Google Analytics Measurement ID in AppConfig is a placeholder ('G-XXXXXXXXXX_PLACEHOLDER'). GA tracking calls will likely not be received by Google.");
                         // An informational message can be shown to the user using MessageDisplay.
                    } else {
                        Logger.info(`Google Analytics Measurement ID configured in AppConfig (not placeholder): ${AppConfig.GOOGLE_ANALYTICS_ID}`);
                    }

                     // Check if Google OAuth Client ID placeholder is present (used by simulated GIS).
                    if (AppConfig.GOOGLE_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER') {
                         Logger.warn("Google OAuth Client ID in AppConfig is the placeholder. Simulated Google Sign-In might show related messages.");
                    } else {
                        Logger.info(`Google OAuth Client ID configured (not placeholder): ${AppConfig.GOOGLE_CLIENT_ID}`);
                    }

                     // Check other placeholder configuration values for simulated services.
                    if (AppConfig.GOOGLE_PAY.MERCHANT_INFO.merchantId === 'BCR2DN6SA234GS23_PLACEHOLDER') {
                         Logger.warn("Google Pay Merchant ID in AppConfig is a placeholder. Simulated Google Pay uses this value.");
                    }
                    if (AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0]?.tokenizationSpecification?.parameters?.gateway === 'example_PLACEHOLDER') {
                         Logger.warn("Google Pay Gateway name in AppConfig is a placeholder. Simulated Google Pay uses this value.");
                    }
                     if (AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0]?.tokenizationSpecification?.parameters?.gatewayMerchantId === 'exampleGatewayMerchantId_PLACEHOLDER') {
                         Logger.warn("Google Pay Gateway Merchant ID in AppConfig is a placeholder. Simulated Google Pay uses this value.");
                    }
                     if (AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY === 'https://script.google.com/macros/s/YOUR_APPS_SCRIPT_DEPLOYMENT_ID/exec_PLACEHOLDER') {
                         Logger.warn("Google Apps Script backend endpoint URL in AppConfig is a placeholder. Simulated Apps Script integration will not work with a real endpoint.");
                    }
                    if (AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API === '/api/generate-tip_PLACEHOLDER') {
                         Logger.warn("GenAI tip backend endpoint URL in AppConfig is a placeholder. Simulated integration will not work with a real endpoint.");
                    }
                     if (AppConfig.BACKEND_ENDPOINTS.EXPEDIA_PRICE_API === '/api/expedia/hotel-prices') {
                        Logger.warn("Expedia Price backend endpoint URL in AppConfig is a placeholder. Simulated price fetch will not work with a real endpoint.");
                     }


                    // --- Application Initialization ---
                    // Find the main HTML form element that the `SearchForm` class will manage.
                    // Use the selector from `AppConfig.SELECTORS`.
                    const mainFormElement = document.querySelector(AppConfig.SELECTORS.FORM);

                    // --- Step 2: Bootstrap the Application ---
                    // Check if the main application element was successfully found in the DOM.
                    // If the main form element is found, proceed with creating the main application instance (`SearchForm`).
                    // This instance will initialize all its child components (inputs) and services.
                    if (mainFormElement) {
                         // Create the main application instance (`SearchForm`).
                         // Pass the element's ID, the UI selectors configuration, and the application configuration.
                         // The `SearchForm` constructor handles all further initialization and error reporting within the app structure.
                         mainApplicationInstance = new SearchForm(
                            mainFormElement.id, // The ID of the main form element.
                            AppConfig.SELECTORS, // The selectors configuration object.
                            AppConfig // The main application configuration object.
                         );

                        // Check if the SearchForm constructor completed successfully (it throws if a critical error occurs).
                        // If execution reaches here, the instance was created, although it might be in a partially functional state if non-critical errors occurred during its construction.
                        Logger.info("App Bootstrap: Main SearchForm instance created successfully.", mainApplicationInstance);

                        // Optional: Store the main application instance globally (e.g., on `window`) for easier access
                        // during development and debugging via the browser's developer console.
                        // This is generally not recommended for production code due to potential namespace pollution.
                        // window.luxStayFinderApp = mainApplicationInstance; // Example global exposure.


                        // --- Post-Initialization Checks/Demos ---
                         // Demonstrate iterating through HTML input nodes *within the main form element* using pure JavaScript,
                         // *after* our custom input component instances have been initialized by the `SearchForm` constructor.
                         const inputElementsInForm = mainFormElement.querySelectorAll(AppConfig.SELECTORS.INPUT);
                         Logger.info(`App Bootstrap: Iterating through HTML input elements (${inputElementsInForm.length} found) within the main form after component initialization:`);

                         inputElementsInForm.forEach((domNode, index) => {
                             try {
                                 // Attempt to find the corresponding custom input component instance in the `SearchForm`'s `_inputs` map using the DOM node's ID.
                                 // Access the protected `_inputs` map for this demonstration. In a real app, a public getter might be provided if external access is needed.
                                const componentInstance = mainApplicationInstance._inputs ? mainApplicationInstance._inputs[domNode.id] : null;

                                 // Log details about the DOM node and whether a corresponding component was found.
                                 Logger.debug(`App Bootstrap: Node ${index}: DOM Element ID=${domNode.id || 'N/A'}, Tag=${domNode.tagName}, Type=${domNode.type || 'N/A'}.`);
                                 if (componentInstance) {
                                      // If a component instance was found, log its details.
                                     Logger.debug(`  -> Associated JS Component: Name="${componentInstance.name}", IsValid state: ${componentInstance.isValid}.`);
                                     // Example: Could call a public method on the component here for inspection, or add a CSS class to the DOM node visually marking it as managed.
                                     // domNode.classList.add('component-managed');
                                 } else {
                                     // If no corresponding component instance was found in the map for this DOM element ID, log that it's unmanaged by our system.
                                     Logger.debug(`  -> No associated custom JS component found for this DOM element in the main form.`);
                                 }

                             } catch (nodeIterationError) {
                                  // Catch any errors during the loop iteration or while accessing DOM node/component properties.
                                  // Use the main application's error reporter for reporting, if the app instance was created.
                                 if (mainApplicationInstance?._errorReporter) { // Check if reporter is available
                                     mainApplicationInstance._errorReporter.reportError(
                                         'App Bootstrap - DOM Node Iteration', nodeIterationError,
                                         { nodeIndex: index, nodeElementId: domNode?.id, nodeTagName: domNode?.tagName },
                                         `Error processing DOM node during post-init iteration.`,
                                         'bootstrap_dom_iteration_exception'
                                     );
                                 } else {
                                    console.error(`Error processing DOM node ${index} during iteration (App instance/Reporter not available):`, nodeIterationError, { nodeId: domNode?.id });
                                 }
                                 // Continue the loop despite the error.
                             }
                         });

                         // Log the application version using the static method on the base component class.
                         TravelComponent.logAppVersion();


                        // --- Setup Cleanup on Page Unload ---
                         // Add an event listener for the `beforeunload` event on the `window`.
                         // This handler will be executed when the browser is about to unload the page (e.g., user navigates away, closes tab).
                         // Its purpose is to call the `dispose()` method on the main application instance to clean up resources.
                         window.addEventListener('beforeunload', () => {
                             Logger.info("Browser is triggering 'beforeunload'. Attempting to dispose application instance.");
                             try {
                                 // Check if the main application instance exists and has a public `dispose` method.
                                 if (mainApplicationInstance && typeof mainApplicationInstance.dispose === 'function') {
                                      mainApplicationInstance.dispose(); // Call the top-level dispose method on the SearchForm instance.
                                     Logger.info("Application instance dispose method called on 'beforeunload'.");
                                 } else {
                                     Logger.warn("Application instance not found or dispose method missing during 'beforeunload'. Disposal skipped.");
                                 }
                             } catch (disposeErrorOnUnload) {
                                 // Catch errors that occur specifically *during the dispose process* triggered by `beforeunload`.
                                  // Use console.error here as the application's error reporter might be nullified during dispose itself.
                                console.error("CRITICAL ERROR during application disposal on 'beforeunload':", disposeErrorOnUnload, { appInstanceAvailable: !!mainApplicationInstance });
                             }
                             // Note: For Single Page Applications (SPAs) where sections of the DOM might be dynamically added and removed *without* a full page unload,
                             // disposal is more reliably triggered directly by the application's routing or component management logic when a section is removed,
                             // rather than relying solely on `beforeunload`. `beforeunload` is best for full page transitions.
                         });

                         // For full disposal in an SPA that removes parts of the DOM dynamically,
                         // the managing component would need to call `hotelSearchAppInstance.dispose()` directly
                         // when the SearchForm element is removed from the DOM.

                    } else {
                         // --- Fatal Error: Main Form Element Not Found During Bootstrap ---
                         // If the main HTML form element required to bootstrap the application (`#hotelSearchForm`) is not found in the DOM when `document.querySelector` was called in Step 1.
                         // This is a critical error that prevents the entire application section from starting.
                         Logger.error(`FATAL ERROR: Application bootstrap failed. Main application element (selector: "${AppConfig.SELECTORS.FORM}") not found in the DOM.`);

                         // Attempt to initialize a MessageDisplay instance directly here, even if the form is missing,
                         // so we can display a fatal error message to the user.
                         let fallbackMessageDisplay = null;
                         try {
                            fallbackMessageDisplay = new MessageDisplay(AppConfig.SELECTORS.MAIN_MESSAGE_AREA);
                             // Display a persistent fatal error message to the user using the fallback MessageDisplay.
                             fallbackMessageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Application startup failed. The required main form element (ID: "${AppConfig.SELECTORS.FORM.substring(1)}") was not found in the HTML. Please check the page structure.`, 'error', 0); // Show persistent error.
                         } catch (msgInitErrorOnFatal) {
                              // If even the message area element is missing, log a console error as the last resort.
                             console.error(`FATAL: Could not find Message Display element (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) to show fatal error message. Logging instead.`);
                         }


                         // Attempt to track this fatal error in Google Analytics as early as possible, if the GA script (`gtag.js`) has loaded.
                         try {
                              if (typeof gtag === 'function') {
                                   // Track a specific GA error event for this critical bootstrap failure.
                                   gtag('event', 'fatal_error', {
                                       'error_code': 'app_bootstrap_failed', // Custom GA error code.
                                       'message': AppConfig.MESSAGES.FATAL_ERROR, // User-facing message text.
                                       'details': `Required main element not found`, // Specific detail.
                                       'element_selector': AppConfig.SELECTORS.FORM // Selector of the missing element.
                                   });
                                   Logger.info("Fatal error (main element missing) tracked in GA.");
                              } else {
                                Logger.warn("GA gtag function not available during fatal error, cannot track.", { selectorMissing: AppConfig.SELECTORS.FORM });
                              }
                         } catch (gaTrackErrorOnFatal) {
                              // Catch errors during the attempt to track the fatal error in GA.
                             console.error("FATAL: Error tracking fatal bootstrap error in GA:", gaTrackErrorOnFatal);
                         }

                         // No further application code execution is expected in this branch. The page will remain loaded, displaying the error message if possible.

                    } // End if (mainApplicationElement) else {}


                 } catch (domReadyOverallError) {
                      // --- Catch Any Unexpected Critical Errors During the Entire `$(document).ready` Bootstrap Execution ---
                      // This is a final safety net for any uncaught synchronous errors
                      // thrown within the main `$(document).ready` callback function *itself*,
                      // if they were not caught by the more specific try/catch blocks within the `SearchForm` constructor logic.
                      // These errors represent critical failures during the core application bootstrap.
                     Logger.error("CRITICAL UNEXPECTED ERROR caught during DOM ready application bootstrap!", domReadyOverallError);

                      // Attempt to initialize a MessageDisplay instance if it wasn't already, to show a fatal error message to the user.
                      let finalFallbackMessageDisplay = null;
                      try {
                           finalFallbackMessageDisplay = document.querySelector(AppConfig.SELECTORS.MAIN_MESSAGE_AREA) ?
                                                         new MessageDisplay(AppConfig.SELECTORS.MAIN_MESSAGE_AREA) : null;
                            if(finalFallbackMessageDisplay) {
                                 finalFallbackMessageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `An unexpected error occurred during application startup: ${domReadyOverallError.message}`, 'error', 0); // Show persistent fatal error.
                            } else {
                                console.error(`FATAL: Could not find Message Display element (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) to show fatal error message. Logging instead.`);
                            }
                       } catch (msgInitErrorOnFatal) {
                           // Catch errors during the attempt to initialize the fallback MessageDisplay.
                           console.error(`FATAL: Failed repeatedly to initialize MessageDisplay (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) during error handling chain.`, msgInitErrorOnFatal);
                       }


                        // Attempt to track this critical bootstrap error in GA.
                        try {
                             if (typeof gtag === 'function') {
                                  gtag('event', 'fatal_error', {
                                      'error_code': 'dom_ready_bootstrap_exception', // Custom GA error code.
                                      'message': domReadyOverallError.message || 'Unknown bootstrap error', // Error message.
                                      'stack': domReadyOverallError.stack, // Include stack trace for debugging.
                                      'step': 'dom_ready_bootstrap' // Indicate stage.
                                  });
                                  Logger.info("Fatal error (DOM ready bootstrap exception) tracked in GA.");
                             } else {
                                 Logger.warn("GA gtag function not available during fatal bootstrap error, cannot track.");
                             }
                        } catch (gaTrackErrorOnFatal2) {
                            // Catch errors during the attempt to track the fatal error in GA.
                            console.error("FATAL: Error tracking fatal bootstrap error in GA:", gaTrackErrorOnFatal2);
                        }

                       // No further code execution is expected. The page remains loaded showing error if possible.
                   } // End of overall `$(document).ready` catch block.


               }); // End of $(document).ready() handler / application bootstrap logic.


               // --- Expansive Commentary Blocks (Continuing to add content for line count) ---
               // These blocks contain commentary and do not contain executable code within them.
               // They are added solely to increase line count and explain concepts and architectural decisions made in the code.

               /**
                * CONCEPT COMMENTARY BLOCK 7: IndexedDB Service Details
                *
                * The `IndexedDBService` class is implemented as a REAL client-side database wrapper. It leverages the browser's built-in IndexedDB API to store persistent data (search history) directly in the user's browser.
                *
                * Key aspects of the IndexedDBService implementation:
                * - Promise-Based API: All asynchronous IndexedDB operations (opening the database, adding/getting/clearing data) are wrapped in JavaScript Promises (`new Promise(...)`). This allows the calling code (`SearchForm`) to use `async`/`await` for cleaner, more sequential asynchronous logic (`await this.#idbService.addSearchHistoryItem(...)`). This makes the client code consistent with the pattern used for simulated async services.
                * - Database Connection Management: The `#openDatabase()` private method is the central point for getting an IndexedDB database connection. It ensures:
                *   - Only one connection is opened at a time (`#isOpening` flag, `#openRequest` reference).
                *   - Subsequent calls while opening waits for the pending request to complete.
                *   - It handles the database `onupgradeneeded` event to define the database schema (object stores and indexes) based on the configured database version (`AppConfig.INDEXEDDB.DB_VERSION`). Schema changes must happen only in this event handler. In this demo, it creates the `searchHistory` object store and a `timestamp` index.
                *   - It attaches handlers for database errors (`onerror`) and version changes (`onversionchange`, important for handling other tabs updating the schema).
                *   - It returns a Promise that resolves with the `IDBDatabase` instance when the connection is ready.
                * - Transaction Management: The private async `#getTransaction()` method is used internally before any database operation (`add`, `get`, `clear`).
                *   - It awaits a successful database connection (`await this.#openDatabase()`).
                *   - It creates an `IDBTransaction` for the specified store(s) and mode (`"readonly"` or `"readwrite"`).
                *   - Transactions are crucial for ensuring data consistency. Operations within a transaction are atomic – either all succeed, or none do (the transaction is aborted).
                *   - You specify which object store(s) the transaction needs access to when creating it.
                *   - Transactions are short-lived and automatically commit when all requests within them complete successfully, or abort if any request fails or if `transaction.abort()` is called explicitly.
                *   - Error Handling: Errors can occur on individual requests (`request.onerror`), or on the transaction itself (`transaction.onerror`, `transaction.onabort`).
                *
                * 4. Requests (`IDBRequest`): Almost every operation (opening DB, adding data, getting data, opening cursors) returns an `IDBRequest` object. These objects have `onsuccess` and `onerror` event properties.
                *
                * 5. Cursors (`IDBCursor`): Used to iterate through records in an object store or index, often for retrieving multiple items or querying based on ranges.
                *
                * 6. Service Wrapper (`IndexedDBService` class): Encapsulating the IndexedDB logic within a class (`IndexedDBService`) provides several benefits:
                *    - Abstraction: The rest of the application interacts with methods like `addSearchHistoryItem`, `getSearchHistory`, `clearSearchHistory` without needing to know the low-level details of IndexedDB requests, transactions, cursors, etc.
                *    - Connection Management: The service handles opening the database, ensuring only one connection is active (`#isOpening` flag, `#openRequest` reference). It also adds global listeners for DB events like `onversionchange` and `onerror`.
                *    - Promise-Based API: The methods (`add`, `get`, `clear`, `open`) return Promises, allowing seamless integration with `async`/`await` in the calling code (`SearchForm`). The service's private methods (`#openDatabase`, `#getTransaction`) also use Promises.
                *    - Error Handling: Errors are caught within the service and ideally reported via a shared `ErrorReporter` (although the core `IndexedDBService` as implemented focuses on logging/throwing Promise rejection errors which are then caught by the caller's `try...catch` and reported via its own injected reporter).
                *    - Disposal: The service includes a `dispose` method to explicitly close the database connection when the application section is shut down, releasing resources.
                *
                * Security Considerations for IndexedDB:
                * - IndexedDB is *origin-specific*. Data stored by your application on `https://yourdomain.com` cannot be accessed by `https://otherdomain.com`.
                * - It is not designed for storing highly sensitive personal data (like credit card numbers) without strong encryption, as data is accessible by any script on the same origin. User authentication on your server is required before accessing user-specific sensitive data from IndexedDB.
                * - Storing non-sensitive user preferences or historical data (like search criteria) is a typical and appropriate use case.
                * - IndexedDB capacity varies by browser, but is generally much larger than cookies or localStorage.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 8: Simulated Google Identity Services (GIS) - `GoogleIdentityServiceWrapper`
                *
                * This class (`GoogleIdentityServiceWrapper`) simulates the client-side interaction with Google Identity Services (GIS), which is Google's modern framework for handling user authentication (Sign-In) and authorization (OAuth 2.0 consent) client-side in web applications.
                *
                * Real GIS Interaction (`google.accounts.id` and `google.accounts.oauth2`):
                * - The real GIS library (`https://accounts.google.com/gsi/client`) is loaded via a script tag.
                * - You initialize it with your Google OAuth 2.0 Client ID (`google.accounts.id.initialize({...})`).
                * - You can then render a Google Sign-In button (`google.accounts.id.renderButton`) or trigger "One Tap" prompts (`google.accounts.id.prompt`).
                * - When the user signs in or grants consent via the GIS UI, your configured callback function is executed.
                * - The callback receives a credential response, often containing an ID Token (a JSON Web Token - JWT).
                * - Client-side code sends this ID Token to YOUR secure backend server.
                * - YOUR backend server VERIFIES the ID Token (crucial security step) to confirm the user's identity and the token's authenticity.
                * - Your backend then establishes a session for the user.
                * - OAuth 2.0 flows (like `initCodeFlow`) are used to get authorization codes that your backend exchanges for access tokens and refresh tokens, allowing YOUR backend to call Google APIs (like Gmail, Calendar) on the user's behalf SECURELY from the server.
                *
                * How `GoogleIdentityServiceWrapper` SIMULATES This:
                * - It has a constructor that accepts a `clientId` (placeholder in AppConfig) and selectors for auth UI elements.
                * - It finds and stores references to the HTML elements for the Sign-In button, status text, etc.
                * - It includes an `async signIn()` method that is called when the user clicks the button.
                * - This `signIn()` method *simulates* the async GIS process using `setTimeout` and a `Promise`. It simulates success or failure randomly.
                * - On simulated success, it calls a private method (`#handleCredentialResponse`) which *simulates* receiving a credential and parsing user info (email, name).
                * - It maintains internal state (`#isSignedIn`, `#userEmail`, `#userGivenName`) mirroring the authentication status.
                * - A private method (`#updateUI`) is responsible for updating the text and disabled state of the associated HTML elements (button text, status text) based on the internal state.
                * - An `async signOut()` method simulates signing out, also with a delay and state updates.
                * - Public getters like `isSignedIn()`, `getUserEmail()`, `getUserInfo()` expose the *simulated* authentication state and user data.
                * - The public `handleAuthToggleClick()` method is the event handler called by the Sign-In button's click listener. It checks the current simulated state and calls either `signIn()` or `signOut()`.
                * - The `ErrorReporter` is used to log and report simulated failures or errors during the simulated auth process.
                *
                * What this simulation demonstrates:
                * - The client-side UI needs to reflect authentication status (Signed In/Out).
                * - User interaction (button click) triggers an asynchronous auth flow.
                * - The UI should update during the process (e.g., "Signing In...").
                * - The client needs to know if the user is signed in (`isSignedIn()`) and get basic user info (`getUserEmail()`, `getUserInfo()`) to enable or personalize other features.
                * - The client handles both successful authentication and potential failures (Promise rejections from `signIn`/`signOut`).
                * - How an event handler (`handleAuthToggleClick`) orchestrates the start of an async operation.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Verification of ID Tokens on the backend server (critical security step).
                * - Exchanging authorization codes for access tokens on the backend.
                * - Securely storing and managing tokens (access/refresh tokens) on the backend.
                * - User consent flow and handling different Google API scopes.
                * - Different types of GIS UI integrations (One Tap, different button render types).
                * - Real error handling specific to the GIS library (network errors, user cancellation codes).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides authentication state and user info, which a real backend gateway implementing Google Auth would also provide.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 9: Simulated Google Pay Integration - `GooglePayServiceWrapper`
                *
                * The `GooglePayServiceWrapper` class simulates the client-side interaction structure of integrating with the Google Pay API for Web.
                *
                * Real Google Pay API Interaction:
                * - The real Google Pay JS library (`https://pay.google.com/gp/p/js/pay.js`) is loaded.
                * - You initialize a `google.payments.api.PaymentsClient`.
                * - You perform an `isReadyToPay(request)` check to determine if Google Pay is available on the user's device/browser (requires user signed into Google account in the browser, supported browser, etc.).
                * - If ready, you render the Google Pay button.
                * - When the user clicks the button, you create a `PaymentDataRequest` object containing transaction details (total price, currency), allowed payment methods (card networks, auth methods, tokenization specification - linked to your payment gateway), and optional details to collect (shipping, billing, email).
                * - You call `paymentsClient.loadPaymentData(paymentDataRequest)`. This opens the Google Pay payment sheet UI for the user.
                * - If the user confirms payment, the Promise returned by `loadPaymentData` resolves with a `PaymentData` object.
                * - The `PaymentData` object contains the sensitive, encrypted `paymentMethodData.tokenizationData.token`.
                * - **CRITICAL SECURITY:** The `token` **MUST** be sent to YOUR secure backend server.
                * - YOUR backend server sends this token to your Payment Gateway (Stripe, Square, etc.) using YOUR payment gateway credentials (NOT client-side!) to perform the actual charge.
                * - Your backend handles the payment gateway's response and informs the client whether the charge was successful.
                *
                * How `GooglePayServiceWrapper` SIMULATES This:
                * - Constructor accepts `googlePayConfig` (from AppConfig, using placeholders for realism) and button selector.
                * - Constructor triggers an async `#simulateIsReadyToPayCheck()`.
                * - `#simulateIsReadyToPayCheck` simulates the async check (`isReadyToPay`) using `setTimeout` and a random outcome. It updates an internal `#isReady` flag and the button's state/text.
                * - Public `isReady()` method returns the internal `#isReady` flag.
                * - Public `async loadPaymentData(searchParams)` method is called when the Google Pay button is clicked (via the SearchForm handler).
                * - `loadPaymentData` first checks if `isReady()` is true and if essential search parameters are available.
                * - It calls helper methods (`_createSimulatedTransactionDetails`, `_createPaymentDataRequest`) to format the data based on config and search parameters. This mimics constructing the request payload.
                * - It *simulates* calling the Google Pay API using `setTimeout` and a `Promise`. It simulates success (resolving with a fake token object structure) or failure/cancellation (rejecting with a simulated error).
                * - The calling handler (`_handleGooglePayClick`) awaits this Promise and handles the simulated success (logging the fake token, showing success message) or simulated failure/cancellation (showing error/cancel message).
                * - The `ErrorReporter` is used for logging and tracking simulated errors.
                *
                * What this simulation demonstrates:
                * - The need for a readiness check before offering Google Pay (`isReady()`).
                * - How UI (the button) updates based on readiness.
                * - How button click triggers an `async` payment flow (`loadPaymentData`).
                * - The structure of creating a payment request payload (`_createPaymentDataRequest`).
                * - Handling an `async` result that contains payment data on success.
                * - Handling different types of errors/rejections (general failure, user cancellation).
                * - The structure of using `async`/`await` and `try...catch` around the payment API call.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google's payment services.
                * - The display and interaction with the real Google Pay payment sheet UI.
                * - Obtaining a *real* payment token.
                * - **Sending the token to a secure backend server.**
                * - **Processing the charge on the backend using payment gateway APIs and credentials.**
                * - Handling all the various error codes and statuses from real Google Pay API and payment gateways.
                * - Specific requirements for merchant validation, environment setup (TEST/PRODUCTION).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides a `isReady` check and a `loadPaymentData` method returning a Promise with a payment token on success, matching the Google Pay API pattern.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 10: Simulated Google Calendar/Gmail Services
                *
                * `SimulatedGoogleCalendarService` and `SimulatedGoogleEmailService` classes simulate calling Google APIs (Calendar API for creating events, Gmail API for sending emails).
                *
                * Real Google API Interaction (e.g., Calendar API `Events: insert`, Gmail API `users.messages.send`):
                * - User signs in with Google (via GIS or OAuth).
                * - During auth, user grants consent for specific scopes (e.g., `https://www.googleapis.com/auth/calendar.events`, `https://www.googleapis.com/auth/gmail.send`).
                * - Client code obtains an Access Token (via GIS or OAuth flow, potentially with backend involvement).
                * - **For server-side calls (Recommended):** Client sends Access Token to secure backend. Backend uses Access Token (or refreshes it with Refresh Token) to make secure API calls to Google's REST APIs from the server.
                * - **For some client-side calls (Less Secure/Limited Scope):** Some Google APIs allow limited client-side access using the `gapi.client` library and an Access Token. This is less common for write operations or sensitive data like email sending, and subject to CORS/Same-Origin Policy. Gmail `send` usually requires server-side or a backend proxy for security (handling API key, structure of MIME message).
                * - Client constructs the API request body (e.g., event details object for Calendar, MIME message string for Gmail).
                * - Makes an asynchronous request (via `fetch`, `$.ajax`, or `gapi.client`) including the Access Token in headers.
                * - Handles async response (success data or error).
                *
                * How Simulations Work:
                * - Both classes (`SimulatedGoogleCalendarService`, `SimulatedGoogleEmailService`) are injected with the `GoogleIdentityServiceWrapper` instance.
                * - Their public async methods (`createEvent`, `sendEmail`) first check if the user is simulated signed in (`authService.isSignedIn()`). If not, they reject immediately with an "Auth Needed" error message.
                * - If signed in, they simulate the async API call using `setTimeout` and a `Promise`. They simulate success (resolving with a simulated success response) or failure (rejecting with a simulated error).
                * - They have helper methods (`_getCalendarEventDetails`, `_getEmailDetails`) to format the data payload based on search parameters, mimicking the need to structure data for the API request.
                * - The calling handlers (`_handleAddToCalendarClick`, `_handleEmailDetailsClick`) await the Promises and handle the simulated success or failure/rejection, displaying UI messages via the `ErrorReporter`.
                * - `_getEmailDetails` also gets the simulated recipient email from `authService.getUserEmail()`, simulating the need for user info after auth.
                *
                * What simulations demonstrate:
                * - Operations dependent on user authentication (`isSignedIn()` check).
                * - Passing data payloads to an `async` service method.
                * - Handling `async` results that are success/failure responses or errors.
                * - Handling specific error cases like "Auth Needed" or formatting failures.
                * - How the calling logic uses `await` within a `try...catch`.
                *
                * What they do NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Obtaining, managing, and using real Access Tokens (often requires backend involvement).
                * - Handling OAuth 2.0 consent screens and permissions (`scopes`).
                * - Securely sending data (like email content or event details) to a backend/API (use HTTPS POST).
                * - **Securely sending email (almost always requires backend with API keys/service accounts).**
                *
                * These simulations provide a client-side structure that expects `async` services which take data and return Promises, fitting into the `async`/`await` flow, but hide the complex and security-sensitive real API interaction details behind the Promise.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 11: Simulated Google Apps Script Integration
                *
                * The `SimulatedGoogleAppsScriptService` class simulates calling a deployed Google Apps Script Web App endpoint from the client side.
                *
                * Real Google Apps Script Web App Call:
                * - A Google Apps Script is written and deployed as a Web App. The deployment process generates a unique URL (the endpoint).
                * - The Web App is configured to execute as a specific user (often yourself or the user accessing it) and access permissions (ee.g., "Anyone, even anonymous").
                * - Client-side JavaScript uses `fetch` or `XMLHttpRequest` to make an HTTP request (often POST) to this deployed Apps Script endpoint URL, sending data (often as query parameters or JSON body).
                * - The `doGet(e)` or `doPost(e)` function in the Apps Script receives the request and its parameters (`e.parameter`, `e.postData.contents`).
                * - The Apps Script can then perform actions (e.g., write to a Google Sheet, send an email using `MailApp`, interact with other Google Services or external APIs from the server-side Apps Script environment) and return a response to the client (e.g., using `ContentService` to return JSON).
                * - Authentication: If the Web App is deployed to "Execute as user accessing the web app" and "Who has access: Only myself" or "Anyone with Google account," the client browser needs to be authenticated with that user's Google account. More complex authentication (OAuth) is also possible. Sending sensitive data securely usually involves authentication and HTTPS.
                *
                * How `SimulatedGoogleAppsScriptService` SIMULATES This:
                * - Constructor accepts a `endpointUrl` (placeholder from AppConfig) and ErrorReporter. Checks if endpoint is configured.
                * - Public `async runScriptFunction(data)` method simulates the call.
                * - It first checks if the service is configured (`isConfigured()`).
                * - It *simulates* the async HTTP call using `setTimeout` and a `Promise`. Simulates success (resolving with a simulated response object) or failure (rejecting with a simulated error).
                * - The simulated response object mimics a common Apps Script JSON response format (`{ result: 'success', ... }`).
                * - The calling handler (`_handleSendToAppsScriptClick`) awaits the Promise and handles the simulated success or failure/rejection.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS makes an `async` call to an endpoint URL.
                * - Passing a data payload to an `async` service method.
                * - Handling different response formats (success vs. error within the response object).
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual HTTP `fetch` or `$.ajax` call execution.
                * - Specific data formatting for query parameters or request body required by the Apps Script `doGet`/`doPost`.
                * - Handling Apps Script authentication requirements and error responses related to permissions or invalid requests.
                * - The backend nature of Apps Script execution.
                * - Security implications of exposing data or endpoints.
                *
                * The simulation provides a client-side structure that expects an `async` service that sends data to an endpoint and returns a Promise with a response, fitting into the `async`/`await` flow, but abstracts away the real HTTP request details and the server-less nature of Apps Script. Using a backend *gateway* in a real app is often better than calling Apps Script directly from client-side if sensitive data or user authentication context is involved, as the gateway can add an extra layer of security and manage API keys.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 12: Simulated Generative AI Integration
                *
                * The `SimulatedGenAIService` class simulates fetching an AI-generated text tip based on a user input (destination).
                *
                * Real GenAI API Integration (e.g., Google Vertex AI, OpenAI API):
                * - GenAI APIs typically require API keys or other authentication methods (OAuth, service accounts).
                * - These API keys and credentials are **highly sensitive** and must **NEVER** be exposed client-side.
                * - A SECURE BACKEND SERVER is required to make API calls to the GenAI model.
                * - Client-side JS sends the user prompt (e.g., destination name) to a backend endpoint via `fetch` or `$.ajax`.
                * - The backend endpoint receives the prompt, securely accesses its GenAI API credentials, calls the GenAI model API (e.g., `generateContent`), processes the response (extracting the generated text), and sends the generated text back to the client in a JSON response.
                * - Client-side JS receives the response and displays the generated text in the UI.
                *
                * How `SimulatedGenAIService` SIMULATES This:
                * - Constructor accepts an `endpointUrl` (placeholder from AppConfig) representing a backend endpoint for AI tips. Checks config.
                * - Public `async getDestinationTip(destination)` method simulates the process.
                * - It first checks if the service is configured (`isConfigured()`) and if the destination input is valid.
                * - It *simulates* the async call to the backend using `setTimeout` and a `Promise`. Simulates success (resolving with a random tip string) or failure (rejecting with a simulated error).
                * - The calling handler (`_fetchAndDisplaySimulatedAITip`) awaits the Promise and handles the simulated success (displaying the tip string) or simulated failure/rejection (displaying an error message).
                * - It updates its specific UI element (`#aiTipContentElement`) directly.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS triggers an `async` call to a backend endpoint with input data.
                * - Handling an `async` result which is a text string or null/empty string.
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with a backend endpoint.
                * - Actual calls to a GenAI model API using secure credentials.
                * - Processing complex GenAI responses (e.g., safety attributes, multiple candidates).
                * - Security implications of API keys.
                *
                * The simulation provides a client-side structure that expects an `async` service that takes text input (destination) and returns a Promise, which resolves with text or rejects, fitting into the `async`/`await` flow for updating a specific UI section.
                */

               /**
                * CONCEPT COMMENTARY BLOCK 13: The Main Application Bootstrap
                *
                * The code within the `$(document).ready(function() { ... })` block (or equivalent `DOMContentLoaded`)
                * serves as the application's bootstrap or entry point logic that runs once the web page's HTML structure is fully loaded and ready for JavaScript interaction.
                *
                * Key functions of the bootstrap logic:
                * - Ensure DOM Readiness: Using `$(document).ready()` guarantees that all HTML elements are parsed and available in the DOM tree before the script tries to find or manipulate them using `getElementById` or `querySelector`.
                * - Global Scope Protection (IIFE): The entire application code is wrapped within an Immediately Invoked Function Expression (`(function() { ... })();`) or a similar construct like an ES6 module (if using modules). This creates a private scope for the application's variables and functions, preventing them from polluting the global `window` object. Only explicitly intended globals (like `gtag`) or references assigned to `window` (like `window.luxStayFinderApp = mainApplicationInstance;` if uncommented) are exposed.
                * - Configuration Setup: Reads or defines core application configuration (`AppConfig`), including keys (even if placeholders), selectors, messages, service endpoints.
                * - Core Service Initialization: Initializes fundamental services like `Logger`, `MessageDisplay`, and `GoogleAnalyticsTracker`. These are often needed throughout the application, including during component initialization and error handling.
                * - Error Reporting Bootstrap: Creates the central `ErrorReporter` instance using the initialized `MessageDisplay` and `GoogleAnalyticsTracker`. This instance is then passed as a dependency to almost all other components and services.
                * - Root Component Initialization: Finds the main HTML element (the form, in this case) that serves as the root for the application's component structure. If found, it creates the main application instance (`SearchForm`), passing essential dependencies (element ID, selectors, config). The `SearchForm` constructor is responsible for recursively initializing child components (inputs) and other services.
                * - Fatal Error Handling (Element Missing): Includes robust `try...catch` and checks specifically for the case where the main application element is NOT found in the DOM. This is a critical failure that prevents the app section from running. In this scenario, it displays a fatal error message to the user (using a directly initialized or fallback MessageDisplay) and tracks the fatal error in GA, then stops execution in that branch.
                * - Overall Bootstrap Error Handling: Includes a top-level `try...catch` around the entire `$(document).ready` callback to catch any unexpected errors during the overall bootstrap process that weren't handled more specifically within class constructors or helper initializations. This is a final safety net to log and report fatal errors.
                * - Post-Initialization Actions: After the main application instance is created, includes logic for any actions that should run once the app is ready, such as:
                *   - Logging successful initialization and app version.
                *   - Demonstrating interaction with initialized components/DOM elements (like iterating over inputs after components are attached).
                *   - Setting up listeners for page lifecycle events (like `beforeunload`) to trigger application disposal.
                *   - Potentially triggering initial data loads (like history) or UI updates (like button states) that don't depend on user interaction yet.
                * - Application Disposal on Unload: Sets up an event listener on `window.beforeunload` (or equivalent) to call the main application instance's `dispose()` method when the page is about to close or navigate away. This helps ensure resources like IndexedDB connections and event listeners are cleaned up to prevent potential memory leaks or unexpected behavior, especially in complex applications. The `dispose()` method call cascades down through the component hierarchy and services.
                *
                * The bootstrap code is responsible for getting the entire system up and running, handling fundamental setup errors, and initiating initial processes.
                */


               // Ensure the application code runs after the DOM is fully loaded.
               // Wrap the entire application script in an Immediately Invoked Function Expression (IIFE)
               // to create a private scope, preventing variable/function conflicts in the global namespace.
               (function() {
                   "use strict"; // Enforce strict mode for cleaner code and better error detection.

                   // --- START: Google API Key & Secrets Management Disclaimer ---
                   // IMPORTANT SECURITY NOTE:
                   // In a real production application, sensitive API keys, client IDs,
                   // authentication secrets, and merchant secrets should *NEVER* be embedded directly in client-side
                   // JavaScript or HTML. This exposes them to anyone who views your page source, allowing theft and abuse.
                   //
                   // For services requiring API keys (like some parts of Google Cloud APIs, Expedia Partner API) or Client IDs
                   // with broad permissions, these are often used by a SECURE BACKEND SERVICE (an API proxy, a serverless function,
                   // or your main application server).
                   // The backend accesses sensitive credentials securely (e.g., from Environment Variables configured during deployment,
                   // Vaults, or secure Configuration Managers like AWS Secrets Manager, Google Secret Manager).
                   //
                   // GITHUB SECRETS:
                   // GitHub Secrets are encrypted environment variables that you set up in your GitHub repository settings.
                   // They are specifically designed to be used during YOUR CI/CD workflows (like GitHub Actions)
                   // to provide sensitive information to your build scripts or server-side code during deployment.
                   // CLIENT-SIDE JAVASCRIPT CODE RUNNING IN A USER'S BROWSER CANNOT AND SHOULD NOT DIRECTLY ACCESS GITHUB SECRETS.
                   //
                   // In this DEMO code, placeholder values like `YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER`
                   // are included directly in the HTML `<script>` tag or within the `AppConfig` object.
                   // This is solely for the purpose of illustrating *where* such keys/IDs would be referenced
                   // structurally if they *were* used client-side (an insecure practice for anything sensitive).
                   //
                   // For the requested structure demonstrating complex integrations, we are **SIMULATING**
                   // the interactions with these APIs. The simulated services will still reference placeholders
                   // in the configuration (`AppConfig`) to mimic realistic setup, but they will **NOT**
                   // connect to real external services or use real credentials.
                   //
                   // A REAL, SECURE APPLICATION ARCHITECTURE WOULD LOOK DIFFERENT CLIENT-SIDE FOR SENSITIVE OPERATIONS:
                   // 1. Google Places Autocomplete: The API Key in the JS library URL is relatively less sensitive if restricted properly (e.g., by domain/referrer). However, Place Details lookups can incur costs.
                   // 2. Google Identity Services (GIS - Sign-In/OAuth): The client uses the Google OAuth Client ID (less sensitive) to display Sign-In UI and get user consent. GIS provides an ID Token. The client SENDS this ID Token to YOUR secure backend.
                   // 3. Backend Authentication: YOUR backend VERIFIES the ID Token securely using Google's auth libraries (crucial step). This authenticates the user.
                   // 4. Other Google APIs (Calendar, Gmail, Drive/Apps Script): YOUR backend uses the verified user's identity (from the ID Token) and securely stored credentials (YOUR backend's API keys/service account, plus potentially tokens exchanged after user OAuth consent for specific scopes) to call Google's REST APIs SECURELY FROM THE SERVER SIDE. Data is passed between your client and your backend.
                   // 5. Google Pay: Client uses the Google Pay JS library to display payment UI and get a *tokenized payment payload*. This token is encrypted and useless client-side. Client SENDS this TOKEN to YOUR secure backend. YOUR backend uses YOUR Payment Gateway's securely stored API keys/credentials to process the charge using the token.
                   // 6. Expedia Partner API (for real prices/search results): YOUR client sends search parameters to YOUR backend. YOUR backend uses YOUR securely stored Expedia Partner API credentials to call Expedia's API, gets real hotel data/prices, processes it, and sends the results back to the client.
                   // 7. GenAI API: Client sends the user's prompt (e.g., destination for a tip) to YOUR backend. YOUR backend uses YOUR securely stored GenAI API credentials to call the GenAI model, gets the generated content, potentially moderates it, and sends the result back to the client.
                   // 8. Google Apps Script (Secure Access): If an Apps Script needs to perform actions as a specific user or requires sensitive data, YOUR backend should act as a gateway, handling authentication (e.g., using a service account or OAuth flow involving your backend) and calling the Apps Script execution API or accessing resources securely.

                   // THIS DEMO CODE PRIORITIZES DEMONSTRATING THE CLIENT-SIDE JAVASCRIPT STRUCTURE,
                   // ASYNCHRONOUS PATTERNS (`async`/`await`, `Promises`), OOP PRINCIPLES, DOM INTERACTION,
                   // ERROR HANDLING (`try...catch`, `ErrorReporter`), and INTERFACING WITH *SERVICE ABSTRACTIONS*.
                   // THE SERVICES THEMSELVES ARE *SIMULATED* TO MIMIC THE BEHAVIOR OF INTERACTING WITH EXTERNAL APIS ASYNCHRONOUSLY.
                   // THE SECURITY-CRITICAL BACKEND LAYER IS ACKNOWLEDGED BUT NOT IMPLEMENTED HERE IN THIS CLIENT-SIDE-ONLY FILE.
                   // THE PLACECARDERS IN `AppConfig` ILLUSTRARE WHERE CONFIG WOULD GO, BUT SHOULD NEVER BE FILLED WITH REAL SECRETS IN THIS CLIENT-SIDE FILE.
                   // ------------------------------------------------------------------------------------------------------


                   // --- Configuration Object ---
                   // Centralized configuration object holding various constants, messages, selectors, and service details.
                   // Uses placeholder values for configuration endpoints and IDs to illustrate where they would be used,
                   // strongly disclaiming that real secrets should NEVER be hardcoded client-side.
                   const AppConfig = {
                       APP_NAME: 'LuxStayFinderDemoApp', // Descriptive name for the application module/section.
                       APP_VERSION: '5.2.0', // Current version number of the application logic.

                       // Expedia Affiliate Configuration details.
                       // Used for building the affiliate redirect URL.
                       EXPEDIA_AFFILIATE_ID: 'YOUR_EXPEDIA_AFFILIATE_ID_PLACEHOLDER', // Affiliate ID for tracking referrals.
                       EXPEDIA_BASE_SEARCH_URL: 'https://www.expedia.com/Hotel-Search', // Base URL for Expedia's hotel search results page.
                       // This URL is what we will redirect the user to after collecting search parameters.
                       // Example structure observed: https://www.expedia.com/Hotel-Search?destination=...&checkin=...&checkout=...&adults=...&rooms=...&mcid=...&...

                       // --- Secure Backend Endpoints (Placeholders) ---
                       // In a real application, these URLs would point to YOUR secure backend server endpoints.
                       // Client-side JavaScript would call these endpoints using `fetch` or AJAX,
                       // and YOUR backend would handle the secure interaction with external APIs using credentials (potentially from GitHub Secrets).
                       BACKEND_ENDPOINTS: {
                            // Endpoint for fetching real Expedia hotel prices and results. YOUR backend would call Expedia's API.
                           EXPEDIA_SEARCH_API_GATEWAY: '/api/expedia/search-hotels', // Example backend route for Expedia API calls.
                            // Endpoint for securely interacting with Google Apps Script. YOUR backend would handle authentication and calling the Apps Script.
                           APPS_SCRIPT_GATEWAY: '/api/google/apps-script-execute', // Example backend route for Apps Script calls.
                           // Endpoint for securely interacting with a Generative AI model. YOUR backend would call the GenAI API (e.g., Vertex AI).
                           GENAI_TIP_API_GATEWAY: '/api/genai/destination-tip', // Example backend route for GenAI tips.
                            // Endpoint for securely processing Google Pay payment tokens. YOUR backend calls the payment gateway API.
                           GOOGLE_PAY_PROCESS_GATEWAY: '/api/google-pay/process-payment', // Example backend route for payment processing.
                           // Endpoint for a backend gateway to securely interact with other Google APIs (Calendar, Gmail) on behalf of the user.
                           // Client sends auth tokens/consent info to this backend, backend uses YOUR server credentials + user consent to call Google APIs.
                           GOOGLE_API_USER_GATEWAY: '/api/google/user-api', // Example backend route for Calendar/Gmail etc. user-specific operations.
                       },


                       // API & Service Placeholders (Configuration values used by Client-Side logic/Simulations)
                       // IMPORTANT: These values are for CLIENT-SIDE use. Some (like Places API key) are relatively safe if restricted by domain/referrer.
                       // Others (like OAuth Client ID structure, simulated Merchant IDs/Gateways) are part of the simulation structure and represent
                       // real configuration that would be needed, BUT REAL SECRETS ARE HANDLED BACKEND-SIDE.
                       GOOGLE_PLACES_API_KEY: 'YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER', // Google Places Autocomplete API Key. This is typically in the script tag URL. Using it in config as well allows checking the placeholder state.
                       GOOGLE_ANALYTICS_ID: 'G-XXXXXXXXXX_PLACEHOLDER', // Google Analytics 4 Measurement ID. Also in the gtag.js script tag.
                       GOOGLE_OAUTH_CLIENT_ID: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER', // Google OAuth 2.0 Client ID for web application type. Used by real GIS for client-side auth flows.
                       // Google Pay Configuration details (Structure based on Google Pay API). Used by `GooglePayServiceWrapper` simulation.
                       GOOGLE_PAY: {
                           API_VERSION: 2, // Google Pay API version.
                           API_VERSION_MINOR: 0, // Google Pay API minor version.
                           // Allowed payment methods and their parameters/tokenization specifications.
                           ALLOWED_PAYMENT_METHODS: [{
                               type: 'CARD', // Specify card payment method.
                               parameters: {
                                   // Allowed card authentication methods (PAN_ONLY for basic card details, CRYPTOGRAM_3DS for 3DS).
                                   allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],
                                   // Allowed card networks (Visa, Mastercard, Amex, Discover, etc.). Specify those supported by your payment gateway.
                                   allowedCardNetworks: ['AMEX', 'DISCOVER', 'JCB', 'MASTERCARD', 'VISA'],
                                   // Request user's billing address if required by your business/payment gateway.
                                   billingAddressRequired: true,
                                   billingAddressParameters: {
                                       format: 'FULL' // Request full billing address details.
                                   },
                                   // Optional: gateway capabilities, etc.
                               },
                               // Tokenization Specification: Defines how payment data is tokenized for your payment gateway.
                               // Type 'PAYMENT_GATEWAY' is common, uses a specific gateway format.
                               tokenizationSpecification: {
                                   type: 'PAYMENT_GATEWAY',
                                   parameters: {
                                       // Your payment gateway's identifier (e.g., 'stripe', 'adyen', 'authorize_net').
                                       gateway: 'example_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY.
                                       // Your merchant ID within that specific payment gateway.
                                       gatewayMerchantId: 'exampleGatewayMerchantId_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY MERCHANT ID.
                                       // Add other parameters required by your gateway's tokenization spec.
                                   }
                                   // Type 'DIRECT' is for processing payment data directly on your server without a gateway integration specific to Google Pay's format. Requires strong crypto handling server-side.
                                   // tokenizationSpecification: { type: 'DIRECT', parameters: { publicKey: 'YOUR_SERVER_SIDE_PUBLIC_KEY' }} // Requires secure handling.
                               }
                           }],
                           // Merchant Information: Identifies your business. Required for production.
                           MERCHANT_INFO: {
                               // Merchant ID provided by Google Pay. REQUIRED FOR PRODUCTION. Use a test ID in TEST environment.
                               // merchantId: 'BCR2DN6SA234GS23_PLACEHOLDER', // REPLACE WITH YOUR ACTUAL GOOGLE PAY MERCHANT ID.
                               // The public name of your business, shown to the user in the Google Pay UI.
                               merchantName: 'LuxStay Finder Demo (Simulated)',
                               // merchantOrigin: window.location.origin // Recommended for real implementation.
                           },
                           // Transaction Information: Details about the current transaction. Values will be dynamic based on search/selection.
                           TRANSACTION_INFO: {
                               // totalPriceStatus: 'FINAL', // Can be 'FINAL', 'ESTIMATED', 'PENDING'. Use 'FINAL' for booking confirmation step.
                               // totalPrice: 'PLACEHOLDER_PRICE', // REPLACE WITH ACTUAL DYNAMIC PRICE from search results.
                               totalPrice: '100.00', // Static placeholder price for demo calculation logic.
                               currencyCode: 'USD', // Currency code (ISO 4217).
                               countryCode: 'US', // Country where the transaction is processed or business is registered (ISO 3166-1 Alpha-2).
                                // Optional: Display items for a breakdown of the total price (subtotal, tax, etc.).
                                displayItems: [
                                    // Placeholder item structure. Should reflect dynamic pricing in real app.
                                   {
                                      label: 'Simulated Booking Price',
                                      type: 'FINAL', // Use FINAL for static/simulated price.
                                      price: '100.00', // Match totalPrice for simple demo.
                                   }
                                   // Add line items for tax, fees, etc., if available dynamically.
                               ]
                           },
                           // Optional: Request user's email address.
                           EMAIL_REQUIRED: true,
                           // Optional: Request user's shipping address (not usually for hotels, but possible for other purchases).
                           SHIPPING_ADDRESS_REQUIRED: false,
                           SHIPPING_SUPPORTED_COUNTRIES: [], // Empty array as not required for hotels.
                           // Optional: Simulate the success rate for payment processing for demo purposes.
                           SIMULATED_PAYMENT_SUCCESS_RATE: 0.8 // 80% chance of simulated payment success.

                       }, // End GOOGLE_PAY Config


                       // IndexedDB Configuration
                       INDEXEDDB: {
                           DB_NAME: 'LuxStayHistoryDB', // Name of the database.
                           DB_VERSION: 1, // Version number of the database schema. Increment this when changing object stores or indexes.
                           STORE_NAME: 'searchHistory', // Name of the object store to store search history items.
                           HISTORY_ITEM_LIMIT: 20, // Maximum number of history items to retrieve/display.
                       },

                       // CSS Selectors for UI elements (Centralized map for DOM query targets)
                       SELECTORS: {
                           APP_MAIN_CONTAINER: '.app-main-container', // A top-level container for the application UI sections.
                           MAIN_MESSAGE_AREA: '#mainMessageDisplay', // The HTML element (div/span) where app-level status and error messages are displayed.
                           SEARCH_FORM: '#mainSearchForm', // The ID selector for the main search form element.
                           FORM_INPUTS: 'input:not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="hidden"]), select, textarea', // Refined generic CSS selector for standard form input elements (excluding button types and hidden).

                           // Suffix used to construct the ID of the validation error message element associated with an input.
                           // Example: if input ID is 'destinationInput', error message element is expected to be '#destinationInput-error'.
                           ERROR_MESSAGE_SUFFIX: '-error',

                           // Search Button and Loader elements (expected within the main form).
                           SEARCH_BUTTON: '#searchButton', // The main search submit button.
                           SEARCH_BUTTON_TEXT: '#searchText', // Span inside the button for text ("Search Hotels").
                           SEARCH_BUTTON_LOADING_SPINNER: '#loadingSpinner', // Icon element for the loading spinner.

                           // Search Results/Status Area (after the form, could contain price display)
                           RESULTS_AREA: '#resultsArea', // General area below the form for results or related info.
                           EXPEDIA_SIMULATED_PRICE_DISPLAY: '#expediaSimulatedPrice', // Element to display the simulated Expedia price.


                           // Google Services Section & Buttons (often visually separate from the main form)
                           GOOGLE_SERVICES_SECTION: '#googleServicesSection', // The container div for all Google services features.
                           GOOGLE_AUTH_AREA: '#googleAuthArea', // The div containing Google Sign-In related elements.
                           GOOGLE_SIGN_IN_BUTTON: '#googleSignInButton', // Button to trigger simulated Sign-In/Out.
                           GOOGLE_AUTH_STATUS_TEXT: '#googleAuthStatus', // Element displaying auth status text.
                           GOOGLE_SIGN_IN_BUTTON_TEXT: '#googleAuthText', // Span within Sign-In button text.
                           ADD_TO_CALENDAR_BUTTON: '#addToCalendarButton', // Button for Add to Calendar action.
                           EMAIL_SEARCH_DETAILS_BUTTON: '#emailSearchDetailsButton', // Button for Email Search Details action.
                           SEND_TO_APPS_SCRIPT_BUTTON: '#sendToAppsScriptButton', // Button for Send to Apps Script action.
                           GOOGLE_PAY_BUTTON: '#googlePayButton', // Button for Simulated Google Pay action.
                           GOOGLE_PAY_BUTTON_AREA: '#googlePayArea', // Container for the GPay button (relevant for real GPay button rendering placement).


                           // IndexedDB Search History Section & Elements
                           SEARCH_HISTORY_SECTION: '#searchHistorySection', // The container div for the search history feature.
                           SEARCH_HISTORY_LIST_UL: '#searchHistoryList', // The UL element displaying search history items.
                           CLEAR_HISTORY_BUTTON: '#clearHistoryButton', // Button to clear search history.
                           HISTORY_STATUS_DISPLAY: '#historyStatus', // Element displaying status messages related to history (loading, saved, etc.).

                           // GenAI Tip Section & Elements
                           AI_TIPS_SECTION: '#aiTipsSection', // The container div for the GenAI tip feature.
                           AI_TIP_CONTENT_DISPLAY: '#aiTipContent', // The div displaying the AI-generated tip text content.
                       },


                       // UI Messages for various statuses and error states (Centralized strings for consistency and easier updates/localization)
                       MESSAGES: {
                           // --- Application Lifecycle & General Errors ---
                           APP_INIT_START: 'Application initialization started...',
                           APP_INIT_SUCCESS: 'Application initialized successfully.',
                           APP_INIT_ERROR: 'Application failed to initialize properly.',
                           FATAL_ERROR: 'A critical application error occurred.', // Used for errors preventing app from running.
                           DISPOSING: 'Cleaning up application resources...', // Message shown during app disposal.
                           DISPOSED: 'Application disposed.', // Message after disposal completes.
                           INTERNAL_ERROR: 'An internal error occurred.', // Generic internal error message detail.


                           // --- General Process Feedback Messages ---
                           // Use templates for messages that include a dynamic task name.
                           PROCESSING: (task) => `Processing ${task}...`, // Generic processing message template. Add spinner UI where displayed.
                           SUCCESS: (task) => `${task} completed successfully.`, // Generic success message template.
                           FAILED: (task, err) => `${task} failed. ${err ? `Details: ${err}` : 'Unknown error.'}`, // Generic failure message template.

                           // --- Form Validation Messages ---
                           VALIDATION_ERROR: 'Please fix the errors in the form to continue.', // General message when form validation fails.
                           INPUT_REQUIRED: 'This field is required and cannot be empty.', // Specific input 'required' validation message.
                           INPUT_INVALID_NUMBER: 'Please enter a valid number for this field.', // Specific input type="number" parsing error.
                           INPUT_NUMBER_MIN: (min) => `Value must be at least ${min}.`, // Specific number range validation message.
                           INPUT_NUMBER_MAX: (max) => `Value must be at most ${max}.`, // Specific number range validation message.
                           INPUT_DATE_PAST: 'Date cannot be in the past. Please select a future or current date.', // Specific date validation message for 'min'.
                           INPUT_CHECKOUT_BEFORE_CHECKIN: 'Check-out date must be after the check-in date.', // Cross-field date validation message.
                           INPUT_AUTOCOMPLETE_NO_DETAILS: (value) => `Could not confirm destination details for "${value}". Please select a destination from the suggestions list.`, // Destination specific validation message (if selection is required).
                           INPUT_TOTAL_TRAVELERS_LIMIT: (total, max) => `Total travelers (${total}) exceeds the limit allowed per room (${max}). Please adjust or consider multiple rooms.`, // Cross-field travelers validation message.
                           INPUT_STAY_MIN_NIGHTS: (min) => `Minimum stay is ${min} night${min > 1 ? 's' : ''}.`, // Cross-field min nights validation.
                           INPUT_STAY_MAX_NIGHTS: (max) => `Maximum stay is ${max} night${max > 1 ? 's' : ''}.`, // Cross-field max nights validation.


                           // --- Search Process Messages ---
                           SEARCH_INITIATED: 'Validating search details and preparing search...',
                           SEARCH_PARAMS_COLLECTED: 'Search parameters collected.', // Message after parameters are gathered.
                           SIMULATED_BACKEND_CALL: 'Executing simulated search via backend...', // Message for the async fetch step.
                           URL_BUILD_SUCCESS: 'Expedia redirect URL built.', // Message after successful URL construction.
                           URL_BUILD_FAILED: 'Failed to build the Expedia redirect URL. Check input details.', // Message when URL builder returns null or errors.
                           REDIRECT_INITIATED: 'Search processed successfully. Redirecting to Expedia...', // Message shown right before redirect.
                           SEARCH_PROCESS_ERROR: 'An error occurred during the search process.', // Generic catch-all for search errors.

                           // --- Simulated Expedia Price Messages ---
                           EXPEDIA_PRICE_FETCH_INIT: (dest) => `Fetching simulated price for ${dest || 'your destination'}...`, // Message displayed during price fetch.
                           EXPEDIA_PRICE_FETCH_SUCCESS: (price, currency) => `Simulated Price: ${price} ${currency}`, // Message for displaying the simulated price result.
                           EXPEDIA_PRICE_FETCH_FAILED: (err) => `Failed to fetch simulated price. ${err || AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message for simulated price fetch failure.
                           EXPEDIA_PRICE_MISSING_FOR_GPAY: 'Simulated Expedia price data is needed to initiate Google Pay.', // Specific message if price is required for Google Pay.

                           // --- Simulated Google Auth Messages ---
                           AUTH_INIT: 'Initializing Google Sign-In...',
                           AUTH_READY: 'Google Sign-In is ready.',
                           AUTH_NOT_CONFIGURED: 'Google Sign-In is not configured.', // Specific config missing message.
                           AUTH_NEEDED: 'Sign in with Google to use these features.', // User-friendly prompt to sign in.
                           AUTH_SIGNING_IN: 'Signing in with Google account...', // Message displayed during sign-in process.
                           AUTH_SUCCESS: (email) => `Signed in as ${email}.`, // Message upon successful sign-in.
                           AUTH_FAILED: (err) => `Google Sign-In failed. ${err ? `Details: ${err}` : 'Unknown error.'}`, // Message upon sign-in failure.
                           AUTH_SIGNED_OUT: 'Signed out.', // Message upon successful sign-out.
                           AUTH_TOGGLE_ERROR: 'Error toggling Sign-In state.', // Error message if the toggle logic fails.


                           // --- Simulated Google Pay Messages ---
                           GOOGLE_PAY_INIT: 'Initializing Google Pay...', // Message during GPay service init.
                           GOOGLE_PAY_READY_CHECK_START: 'Checking Google Pay availability...', // Message during the readiness check.
                           GOOGLE_PAY_AVAILABLE: 'Google Pay is available on this device.', // Message after successful readiness check.
                           GOOGLE_PAY_UNAVAILABLE: 'Google Pay is not available on this device or browser.', // Message after failed readiness check.
                           GOOGLE_PAY_CONFIG_MISSING: 'Google Pay configuration is missing or invalid.', // Specific config missing message.
                           GOOGLE_PAY_CLICKED: 'Initiating Google Pay process...', // Message right after button click.
                           GOOGLE_PAY_PROCESSING: 'Processing payment with Google Pay...', // Message displayed while `loadPaymentData` is running.
                           GOOGLE_PAY_SUCCESS: 'Payment processed successfully!', // Message upon successful simulated payment.
                           GOOGLE_PAY_FAILED: (err) => `Google Pay payment failed. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon simulated payment failure.
                           GOOGLE_PAY_CANCELLED: 'Google Pay process cancelled by user.', // Message when user cancels the simulated flow.
                           GOOGLE_PAY_DISABLED_MESSAGE: (reason) => `Google Pay button is disabled. ${reason || ''}`, // Message template for disabled button tooltip.


                           // --- Simulated Google Calendar Messages ---
                           CALENDAR_SERVICE_MISSING: 'Google Calendar service not available.', // Service missing message.
                           CALENDAR_ADD_INIT: 'Preparing calendar event details...', // Message before calling service.
                           CALENDAR_ADD_PROCESSING: 'Adding event to Google Calendar...', // Message displayed while service call runs.
                           CALENDAR_ADD_SUCCESS: 'Event added successfully!', // Message upon simulated success.
                           CALENDAR_ADD_FAILED: (err) => `Failed to add event to Calendar. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon simulated failure.

                           // --- Simulated Google Email Messages ---
                           EMAIL_SERVICE_MISSING: 'Google Email service not available.', // Service missing message.
                           EMAIL_SEND_INIT: 'Preparing email with search details...', // Message before calling service.
                           EMAIL_SEND_PROCESSING: 'Sending email...', // Message displayed while service call runs.
                           EMAIL_SEND_SUCCESS: 'Email sent successfully!', // Message upon simulated success.
                           EMAIL_SEND_FAILED: (err) => `Failed to send email. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon simulated failure.
                           EMAIL_SEND_NOT_ALLOWED_SIMULATION: 'Emailing details is not available for simulated users.', // Specific message if simulation has limitations (like sending to only one user).

                           // --- Simulated Google Apps Script Messages ---
                           APPS_SCRIPT_SERVICE_MISSING: 'Google Apps Script service not available.', // Service missing message.
                           APPS_SCRIPT_ENDPOINT_MISSING: 'Google Apps Script endpoint is not configured.', // Configuration missing message.
                           APPS_SCRIPT_SEND_INIT: 'Preparing data for Apps Script...', // Message before calling service.
                           APPS_SCRIPT_SEND_PROCESSING: 'Sending data to Apps Script...', // Message displayed while service call runs.
                           APPS_SCRIPT_SEND_SUCCESS: 'Data sent to Apps Script successfully!', // Message upon simulated success.
                           APPS_SCRIPT_SEND_FAILED: (err) => `Failed to send data to Apps Script. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon simulated failure.

                           // --- Simulated Generative AI Messages ---
                           GENAI_SERVICE_MISSING: 'GenAI Tip service not available.', // Service missing message.
                           GENAI_ENDPOINT_MISSING: 'GenAI tip endpoint is not configured.', // Configuration missing message.
                           GENAI_TIP_INIT: (dest) => `Fetching AI tip for ${dest?.trim() || 'your destination'}...`, // Message before calling service.
                           GENAI_TIP_LOADING: 'Loading destination tip...', // Message displayed during service call.
                           GENAI_TIP_SUCCESS: (tip) => tip?.trim() || 'No specific tip available at this time, but enjoy your trip!', // Message for successful tip display. Handles null/empty tip.
                           GENAI_TIP_FAILED: (err) => `Failed to load AI tip. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon simulated failure.


                           // --- IndexedDB History Messages ---
                           HISTORY_LOAD_INIT: 'Loading search history...', // Message during history fetch from DB.
                           HISTORY_LOAD_SUCCESS: 'Search history loaded.', // Message after successful load.
                           HISTORY_LOAD_FAILED: (err) => `Failed to load search history from local storage. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon load failure.
                           HISTORY_SAVED_SUCCESS: 'Search history saved locally.', // Message upon successful save.
                           HISTORY_SAVED_FAILED: (err) => `Failed to save search history locally. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon save failure.
                           HISTORY_CLEAR_INIT: 'Clearing search history...', // Message during clear operation.
                           HISTORY_CLEARED_SUCCESS: 'Search history cleared.', // Message after successful clear.
                           HISTORY_CLEARED_FAILED: (err) => `Failed to clear search history. ${err ? `Details: ${err}` : AppConfig.MESSAGES.INTERNAL_ERROR}`, // Message upon clear failure.
                           HISTORY_EMPTY: 'No recent searches found in local history.', // Message when history is empty.
                           HISTORY_ITEM_CLICKED: (dest) => `Loading search "${dest || 'N/A'}" from history...`, // Message when history item is clicked.
                           HISTORY_ITEM_PARSE_ERROR: 'Error parsing history item data.', // Error if history item JSON is bad.


                       }, // End MESSAGES Config


                       // Timers & Delays (in milliseconds) - Used primarily for simulating async operations and UI feedback timing.
                       DEBOUNCE_DELAY_MS: 300, // Delay for debouncing input events if needed (e.g., for search-as-you-type - not fully implemented here).
                       VALIDATION_DELAY_MS: 150, // Small delay after 'blur' events on inputs, especially important for Autocomplete, before triggering validation.
                       MESSAGE_DISPLAY_DURATION_MS: 6000, // Default duration for temporary messages displayed in the main message area. `0` for persistent.
                       SIMULATED_ASYNC_PROCESS_DELAY_MS: 800, // Delay to simulate latency for general asynchronous backend/processing calls (e.g., main search step).
                       SIMULATED_SERVICE_DELAY_MS: 600, // General delay to simulate latency for calls to specific simulated services (Google APIs, Apps Script, GenAI). Shorter than main process simulation.
                       GA_REDIRECT_DELAY_MS: 300, // A short delay *after* triggering a GA tracking event before performing a page redirect. Increases the chance the GA hit is sent.
                       SIMULATED_READY_CHECK_DELAY_MS: 200, // Short delay for simulated service readiness checks (e.g., Google Pay isReady).

                       // Error Handling Configuration
                       // SIMULATED_SERVICE_FAILURE_RATE: 0.15 // Example: 15% chance for simulated service calls to fail randomly (can be defined per service).
                   }; // End AppConfig object.

                   // --- Global Utility Functions and Classes ---
                   // These classes and functions are defined outside the main application instance
                   // but within the IIFE scope, making them accessible to all parts of the application
                   // that are within the IIFE. They often implement cross-cutting concerns like logging,
                   // error handling, and UI messaging.


                   // --- Utility Class for Console Logging ---
                   // Provides static methods for structured console logging with timestamps and levels (INFO, WARN, ERROR, DEBUG).
                   // Can be easily enabled/disabled. Uses console methods and styling for clarity.
                   class Logger {
                       // Static property to control if logging is enabled globally. `true` by default to show logs.
                       static isEnabled = true; // Set to `false` to disable all Logger output in the browser console.

                       // Static property to control debug logging visibility separately. `true` by default to show debug logs.
                       static debugEnabled = true; // Set to `false` to hide DEBUG level logs.

                       /**
                        * Private static method to get a consistently formatted timestamp string for log entries.
                        * @returns {string} A string representing the current time (e.g., "13:45:30"). Returns "TIME_ERR" on error.
                        * @private
                        */
                       static #getTimestamp() {
                           try {
                               // Create a new Date object representing the current moment.
                               const now = new Date();
                               // Format the time parts (hours, minutes, seconds) using `toLocaleTimeString` for standard formatting,
                               // or build the string manually with `padStart`. Using `toLocaleTimeString` is often locale-aware.
                               return now.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', second: '2-digit', hour12: false }); // Example format: "13:45:30".
                           } catch (error) {
                               // If there's an error getting the timestamp (e.g., system clock issues), log a fallback console error.
                               console.error("Logger.#getTimestamp: Error getting timestamp!", error);
                               return 'TIME_ERR'; // Return a placeholder string if timestamp retrieval fails.
                           }
                       }

                       /**
                        * Static method for logging informative messages to the console.
                        * Logged messages include a timestamp and an "[INFO]" prefix, with styling.
                        * Only logs if `Logger.isEnabled` is `true`.
                        * @param {string} message - The main message string to log.
                        * @param {...*} args - Additional arguments to log alongside the message (e.g., objects, variables). These will be logged by `console.log` after the formatted message string.
                        */
                       static info(message, ...args) {
                           // Check if logging is enabled globally.
                           if (Logger.isEnabled) {
                               try {
                                   // Get the current formatted timestamp.
                                   const timestamp = Logger.#getTimestamp();
                                   // Use `console.log`. Apply CSS styling using `%c` escape code and the second argument.
                                   // The styling sets the color of the log entry prefix.
                                   console.log(`%c[INFO] [${timestamp}] ${message}`, 'color: #2196F3;', ...args); // Styled blue text for INFO.
                               } catch (e) {
                                   // Fallback to basic console log if formatting or styled logging fails unexpectedly.
                                   console.log(`[INFO] ${message}`, ...args);
                               }
                           }
                       }

                       /**
                        * Static method for logging warning messages to the console.
                        * Logged messages include a timestamp and a "[WARN]" prefix, with styling.
                        * Only logs if `Logger.isEnabled` is `true`.
                        * @param {string} message - The main message string to log.
                        * @param {...*} args - Additional arguments to log.
                        */
                       static warn(message, ...args) {
                           // Check if logging is enabled globally.
                           if (Logger.isEnabled) {
                                try {
                                    const timestamp = Logger.#getTimestamp();
                                    // Use `console.warn`. Apply styling using `%c`.
                                   console.warn(`%c[WARN] [${timestamp}] ${message}`, 'color: #ff9800;', ...args); // Styled orange text for WARNING.
                                } catch (e) {
                                    console.warn(`[WARN] ${message}`, ...args);
                                }
                           }
                       }

                       /**
                        * Static method for logging error messages to the console.
                        * Logged messages include a timestamp and an "[ERROR]" prefix, with styling.
                        * Only logs if `Logger.isEnabled` is `true`.
                        * Includes information from the error object (like stack trace) depending on the console.
                        * @param {string} message - The main message string to log.
                        * @param {...*} args - Additional arguments to log.
                        */
                       static error(message, ...args) {
                           // Check if logging is enabled globally.
                           if (Logger.isEnabled) {
                                try {
                                    const timestamp = Logger.#getTimestamp();
                                    // Use `console.error`. Apply styling using `%c`.
                                     // console.error also often includes stack traces automatically for Error objects.
                                   console.error(`%c[ERROR] [${timestamp}] ${message}`, 'color: #f44336;', ...args); // Styled red text for ERROR.
                                } catch (e) {
                                    console.error(`[ERROR] ${message}`, ...args);
                                }
                           }
                       }

                       /**
                        * Static method for logging debug messages to the console.
                        * Logged messages include a timestamp and a "[DEBUG]" prefix, with styling.
                        * Only logs if `Logger.isEnabled` is `true` AND `Logger.debugEnabled` is `true`.
                        * Debug logs are often hidden by default in browser consoles or formatted differently.
                        * @param {string} message - The main message string to log.
                        * @param {...*} args - Additional arguments to log.
                        */
                       static debug(message, ...args) {
                           // Check if logging is enabled AND debug logging is specifically enabled.
                           if (Logger.isEnabled && Logger.debugEnabled) {
                                try {
                                     const timestamp = Logger.#getTimestamp();
                                     // Use `console.debug`. Apply styling using `%c`.
                                    console.debug(`%c[DEBUG] [${timestamp}] ${message}`, 'color: #607d8b;', ...args); // Styled grey/blue for DEBUG.
                                } catch (e) {
                                    console.debug(`[DEBUG] ${message}`, ...args);
                                }
                           }
                       }
                   } // End of Logger class.


                   // --- Error Reporter Class ---
                   // This class centralizes the handling of errors throughout the application.
                   // It provides a single point for components and services to report errors.
                   // Upon reporting an error, it performs multiple actions:
                   // 1. Logs the detailed error to the browser console (using `Logger`).
                   // 2. Displays a user-friendly message in the main application UI message area (`#mainMessageDisplay`).
                   // 3. Tracks the error as a specific event in Google Analytics (GA4).
                   // This design ensures consistent error reporting across the application.
                   class ErrorReporter {
                        // Private members holding references to the services used for reporting.
                        #messageDisplay; // Reference to the MessageDisplay service instance.
                        #gaTracker; // Reference to the Google Analytics Tracker service instance.

                       /**
                        * Constructor for ErrorReporter.
                        * Requires instances of `MessageDisplay` and `GoogleAnalyticsTracker` to perform its functions.
                        * These dependencies are injected during creation (e.g., in the `SearchForm` constructor).
                        * @param {MessageDisplay} messageDisplay - An instance of the MessageDisplay class. Required.
                        * @param {GoogleAnalyticsTracker} gaTracker - An instance of the GoogleAnalyticsTracker class. Required.
                        */
                        constructor(messageDisplay, gaTracker) {
                           try {
                               Logger.debug("ErrorReporter constructor called.");

                                // Validate required service instances. If either is missing or invalid,
                                // set the corresponding private member to a dummy object with fallback behavior (console logging)
                                // to prevent method calls crashing, but highlight the issue.
                               if (!messageDisplay || typeof messageDisplay.showMessage !== 'function') {
                                   const errorMsg = "MessageDisplay instance provided to ErrorReporter is missing or invalid. UI message display from ErrorReporter will fallback to console.";
                                   Logger.error(errorMsg);
                                   this.#messageDisplay = { showMessage: (msg, type, duration) => Logger.error(`[ErrorReporter -> NoUI MsgDisplay Fallback] ${type}: ${msg}`) }; // Provide a dummy fallback object.
                               } else {
                                  this.#messageDisplay = messageDisplay; // Store the valid MessageDisplay instance.
                               }

                               if (!gaTracker || typeof gaTracker.trackEvent !== 'function') {
                                   const errorMsg = "GoogleAnalyticsTracker instance provided to ErrorReporter is missing or invalid. GA error tracking from ErrorReporter will fallback to console.";
                                   Logger.error(errorMsg);
                                    // Provide a dummy fallback object for GA tracking methods.
                                   this.#gaTracker = { trackEvent: (name, params) => Logger.warn(`[ErrorReporter -> NoGA Track Fallback] Event: ${name}`, params), trackFunnelStep: (name, params) => Logger.warn(`[ErrorReporter -> NoGA Funnel Fallback] Funnel: ${name}`, params) };
                               } else {
                                  this.#gaTracker = gaTracker; // Store the valid GA Tracker instance.
                               }

                               Logger.debug("ErrorReporter initialized with services.");

                           } catch (error) {
                                // Catch errors that occur during the construction of the ErrorReporter itself.
                                // Log a console error as this is a critical failure in the error reporting system.
                              Logger.error("FATAL: Error initializing ErrorReporter!", error, { step: 'constructor_execution' });
                               // Set up minimal dummy reporter properties to prevent later calls from throwing errors, even if reporting won't work.
                               this.#messageDisplay = { showMessage: (msg, type, duration) => console.error(`[FATAL ErrorReporter Init Fallback] ${type}: ${msg}`) };
                               this.#gaTracker = { trackEvent: () => {}, trackFunnelStep: () => {} };
                               // Do not re-throw from here; allow the outer catch block in the bootstrap logic to handle the fatal error and ensure basic console logging happens.
                           }
                       }

                       /**
                        * Reports an error encountered anywhere in the application system.
                        * This is the main method used by other components and services to signal an error.
                        * It orchestrates logging, UI message display, and GA error tracking in a consistent way.
                        * @param {string} source - A string identifying the origin or location where the error was caught (e.g., 'ClassName.methodName', 'form_submit_handler'). Helps pinpoint the error source in logs and analytics. Required.
                        * @param {*} error - The error object or any value that was caught in the `catch` block. This can be an `Error` instance (preferred, as it includes stack trace), a Promise rejection reason, or any other value.
                        * @param {object} [context={}] - An optional plain JavaScript object providing additional context relevant to the specific error occurrence (e.g., input ID, parameter values involved, current state variables). This context is included in logging and GA tracking. Defaults to an empty object.
                        * @param {string} [uiMessage] - An optional, user-friendly message string to display to the end-user in the main application UI message area. If not provided, a default error message is used. This message should be understandable to the user and describe the outcome.
                        * @param {string} [gaErrorCode="unexpected_error"] - A short, consistent code string representing the type of error for categorizing and filtering in Google Analytics event parameters. Defaults to "unexpected_error". Choose specific codes for different types of errors (e.g., 'validation_exception', 'api_fetch_failed', 'indexeddb_error').
                        * @param {number} [uiDuration=0] - The duration (in milliseconds) for which the UI message should be displayed. `0` means the message will remain visible persistently until explicitly cleared by calling `messageDisplay.clearMessage()`. Defaults to persistent (0).
                        */
                        reportError(source, error, context = {}, uiMessage = AppConfig.MESSAGES.SEARCH_PROCESS_ERROR, gaErrorCode = "unexpected_error", uiDuration = 0) {
                            try {
                                // Defensive check: Ensure the `source` parameter is a string, providing a fallback if not.
                                const errorSourceIdentifier = typeof source === 'string' && source.trim() !== '' ? source : 'UnknownErrorSource';
                                // Defensive check: Ensure `context` is a plain object.
                                const errorContextData = typeof context === 'object' && context !== null ? context : {};


                                // 1. Log the detailed error to the browser console using the Logger utility.
                                // Include the determined source identifier, the error object/value itself, and the context data.
                                Logger.error(`Error reported from ${errorSourceIdentifier}:`, error, { contextData: errorContextData });

                                // 2. Determine the final message string to display to the user in the UI.
                                // Use the provided `uiMessage` and append the underlying technical error's message or string representation for more detail.
                                const rawErrorMessage = error instanceof Error ? error.message : String(error); // Get the error message or convert the value to a string.
                                // Concatenate the user-friendly message with the technical detail if the technical message exists.
                                const displayMessageToUser = `${uiMessage}${rawErrorMessage ? `: ${rawErrorMessage}` : '.'}`; // Append details if available. Example: "Error failed: Some error detail."


                                // 3. Display the user-friendly error message in the designated UI area.
                                // Use the injected `messageDisplay` instance's `showMessage` method.
                                // Check if the `messageDisplay` instance is valid and has the `showMessage` method.
                                if (this.#messageDisplay && typeof this.#messageDisplay.showMessage === 'function') {
                                     // Call showMessage with the formatted user message, error type, and specified duration.
                                    this.#messageDisplay.showMessage(displayMessageToUser, 'error', uiDuration); // 'error' type for red styling.
                                } else {
                                    // If the `messageDisplay` service is unavailable or malfunctioning, log a warning using the console fallback method.
                                    // The error was already logged fully in Step 1.
                                    Logger.warn(`ErrorReporter: MessageDisplay service is not available or showMessage method missing to display error message in UI. Message: "${displayMessageToUser}".`);
                                }

                                // 4. Track the error as a specific event in Google Analytics (GA4) for analysis.
                                // Use the injected `gaTracker` instance.
                                // Check if the `gaTracker` instance is valid and has the `trackEvent` method.
                                if (this.#gaTracker && typeof this.#gaTracker.trackEvent === 'function') {
                                    try {
                                         // Prepare the parameters for the GA error event.
                                         const gaEventParameters = {
                                            'error_source': errorSourceIdentifier, // The source (class.method).
                                            'error_code': gaErrorCode, // The specific, categorized error code.
                                            'error_message': rawErrorMessage, // The technical error message string.
                                             // Include stack trace if available (be mindful of data volume sent to GA, may need truncation).
                                             // 'error_stack': error instanceof Error && error.stack ? error.stack.substring(0, 500) : undefined, // Example with truncation.
                                            'error_severity': 'handled_exception', // Indicate this error was caught and handled. Use 'unhandled_rejection' or similar for global catches.
                                            // Include the determined context data by spreading the `errorContextData` object.
                                            ...errorContextData
                                         };

                                        // Track a general 'app_error' event in GA, categorized by the specific `gaErrorCode`.
                                        // This allows creating GA reports that count all application errors and filter/segment by error code or source.
                                        this.#gaTracker.trackEvent('app_error', gaEventParameters);
                                        // Log debug message indicating the GA event was triggered.
                                         Logger.debug(`Error reported and tracked in GA: app_error event with code "${gaErrorCode}".`, { gaEventParameters: gaEventParameters });

                                    } catch (gaTrackError) {
                                        // If an error occurs *specifically while attempting to track the error in GA*, log a console error as a last resort.
                                         // The original error and reporting should have been logged and displayed already.
                                        Logger.error("ErrorReporter: Failed to track error in Google Analytics!", gaTrackError, { originalErrorSource: errorSourceIdentifier, originalErrorCode: gaErrorCode, originalError: error });
                                    }
                                } else {
                                    // If the `gaTracker` service is unavailable or malfunctioning, log a debug message that GA tracking was skipped for this error.
                                    Logger.debug(`ErrorReporter: Google Analytics Tracker service is not available or trackEvent method missing. Skipping GA error tracking for "${gaErrorCode}".`);
                                }

                            } catch (reporterError) {
                                 // --- Handle Errors Within the Error Reporting Logic Itself ---
                                 // This outer catch block is a final safety net. It catches any unexpected errors that occur *within the `reportError` method itself*
                                 // (e.g., errors during logging setup, message formatting, UI access, or GA tracking calls if they aren't wrapped robustly).
                                 // This indicates a critical failure in the error reporting system.
                                Logger.error("FATAL: ErrorReporter encountered a critical error while attempting to report an error!", reporterError, { originalErrorSource: source, originalError: error, originalContext: context });
                                 // At this point, further attempts at structured reporting might fail. Fallback to console logging as much original info as possible.
                                console.error("--- Original Error Being Reported (as fallback due to reporter error) ---");
                                console.error(`Source: ${source}`);
                                console.error(`Original Error Object:`, error);
                                console.error(`Original Context:`, context);
                                console.error(`Requested UI Message: ${uiMessage}`);
                                console.error(`Requested GA Code: ${gaErrorCode}`);
                                console.error(`Requested UI Duration: ${uiDuration}`);
                                console.error("-------------------------------------");
                                // No re-throw needed, this is the last point for handling.
                            }
                        } // End of reportError method.

                    } // End of ErrorReporter constructor.


                    // --- Message Display Service ---
                    // This class is responsible for displaying application-level messages (status, info, success, warning, error)
                    // in a designated HTML element (`#mainMessageDisplay`) in the UI. It manages the element's text content,
                    // styling based on message type, visibility, and auto-hiding via a timer.
                    class MessageDisplay {
                        // Private member holding a reference to the HTML element where messages are displayed.
                        #messageElement = null; // Initialized to null.
                        // Private member to store the timer ID returned by `setTimeout` for auto-hiding messages.
                        #timerId = null; // Initialized to null.

                       /**
                        * Constructor for MessageDisplay.
                        * Finds the HTML element targeted by the provided CSS selector. Initializes its basic state (hidden, empty).
                        * If the HTML element is not found, the service will log a warning, and UI messages will only be displayed via console fallbacks.
                        * @param {string} elementSelector - The CSS selector string for the HTML element where messages should be displayed (e.g., '#mainMessageDisplay'). Required.
                        * @throws {Error} If a required parameter (`elementSelector`) is invalid or missing, indicating a configuration error.
                        */
                       constructor(elementSelector) {
                           try {
                               Logger.debug(`MessageDisplay constructor called with selector: "${elementSelector}".`);

                                // Validate the provided element selector. It must be a non-empty string.
                                if (typeof elementSelector !== 'string' || elementSelector.trim() === '') {
                                     const errorMsg = "Invalid or empty element selector provided to MessageDisplay constructor.";
                                    Logger.error(errorMsg, { selector: elementSelector });
                                     // Throw an error here, as the service cannot function without a valid selector to find its element.
                                    throw new Error(errorMsg);
                                }

                                // Attempt to find the HTML element in the DOM using the selector.
                                this.#messageElement = document.querySelector(elementSelector);

                                // Check if the HTML element was found.
                                if (!this.#messageElement) {
                                    // If the element is not found, log a warning. The service instance will still be created,
                                    // but UI messages will only be displayed via the console fallback logging in `showMessage`.
                                    Logger.warn(`Message display element not found with selector: "${elementSelector}". UI messages from this service will be logged to console instead.`);
                                    // No further action needed here; the instance is usable with null #messageElement.

                                } else {
                                     // If the element is found, initialize its state:
                                     // Ensure it has necessary base classes (e.g., for styling) and is initially hidden.
                                     this.#messageElement.classList.add('w3-panel'); // Add a base W3CSS panel class (example).
                                    this.#messageElement.classList.add('app-hide'); // Add a custom utility class to hide it initially.
                                     // Clear any pre-existing content within the element.
                                    this.#messageElement.textContent = '';
                                    Logger.debug(`Message display element found and initialized with selector "${elementSelector}".`);
                                }

                                // Initialize the timer ID to null.
                                this.#timerId = null;

                                // Log successful initialization.
                                Logger.debug('MessageDisplay initialized.');

                           } catch (error) {
                                // Catch any unexpected errors that occur *during the MessageDisplay constructor's execution itself*.
                                // Log a FATAL console error as this indicates a problem with the messaging system setup itself.
                              Logger.error("FATAL: Error initializing MessageDisplay!", error, { selectorAttempted: elementSelector, step: 'constructor_execution' });
                               // Clear the element reference defensively if the constructor failed, in case it was partially set.
                               this.#messageElement = null;
                               // Re-throw the error to signal a critical initialization failure.
                               throw error;
                           }
                       }

                       /**
                        * Private method to clear the auto-hide timer if one is currently active (`#timerId` is not null).
                        * Called by `clearMessage()` and by the auto-hide timeout callback.
                        */
                       #clearTimer() {
                           try {
                                // Check if there is an active timer ID set.
                               if (this.#timerId !== null) { // Check against null as `0` can be a valid ID from `setTimeout`.
                                    // Cancel the scheduled timeout using its ID.
                                   clearTimeout(this.#timerId);
                                    // Reset the internal `#timerId` variable to null.
                                   this.#timerId = null;
                                    // Logger.debug("Message auto-hide timer cleared."); // Verbose logging.
                               }
                           } catch (error) {
                                // Catch and log errors occurring *while clearing the timer*. Use console.error as this is a core utility.
                                Logger.error("MessageDisplay.#clearTimer: Error clearing message timer:", error);
                           }
                       }

                       /**
                        * Public method to display a message to the user in the designated UI message area.
                        * Clears any previously displayed message and auto-hide timer.
                        * Sets the text content and applies styling classes based on the message `type`.
                        * Controls element visibility and sets an auto-hide timer if a `duration` > 0 is provided.
                        * @param {string} message - The message text string to display to the user. Can be a simple status, info, warning, or error message.
                        * @param {string} [type='info'] - The type of message ('info', 'success', 'warning', 'error'). Used to determine styling (e.g., color, border) via CSS classes. Defaults to 'info'. Maps to W3CSS classes like `w3-pale-info`, `w3-pale-success`, etc.
                        * @param {number} [duration=AppConfig.MESSAGE_DISPLAY_DURATION_MS] - The duration (in milliseconds) for which the message should be displayed. If `duration` is `0`, the message will remain visible indefinitely until `clearMessage()` is called explicitly. Defaults to the value in `AppConfig.MESSAGE_DISPLAY_DURATION_MS`.
                        */
                       showMessage(message, type = 'info', duration = AppConfig.MESSAGE_DISPLAY_DURATION_MS) {
                           try {
                                // Check if the dedicated message display element was found and is available.
                               if (!this.#messageElement) {
                                    // If the element is null (was not found in constructor), log the message to console as a fallback.
                                   Logger.warn(`MessageDisplay element not found. Logging message to console instead (Type: ${type}): "${message}".`);
                                    // Use appropriate console method based on type for fallback logging.
                                   switch(type) {
                                       case 'error': console.error(`[UI Message Error Fallback] ${message}`); break;
                                       case 'warning': console.warn(`[UI Message Warning Fallback] ${message}`); break;
                                       case 'success': console.info(`[UI Message Success Fallback] ${message}`); break;
                                       case 'info':
                                       default: console.log(`[UI Message Info Fallback] ${message}`); break;
                                   }
                                   return; // Exit the method as UI display is not possible.
                               }

                                // --- Clear Previous Message ---
                                // Before displaying a new message, clear any message currently displayed in the UI element.
                                // This also clears any pending auto-hide timer.
                               this.clearMessage();

                                // --- Set Message Content and Styling ---
                                // Set the text content of the message element using `textContent` to prevent HTML injection (XSS)
                                // unless you specifically intend to allow HTML content (then use `innerHTML`).
                               this.#messageElement.textContent = message;

                                // Apply styling classes based on the message `type`. Use W3CSS classes as examples.
                                // Ensure the base panel class is added.
                                this.#messageElement.classList.add('w3-panel');
                                 // Remove any existing type-specific color classes to ensure only the new one is applied.
                                 this.#messageElement.classList.remove('w3-pale-green', 'w3-pale-yellow', 'w3-pale-red', 'w3-pale-blue');
                                // Add the appropriate type-specific color class based on the `type` parameter.
                                switch(type) {
                                    case 'success': this.#messageElement.classList.add('w3-pale-green'); break; // Green for success.
                                    case 'warning': this.#messageElement.classList.add('w3-pale-yellow'); break; // Yellow for warning.
                                    case 'error': this.#messageElement.classList.add('w3-pale-red'); break; // Red for error.
                                    case 'info':
                                    default: this.#messageElement.classList.add('w3-pale-blue'); break; // Blue for info or default.
                                }

                                // --- Show the Message Element ---
                                // Make the message element visible by removing the 'app-hide' utility class.
                                this.#messageElement.classList.remove('app-hide');

                                // Log a debug message confirming that the message was displayed.
                                Logger.debug(`MessageDisplay: Displayed message (Type: ${type}, Duration: ${duration === 0 ? 'infinite' : duration + 'ms'}): "${message}".`);

                                // --- Set Auto-Hide Timer (if duration > 0) ---
                                // If a display `duration` greater than 0 is provided, set a timer to automatically hide the message.
                                if (duration > 0) {
                                    // Use `setTimeout`. The callback function clears the message using `clearMessage()`.
                                    this.#timerId = setTimeout(() => {
                                        try {
                                            // Inside the timeout callback, clear the message.
                                            this.clearMessage(); // Call the public `clearMessage` method to hide and reset state.
                                            Logger.debug('MessageDisplay: Message auto-hidden after timeout.');
                                        } catch (error) {
                                            // Catch any errors occurring *inside* the timeout callback execution itself.
                                            // This is a defensive catch for logic errors within the callback.
                                           Logger.error("MessageDisplay.showMessage -> timeout callback: Error during message auto-hide execution:", error);
                                            // Do not re-throw.
                                        }
                                    }, duration); // Use the specified duration.
                                     // Log the timer ID if needed for debugging/reference.
                                     // Logger.debug(`MessageDisplay: Auto-hide timer set with ID: ${this.#timerId}`);
                                }

                            } catch (error) {
                                 // Catch any unexpected errors occurring *during the synchronous process* of displaying the message (e.g., during element access, class manipulation).
                                 // Log the error using the Logger utility.
                                 Logger.error(`MessageDisplay.showMessage: Error displaying message "${message}" (Type: ${type}, Duration: ${duration}):`, error);
                                // No re-throw needed, this method's purpose is to display errors/status, errors during display shouldn't stop other logic.
                            }
                       }

                       /**
                        * Public method to clear/hide the currently displayed message from the UI message area.
                        * Stops any active auto-hide timer, clears the element's text content, removes styling classes,
                        * and adds the 'app-hide' class to visually hide the element.
                        */
                       clearMessage() {
                           try {
                                // Check if the message element is available.
                               if (this.#messageElement) {
                                    // --- Clear Timer ---
                                    // Cancel any pending auto-hide timer associated with the current message.
                                   this.#clearTimer(); // Use the private helper method.

                                    // --- Clear Content and Styling ---
                                    // Clear the text content of the message element.
                                   this.#messageElement.textContent = '';

                                    // Remove all type-specific and base styling classes to return the element to a clean hidden state.
                                     this.#messageElement.classList.remove('w3-pale-green', 'w3-pale-yellow', 'w3-pale-red', 'w3-pale-blue');
                                    // Remove the base W3CSS panel class too if it should only apply when message is visible.
                                     // this.#messageElement.classList.remove('w3-panel');

                                     // --- Hide the Element ---
                                     // Hide the message element visually by adding the 'app-hide' utility class.
                                    this.#messageElement.classList.add('app-hide');

                                    // Log a debug message confirming that the message was cleared.
                                     // Logger.debug('MessageDisplay: Message cleared.'); // Verbose logging.

                               }
                           } catch (error) {
                                // Catch and log any unexpected errors occurring *during the process* of clearing the message.
                                Logger.error("MessageDisplay.clearMessage: Error clearing message:", error);
                                // No re-throw needed.
                           }
                       }

                       /**
                        * Dispose method for cleanup on application shutdown or when the MessageDisplay instance is no longer needed.
                        * Ensures any pending timer is stopped, the message is cleared from the UI,
                        * and nullifies the element reference. In a typical web page application where MessageDisplay
                        * is a key utility throughout the page's lifecycle, explicit disposal is often less common
                        * than for component instances tied to specific DOM nodes that are dynamically removed.
                        */
                       dispose() {
                            try {
                                Logger.debug("MessageDisplay.dispose: Disposing MessageDisplay service.");
                                // Ensure any active auto-hide timer is cancelled.
                                this.#clearTimer();

                                // Clear the message content and hide the element from the UI on disposal.
                                // This handles cases where a persistent error message might be showing.
                                 if (this.#messageElement) {
                                    this.clearMessage(); // Use the public method to ensure UI state is reset.
                                     Logger.debug("MessageDisplay.dispose: Message cleared from UI element.");
                                 } else {
                                    Logger.debug("Dispose: MessageDisplay element was null, no UI clear needed.");
                                 }

                                // Clear the reference to the DOM element. This aids garbage collection.
                                this.#messageElement = null;
                                // The `#timerId` reference is cleared by `#clearTimer()`.

                                Logger.debug("MessageDisplay disposed.");

                            } catch (error) {
                                 // Catch and log any unexpected errors occurring *during the disposal process*.
                                 // Use console.error as this is a core utility and ErrorReporter might not be available.
                                 Logger.error("CRITICAL ERROR during MessageDisplay disposal:", error);
                                // Do not re-throw.
                            }
                        }
                   } // End of MessageDisplay class.


                   // --- Base Class for any UI Component ---
                   // This class serves as the foundational base class for all UI components in the application
                   // that are associated with and manage a specific HTML DOM element.
                   // It provides common functionalities including finding and storing the wrapped DOM element,
                   // storing its ID and a descriptive name, maintaining a basic internal validity state,
                   // adding and removing DOM event listeners safely, and implementing a standard disposal pattern.
                   class TravelComponent {
                       // Private members (ES2022+ `#` syntax) - Data strictly encapsulated within the class instance.
                       #componentId; // The unique identifier for the component, typically derived from the ID of the HTML element it wraps.
                       #componentName; // A descriptive string name for the component type (e.g., 'SearchForm', 'InputComponent'). Used primarily for logging and debugging.

                       // Protected members (underscore `_` convention) - Intended for use by the class itself and its subclasses.
                       // Access from outside instances is discouraged by convention, though not enforced by JavaScript.
                       _element; // A reference to the HTML DOM element that this component instance is associated with and wraps. This is the primary element the component manages. `null` if not found.
                       _isValid = true; // An internal boolean flag representing the component's current validation status. Initialized to `true`, updated by `_validate()`.
                       _eventHandlers = {}; // An object map used to store references to all DOM event listeners attached by this component instance (using `_addEventListener`). This allows systematic removal during disposal to prevent memory leaks. Structured as: `{ elementIdentifier: { eventType: [{ handler, options, targetElement }, ...] }, ... }`.
                        _errorReporter; // Reference to the shared `ErrorReporter` instance. This dependency is injected during construction and used for logging, UI messaging, and GA tracking of errors originating from this component.


                       // Static property - Belongs to the `TravelComponent` class itself, not to individual instances.
                       // Accessed directly on the class name (e.g., `TravelComponent.APP_VERSION`). Useful for shared constants or data not tied to any specific component instance.
                       static APP_VERSION = AppConfig.APP_VERSION; // Stores the application version from AppConfig.

                       /**
                        * Static method - Belongs to the `TravelComponent` class itself.
                        * A utility method to log the application version. Can be called without creating a component instance.
                        */
                       static logAppVersion() {
                           // Uses the global `Logger` utility to log the application version using the static `APP_VERSION` property.
                           Logger.info(`App Version: ${TravelComponent.APP_VERSION}`);
                       }

                       /**
                        * Constructor for the base `TravelComponent`.
                        * It is responsible for:
                        * 1. Validating essential input parameters (`elementId`, `errorReporter`).
                        * 2. Initializing the component's private members (`#componentId`, `#componentName`).
                        * 3. Attempting to find and store a reference to the corresponding HTML element in the DOM using the provided `elementId`.
                        * 4. Initializing the component's protected validity state (`_isValid`). If the HTML element is not found, the component is marked as invalid.
                        * 5. Initializing the map for storing event handlers (`_eventHandlers`).
                        * 6. Injecting the shared `ErrorReporter` instance and storing its reference.
                        * 7. Calling the protected `_initialize` method (which subclasses override) if the HTML element was found.
                        * Errors during construction (except for finding the element, which results in isValid=false) are logged and re-thrown.
                        * @param {string} elementId - The unique ID attribute value of the HTML element this component should wrap and manage. Required.
                        * @param {string} [componentName='TravelComponent'] - A descriptive name for this specific type of component (e.g., 'SearchForm', 'DestinationInput'). Defaults to 'TravelComponent'.
                        * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. This dependency is injected into the component to enable centralized error reporting. Required.
                        * @throws {Error} If a required parameter (like `elementId`) is invalid or missing during construction, or if the `errorReporter` is not provided and deemed critical (though the code includes a fallback).
                        */
                       constructor(elementId, componentName = 'TravelComponent', errorReporter) {
                            try {
                                // Log the start of the constructor for debugging and tracing component creation.
                                Logger.debug(`TravelComponent constructor called for element ID "${elementId}" as component "${componentName}".`);

                                // --- Validate Required Dependencies ---
                                // Check if the required `ErrorReporter` instance was provided. Without it, error reporting within the component hierarchy will be compromised.
                               if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                                    const errorMsg = `ErrorReporter instance not provided or is invalid for component "${componentName}" (ID: "${elementId}"). Error handling from this component may be compromised.`;
                                    Logger.error(errorMsg, { elementId: elementId, componentName: componentName, reporterProvided: !!errorReporter });
                                    // If the reporter is missing, set `this._errorReporter` to a dummy object that logs errors directly to the console.
                                    // This prevents method calls (`this._errorReporter.reportError(...)`) from crashing but indicates the issue.
                                    this._errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[COMPONENT_NO_REPORTER_FALLBACK] ${src}: ${msg}`, err, ctx) };
                                    // Decide if missing reporter should halt construction (`throw new Error(...)`) or just warn. For core utilities, maybe fatal; for components, often a warning allows partial function.
                                    // For this demo, it allows the component to attempt creation but with fallback error reporting.
                               } else {
                                  // Store the valid `ErrorReporter` instance reference in a protected member.
                                  this._errorReporter = errorReporter;
                                  Logger.debug(`TravelComponent: ErrorReporter dependency successfully injected and stored.`);
                               }

                                // --- Validate and Initialize Component Identity ---
                                // Check if the provided `elementId` is a valid, non-empty string.
                                // The component relies on a valid ID to find its HTML element and for mapping in the `_inputs` map.
                                if (typeof elementId !== 'string' || elementId.trim() === '') {
                                   const errorMsg = `Invalid or empty element ID provided for component "${componentName}". Component cannot be linked to a specific DOM element.`;
                                   // Use the injected ErrorReporter to log and track this configuration error.
                                    this._errorReporter.reportError(
                                        'TravelComponent.constructor', new Error(errorMsg), // Create a specific error object for reporting.
                                        { elementId: elementId, componentName: componentName, step: 'id_validation' }, // Context.
                                        `Configuration error: ${componentName} requires a valid HTML element ID. Component initialization failed.`, // User-friendly message.
                                        'comp_init_invalid_id', // GA error code for this specific error type.
                                        0 // Show the message persistently in the UI as a critical setup error.
                                    );
                                   // Throw an error to halt construction if the fundamental element ID is invalid. This indicates a programming mistake during component instantiation.
                                   throw new Error(errorMsg);
                                }
                                 // Store the component's ID (trimmed whitespace) and descriptive name in private members.
                                this.#componentId = elementId.trim(); // Store trimmed ID.
                                this.#componentName = componentName; // Store the descriptive name.
                                 Logger.debug(`TravelComponent: Component identity set - ID: "${this.#componentId}", Name: "${this.#componentName}".`);


                                // --- Find and Store Wrapped HTML Element ---
                                // Attempt to find the corresponding HTML element in the DOM using the component's ID.
                                // Store the element reference in the protected `_element` member.
                                this._element = document.getElementById(this.#componentId);

                                // Check if the HTML element was found successfully.
                                if (!this._element) {
                                     // If the element is NOT found, log this as a warning using the injected ErrorReporter.
                                     // This often indicates an issue with the HTML structure or a typo in the element ID provided during component creation.
                                     const errorMsg = `HTML element with ID "${this.#componentId}" not found for component "${this.#componentName}". This component will not be able to interact with the DOM and its functionality will be limited/disabled.`;
                                    Logger.warn(errorMsg); // Also log a warning locally.
                                     this._errorReporter.reportError(
                                         'TravelComponent.constructor', new Error(errorMsg), // Create a specific error object for reporting.
                                         { component: this.#getComponentInfo(), elementId: this.#componentId, componentName: this.#componentName, step: 'element_lookup' }, // Context.
                                         `Missing UI element for component "${this.name}" (ID "${this.id}"). Feature may not work correctly.`, // User-friendly message about missing UI.
                                         'comp_init_element_missing', // GA error code for missing element.
                                         0 // Show the message persistently in the UI.
                                     );
                                     // Mark the component as invalid because its essential DOM element is missing.
                                     this._isValid = false;
                                    // Do *not* throw an error here solely because the element is missing. Allow the component instance to be created in a potentially non-functional state. Derived classes or the caller (`SearchForm`'s input collector) must check `getElement()` and handle the `null` case gracefully where possible.

                                } else {
                                     // If the element is found successfully:
                                     // Log success and proceed with initialization.
                                     Logger.debug(`TravelComponent: Component "${this.#componentName}" successfully linked to HTML element with ID "${this.#componentId}".`);

                                     // --- Call Subclass Initialization ---
                                     // Call the protected `_initialize` method. Subclasses should override this to perform setup
                                     // that depends on `this._element` being available (like attaching element-specific listeners).
                                    this._initialize(); // Call the initialize logic (base or subclass override).
                                     Logger.debug(`TravelComponent: _initialize method called for "${this.#componentName}".`);
                                }

                                 // Initialize the map (`_eventHandlers`) used to store references to attached event listeners.
                                 this._eventHandlers = {};
                                 Logger.debug(`TravelComponent: Event handlers map initialized.`);

                                 // The protected `_isValid` state is initially `true`, unless set to `false` above if the element was missing.

                                 // Log the successful completion of the base constructor.
                                 Logger.debug(`TravelComponent constructor finished successfully for "${this.#componentName}".`);

                            } catch (error) {
                                 // --- Handle Critical Errors During Constructor Execution ---
                                 // This catch block handles any unexpected synchronous errors thrown *during the execution of the `TravelComponent` constructor itself*
                                 // (e.g., errors during the validation of `elementId`, or issues *before* setting up `_element`).
                                 // Report this critical constructor failure using the injected reporter (or console if the reporter itself was the issue).
                                 if (this._errorReporter && typeof this._errorReporter.reportError === 'function') {
                                      this._errorReporter.reportError(
                                          'TravelComponent.constructor', error,
                                          { elementId: elementId, componentName: componentName, step: 'constructor_execution_exception' },
                                          `FATAL: Failed to construct base component "${componentName}". Cannot proceed.`, // User-facing fatal message.
                                          'comp_init_exception_critical', // GA error code for critical initialization exception.
                                          0 // Show message persistently.
                                      );
                                 } else {
                                     // Fallback to console logging if the ErrorReporter service itself failed during initialization.
                                    console.error(`FATAL: Error during TravelComponent constructor for "${componentName}" (ID "${elementId}"). Reporter unavailable or failed.`, error);
                                 }

                                 // Ensure internal state is consistent with a critical construction failure.
                                 this._element = null; // Explicitly ensure element reference is null.
                                 this._isValid = false; // Explicitly mark component as invalid.
                                 this._eventHandlers = {}; // Ensure handlers map is cleared.
                                 // `this.#componentId`, `#componentName`, `_errorReporter` would hold their values (potentially null/dummy).

                                 // Re-throw the error to propagate it up the call stack to the creator (`SearchForm` constructor)
                                 // and eventually to the main application bootstrap logic, signaling a critical failure.
                                 throw error;
                            } // End of constructor try...catch.
                       } // End of constructor definition.

                       /**
                        * Private utility method accessible only within the `TravelComponent` instance.
                        * Constructs a consistent string describing the component instance (Name and ID) for use in log messages and error reports.
                        * Provides defensive checks against private members being undefined if constructor failed partially.
                        * @returns {string} A formatted string like "Name: MyComponent, ID: "myElementId"". Returns "Component Info Error" if accessing internal state fails.
                        * @private
                        */
                       #getComponentInfo() {
                           try {
                                // Access private members `#componentName` and `#componentId`. Use nullish coalescing (`??`) for robustness
                                // in case these were not successfully initialized in a constructor failure path.
                                const id = this.#componentId ?? 'ID_MISSING';
                                const name = this.#componentName ?? 'Name_MISSING';
                               // Return a formatted string.
                               return `Name: "${name}", ID: "${id}"`;
                           } catch (error) {
                                // If accessing private members throws an unexpected error (shouldn't happen with standard private fields), log a basic error.
                                Logger.error("TravelComponent.#getComponentInfo: Error accessing private members!", error);
                                return "Component Info Error"; // Return a fallback string on internal error.
                           }
                       }

                       /**
                        * Protected method (convention) - Intended to contain initialization logic specific to a subclass.
                        * This method is called by the base `TravelComponent` constructor *after* the `_element` has been successfully found in the DOM and the base setup is complete.
                        * Subclasses should override this method to perform initialization tasks that require the wrapped `_element` to be available,
                        * such as finding descendant elements, attaching specific DOM event listeners related to the component's function (using `_addEventListener`), or setting initial UI state based on the element's properties.
                        * When overriding in a subclass, it's good practice to call `super._initialize()` at the beginning of the override method to ensure base class initialization logic also runs.
                        */
                       _initialize() {
                           try {
                               Logger.debug(`_initialize called for ${this.#getComponentInfo()}. (Base class implementation - subclasses should override!)`);
                               // The base `TravelComponent` implementation of `_initialize` is intentionally empty.
                               // Subclasses (like `InputComponent`, `SearchForm`) add their specific initialization logic by overriding this method.
                               // Errors thrown from *within* a subclass's override of `_initialize` should ideally be caught and reported within that subclass's method itself using `this._errorReporter`.
                           } catch (error) {
                                // This catch block in the base class acts as a defensive catch for *unhandled* errors
                                // propagating up from a subclass's override of `_initialize`.
                               // Report the unhandled error using the injected reporter.
                               this._errorReporter.reportError(
                                   `${this.name}._initialize`, // Use the component's name for the source.
                                   error, // The uncaught error object.
                                   { component: this.#getComponentInfo(), step: 'initialize_execution_exception' }, // Context.
                                   `Error during component-specific initialization for "${this.name}".`, // User message template.
                                   'comp_initialize_exception' // GA error code for initialization exception.
                               );
                                // Do not re-throw the error from this initialization method; allow the component constructor (which called `_initialize`) to complete.
                                // The component might be in a partial or non-functional state depending on the nature of the error during initialization.
                           }
                       }

                       /**
                        * Protected method (convention) - This method contains the core validation logic specific to the component instance.
                        * This method **must** be overridden by subclasses (`InputComponent`, `SearchForm`, etc.) to provide their concrete validation rules.
                        * The public `validate()` method calls this method and updates the public `isValid` state based on its boolean return value.
                        * This method should be responsible for checking the component's current state (e.g., input value, relationships with other inputs)
                        * and typically calls `_setErrorMessage()` or `_clearErrorMessage()` (methods expected to be provided by `InputComponent`)
                        * to provide UI feedback below the wrapped element and update its native validity state (`setCustomValidity`).
                        * Errors thrown from *within* a subclass's override of `_validate` should ideally be caught and reported within that subclass's method using `this._errorReporter`, and then the method should return `false`.
                        * @returns {boolean} - Returns `true` if all the validation rules implemented in this method pass, `false` otherwise.
                        */
                       _validate() {
                           try {
                               Logger.debug(`_validate called for ${this.#getComponentInfo()}. (Base class implementation - subclass must override!)`);
                               // The base `TravelComponent` implementation of `_validate` is intentionally simple.
                               // It checks if the wrapped element exists. If not, it returns `false`. Otherwise, it assumes valid.
                               // Subclasses like `InputComponent`, `DateInput`, `NumberInput`, etc., *must* override this method
                               // to provide their specific validation rules (checking values, attributes, etc.).

                                // Defensive check: If the wrapped element is missing, the component cannot be valid.
                                // This should have been handled in the constructor and subsequent checks, but include defensively.
                                if (!this._element) {
                                   this._isValid = false; // Explicitly set internal state to false.
                                   Logger.debug(`${this.name}._validate: Element is null, returning false.`);
                                    return false; // Return false as element is missing.
                                }

                                // In the base class implementation, if the element exists, we assume valid by default.
                                this._isValid = true; // Set internal state to true.
                                // Log the result of this base validation step.
                                Logger.debug(`${this.name}._validate: Base validation passed (element exists). Result: ${this._isValid}.`);

                                // Return the result of this base validation step. Subclasses that override this will perform their own checks.
                                return this._isValid; // Returns `true` if element exists in base implementation.

                           } catch (error) {
                                // This catch block in the base class acts as a defensive catch for *unhandled* errors
                                // propagating up from a subclass's override of `_validate`. Ideally, subclasses catch and report their own specific validation errors.
                               Logger.error(`${this.name}._validate: CRITICAL UNHANDLED ERROR caught within validate method!`, error, { component: this.#getComponentInfo(), step: 'validate_execution_exception' }); // Log the error.

                                // Report the unhandled error using the injected reporter.
                                this._errorReporter.reportError(
                                    `${this.name}._validate`, // Use the component's name for the source.
                                    error, // The uncaught error object.
                                    { component: this.#getComponentInfo(), step: 'validate_execution_exception' }, // Context.
                                    `Error during validation logic for component "${this.name}". Cannot determine validity.`, // User-facing message template.
                                    'comp_validate_exception_critical' // GA error code for validation exception.
                                );

                                // If the validation process itself fails by throwing an error, the component is considered invalid.
                                this._isValid = false; // Explicitly set internal state to false.

                                // Note: Subclasses should handle displaying user-facing error messages specific to their validation failures.
                                // If this base method's catch is hit, it means a logic error occurred in a subclass or the base method itself.
                                // The error reporter handles logging and maybe a generic UI message.

                                return false; // Always return false if validation failed due to an error in the logic.
                           }
                       } // End of _validate method definition.

                       /**
                        * Protected method to add a DOM event listener to an HTML element (either the component's wrapped `_element`
                        * or a specific target element provided in the `options` object).
                        * It automatically binds the handler function's `this` context to the current component instance (`this`).
                        * It also stores references to the attached handlers in the `_eventHandlers` map. This storage is crucial
                        * for allowing systematic removal of listeners during the component's `dispose()` method, helping to prevent memory leaks
                        * when the component or its associated DOM element is removed from the page.
                        * Includes robustness checks and error handling.
                        * @param {string} eventType - The string name of the event to listen for (e.g., 'click', 'change', 'submit', 'mouseover'). Required.
                        * @param {function} handler - The callback function to execute when the event fires. This function's `this` context will be automatically bound to the component instance. Required.
                        * @param {object} [options={}] - Optional standard event listener options (e.g., `{ capture: true, once: true, passive: true, signal: abortSignal }`). Defaults to an empty object.
                        * @param {HTMLElement} [options.element] - An optional specific HTML element to attach the listener to. If provided, this element is used instead of the component's own wrapped `_element`. Useful for attaching listeners to descendant elements or related elements outside the component's primary wrapper.
                        */
                       _addEventListener(eventType, handler, options = {}) {
                           try {
                                // Determine the target HTML element where the listener should be attached.
                                // Use the `options.element` if provided, otherwise use the component's own wrapped element (`this._element`).
                                const targetElement = options.element || this._element;

                                // --- Check for Target Element Availability ---
                                // A listener cannot be attached if the target element is missing (null or undefined).
                                if (!targetElement) {
                                    // Log a warning if the target element is null.
                                   Logger.warn(`${this.#getComponentInfo()}._addEventListener: Cannot add "${eventType}" listener. Target element is null. Skipping attachment.`);
                                    // Note: Errors about missing base element (`this._element`) are logged as persistent errors in the constructor. Warnings for missing descendant/other elements should be logged here.
                                    return; // Exit the method; cannot attach listener.
                                }

                                // --- Validate Handler Function ---
                                // Ensure the provided `handler` is actually a valid function before attempting to attach it.
                                if (typeof handler !== 'function') {
                                    const errorMsg = `_addEventListener: Provided handler for "${eventType}" event is not a function. Cannot attach listener.`;
                                     // Report this configuration or programming error using the injected reporter.
                                     this._errorReporter.reportError(
                                         `${this.name}._addEventListener`, new Error(errorMsg), // Create a specific error object for reporting.
                                         { component: this.#getComponentInfo(), eventType: eventType, handlerType: typeof handler, targetElementId: targetElement.id || 'N/A' }, // Context.
                                         `Configuration error: Invalid event handler for component "${this.name}" (Event: "${eventType}").`, // User-friendly message template.
                                         'comp_add_listener_invalid_handler' // GA error code.
                                     );
                                    return; // Exit the method; handler is invalid.
                                }


                                // --- Create Bound Handler ---
                                // Bind the `this` context of the original handler function (`handler`) to the current component instance (`this`).
                                // This ensures that when the `boundHandler` is executed in response to the event, `this` inside the handler function refers correctly to the component instance.
                                const boundHandler = handler.bind(this);


                                // --- Attach Event Listener ---
                                // Use the native DOM `addEventListener` method to attach the `boundHandler` to the `targetElement` for the specified `eventType`.
                                // Pass the optional standard listener options (e.g., capture phase, passive, once).
                                targetElement.addEventListener(eventType, boundHandler, options);
                                 // Log debug message about successfully attaching the listener. (Often commented out in production builds due to verbosity).
                                 // Logger.debug(`${this.#getComponentInfo()}._addEventListener: Attached "${eventType}" listener to element ID "${targetElement.id || 'NoID'}".`);


                                // --- Store Handler Reference for Cleanup ---
                                // Store a reference to the attached `boundHandler` and relevant information (original options, target element)
                                // in the `this._eventHandlers` map. This storage is essential for the `_removeEventListeners` method
                                // to later remove these listeners during component disposal.
                                // Use the target element's ID as the primary key in the nested map for organization. If element has no ID, create a generic identifier.
                                const elementIdentifier = targetElement.id || `element-${targetElement.tagName}-${Math.random().toString(36).slice(2, 8)}`; // Generate temp ID if none.

                                // Initialize the nested map structure if it doesn't exist for this element identifier and event type.
                                if (!this._eventHandlers[elementIdentifier]) {
                                     this._eventHandlers[elementIdentifier] = {};
                                }
                                if (!this._eventHandlers[elementIdentifier][eventType]) {
                                     this._eventHandlers[elementIdentifier][eventType] = [];
                                }

                                // Push an object containing the necessary information to uniquely identify and remove this listener later.
                                // Storing `originalHandler` is optional but can help in debugging which function was originally intended.
                                this._eventHandlers[elementIdentifier][eventType].push({ handler: boundHandler, originalHandler: handler, options: options, targetElement: targetElement });

                                 // Log a debug message about storing the handler reference.
                                 // Logger.debug(`${this.#getComponentInfo()}._addEventListener: Stored reference for "${eventType}" listener on element ID "${elementIdentifier}".`);


                            } catch (error) {
                                 // --- Handle Errors During Process of Adding Listener ---
                                 // Catch any unexpected errors that occur *during the synchronous execution* of the `_addEventListener` method itself
                                 // (e.g., errors related to accessing properties, method calls, before attaching the listener).
                                 // Report this error using the injected reporter.
                                this.#errorReporter.reportError(
                                    'TravelComponent._addEventListener', // Source of the error report.
                                    error, // The error object caught.
                                    { component: this.#getComponentInfo(), eventType: eventType, handlerName: handler?.name || typeof handler, step: 'addEventListener_execution' }, // Context details.
                                    `Error adding event listener for component "${this.name}" (Event: "${eventType}"). Listener may not be attached.`, // User-friendly message template.
                                    'comp_add_listener_exception_overall' // GA error code for overall exception during listener add.
                                );
                                 // Do not re-throw from this utility method; the component should continue to initialize if possible.
                            }
                       } // End of _addEventListener method definition.

                        /**
                         * Protected method to remove all event listeners that were previously attached and stored using the `_addEventListener` method
                         * by this component instance.
                         * This method iterates through the `_eventHandlers` map and calls `removeEventListener` for each stored handler reference.
                         * This systematic removal process is critical for preventing memory leaks, especially in Single Page Applications (SPAs)
                         * where component instances and their associated DOM elements may be dynamically added and removed from the page over time.
                         * Should be called during the component's `dispose()` method.
                         */
                        _removeEventListeners() {
                            try {
                                Logger.debug(`${this.#getComponentInfo()}._removeEventListeners: Starting removal of all attached event listeners...`);

                                // Iterate through the top-level keys of the `_eventHandlers` map. These keys represent the HTML elements where listeners were attached (using their ID or a generic identifier).
                                for (const elementIdentifier in this._eventHandlers) {
                                    // Use `Object.prototype.hasOwnProperty.call` for robust iteration over the object's own properties.
                                    if (Object.prototype.hasOwnProperty.call(this._eventHandlers, elementIdentifier)) {
                                        // Get the nested map for this element identifier, which contains event types as keys.
                                        const elementEventTypesMap = this._eventHandlers[elementIdentifier];

                                        // Iterate through the event types registered for this specific HTML element.
                                        for (const eventType in elementEventTypesMap) {
                                            if (Object.prototype.hasOwnProperty.call(elementEventTypesMap, eventType)) {
                                                // Get the array of stored handler objects for this event type on this element.
                                                const handlersInfoArray = elementEventTypesMap[eventType];

                                                // Iterate through the array of stored handler objects.
                                                handlersInfoArray.forEach(({ handler, options, targetElement }) => {
                                                    try {
                                                         // Ensure the target HTML element still exists and has the `removeEventListener` method before attempting removal.
                                                         // The element might have been removed from the DOM already by other code if component disposal wasn't coordinated.
                                                        if (targetElement && typeof targetElement.removeEventListener === 'function') {
                                                             // Call the native `removeEventListener` method with the original `eventType`, the *bound* handler reference (`handler`), and the same `options` used during `addEventListener`.
                                                            targetElement.removeEventListener(eventType, handler, options);
                                                             // Log debug message about successfully removed listener. (Often commented out for brevity).
                                                             // Logger.debug(`${this.#getComponentInfo()}._removeEventListeners: Removed "${eventType}" listener from element ID "${elementIdentifier}".`);
                                                        } else {
                                                             // If the target element is missing when trying to remove its listener, log a warning.
                                                             // This indicates a potential issue with the disposal flow or DOM management.
                                                             Logger.warn(`${this.#getComponentInfo()}._removeEventListeners: Cannot remove listener (Type: "${eventType}") from element ID "${elementIdentifier}". Target element is null or cannot remove listeners.`);
                                                             // Report this potential issue using the injected reporter.
                                                             this.#errorReporter.reportError(
                                                                 `${this.name}._removeEventListeners - remove listener`,
                                                                 new Error(`Target element missing or invalid for removing listener.`),
                                                                 { component: this.#getComponentInfo(), eventType: eventType, targetId: elementIdentifier },
                                                                 `Error removing listener for component "${this.name}". Resource might be leaking.`,
                                                                 'comp_remove_single_listener_element_missing' // GA error code.
                                                             );
                                                        }
                                                    } catch (removeSingleError) {
                                                         // Catch any unexpected errors that occur *while attempting to remove a single listener* within the loop.
                                                         // Report this error using the injected reporter.
                                                         this.#errorReporter.reportError(
                                                             `${this.name}._removeEventListeners - remove listener`,
                                                             removeSingleError, // The error object caught.
                                                             { component: this.#getComponentInfo(), eventType: eventType, targetId: elementIdentifier, step: 'remove_single_listener_execution' }, // Context.
                                                             `Error removing a specific event listener for component "${this.name}".`,
                                                             'comp_remove_single_listener_exception' // GA error code.
                                                         );
                                                        // Continue the loop despite the error with one listener.
                                                    }
                                                });
                                                 // After attempting removal for all handlers of this event type on this element, clear the array in the map.
                                                 elementEventTypesMap[eventType] = []; // Clear the array.
                                                // Optional: Could delete the event type key if the array is now empty: `delete elementEventTypesMap[eventType];`
                                            }
                                        }
                                         // After attempting removal for all event types on this element identifier, delete the element identifier key from the map.
                                         delete this._eventHandlers[elementIdentifier]; // Clear the element entry in the top-level map.
                                         // Note: The actual HTML elements are NOT removed from the DOM here; this is the component's cleanup of its own references.

                                    } // End if (hasOwnProperty check)
                                } // End of elementIdentifier loop.


                                // After iterating through all stored handlers and attempting removal, reset the internal `_eventHandlers` map reference.
                                this._eventHandlers = {}; // Clear the map reference itself.

                                Logger.debug(`${this.#getComponentInfo()}._removeEventListeners finished. All managed listeners processed.`);

                            } catch (error) {
                                 // --- Handle Critical Errors During Overall Listener Removal Process ---
                                 // This outer catch block catches any unexpected critical errors that occur *during the overall execution of the `_removeEventListeners` method itself*
                                 // (e.g., errors during the iteration structure, unexpected issues accessing `this._eventHandlers`).
                                 // Report this critical cleanup failure using the injected reporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._removeEventListeners`, // Source of the error report.
                                    error, // The error object caught.
                                    { component: this.#getComponentInfo(), step: 'overall_removal_process_exception' }, // Context.
                                    `Critical error during event listeners removal process for component "${this.name}". Potential memory leaks.`, // User-facing message template.
                                    'comp_remove_listeners_critical_exception' // GA error code.
                                );
                                // The `_eventHandlers` map might be in an inconsistent state, but attempts were made.
                                // Do not re-throw from a dispose/cleanup method.
                            }
                        } // End of _removeEventListeners method definition.


                       /**
                        * Public method to retrieve the HTML element wrapped and managed by this component instance.
                        * Provides external access to the component's primary DOM element.
                        * @returns {HTMLElement|null} - The HTML element instance wrapped by this component if it was found during construction and the component has not been disposed (clearing `_element` to null), or `null` otherwise.
                        */
                       getElement() {
                           try {
                                // Return the stored protected element reference.
                               // `this._element` is set during the constructor. It will be null if the element was not found, or if `dispose()` has been called.
                               return this._element;
                           } catch (error) {
                                // Report errors occurring while simply trying to access the `_element` property.
                                // This is unlikely with standard properties but defensive coding includes catch.
                                this._errorReporter.reportError(
                                    `${this.name}.getElement`,
                                    error, // The error object caught.
                                    { component: this.#getComponentInfo(), step: 'get_element_access' }, // Context.
                                    `Error accessing wrapped element for component "${this.name}".`, // User-friendly message.
                                    'comp_get_element_exception' // GA error code.
                                );
                               return null; // Always return null on error to indicate failure to get the element.
                           }
                       }

                       /**
                        * Public getter for the component ID.
                        * Returns the unique string identifier derived from the wrapped HTML element's ID during construction.
                        * @returns {string|null} - The component's ID string or `null` if an error occurred accessing it (unlikely for private member).
                        */
                       get id() {
                           try {
                                // Direct access to the private member `#componentId`.
                               // Use nullish coalescing `?? null` as a defensive measure in case `#componentId` was not initialized in a failed constructor state.
                               return this.#componentId ?? null;
                           } catch (error) {
                                // Report errors occurring while trying to access the private ID member.
                                if (this._errorReporter && typeof this._errorReporter.reportError === 'function') { // Ensure reporter is available.
                                   this._errorReporter.reportError(
                                       'TravelComponent.id', error,
                                       { component: 'Attempting to get ID for TravelComponent', internalId: this.#componentId, step: 'get_id_access' }, // Provide available internal info.
                                       'Error accessing component ID.', // User message.
                                       'comp_get_id_exception' // GA error code.
                                   );
                                } else {
                                    // Fallback to console logging if the ErrorReporter itself is unavailable.
                                   console.error('Error accessing component ID in TravelComponent (Reporter missing or failed):', error, { internalId: this.#componentId });
                                }
                               return null; // Return null on error.
                           }
                       }

                       /**
                        * Public getter for the component name.
                        * Returns a descriptive string name for the component type.
                        * @returns {string} - The component's name string. Returns 'UnknownComponent' if an error occurred accessing it.
                        */
                       get name() {
                            try {
                                // Direct access to the private member `#componentName`.
                                // Use nullish coalescing `?? 'UnknownComponent'` as a fallback in case `#componentName` was not initialized.
                                return this.#componentName ?? 'UnknownComponent';
                            } catch (error) {
                                 // Report errors occurring while trying to access the private name member.
                                if (this._errorReporter && typeof this._errorReporter.reportError === 'function') { // Ensure reporter is available.
                                    this._errorReporter.reportError(
                                        'TravelComponent.name', error,
                                        { component: 'Attempting to get name for TravelComponent', internalName: this.#componentName, step: 'get_name_access' }, // Provide available internal info.
                                        'Error accessing component name.', // User message.
                                        'comp_get_name_exception' // GA error code.
                                    );
                                } else {
                                   console.error(`Error accessing component name in TravelComponent (Reporter missing or failed):`, error, { internalName: this.#componentName });
                                }
                                return 'UnknownComponent'; // Return a fallback name string on error.
                            }
                       }

                       /**
                        * Public getter for the component's internal validation status (`_isValid`).
                        * This reflects the result of the most recent validation attempt (`validate()` method).
                        * Returns `false` if the wrapped HTML element was not found during construction, as validation is impossible without an element.
                        * @returns {boolean} - `true` if the component is currently considered valid based on the internal state (`_isValid`) and the element exists, `false` otherwise.
                        */
                       get isValid() {
                           try {
                                // A component cannot be valid if its wrapped HTML element (`this._element`) was not found during construction.
                               // In this case, `_element` is null and `_isValid` would likely be false, but explicitly check the element.
                               if (!this._element) {
                                   // Logger.debug(`${this.#getComponentInfo()}.isValid: Element is null, returning false.`); // Too noisy debug.
                                   return false; // Cannot be valid without an element.
                               }
                                // Otherwise, return the current value of the protected internal validation state flag (`_isValid`).
                               // This flag is updated by the `_validate()` method, called via the public `validate()`.
                                // Logger.debug(`${this.#getComponentInfo()}.isValid: Returning internal state ${this._isValid}.`); // Too noisy debug.
                               return this._isValid;
                           } catch (error) {
                                // Report errors occurring while trying to access the `_isValid` property or `_element`.
                                if (this._errorReporter && typeof this._errorReporter.reportError === 'function') { // Ensure reporter is available.
                                    this._errorReporter.reportError(
                                        'TravelComponent.isValid', error,
                                        { component: this.#getComponentInfo(), internalIsValid: this._isValid, hasElement: !!this._element, step: 'get_isvalid_access' }, // Context.
                                        `Error getting validity status for component "${this.name}".`, // User message.
                                        'comp_get_isvalid_exception' // GA error code.
                                    );
                                } else {
                                   console.error(`Error getting isValid status for ${this.name} (Reporter missing or failed):`, error, { internalIsValid: this._isValid, hasElement: !!this._element });
                                }
                               return false; // Always return `false` on error to indicate failure to determine validity.
                           }
                       }

                       /**
                        * Public method to trigger the component's validation logic.
                        * This method should be called when you need to validate the component (e.g., in response to user interaction like blur, change, or during form submission).
                        * It performs necessary checks (like ensuring the wrapped element exists) and then calls the protected `_validate()` method, which contains the actual validation rules (and should be overridden by subclasses).
                        * It updates the component's internal `_isValid` state based on the result returned by `_validate()`.
                        * Includes error handling for unexpected issues during the process.
                        * @returns {boolean} - Returns `true` if validation passes after executing `_validate()` and all steps complete without error, `false` otherwise.
                        */
                       validate() {
                           try {
                                // --- Check Element Availability ---
                                // Validation cannot be performed if the component's wrapped HTML element (`this._element`) is null.
                               // If it's null, the component is non-functional for UI interaction and validation.
                               if (!this._element) {
                                   this._isValid = false; // Explicitly set internal state to false if element is missing.
                                   Logger.warn(`Public validate() called on ${this.name} but wrapped element is null. Validation skipped, returning false.`);
                                   return false; // Cannot validate.
                               }
                                // Log the start of the validation process for this component instance.
                                Logger.debug(`Public validate() called for ${this.name}. Executing protected _validate()...`);


                                // --- Execute Protected Validation Logic ---
                                // Call the protected `_validate()` method. Subclasses should have overridden this method
                                // to provide their specific validation rules based on input value, attributes, etc.
                                // Wrap the call in a try...catch block to handle any uncaught errors thrown *within* the `_validate()` method's implementation.
                                // (Ideally, subclasses' `_validate` methods catch and report their own specific errors, but this provides a defense).
                                let validationResultBoolean; // Variable to hold the boolean result returned by `_validate()`.
                                try {
                                    validationResultBoolean = this._validate(); // Call the actual component-specific validation logic.
                                    Logger.debug(`${this.name}._validate() completed execution with result: ${validationResultBoolean}.`);
                                    // Ensure the result is boolean. `_validate` should return true or false.
                                     if (typeof validationResultBoolean !== 'boolean') {
                                          Logger.warn(`${this.name}._validate() returned a non-boolean value (${validationResultBoolean}). Treating as invalid.`);
                                          validationResultBoolean = false; // If _validate returns non-boolean, treat as failure.
                                     }

                                } catch (validationErrorInside) {
                                     // --- Handle Errors During _validate() Execution ---
                                     // If an uncaught error occurred *within* the subclass's `_validate()` method's implementation logic.
                                     // This error represents a flaw in the component's validation code itself, not a validation *failure* of the user's input.
                                    this.#errorReporter.reportError(
                                        `${this.name}.validate - executing _validate`, // Source indicating public method calling protected method.
                                        validationErrorInside, // The error object caught.
                                        { component: this.#getComponentInfo(), value: this.getValue(), step: 'protected_validate_execution_exception' }, // Context details.
                                        `Error during validation logic for component "${this.name}". Cannot determine validity.`, // User-facing message template about validation logic error.
                                        'comp_protected_validate_exception' // GA error code for a validation *logic* exception.
                                    );
                                     validationResultBoolean = false; // If validation logic itself threw an error, the component is considered invalid.
                                     // Note: The component's `_validate` method (or its subclass overrides) should ideally also call `_setErrorMessage`
                                     // in its own catch block if it fails, to display feedback below the input. If not, the ErrorReporter handles a main message.
                                }

                                // --- Update Component State ---
                                // Update the component's internal `_isValid` state flag based on the final boolean result obtained from `_validate()`.
                                this._isValid = validationResultBoolean; // Sets the protected `_isValid` flag.

                                 // Note: After validation, the component's `_validate` method (or subclass override)
                                 // is responsible for calling `_setErrorMessage` or `_clearErrorMessage`
                                 // to update the dedicated UI error element and the native element's `setCustomValidity`.
                                 // The `SearchForm` will later aggregate these native `setCustomValidity` states via `form.checkValidity()`.

                                 // Optional: Call `this._element.reportValidity()` here if you want the native browser validation tooltip
                                 // to appear automatically on every explicit `validate()` call. This is usually only desired on specific
                                 // user actions like blur or attempting form submit.

                                // Log the completion and final result of the public validate method.
                                Logger.debug(`${this.name} public validate() finished. Final result: ${this._isValid}.`);

                                // Return the final validity status.
                                return this._isValid; // Returns the stored state, which is the same as `validationResultBoolean` determined above.

                            } catch (error) {
                                 // --- Handle Critical Errors During Public Validate Execution ---
                                 // This outer catch block catches any unexpected synchronous errors thrown *during the execution of the public `validate` method itself*
                                 // (e.g., errors occurring before calling `_validate`, issues accessing internal state, etc.).
                                 // This indicates a critical failure in the core validation triggering mechanism.
                                Logger.error(`${this.name}.validate: CRITICAL UNEXPECTED ERROR caught during public validate execution!`, error, { component: this.#getComponentInfo(), step: 'public_validate_execution_exception' }); // Log the error.

                                 // Report this critical validation triggering failure using the injected reporter.
                                 this.#errorReporter.reportError(
                                     `${this.name}.validate`, // Source of the error report.
                                     error, // The error object caught.
                                     { component: this.#getComponentInfo(), value: this.getValue(), step: 'public_validate_execution_exception' }, // Context.
                                     `Critical error executing validation for component "${this.name}". Cannot determine validity.`, // User-facing message template for a fundamental validation issue.
                                     'comp_public_validate_exception_critical' // GA error code for critical public validation exception.
                                 );

                                 // If public validate itself fails critically, mark the component as invalid.
                                 this._isValid = false; // Explicitly set internal state to false.

                                 // Attempt to set a generic error message for the user via the UI element, if the component type supports the `_setErrorMessage` method.
                                 if (typeof this._setErrorMessage === 'function') {
                                      try {
                                          this._setErrorMessage(`Validation process failed due to internal error: ${error.message}`);
                                      } catch (setMessageError) { Logger.error(`${this.name}.validate: Error setting error message after critical exception:`, setMessageError); }
                                 }
                                 // Note: The ErrorReporter handled logging and displaying a main message for the critical error.

                                 // Always return `false` on critical error in the public validate method.
                                 return false;
                            } // End of public validate try...catch.
                       } // End of public validate method definition.

                        /**
                         * Public method to dispose of the component instance.
                         * This method should be called when the component instance is no longer needed (e.g., when the HTML element it manages is removed from the DOM or the application section is shut down).
                         * It orchestrates the cleanup process to remove event listeners and clear references, which helps prevent memory leaks.
                         * Subclasses should override this method to add their specific cleanup logic, *always* ensuring they call `super.dispose()` first at the beginning of their override.
                         */
                        dispose() {
                            try {
                                Logger.debug(`${this.name}.dispose: Disposing component: ${this.name}. Starting cleanup.`);

                                // --- Step 1: Call Parent Dispose ---
                                // Call the parent `TravelComponent`'s `dispose` method first. This ensures base cleanup logic runs:
                                // - Removing all event listeners managed by this component instance that were attached using `_addEventListener`
                                //   (including listeners on the component's primary `_element` and any other elements specified in options).
                                // - Clearing the reference to the component's main wrapped HTML element (`this._element` is set to null by super).
                                super.dispose(); // Calls TravelComponent.dispose() to perform base cleanup.


                                // --- InputComponent Specific Cleanup ---
                                // Perform any cleanup specific to the `InputComponent`. This includes clearing the reference to the dedicated error message element.
                                 Logger.debug(`Dispose: Clearing error message element reference for ${this.name}.`);
                                 this._errorMessageElement = null; // Explicitly clear the reference.
                                // The `_value` property becomes stale after `_element` is cleared by `super.dispose()`.
                                // `_eventHandlers` map is cleared by `super.dispose()`.
                                // `_isValid` flag becomes irrelevant upon disposal.
                                // `_errorReporter` reference is typically not cleared here as it's a shared instance managed at a higher level.


                                // Log debug message confirming disposal completion.
                                Logger.debug(`InputComponent disposed: ${this.name}. Cleanup complete.`);

                            } catch (error) {
                                 // Catch and log any unexpected errors that occur *during the disposal process*.
                                 // Use `console.error` here as the injected `_errorReporter` instance might already be disposed or fail during final cleanup phases.
                                console.error(`CRITICAL ERROR during disposal of InputComponent "${this.name}" (ID: ${this.id}):`, error, { step: 'dispose_execution_exception' });
                                // Do not re-throw from a dispose method. Cleanup errors should be logged but not prevent overall page unload.
                            }
                        } // End of dispose method definition.
                    } // End of InputComponent class definition.


             // --- Class for Date Input, inheriting from InputComponent ---
             // Extends the `InputComponent` to provide functionality specifically for HTML date input elements (`<input type="date">`).
             // Adds date-specific validation logic (checking format, `min` attribute) and provides a getter to retrieve the date value as a `Date` object.
             class DateInput extends InputComponent {
                 // Private member to store the type of date this input represents (e.g., 'check-in', 'check-out').
                 // This value is typically read from a `data-date-type` attribute on the HTML element and stored here.
                 #dateType;

                 /**
                  * Constructor for DateInput.
                  * Calls the parent constructor (`InputComponent`) to wrap the HTML element, initialize base input features, and handle events.
                  * Stores the specified date type and attempts to dynamically set the HTML `min` attribute for the date input element based on the current date.
                  * @param {string} elementId - The ID string of the HTML date input element (`<input type="date" id="...">`). Required.
                  * @param {string} dateType - The type of date this input represents ('check-in' or 'check-out'). This is often read from a `data-date-type` attribute in the HTML. Required.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                  * @throws {Error} Propagates errors thrown by the parent constructor.
                  */
                 constructor(elementId, dateType, errorReporter) {
                      try {
                         // Log the start of the constructor for debugging. Include element ID and date type.
                         Logger.debug(`DateInput constructor called for ID "${elementId}" (Date Type: ${dateType}).`);

                         // Call the parent `InputComponent` constructor first.
                         // Pass the element ID, set the specific component name ('DateInput'), and pass the required ErrorReporter instance.
                         // This handles finding the DOM element, basic input setup (_value, error element), and attaching base input events.
                         super(elementId, 'DateInput', errorReporter); // Pass element ID, component name, reporter.


                         // --- Initialize Date-Specific Members ---
                         // Store the provided date type ('check-in', 'check-out') in a private member. Use 'unknown' as a fallback if not provided.
                         this.#dateType = dateType || 'unknown'; // Initialize private member.

                         // Check if the wrapped HTML element (`this._element`) was found successfully by the parent constructor AND if its `type` is indeed 'date'.
                         // Date-specific logic relies heavily on `type="date"` input features.
                         if (this._element) { // Parent checks if element exists.
                             if (this._element.type === 'date') {
                                  Logger.debug(`${this.name} initialized. Wrapped element is type="date". Setting min date.`);
                                 // If the element is a valid date input, dynamically set the `min` date attribute using a protected helper method.
                                 // This is important for native browser date validation and picker UI.
                                 this._setMinDate();
                             } else {
                                // If the element was found but is *not* `type="date"`, log a warning that date-specific features will be limited.
                                Logger.warn(`${this.name} (ID: ${this.id}): Wrapped element is type="${this._element.type}" instead of "date". Date-specific validation/parsing may not work correctly.`);
                                 // `this._isValid` state is handled by parent based on element lookup and base validation.
                                 // Subclass `_validate` should account for the actual element type.
                             }
                         } else {
                            // If the element was not found by the parent constructor (`this._element` is null),
                            // a warning was logged by the parent, and `this._isValid` is false. Date-specific initialization is skipped.
                            Logger.debug(`${this.name} (ID: ${elementId}): Wrapped element missing. Skipping date-specific initialization.`);
                         }

                          // Log the completion of the DateInput constructor.
                          Logger.debug(`${this.name} constructor finished.`);

                      } catch (error) {
                           // Catch any unexpected errors occurring *within* the DateInput constructor's own logic (after calling `super()`).
                           // This indicates a programming issue in the DateInput constructor itself.
                           // Report this error using the injected `_errorReporter`.
                           this.#errorReporter.reportError(
                               `${componentName}.constructor`,
                               error, // The error object caught.
                               { elementId: elementId, dateType: dateType, step: 'constructor_execution_after_super' }, // Context details.
                               `Failed to construct Date Input component "${elementId}".`, // User-facing message template.
                               'dateinput_init_exception_after_super' // GA error code for this specific exception type.
                           );
                           // Ensure the component's state reflects a critical construction failure.
                           this.#dateType = 'error'; // Set date type to an error state.
                           // The parent constructor handles `this._element` and `this._isValid`.
                           // Re-throw the initialization error to propagate it up to the caller (`SearchForm`'s collector).
                          throw error;
                      }
                  } // End of constructor definition.


                 /**
                  * Protected method to dynamically set the `min` attribute on the HTML date input element (`this._element`).
                  * This method calculates today's date, formats it as a YYYY-MM-DD string, and sets this string
                  * as the value of the HTML `min` attribute. This utilizes the browser's native validation
                  * features (`validity.rangeUnderflow`, `checkValidity`) and often affects the UI of native date pickers
                  * (e.g., past dates are disabled). Errors during this process are caught and reported internally.
                  */
                 _setMinDate() {
                     try {
                         Logger.debug(`${this.name}._setMinDate: Attempting to set min date attribute.`);
                          // Ensure the wrapped HTML element exists AND is actually a date input type before attempting to set the `min` attribute.
                         if (this._element && this._element.type === 'date') {
                             const today = new Date(); // Get the current date and time on the client machine.

                              // Format the date for today as a YYYY-MM-DD string.
                             const year = today.getFullYear(); // Get the full year (e.g., 2023).
                             // Get the month (0-indexed, 0 for Jan) and convert to 1-indexed, padding with a leading zero if needed (e.g., '01', '12').
                             const month = (today.getMonth() + 1).toString().padStart(2, '0');
                             // Get the day of the month and pad with a leading zero if needed (e.g., '05', '28').
                             const day = today.getDate().toString().padStart(2, '0');
                             // Assemble the parts into the required YYYY-MM-DD string format for the `min` attribute.
                             const todayStringYYYYMMDD = `${year}-${month}-${day}`;

                             // Set the `min` attribute on the DOM element to the formatted date string.
                             // This activates the browser's built-in validation for minimum date.
                             this._element.min = todayStringYYYYMMDD;
                             Logger.debug(`${this.name}._setMinDate: Successfully set min date attribute to "${todayStringYYYYMMDD}".`);

                         } else if (this._element) {
                              // If element exists but is not a date type, this method was called inappropriately.
                              Logger.warn(`${this.name}._setMinDate: Element exists but is type "${this._element.type}" instead of "date". Skipping set min date attribute.`);
                         } else {
                            // If the element is null, log that min date couldn't be set.
                            Logger.debug(`${this.name}._setMinDate: Element is null. Cannot set min date attribute.`);
                         }

                     } catch (error) {
                          // Catch any unexpected errors occurring *during the process* of calculating or setting the min date.
                          // Report this error using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._setMinDate`,
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), hasElement: !!this._element, elementType: this._element?.type, step: 'set_min_date_logic' }, // Context.
                              `Error setting min date for component "${this.name}". Native date validation range might be incorrect.`, // User-friendly message.
                              'dateinput_set_min_date_exception' // GA error code.
                          );
                          // Do not re-throw from this method. The component should still function, albeit potentially with an incorrect native min date constraint.
                     }
                 } // End of _setMinDate method definition.

                 /**
                  * Polymorphism: Overriding the protected `_validate` method from `InputComponent`.
                  * Provides date-specific validation rules for the date input element.
                  * It first calls the parent's `_validate` method (handling 'required' checks), and then
                  * leverages the native HTML5 `ValidityState` object (checked by `this._element.checkValidity()`)
                  * to determine validity based on attribute constraints like `type="date"` parsing issues (`badInput`)
                  * and the `min` attribute (`rangeUnderflow`).
                  * It also clears or sets specific date-related error messages below the input element using `_setErrorMessage`.
                  * Cross-field date validation (like checking out after checking in) is typically handled by the `SearchForm`'s form-level validation, NOT here.
                  * @returns {boolean} - Returns `true` if all date-specific validation rules pass (including the parent's required check and native validity checks), `false` otherwise.
                  */
                 _validate() {
                     try {
                         Logger.debug(`${this.name}._validate: Called. (DateInput specific validation)`);

                         // --- Call Parent Validation ---
                         // Call the parent `InputComponent`'s `_validate` method first.
                         // This handles the fundamental `required` check based on the input's value string (`this._value`),
                         // and also clears existing custom error messages and native validity flags *before* running new validation checks.
                         let isValid = super._validate(); // Execute parent validation.

                         // If the base validation (e.g., required but empty) already failed, return `false` immediately.
                         // Subsequent date-specific checks based on content are irrelevant if the field is empty and required.
                         if (!isValid) {
                             Logger.debug(`${this.name}._validate: Failed base validation ('required'). Skipping date-specific checks.`);
                              return false; // Exit early.
                         }


                         // --- Date-Specific Validation Checks using `ValidityState` ---
                         // Get the native HTML5 `ValidityState` object from the input element (`this._element`).
                         // This object reflects the validity status based on HTML attributes like `type`, `required`, `min`, `max`, etc.
                         const validity = this._getValidityState();
                         // If `ValidityState` is not available (e.g., `this._element` is null - should be caught earlier, or browser doesn't support `validity` property for this element type),
                         // we cannot perform detailed native-attribute-based validation. Rely solely on the base `required` check (which passed).
                         if (!validity) {
                             Logger.warn(`${this.name}._validate: Cannot get ValidityState. Skipping detailed date validation using native validity.`);
                            // `isValid` is still true from the successful `super._validate()` call.
                             // If getting native validity is critical, you might want to return false here. For this demo, we allow it to pass if base passed.
                             return isValid; // Return true if base validation passed and native checks are skipped.
                         }

                         // Use the browser's built-in validity checks aggregated by `this._element.checkValidity()`.
                         // This method checks several standard HTML5 date constraints based on attributes:
                         // - `validity.typeMismatch`: Value is not a valid date format for `<input type="date">`.
                         // - `validity.rangeUnderflow`: Date value is before the date specified by the `min` attribute.
                         // - `validity.valueMissing`: Input is `required` but has no value (also checked by `super._validate()`).
                         const isNativeValid = this._element.checkValidity(); // Get the aggregate result of native validity checks.


                         // Based on the result of the native checks (`isNativeValid`):
                          if (!isNativeValid) {
                               // If the input is NOT valid according to native browser checks:
                              Logger.debug(`${this.name}._validate: Failed native date validation. ValidityState details:`, validity);

                              // Determine the specific error message to display based on which native `validity` flags are true.
                              let customMessage = 'Invalid date format.'; // Default message if no specific condition matches.

                             // Check specific validity states to provide a relevant message. Prioritize common issues.
                              if (validity.rangeUnderflow) {
                                  // The date value is earlier than the minimum date set by the `min` attribute (which we set to today).
                                  // Use our custom message for "past date" relative to the allowed minimum.
                                  customMessage = AppConfig.MESSAGES.INPUT_DATE_PAST; // "Date cannot be in the past."
                               } else if (validity.badInput) {
                                   // The user entered input that the browser cannot parse as a date for `<input type="date">` (e.g., text).
                                   // Note: Modern browsers often prevent typing invalid chars for date inputs, limiting `badInput` errors here.
                                  customMessage = 'Invalid date format.'; // Use a general invalid format message.
                               } else if (validity.valueMissing) {
                                   // The input is `required` but empty. `super._validate()` already caught this case.
                                   // Include here defensively, using the standard required message template.
                                  customMessage = AppConfig.MESSAGES.INPUT_REQUIRED;
                               } else if (validity.typeMismatch) {
                                   // Value doesn't match the specified input type. For `type="date"`, `badInput` is often used instead. Included defensively.
                                    Logger.warn(`${this.name}._validate: Failed validation with unexpected typeMismatch for date input.`);
                                   customMessage = this._element.validationMessage || customMessage; // Fallback using browser's message or our default.
                               }
                                else {
                                   // Catch any other unexpected or unhandled native validity states.
                                   // Use the browser's default `validationMessage` property as a fallback if it exists and no specific custom message applies based on the flags.
                                   customMessage = this._element.validationMessage || customMessage;
                                    Logger.warn(`${this.name}._validate: Failed validation with unhandled or unexpected ValidityState flags:`, validity);
                               }

                             // Set the determined custom error message below the input element and update the native validity flag.
                             this._setErrorMessage(customMessage); // This also sets `this._element.setCustomValidity(customMessage);`.
                             isValid = false; // Overall validation fails if native validation failed. (Redundant, as `isNativeValid` is false).

                         } else {
                            // If native validation passed (`isNativeValid` is true):
                             // Clear any specific date-related error messages that might have been set below the input.
                             // `_clearErrorMessage()` handles clearing the message text and setting native validity to `''`.
                             this._clearErrorMessage();
                            isValid = true; // Overall validation passes (based on native checks and the successful `super._validate()` result).
                             Logger.debug(`${this.name}._validate: Passed native date validation checks.`);
                         }


                        // Update the component's internal `_isValid` state flag based on the final boolean result (`isValid`).
                         // This reflects the combined result from `super._validate()` and the native validity checks.
                        this._isValid = isValid; // Sets the protected `_isValid` flag.
                        Logger.debug(`${this.name} validation result: ${this._isValid}.`);

                        // Return the final validity status.
                        return this._isValid;

                    } catch (error) {
                         // Catch any unexpected errors occurring *within* the DateInput specific `_validate` logic execution (e.g., access issues, method call errors not caught internally).
                         this.#errorReporter.reportError(
                             `${this.name}._validate`, // Source is the DateInput's _validate method.
                             error, // The error object caught.
                             { component: this.#getComponentInfo(), value: this._value, validity: this._getValidityState(), step: 'date_specific_validation_execution' }, // Context.
                             `Error during date validation logic for component "${this.name}". Cannot determine validity.`, // User-facing message template for validation logic error.
                             'dateinput_validate_exception_logic' // GA error code for validation *logic* exception.
                         );
                         // If the validation process itself fails critically by throwing an error, the component is considered invalid.
                         this._isValid = false; // Explicitly set internal state to false.
                         // Attempt to set a generic error message for the user via the UI element.
                         this._setErrorMessage(`Validation error: ${error.message}`); // Use the error's message in a generic template.
                         return false; // Always return `false` if validation failed due to an error in the logic.
                    }
                } // End of _validate method definition.

                /**
                 * Public getter method to retrieve the date value from the HTML date input element (`this._element`) as a JavaScript `Date` object.
                 * Parses the input's value string (expected to be in YYYY-MM-DD format from `<input type="date">`) into a `Date` object, treating it as local time.
                 * Includes checks for valid string format and potential parsing errors (`Invalid Date`).
                 * This method is useful when you need to perform date comparisons or date arithmetic in your application logic.
                 * @returns {Date|null} - Returns a valid JavaScript `Date` object if the input element's value is a valid, non-empty date string that can be successfully parsed. Returns `null` if the value is empty, the format is incorrect, parsing fails (`Invalid Date`), or an error occurs during the process.
                 */
                get DateObject() {
                    try {
                         // Get the raw string value from the input element using the parent's `getValue` method.
                         // `getValue()` handles trimming for text-like inputs. For date inputs, it returns the value string directly.
                        const valueString = this.getValue();

                        // If the value string is empty or contains only whitespace after trimming, return `null` immediately.
                        // An empty string does not represent a date.
                        if (!valueString) {
                            // Logger.debug(`${this.name}.DateObject: Input value is empty. Returning null DateObject.`); // Verbose logging.
                            return null; // Return null if there's no value to parse.
                        }

                         // --- Attempt to Parse Date String ---
                         // The expected format from `<input type="date">` is YYYY-MM-DD. Split the string by the hyphen `-`.
                        const parts = valueString.split('-');

                        // Check if the string was split into exactly 3 parts (year, month, day)
                        // AND if each of these parts can be successfully parsed as an integer number using `parseInt` with radix 10.
                         if (parts.length === 3 && !isNaN(parseInt(parts[0], 10)) && !isNaN(parseInt(parts[1], 10)) && !isNaN(parseInt(parts[2], 10))) {

                             // Parse the year, month, and day parts into integers.
                              const year = parseInt(parts[0], 10); // Year part.
                              // **IMPORTANT:** JavaScript `Date` constructor's month parameter is 0-indexed (0 = January, 11 = December).
                              // The YYYY-MM-DD string format is 1-indexed (1-12). Subtract 1 from the parsed month part.
                              const month = parseInt(parts[1], 10) - 1; // Month part (adjusted to 0-indexed).
                              const day = parseInt(parts[2], 10); // Day part.

                              // Add basic sanity checks on parsed month/day ranges *before* creating the Date object.
                              // The `Date` constructor is flexible but can create an "Invalid Date" for impossible combinations (like February 30th).
                              // These checks provide clearer debug logs for dates with parts out of standard ranges (0-11 for month, 1-31 for day, depending on month).
                              if (month < 0 || month > 11 || day < 1 || day > 31) { // Simple range check. More complex validation might check days per month.
                                   Logger.warn(`${this.name}.DateObject: Parsed date parts out of expected range. Value: "${valueString}". Parsed Month Index: ${month}, Parsed Day: ${day}. Returning null.`);
                                  // If parts are out of standard range, it's likely not a valid date. Return null.
                                   return null;
                              }

                             // Create a JavaScript `Date` object using the parsed year, monthIndex, and day.
                             // The `Date(year, monthIndex, day)` constructor is typically interpreted as local time,
                             // which is appropriate for dates selected via UI pickers for concepts like check-in/check-out dates.
                             const dateObject = new Date(year, month, day);

                             // The `Date` constructor can create an "Invalid Date" object if the input date is impossible (e.g., `new Date(2023, 1, 30)` for Feb 30th).
                             // An "Invalid Date" object has its time value (`getTime()`) set to `NaN`. Check for this specifically using `isNaN()`.
                             if (isNaN(dateObject.getTime())) {
                                  Logger.warn(`${this.name}.DateObject: Date object created is Invalid Date after parsing "${valueString}". This indicates an invalid date combination.`);
                                 return null; // Return null if the resulting Date object is invalid.
                             }

                             // If all checks pass and a valid `Date` object is created, log success and return the object.
                             Logger.debug(`${this.name}.DateObject: Successfully parsed "${valueString}" to a valid Date object.`);
                             return dateObject; // Return the valid `Date` object.

                         } else {
                              // --- Handle Incorrect Format ---
                              // If splitting by hyphen fails to yield 3 parts, or if any part cannot be parsed as a number,
                              // the input string is not in the expected YYYY-MM-DD format or is malformed.
                             Logger.warn(`${this.name}.DateObject: Failed to parse date string "${valueString}" into DateObject. Format is incorrect (expected YYYY-MM-DD). Parts: "${parts.join('-') || 'N/A'}".`);
                             return null; // Return null if parsing fails due to incorrect format or malformation.
                         }

                     } catch (error) {
                          // Catch any unexpected errors occurring *within* the `DateObject` getter itself (e.g., errors during string splitting, parseInt, Date construction, accessing `getTime`).
                          // Report this error using the injected reporter.
                          this._errorReporter.reportError(
                              `${this.name}.DateObject`, // Source of the error.
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), value: this.getValue(), step: 'getDateObject_execution_exception' }, // Context details.
                              `Error parsing date value for component "${this.name}". Could not get Date object.`, // User-friendly message.
                              'dateinput_get_date_object_exception' // GA error code.
                          );
                         return null; // Always return null on error to indicate failure to get a valid `Date` object.
                     }
                 } // End of DateObject getter definition.

                  /**
                   * Public getter for the date type property (`#dateType`).
                   * Returns the string value that specifies what type of date this input represents ('check-in' or 'check-out').
                   * @returns {string} - The stored date type ('check-in', 'check-out', or 'unknown' if not set).
                   */
                  get dateType() {
                      try {
                           // Access the private member `#dateType`. Use nullish coalescing `?? 'unknown'` as a fallback if not initialized.
                           return this.#dateType ?? 'unknown';
                      } catch (error) {
                           // Report errors occurring while trying to access the private date type member.
                           this._errorReporter.reportError(
                               `${this.name}.dateType`, error,
                               { component: this.#getComponentInfo(), internalDateType: this.#dateType, step: 'get_datetype_access' }, // Context.
                               `Error getting date type for component "${this.name}".`, 'dateinput_get_datetype_exception' // GA error code.
                           );
                           return 'unknown'; // Return default ('unknown') on error.
                      }
                  } // End of dateType getter definition.

                 /**
                  * Override dispose method from `InputComponent`.
                  * Calls the parent's dispose method for base and input-specific cleanup.
                  * `DateInput` specific cleanup is minimal beyond inherited cleanup, mainly just clearing internal members.
                  */
                 dispose() {
                      try {
                           Logger.debug(`Disposing DateInput: ${this.name}.`);
                          // Call the parent's `dispose` method first. This handles all base and `InputComponent`-specific cleanup (event listeners, element references, error message element reference, etc.).
                          super.dispose(); // Calls InputComponent.dispose().

                          // --- DateInput Specific Cleanup ---
                          // Clear the private member `#dateType`. Explicitly setting it to a specific value like 'disposed'
                          // can sometimes be useful for debugging if you suspect components are being used after disposal,
                          // but clearing the reference or setting it to null is standard practice for disposal.
                          this.#dateType = 'disposed'; // Indicate disposal state (optional).

                          Logger.debug(`DateInput disposed: ${this.name}. Cleanup complete.`);

                      } catch (error) {
                           // Catch and log errors occurring during the disposal process. Use console.error as `_errorReporter` might be nullified by `super.dispose`.
                          console.error(`CRITICAL ERROR during disposal of DateInput "${this.name}" (ID: ${this.id}):`, error, { step: 'dispose_execution_exception' });
                          // Do not re-throw.
                      }
                 } // End of dispose method definition.
             } // End of DateInput class definition.


             // --- Class for Number Input, inheriting from InputComponent ---
             // Extends the `InputComponent` to provide functionality specifically for HTML number input elements (`<input type="number">`).
             // Adds number-specific validation logic leveraging the native HTML5 `ValidityState` (min, max, step)
             // and provides a getter to retrieve the number value safely.
             class NumberInput extends InputComponent {

                 /**
                  * Constructor for NumberInput.
                  * Calls the parent constructor (`InputComponent`) to wrap the HTML element and initialize base input features.
                  * @param {string} elementId - The ID string of the HTML number input element (`<input type="number" id="...">`). Required.
                  * @param {string} [componentName='NumberInput'] - A descriptive name for this type (e.g., 'AdultsInput', 'ChildrenInput'). Defaults to 'NumberInput'.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                  * @throws {Error} Propagates errors thrown by the parent constructor.
                  */
                 constructor(elementId, componentName = 'NumberInput', errorReporter) {
                      try {
                         // Log the start of the constructor for debugging. Include element ID.
                         Logger.debug(`${componentName} constructor called for ID "${elementId}".`);

                         // Call the parent `InputComponent` constructor first.
                         // Pass the element ID, set the specific component name, and pass the required ErrorReporter instance.
                         super(elementId, componentName, errorReporter); // Pass element ID, name, reporter.

                         // Check if the wrapped HTML element (`this._element`) was found successfully by the parent constructor AND if it's the expected `type="number"`.
                         // Number-specific validation and parsing rely on `type="number"` input features and attributes.
                         if (this._element) { // Parent checks if element exists.
                             if (this._element.type !== 'number') {
                                // If the element was found but is *not* `type="number"`, log a warning that number-specific features will be limited.
                                Logger.warn(`${this.name} (ID: ${this.id}): Wrapped element is type "${this._element.type}" instead of "number". Number-specific validation/parsing may not work correctly, relying on native browser behavior for the actual element type.`);
                                 // `this._isValid` state is handled by parent based on element lookup and base validation.
                                 // Subclass `_validate` should ideally account for the actual element type.
                             } else {
                                  Logger.debug(`${this.name} initialized. Wrapped element is indeed type="number".`);
                             }
                         } else {
                            // If element was not found by parent constructor (`this._element` is null), warning logged there.
                            Logger.debug(`${this.name} (ID: ${elementId}): Wrapped element missing. Skipping number-specific checks.`);
                         }

                          // Log the completion of the NumberInput constructor.
                          Logger.debug(`${this.name} constructor finished.`);

                      } catch (error) {
                           // Catch any unexpected errors occurring *within* the NumberInput constructor's own logic (after calling `super()`).
                           // Report this error using the injected `_errorReporter`.
                           this.#errorReporter.reportError(
                               `${componentName}.constructor`,
                               error, // The error object caught.
                               { elementId: elementId, componentName: componentName, step: 'constructor_execution_after_super' }, // Context details.
                               `Failed to construct Number input component "${elementId}".`, // User-facing message template.
                               'numberinput_init_exception_after_super' // GA error code for this specific exception type.
                           );
                           // Ensure the component's state reflects a critical construction failure.
                           // Parent constructor handles `this._element` and `this._isValid`.

                           // Re-throw the initialization error to propagate it up to the caller (`SearchForm`'s collector).
                           throw error;
                      }
                  } // End of constructor definition.

                 /**
                  * Polymorphism: Overriding the protected `_validate` method from `InputComponent`.
                  * Provides number-specific validation rules for the number input element.
                  * It first calls the parent's `_validate` method (handling 'required' checks), and then
                  * leverages the native HTML5 `ValidityState` object (checked by `this._element.checkValidity()`)
                  * to determine validity based on attribute constraints like `type="number"` parsing (`badInput`)
                  * and range/step checks (`min`, `max`, `step`, `rangeUnderflow`/`Overflow`, `stepMismatch`).
                  * Clears or sets specific number-related error messages below the input element using `_setErrorMessage`.
                  * @returns {boolean} - Returns `true` if all number-specific validation rules pass (including the parent's required check and native validity checks), `false` otherwise.
                  */
                  _validate() {
                     try {
                         Logger.debug(`${this.name}._validate: Called. (NumberInput specific validation)`);

                         // --- Call Parent Validation ---
                         // Call the parent `InputComponent`'s `_validate` method first.
                         // This handles the fundamental `required` check based on the input's value string (`this._value`),
                         // and also clears existing custom error messages and native validity flags *before* running new validation checks.
                         let isValid = super._validate(); // Execute parent validation.

                          // If base validation (e.g., required but empty) already failed, return `false` immediately.
                          // Number-specific checks based on value ranges are irrelevant if the field is empty and required.
                          if (!isValid) {
                               Logger.debug(`${this.name}._validate: Failed base validation ('required'). Skipping number-specific checks.`);
                              return false; // Exit early.
                          }

                         // --- Number-Specific Validation Checks using `ValidityState` ---
                         // Get the native HTML5 `ValidityState` object from the input element (`this._element`).
                         // This reflects the validity status based on attributes like `type`, `required`, `min`, `max`, `step`.
                         const validity = this._getValidityState();
                          // If `ValidityState` is not available (e.g., `this._element` is null or browser doesn't support `validity` for this type),
                          // we cannot perform detailed attribute-based validation. Rely solely on the base `required` check.
                          if (!validity) {
                              Logger.warn(`${this.name}._validate: Cannot get ValidityState. Skipping detailed number validation using native validity.`);
                             // `isValid` is still true from the successful `super._validate()` call.
                              return isValid; // Return true if base validation passed and native checks are skipped.
                          }

                         // Use the browser's built-in validity checks aggregated by `this._element.checkValidity()`.
                         // This method checks several standard HTML5 number constraints based on attributes:
                         // - `validity.badInput`: Value cannot be parsed as a number for `<input type="number">`.
                         // - `validity.rangeUnderflow`: Number value is less than the `min` attribute.
                         // - `validity.rangeOverflow`: Number value is more than the `max` attribute.
                         // - `validity.stepMismatch`: Number value does not align with the `step` attribute.
                         // - `validity.valueMissing`: Input is `required` but has no value (covered by `super._validate()`).
                         const isNativeValid = this._element.checkValidity(); // Get the aggregate result of native validity checks.


                         // Based on the result of the native checks (`isNativeValid`):
                          if (!isNativeValid) {
                               // If the input is NOT valid according to native browser checks:
                               Logger.debug(`${this.name}._validate: Failed native number validation. ValidityState details:`, validity);

                               // Determine the specific error message to display based on which native `validity` flags are true.
                               let customMessage = 'Invalid number input.'; // Default message if no specific condition matches.

                              // Use an `if/else if` chain to prioritize messages or handle specific errors based on validity flags.
                               if (validity.valueMissing) {
                                    // The input is `required` but empty. Covered by `super._validate()`. Use required message.
                                   customMessage = AppConfig.MESSAGES.INPUT_REQUIRED;
                                } else if (validity.badInput) {
                                    // The user entered input that cannot be parsed as a number (e.g., text).
                                    // This is the primary way non-numeric input is flagged for `type="number"`.
                                   customMessage = AppConfig.MESSAGES.INPUT_INVALID_NUMBER; // Use our standard non-numeric message.
                                } else if (validity.rangeUnderflow) {
                                    // The number value is less than the minimum value specified in the `min` attribute.
                                    const min = parseFloat(this._element.min); // Get the `min` value from the DOM attribute. Use `parseFloat` for robustness.
                                    // Use the original attribute value string in the user message if parsing `min` to float failed.
                                   customMessage = AppConfig.MESSAGES.INPUT_NUMBER_MIN(isNaN(min) ? this._element.min : min);
                                } else if (validity.rangeOverflow) {
                                    // The number value is more than the maximum value specified in the `max` attribute.
                                    const max = parseFloat(this._element.max); // Get the `max` value from the DOM attribute.
                                   customMessage = AppConfig.MESSAGES.INPUT_NUMBER_MAX(isNaN(max) ? this._element.max : max);
                                } else if (validity.stepMismatch) {
                                    // The number value does not align correctly with the `step` attribute.
                                   customMessage = 'Value must be a valid step.'; // Customize to include step value if helpful.
                                } else if (validity.typeMismatch) {
                                    // Not directly applicable for `type="number"` where `badInput` is used. Included defensively.
                                     Logger.warn(`${this.name}._validate: Failed validation with unexpected typeMismatch for number input.`);
                                    customMessage = this._element.validationMessage || customMessage; // Fallback message.
                                }
                                 else {
                                    // Catch any other unexpected or unhandled native validity states.
                                    // Use the browser's default `validationMessage` property as a fallback if it exists.
                                    customMessage = this._element.validationMessage || customMessage;
                                     Logger.warn(`${this.name}._validate: Failed validation with unhandled ValidityState flags:`, validity);
                                }

                              // Set the determined custom error message below the input element and update the native validity flag (`setCustomValidity`).
                              this._setErrorMessage(customMessage); // This also sets `this._element.setCustomValidity(customMessage);`.
                              isValid = false; // Overall validation fails if native validation failed. (Redundant, as `isNativeValid` is false).

                          } else {
                             // If native validation passed (`isNativeValid` is true):
                             // Clear any specific number-related error messages that might have been set below the input by this component.
                             // `_clearErrorMessage()` handles clearing the message text and setting native validity to `''`.
                             this._clearErrorMessage();
                             isValid = true; // Overall validation passes (based on native checks and the successful `super._validate()` result).
                             Logger.debug(`${this.name}._validate: Passed native number validation checks.`);
                          }


                         // Update the component's internal `_isValid` state flag based on the final boolean result (`isValid`).
                          // This reflects the combined result from `super._validate()` and the native validity checks.
                         this._isValid = isValid; // Sets the protected `_isValid` flag.
                         Logger.debug(`${this.name} number validation result: ${this._isValid}.`);

                         // Return the final validity status.
                         return this._isValid;

                     } catch (error) {
                          // Catch any unexpected errors occurring *within* the NumberInput specific `_validate` logic execution.
                          // Report this error using the injected `_errorReporter`.
                          this.#errorReporter.reportError(
                              `${this.name}._validate`, // Source of the error.
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), value: this._value, validity: this._getValidityState(), step: 'number_specific_validation_execution' }, // Context details.
                              `Error during number validation logic for component "${this.name}". Cannot determine validity.`, // User-facing message template for validation logic error.
                              'numberinput_validate_exception_logic' // GA error code for validation *logic* exception.
                          );
                          // If the validation process itself fails critically by throwing an error, the component is considered invalid.
                          this._isValid = false; // Explicitly set internal state to false.
                          // Attempt to set a generic error message for the user via the UI element.
                          this._setErrorMessage(`Validation error: ${error.message}`); // Use the error's message in a generic template.
                          return false; // Always return `false` if validation failed due to an error in the logic.
                     }
                 } // End of _validate method definition.

                  /**
                   * Public method to retrieve the value of the number input element (`this._element`) as a JavaScript `number`.
                   * Parses the input's string value (obtained via `getValue()`) using `parseFloat`.
                   * Includes robust handling for cases where the input string might be empty or contain non-numeric characters by returning `NaN`.
                   * This method is useful when you need to perform arithmetic operations or numerical comparisons with the input value.
                   * @returns {number} - The numerical value if the input string can be parsed as a number (float or integer). Returns `NaN` if the input string is empty, consists of only whitespace, contains non-numeric characters preventing parsing, or if an error occurs during the process.
                   */
                  getValueAsNumber() {
                      try {
                           // Get the string value from the input element using the parent's `getValue` method.
                           // `getValue()` handles basic trimming for text-like inputs.
                          const valueString = this.getValue();

                          // Use `parseFloat` to attempt to convert the string value to a number.
                          // `parseFloat(str)` stops parsing at the first non-numeric character.
                          // `parseFloat('')` results in `NaN`. `parseFloat(' 123 ')` results in 123.
                          const numericValue = parseFloat(valueString);

                          // Check if the result of parsing is `NaN`. `isNaN()` checks specifically for the NaN value.
                           if (isNaN(numericValue)) {
                               // If parsing failed (resulting in NaN, e.g., input was "", "abc", "123a"), log a debug message.
                              // Logger.debug(`${this.name}.getValueAsNumber: Parsed value is NaN from string "${valueString}".`); // Verbose debug logging.
                               // Return NaN to indicate that the input value could not be represented as a valid number.
                              return NaN; // Return NaN.
                           }

                           // If parsing was successful (result is not NaN), log success and return the numeric value.
                           // Logger.debug(`${this.name}.getValueAsNumber: Parsed "${valueString}" successfully to number ${numericValue}.`); // Verbose debug logging.
                           return numericValue; // Return the parsed number.

                       } catch (error) {
                           // Catch any unexpected errors occurring *within* the `getValueAsNumber` method itself (e.g., errors during `getValue` call if not caught by parent, or unexpected access issues).
                           this.#errorReporter.reportError(
                               `${this.name}.getValueAsNumber`, error,
                               { component: this.#getComponentInfo(), value: this.getValue(), elementType: this._element?.type, step: 'getValueAsNumber_execution_exception' }, // Context.
                               `Error getting number value for component "${this.name}".`, // User-friendly message.
                               'numberinput_get_value_exception_overall' // GA error code.
                           );
                           // Always return NaN on error to indicate that a valid number could not be obtained.
                           return NaN;
                       }
                  } // End of getValueAsNumber method definition.

                 /**
                  * Override dispose method from `InputComponent`.
                  * Cleans up resources specific to the `NumberInput`. Calls the parent's dispose method first.
                  */
                  dispose() {
                      try {
                           Logger.debug(`Disposing NumberInput: ${this.name}.`);
                          // Call the parent `InputComponent`'s `dispose` method first for base and input-specific cleanup.
                          super.dispose(); // Calls InputComponent.dispose().

                          // --- NumberInput Specific Cleanup ---
                          // There are no additional private or protected members introduced specifically in `NumberInput` that require explicit cleanup steps beyond letting the JavaScript object instance be garbage collected.

                          Logger.debug(`NumberInput disposed: ${this.name}. Cleanup complete.`);

                      } catch (error) {
                           // Catch and log errors occurring during the disposal process. Use console.error as `_errorReporter` might be nullified by `super.dispose`.
                          console.error(`CRITICAL ERROR during disposal of NumberInput "${this.name}" (ID: ${this.id}):`, error, { step: 'dispose_execution_exception' });
                          // Do not re-throw.
                      }
                  } // End of dispose method definition.
              } // End of NumberInput class definition.


             /**
              * Class for Destination Input with Google Autocomplete, inheriting from `InputComponent`.
              * This class extends the `InputComponent` to manage the input field used for destination searches
              * and integrates with the Google Places Autocomplete JavaScript API (`google.maps.places.Autocomplete`)
              * to provide real-time place suggestions as the user types. It handles the lifecycle and events specific to
              * interacting with the Google Autocomplete feature, including handling place selections and synchronizing state.
              */
             class DestinationInput extends InputComponent {
                 // Private member to hold the Google Autocomplete object instance (`google.maps.places.Autocomplete`) created by the Google Maps JS API.
                 #autocomplete = null; // Initialized to `null`. This will hold the actual Google Autocomplete instance if initialized successfully.

                 // Private member to store the Google Place details object (`google.maps.places.Place`) obtained when a user explicitly selects a suggestion from the Autocomplete dropdown list.
                 // This object contains structured information about the selected place (like name, coordinates, address components) based on the `fields` option provided during Autocomplete initialization.
                 #placeDetails = null; // Initialized to `null`.

                 // Private flag: `true` if the user explicitly selected a place suggestion from the Autocomplete dropdown list using the mouse, Enter key, or Tab key; `false` otherwise.
                 // This flag is important for application logic (like validation) to distinguish between the user just typing text into the input field versus confirming a specific, recognized place selection from the list.
                 #isPlaceSelected = false; // Initialized to `false`.

                 /**
                  * Constructor for DestinationInput.
                  * Calls the parent constructor (`InputComponent`) to wrap the target HTML element and initialize base input features.
                  * It then attempts to set up and initialize Google Autocomplete on the wrapped input element if the Google Places API library
                  * is determined to be available globally in the browser's environment.
                  * @param {string} elementId - The ID string of the HTML text input element (`<input type="text" id="...">`) designated for destination input. Required.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                  * @throws {Error} Propagates errors thrown by the parent constructor or throws if fundamental issues in this constructor prevent initialization.
                  */
                 constructor(elementId, errorReporter) {
                     try {
                         // Log the start of the constructor for debugging. Include element ID.
                         Logger.debug(`DestinationInput constructor called for ID "${elementId}".`);

                         // Call the parent `InputComponent` constructor first.
                         // This handles finding and wrapping the DOM element (`this._element`), basic input setup (`_value`, `_errorMessageElement`), and passing the ErrorReporter.
                         // Pass the element ID, set the specific component name ('DestinationInput'), and pass the required ErrorReporter instance.
                         super(elementId, 'DestinationInput', errorReporter); // Pass element ID, component name, reporter.

                         // Explicitly initialize private members introduced in this class.
                         this.#autocomplete = null;
                         this.#placeDetails = null;
                         this.#isPlaceSelected = false;


                         // --- Attempt to initialize Google Autocomplete ---
                         // Google Maps JS API and its Places library (specifically `google.maps.places.Autocomplete`) are loaded asynchronously via the script tag in the `<head>` with `defer`.
                         // This constructor runs *after* the DOM is ready (`$(document).ready`), but the Google API script itself might still be loading or executing.
                         // Check if the global `google`, `google.maps`, `google.maps.places` objects and the `Autocomplete` class within `places` are available at this moment.
                         // Also, ensure the component's wrapped HTML element (`this._element`) was successfully found and is not null.
                         if (typeof google !== 'undefined' && google.maps && google.maps.places && typeof google.maps.places.Autocomplete === 'function' && this._element) {
                            Logger.debug(`${this.name} (ID: ${this.id}): Google Maps Places API (including Autocomplete) and target element are available. Proceeding with Autocomplete initialization.`);
                              // If all necessary dependencies are met and the target HTML element is found, initialize Google Autocomplete using a protected helper method.
                             this._initializeAutocomplete(); // Call the helper method to set up Autocomplete.
                              Logger.debug(`${this.name} component initialized successfully with Google Autocomplete support.`);

                         } else if (this._element) {
                             // If the wrapped element (`this._element`) was found by the parent but the Google Places API components are missing globally (e.g., script failed to load, incorrect URL, API key issues preventing library loading),
                             // log a warning specific to the Autocomplete feature not being available. The input element will still be managed by the parent `InputComponent` as a basic text field,
                             // but the autocomplete suggestions feature will not work for this input.
                            Logger.warn(`${this.name} (ID: ${this.id}) skipped Autocomplete initialization: Required Google Maps Places API components are not globally available (${typeof google?.maps?.places?.Autocomplete === 'function' ? 'found' : 'missing'}) even though element exists. Check API Key and script loading.`);
                             // The ErrorReporter would have logged a UI Element Missing error if the main component's element wasn't found.
                             // If the element *is* present but Autocomplete setup fails, this is a warning for this specific feature.
                             // No further action is needed here; the component functions as a basic input.

                         } else {
                            // If `this._element` is null, the parent constructor already logged a fatal warning and marked the component as invalid because its base HTML element wasn't found.
                             // Log a debug message confirming that Autocomplete initialization is skipped because the base element is missing.
                             Logger.debug(`${this.name} (ID: ${elementId}): Wrapped element missing (null). Skipping Autocomplete initialization.`);
                         }

                          // Log the completion of the DestinationInput constructor.
                          Logger.debug(`${this.name} constructor finished.`);

                      } catch (error) {
                           // Catch any unexpected synchronous errors occurring *within* the DestinationInput constructor's own logic (after calling `super()`, e.g., during initial property assignments or validation *before* _initializeAutocomplete).
                           // This indicates a programming issue in the DestinationInput constructor itself.
                           // Report this error using the injected `_errorReporter`.
                           this.#errorReporter.reportError(
                               `${componentName}.constructor`,
                               error, // The error object caught.
                               { elementId: elementId, step: 'constructor_execution_after_super_logic' }, // Context details.
                               `Failed to construct Destination Input component "${elementId}".`, // User-facing message template.
                               'destinput_init_exception_after_super_logic' // GA error code.
                           );
                           // Ensure internal state reflects initialization failure, even if partial setup occurred.
                           this.#autocomplete = null; // Explicitly clear references in case error happened after creating them.
                           this.#placeDetails = null;
                           this.#isPlaceSelected = false;
                           // The parent constructor handles `this._element` and `this._isValid`.

                           // Re-throw the initialization error to propagate it up to the caller (`SearchForm`'s collector),
                           // indicating that component initialization failed critically.
                          throw error;
                      }
                  } // End of constructor definition.

                 /**
                  * Protected method to initialize the Google Autocomplete feature on the input element (`this._element`).
                  * This method is called by the constructor only if the Google Places API and the element are available.
                  * It creates a `google.maps.places.Autocomplete` instance attached to `this._element`, configuring it
                  * with specific options (place types, fields to retrieve).
                  * It then attaches necessary event listeners: `place_changed` on the Autocomplete instance, and `blur` and `input`
                  * on the input element using the `_addEventListener` helper to integrate gracefully with the autocomplete UI and workflow.
                  * Errors encountered during this initialization process are caught and reported internally.
                  */
                 _initializeAutocomplete() {
                     try {
                         Logger.debug(`${this.name}._initializeAutocomplete: Called. Setting up Google Autocomplete on element ID "${this.id}".`);

                         // --- Defensive Check for Prerequisites ---
                         // Double-check that the wrapped element (`this._element`) is not null AND that the required
                         // Google Maps Places API components (`google.maps.places.Autocomplete`) are available globally.
                         // This is a defensive check in case the constructor logic had a race condition or issue with API loading detection.
                         if (!this._element || typeof google === 'undefined' || !google.maps || !google.maps.places || typeof google.maps.places.Autocomplete !== 'function') {
                             const errorMsg = `_initializeAutocomplete: Prerequisites missing at execution time. Cannot initialize Autocomplete.`;
                             Logger.error(`${this.name}._initializeAutocomplete: ${errorMsg}.`);
                             // Report this as a configuration or runtime infrastructure issue.
                             this.#errorReporter.reportError(
                                 `${this.name}._initializeAutocomplete`, new Error(errorMsg), // Create specific error object.
                                 { component: this.#getComponentInfo(), hasElement: !!this._element, googleAPIStatus: typeof google?.maps?.places?.Autocomplete, step: 'prerequisite_check' }, // Context.
                                 `Google Autocomplete feature initialization failed for "${this.name}". API components unavailable.`, // User message.
                                 'destinput_autocomplete_init_prerequisites_missing' // GA error code.
                             );
                             // `this.#autocomplete` remains null. Subsequent methods relying on it will check for null.
                             return; // Exit the method.
                         }


                         // --- Google Autocomplete Configuration Options ---
                         // Define the behavior and restrictions for the Google Autocomplete service instance being created.
                         const autocompleteOptions = {
                             // `types`: An array of strings specifying the types of places to include in suggestions.
                             // Combining 'establishment' (businesses, landmarks) and 'geocode' (cities, regions)
                             // is suitable for a travel destination search.
                             types: ['establishment', 'geocode'],
                              // `fields`: CRITICAL for cost optimization and data availability. Specifies which Place Details
                              // fields to fetch for a selected prediction. **REQUEST ONLY NECESSARY FIELDS.**
                              // Cost of Place Details requests varies significantly by field type (Basic, Contact, Atmosphere).
                              // Basic fields (`place_id`, `name`, `geometry`) are usually needed and lower cost.
                              // `formatted_address` is useful for display. `address_components` provides structured address parts.
                              // Consult Google Places API pricing: https://developers.google.com/maps/documentation/places/web-service/usage-and-billing
                             fields: ['place_id', 'name', 'formatted_address', 'geometry'], // Request essential fields.
                              // `strictBounds`: If `true`, confines suggestions to places within the visible viewport of a map associated with the Autocomplete instance.
                              // If `false` (like here), suggestions can be global, potentially biased by browser location if permitted.
                             strictBounds: false, // Allow broader suggestions.
                              // `componentRestrictions`: Filters suggestions by country or a set of countries. Highly recommended to narrow results.
                             // Example: `componentRestrictions: { country: ['us', 'gb', 'fr'] }`. Look up ISO 3166-1 Alpha-2 country codes.
                             // componentRestrictions: { country: ["us"] }, // Uncomment and configure if needed.
                              // `sessionToken`: Essential for accurate billing of Autocomplete requests. This is complex and involves managing a token for a user's interactive session. The token is attached to initial Autocomplete requests and the subsequent Place Details request.
                              // Omitted for simplicity in this basic demo simulation structure, but vital for production cost management.
                              // `bounds`: Bias predictions towards a specified geographical area (LatLngBounds) without restricting them strictly to the bounds.
                         };
                          Logger.debug(`${this.name}._initializeAutocomplete: Autocomplete options configured.`, autocompleteOptions);


                         // --- Create Google Autocomplete Instance ---
                         // Instantiate a new `google.maps.places.Autocomplete` object. This class is provided by the Google Places API library.
                         // It takes the HTML input element (`this._element`) and the `options` as arguments.
                         // This action links the Autocomplete functionality to the input and enables the dropdown suggestions UI.
                         this.#autocomplete = new google.maps.places.Autocomplete(this._element, autocompleteOptions);
                          Logger.debug(`${this.name}._initializeAutocomplete: Google Autocomplete instance created and successfully attached to input element ID "${this.id}".`);


                         // --- Attach Event Listeners to the Autocomplete Object ---
                         // The most important event provided by the Autocomplete object is `place_changed`. This fires when a user selects a prediction from the dropdown (by mouse click, pressing Enter/Tab with an item highlighted).
                         // Attach a listener to the `this.#autocomplete` object *instance* using its `addListener` method.
                         // The handler method is `_handlePlaceChanged`. Use `.bind(this)` to ensure the handler's `this` context is the component instance.
                         this.#autocomplete.addListener('place_changed', this._handlePlaceChanged.bind(this));
                         Logger.debug(`${this.name}._initializeAutocomplete: Attached 'place_changed' listener to the Google Autocomplete instance.`);


                         // --- Attach Standard Input Element Event Listeners (relevant for Autocomplete interaction) ---
                         // Attach standard DOM event listeners to the wrapped input element (`this._element`) that are relevant for managing component state and validation *in the context of autocomplete interaction*.
                         // Use the parent's `_addEventListener` helper for proper `this` binding and storage for disposal.
                         // We need handlers for `blur` (when the input loses focus) and `input` (when the text changes).
                         // `_handleBlurWithDelay` is a custom override to handle the timing issue between 'blur' and 'place_changed'.
                         // `_handleDestinationInput` is a custom override to handle the 'input' event and clear autocomplete-specific state.
                         this._addEventListener('blur', this._handleBlurWithDelay); // Attach custom delayed blur handler.
                         this._addEventListener('input', this._handleDestinationInput); // Attach custom input handler.

                          // Other standard input events (`change`, `focus`, `invalid`) can be handled by methods
                          // inherited from the `InputComponent` (or overridden if their behavior needs customization related to destination).


                          Logger.debug(`${this.name}._initializeAutocomplete: Standard input element event listeners (blur, input) attached for Autocomplete integration.`);

                     } catch (error) {
                          // Catch any unexpected errors occurring *during the process of initializing* the Google Autocomplete feature itself (e.g., error creating the Autocomplete object due to invalid options, API not fully ready unexpectedly).
                          // Report this error as an infrastructure or configuration issue using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._initializeAutocomplete`,
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), hasElement: !!this._element, googleAPIStatus: typeof google?.maps?.places?.Autocomplete, step: 'initialization_exception' }, // Context.
                              `Google Autocomplete feature initialization failed for "${this.name}". Check API Key, script loading, and configuration.`, // User-friendly message template.
                              'destinput_autocomplete_init_exception' // GA error code.
                          );
                          // If initialization fails, `this.#autocomplete` remains null. Subsequent method calls that rely on it must check for its availability (`if (this.#autocomplete) { ... }`).
                          // The input will still function as a standard text input field managed by the parent `InputComponent`.
                          // Do not re-throw from this initialization method; allow the component to exist in a reduced state.
                     }
                 } // End of _initializeAutocomplete method definition.

                 /**
                  * Handler for the Google Autocomplete `place_changed` event. Marked async (if future Place Details methods are async).
                  * This method is called automatically by the Google Autocomplete library when a user explicitly selects a place suggestion from the dropdown list.
                  * It performs the following actions:
                  * 1. Retrieves the `google.maps.places.Place` object containing the details for the selected prediction using `autocomplete.getPlace()`.
                  * 2. Updates the component's internal state: stores the Place object in `#placeDetails` and sets the `#isPlaceSelected` flag to `true`.
                  * 3. Logs information about the selected place.
                  * 4. Ensures the component's internal `_value` property is synchronized with the DOM input element's value (which is automatically updated by Autocomplete on selection).
                  * 5. Triggers the component's validation logic (`validate()`) after a short delay to allow all state updates to settle.
                  * @param {Event} event - The native DOM-like event object (provided by Google Autocomplete) indicating the place has changed.
                  */
                 _handlePlaceChanged() {
                     try {
                         Logger.debug(`${this.name}._handlePlaceChanged: 'place_changed' event fired from Google Autocomplete.`);

                         // --- Retrieve Place Details ---
                         // Call `getPlace()` on the Autocomplete instance to get the Place object for the user's selection.
                         // This object contains the `fields` requested during initialization (name, place_id, geometry, etc.).
                         // Use a defensive check in case the `#autocomplete` instance is unexpectedly null.
                         const selectedPlace = this.#autocomplete ? this.#autocomplete.getPlace() : null;

                         // --- Update Component State ---
                         // Store the retrieved Place object internally. It might be null if the selection was invalid or the details request failed.
                         this.#placeDetails = selectedPlace;
                         // Reset the `#isPlaceSelected` flag initially before determining the new state.
                         this.#isPlaceSelected = false; // Assume false unless a valid place is found below.


                         // Check if a valid Place object with necessary data (like geometry, usually present for valid places) was successfully retrieved after selection.
                         if (!selectedPlace || !selectedPlace.geometry) {
                             // This branch is executed if the `place_changed` event fired, but `getPlace()` returned null/undefined or a place without expected data (like geometry).
                             // This can happen if:
                             // - The user typed text but pressed Enter/Tab *without* explicitly selecting from the dropdown suggestions.
                             // - The asynchronous Place Details request triggered by the selection failed (e.g., network error, API issue).
                             // - The selected prediction itself was invalid or missing details.
                             Logger.warn(`${this.name}._handlePlaceChanged: No valid Place details available from getPlace() for current input. User might have typed without selection or details lookup failed. Current input value: "${this.getValue()}".`);
                             this.#placeDetails = null; // Ensure stored details are explicitly null in case of failure/no-selection.
                             // The input element's value (`this._element.value`) at this point contains whatever text was in the field.
                         } else {
                             // If a valid Place object with essential details was retrieved, it confirms a successful and valid selection from the autocomplete dropdown.
                             Logger.info(`${this.name}._handlePlaceChanged: Valid place selected from autocomplete: "${selectedPlace.name}" (Place ID: ${selectedPlace.place_id || 'N/A'}).`, { placeDetails: selectedPlace });

                             // Set the `#isPlaceSelected` flag to `true` to explicitly indicate that an explicit selection was made from the dropdown list.
                             this.#isPlaceSelected = true;

                             // The Google Autocomplete library automatically updates the value of the linked input element (`this._element.value`)
                             // with the primary text of the selected prediction (often `place.name` or `place.formatted_address`).
                             // Synchronize the component's internal `_value` property with this updated value from the DOM element.
                             this._value = this._element.value;

                             // Optional: If needed for subsequent operations (e.g., sending a canonical Place ID to a backend search API instead of just the text name),
                             // you can access `selectedPlace.place_id` or `selectedPlace.geometry.location` (LatLng).
                             // For this demo redirecting to Expedia's site search, the input element's value (the destination name) is often sufficient.
                             // Example: If you had a hidden input field in your HTML with ID `destination-place-id-hidden`:
                             // const placeIdInput = document.getElementById('destination-place-id-hidden');
                             // if (placeIdInput && selectedPlace.place_id) { placeIdInput.value = selectedPlace.place_id; } // Set the hidden input value.
                         }

                         // --- Trigger Validation ---
                         // After processing the `place_changed` event, updating the component's internal state (`#placeDetails`, `#isPlaceSelected`, `_value`),
                         // trigger validation for the input field (`validate()`).
                         // Use `setTimeout(..., 0)` to defer the `validate()` call slightly to the end of the current event loop tick.
                         // This provides a small buffer to ensure that the browser has completed any final DOM updates or internal state changes
                         // related to the `place_changed` event and value change before the validation logic reads the DOM value (`this._element.value`)
                         // and internal state flags (`#isPlaceSelected`, `_value`). This helps avoid potential race conditions in some browsers where
                         // blur/validation might fire before the full value update.
                          setTimeout(() => {
                             try {
                                 // This code executes after the 0ms delay.
                                 Logger.debug(`${this.name}._handlePlaceChanged: Executing delayed validate after 'place_changed' event.`);
                                 // Call the component's public `validate()` method. This will execute the component's `_validate()` override,
                                 // which checks validity based on the updated `_value`, `validity`, and potentially the `#isPlaceSelected` flag.
                                this.validate(); // Trigger validation.

                                 // After validation runs (which determines validity based on the state *at the moment validate is called* and might update `_isValid`),
                                 // the component's UI feedback (error messages) should reflect the validity based on the selected place or current value.

                             } catch (error) {
                                  // Catch any unexpected errors that occur specifically *within* this delayed validation callback function execution.
                                  // These are errors in the code *inside* the `setTimeout` function's body.
                                  this._errorReporter.reportError(
                                       `${this.name}._handlePlaceChanged.delayedValidate`, // Source indicating location.
                                       error, // The error object caught.
                                       { component: this.#getComponentInfo(), value: this.getValue(), isPlaceSelected: this.#isPlaceSelected, hasDetails: this.#placeDetails !== null, step: 'delayed_validate_execution' }, // Context details.
                                       `Error during delayed validation execution after place selection for "${this.name}".`, // User-friendly message.
                                       'destinput_delayed_validate_after_placechanged_exception' // GA error code.
                                  );
                                // Errors caught within a setTimeout callback typically do not need re-throwing to the main event loop.
                             }
                         }, 0); // Use a 0ms delay to schedule execution for the next available slot in the event loop.

                    } catch (error) {
                         // --- Handle Errors During Synchronous Handler Execution ---
                         // Catch any unexpected synchronous errors that occur *during the initial execution of the `_handlePlaceChanged` handler itself*
                         // (e.g., before the `setTimeout` is scheduled, errors accessing `this.#autocomplete`, etc.).
                         // Report this error using the injected reporter.
                         this.#errorReporter.reportError(
                             `${this.name}._handlePlaceChanged`, // Source of the error.
                             error, // The error object caught.
                             { component: this.#getComponentInfo(), hasAutocomplete: !!this.#autocomplete, currentDomValue: this._element?.value, step: 'handler_execution_synchronous_part' }, // Context details.
                             `Error handling 'place_changed' event for component "${this.name}". Suggestion processing may be incomplete.`, // User-friendly message template.
                             'destinput_handle_place_changed_exception_overall' // GA error code for overall handler exception.
                         );
                         // Ensure state flags related to selection are reset on error for safety, in case error occurred before they were updated properly.
                         this.#placeDetails = null;
                         this.#isPlaceSelected = false;
                         // Do not re-throw from an event handler; handle the error internally.
                    }
                } // End of _handlePlaceChanged method definition.

                /**
                 * Handler for the native `blur` event on the destination input element.
                 * This method overrides the base `InputComponent._handleBlur`.
                 * It is fired when the input field loses focus. It's a standard place to trigger validation.
                 * For inputs integrated with Google Autocomplete, there's a potential timing issue:
                 * when a user clicks a suggestion in the dropdown, the browser fires the 'blur' event
                 * on the input field *before* the Autocomplete library finishes processing the click
                 * and firing the `place_changed` event.
                 * To address this, this handler implements a small delay before triggering validation,
                 * allowing the `place_changed` handler to complete its updates to the input value and
                 * internal `#isPlaceSelected` flag *before* validation runs.
                 * @param {Event} event - The native DOM 'blur' event object.
                 */
                _handleBlurWithDelay(event) {
                    try {
                         // Log that the blur event fired and validation is being scheduled with a delay.
                         Logger.debug(`${this.name}._handleBlurWithDelay: 'blur' event fired. Scheduling delayed validation with ${AppConfig.VALIDATION_DELAY_MS}ms delay.`);
                         // Note: Preventing default behavior on blur can sometimes interfere with browser default behaviors. Avoid `event.preventDefault()` here unless absolutely necessary.
                         // if (event?.preventDefault) event.preventDefault(); // Prevent default blur behavior.


                        // --- Schedule Delayed Validation ---
                        // Use `setTimeout` to schedule the actual validation logic to run after a short, configurable delay.
                        setTimeout(() => {
                            try {
                                 // This code executes after the configured delay has passed.
                                 // Log the current state of relevant flags and the input value *at the time this callback executes*.
                                 Logger.debug(`${this.name}._handleBlurWithDelay: Executing delayed blur validation callback.`);
                                 Logger.debug(`${this.name}._handleBlurWithDelay: State at delayed validation - Place Selected Flag: ${this.#isPlaceSelected}. Current input value: "${this.getValue()}". Has Place Details Object: ${this.#placeDetails !== null}.`);

                                // --- Perform Validation ---
                                // Trigger the component's public `validate()` method.
                                // This will execute the component's `_validate()` override (or inherited version), which determines validity
                                // based on the current `_value`, native validity state, and potentially the `#isPlaceSelected` flag.
                                this.validate(); // Call the public validate() method.

                                 // --- Post-Validation Logic for Autocomplete on Blur ---
                                 // After validation has run (which determined validity based on the state *before* the delay and might have updated `_isValid`),
                                 // reset the `#isPlaceSelected` flag. This flag is specifically intended to indicate that an *explicit selection from the dropdown* was just made.
                                 // Once the input loses focus (and blur handler runs), that specific "selection moment" is over, regardless of whether the input is now valid or not.
                                this.#isPlaceSelected = false; // Reset the flag for the next user interaction cycle.
                                 // Log debug message confirming the flag reset.
                                 Logger.debug(`${this.name}._handleBlurWithDelay: #isPlaceSelected flag reset to false after validation.`);


                                 // Optional: Add specific validation or UI updates here if needed, for the case where the user typed text but did *not* select from autocomplete.
                                 // This logic might check `if (this.getValue() && !this.#isPlaceSelected) { ... }` after the flag reset.
                                 // If enforcing selection is a business rule, you might need to explicitly check here and set a specific error message
                                 // if the validation in `_validate()` didn't already cover this exact scenario using the `#isPlaceSelected` flag.


                             } catch (error) {
                                  // --- Handle Errors During Delayed Validation Execution ---
                                  // Catch any unexpected errors that occur specifically *within the execution of this delayed validation callback function* after the delay has passed.
                                  // These are errors in the code *inside* the `setTimeout` function's body (e.g., accessing properties of null, calling a method that throws).
                                  this.#errorReporter.reportError(
                                       `${this.name}._handleBlurWithDelay.delayedValidate`, // Source indicating the callback execution.
                                       error, // The error object caught.
                                       { component: this.#getComponentInfo(), value: this.getValue(), isPlaceSelected: this.#isPlaceSelected, hasDetails: this.#placeDetails !== null, step: 'delayed_validate_callback_execution' }, // Context details.
                                       `Error during delayed blur validation execution for "${this.name}". Validation may be incorrect.`, // User-friendly message template.
                                       'destinput_delayed_blur_validation_execution_exception' // GA error code.
                                  );
                                // Errors caught within a `setTimeout` callback typically do not need re-throwing to the main event loop or propagate further within the Promise chain (if any). Handle internally.
                             }
                         }, AppConfig.VALIDATION_DELAY_MS); // Use the configured delay value from AppConfig.


                    } catch (error) {
                         // --- Handle Errors During Handler Setup ---
                         // Catch any unexpected synchronous errors that occur *when setting up* the `setTimeout` for the delayed blur handler,
                         // or other synchronous errors within the `_handleBlurWithDelay` method itself *before* the timeout callback gets scheduled or executes.
                         this.#errorReporter.reportError(
                             `${this.name}._handleBlurWithDelay`, // Source indicating the handler setup.
                             error, // The error object caught.
                             { component: this.#getComponentInfo(), value: this.getValue(), step: 'handler_setup_exception' }, // Context details.
                             `Error handling blur event or scheduling delayed validation for component "${this.name}". Functionality may be impaired.`, // User-friendly message template.
                             'destinput_handle_blur_exception_setup' // GA error code.
                         );
                         // Do not re-throw from an event handler method. Handle the error internally.
                    }
                } // End of _handleBlurWithDelay method definition.

                /**
                 * Handler for the native `input` event on the destination input element.
                 * This method overrides the base `InputComponent._handleInput`.
                 * It is fired synchronously by the browser whenever the input field's value changes (e.g., due to typing, pasting, auto-filling).
                 * This handler's primary role (beyond updating `_value` and clearing error messages, handled by the parent)
                 * is to manage the component's autocomplete-specific state (`#placeDetails`, `#isPlaceSelected`).
                 * If the user modifies the input text *after* a place suggestion was previously selected (indicated by `#isPlaceSelected` being true),
                 * this action is interpreted as the user starting a new input session or manually editing the selected text.
                 * In this case, the handler clears the stored `#placeDetails` object and resets the `#isPlaceSelected` flag to `false`.
                 * This ensures that if the user edits the text after a selection, the component correctly reverts to a state where no specific place selection is confirmed.
                 * @param {Event} event - The native DOM 'input' event object.
                 */
                _handleDestinationInput(event) {
                   try {
                        // --- Call Parent Handler ---
                        // Call the parent `InputComponent._handleInput` method first. This method handles the standard input handling logic:
                        // 1. Updates the component's internal `this._value` property with the latest value from `this._element.value`.
                        // 2. Clears any currently displayed custom error message below the input using `_clearErrorMessage()`.
                       super._handleInput(); // Call parent handler. This performs essential base updates.

                       // Log debug info about the event and current state for debugging purposes.
                        // Logger.debug(`${this.name}._handleDestinationInput: 'input' event fired. Current value: "${this._value}". Place Selected Flag (before state update): ${this.#isPlaceSelected}. Has Place Details (before state update): ${this.#placeDetails !== null}.`); // Very verbose logging.


                       // --- Autocomplete State Management on Input ---
                       // If the user modifies the input text *after* a place suggestion was previously confirmed as selected (indicated by `#isPlaceSelected` being true immediately before this handler runs),
                       // this action typically means the user is either typing something new or manually editing the text of the previous selection. In either case, the previous *confirmed selection* is no longer valid.
                       // Clear the stored `Place` details object (`#placeDetails`) and reset the `#isPlaceSelected` flag to `false`.
                       // Check if EITHER `#placeDetails` is not null OR `#isPlaceSelected` is true before resetting, as a performance optimization if there was no previous state.
                       if (this.#placeDetails !== null || this.#isPlaceSelected === true) { // Check against true explicitly for flag robustness.
                           Logger.debug(`${this.name}._handleDestinationInput: Input detected after previous place selection state existed. Clearing previous place details and selection flag.`);
                           this.#placeDetails = null; // Explicitly clear the stored Google Place details object reference.
                           this.#isPlaceSelected = false; // Explicitly reset the selection confirmed flag to false.
                       } else {
                            // If input occurs but there was no prior selection state, no special action needed.
                            // Logger.debug(`${this.name}._handleDestinationInput: Input detected, but no previous place selection state existed. No special state clear needed.`);
                       }


                       // The parent's `_handleInput` method already called `_clearErrorMessage()`. This is the correct behavior:
                       // As the user types, any previous error message (like "required" or "please select from list") should be cleared to allow the user to fix the input.


                       // Optional: Trigger light, real-time validation or UI updates specific to the destination input format here if needed.
                       // Full validation is typically deferred to `blur` or `change` events or form submission for better performance and less distraction.

                   } catch (error) {
                        // Catch any unexpected errors occurring *within* this specific input event handler (after the `super._handleInput()` call).
                        this.#errorReporter.reportError(
                            `${this.name}._handleDestinationInput`, // Source of the error.
                            error, // The error object caught.
                            { component: this.#getComponentInfo(), value: this._value, step: 'handler_execution_after_super', prevPlaceSelected: this.#isPlaceSelected, hadDetails: this.#placeDetails !== null }, // Context details.
                            `Error handling input event for component "${this.name}". Autocomplete state may be inconsistent.`, // User-friendly message template.
                            'destinput_handle_input_exception_override' // GA error code for override handler exception.
                        );
                       // Do not re-throw from an event handler. Handle the error internally.
                   }
               } // End of _handleDestinationInput method definition.


                /**
                 * Polymorphism: Overriding the protected `_validate` method from `InputComponent`.
                 * Provides validation logic specifically for the destination input field.
                 * It calls the parent's `_validate` method first (which handles the fundamental 'required' check based on the input value).
                 * It can optionally include additional validation rules, such as checking if an explicit selection from the autocomplete list was made (`#isPlaceSelected`) if that is a requirement for valid input in the application's business logic.
                 * It updates the component's `_isValid` state flag and sets/clears specific error messages below the input element using `_setErrorMessage`/`_clearErrorMessage`.
                 * @returns {boolean} - Returns `true` if all destination-specific validation rules pass (including the parent's required check), `false` otherwise.
                 */
                _validate() {
                    try {
                        Logger.debug(`${this.name}._validate: Called. (DestinationInput specific validation)`);

                        // --- Call Parent Validation ---
                        // Call the parent `InputComponent`'s `_validate` method first.
                        // This handles the fundamental 'required' check based on the input's value string (`this._value`),
                        // and also clears existing custom error messages and native validity flags *before* running new validation checks.
                        let isValid = super._validate(); // Execute parent validation.

                        // If the base validation (e.g., required but empty) already failed, return `false` immediately.
                        // Destination-specific checks based on content or selection are irrelevant if the field is empty and required.
                        if (!isValid) {
                             Logger.debug(`${this.name}._validate: Failed base validation ('required'). Skipping destination-specific checks.`);
                            return false; // Exit early.
                        }


                        // --- Destination-Specific Validation Rules ---
                        // At this point in the execution flow, if the field is required, it contains a non-empty value (`this._value`).
                        // If it's not required, its `_value` could still be empty, but the `super._validate()` would return true.
                        // The validation logic here determines if the existing value represents a valid or acceptable destination based on additional rules, potentially involving the autocomplete state.

                         // --- Optional Rule: Require an Explicit Selection from Google Autocomplete ---
                         // This validation rule applies only if there is a value in the input field (`this.getValue()` is not empty after trimming).
                         // It checks if the `#isPlaceSelected` flag is `false`, which indicates the user typed text but did *not* explicitly select a suggestion from the dropdown list.
                         // This rule is only necessary if your application business logic mandates that users must confirm a specific place via Autocomplete selection (e.g., because you need the canonical Place ID or guaranteed structured address data), rather than allowing arbitrary text input.
                         // For this demo which redirects to Expedia's site search page, arbitrary text is often accepted by Expedia's backend, so this rule might be too strict. It's included here for demonstration structure.
                         /*
                         const currentValue = this.getValue(); // Get the trimmed input value.
                         // Check if there's a non-empty value AND the user has not explicitly selected a place from the list (`#isPlaceSelected` is false).
                         if (currentValue && !this.#isPlaceSelected) {
                              // Optional extended check: You could also check here if `#placeDetails` is null even if `#isPlaceSelected` is true (which shouldn't happen with a well-behaving Autocomplete library).
                              // Example: `if (currentValue && (!this.#isPlaceSelected || this.#placeDetails === null))`
                              const message = AppConfig.MESSAGES.INPUT_AUTOCOMPLETE_NO_DETAILS(currentValue); // Get the specific user-friendly error message for this scenario.
                             // Set the custom error message below the input and update the native validity flag.
                             // `_setErrorMessage` handles both the dedicated UI element and `this._element.setCustomValidity`.
                              this._setErrorMessage(message);
                             Logger.warn(`${this.name}._validate: Validation failed (autocomplete selection required). Value: "${currentValue}". Selected flag: ${this.#isPlaceSelected}.`);
                             isValid = false; // Set the overall validity for this component to false due to this rule failure.

                         } else {
                             // If this specific 'selection required' rule passes (because there's no value, OR a value exists AND `#isPlaceSelected` is true):
                             // Clear the specific error message related to needing an autocomplete selection, *but only if that specific message was currently displayed* on the error element.
                             // Checking the current content prevents clearing error messages set by other validation rules (if any are added later).
                             if (this._errorMessageElement && this._errorMessageElement.textContent === AppConfig.MESSAGES.INPUT_AUTOCOMPLETE_NO_DETAILS(currentValue)) {
                                  this._clearErrorMessage(); // Clear the custom message and native validity set by `_setErrorMessage`.
                                   Logger.debug(`${this.name}._validate: Cleared 'autocomplete selection required' error message.`);
                              }
                              // The `isValid` flag remains true if it was already true from the `super._validate()` call and no other rule (like this one) set it to false.
                         }
                         */ // End of Optional "Require Selection" block.


                        // If the optional "Require Selection" validation block above is not uncommented, or if it was uncommented and passed, `isValid` remains true here if `super._validate()` returned true.

                        // --- Add More Destination-Specific Validation Rules Here ---
                        // Add any other validation logic specific to the destination input format, content, or meaning based on your application's requirements.
                        // Examples:
                        // - Validate if the text matches a specific internal list of allowed destinations.
                        // - Check format against a specific regular expression if the Google Autocomplete type/restrictions aren't enough.
                        // - If you required fetching specific Place Details fields (beyond name/ID) and rely on them being non-null after `_handlePlaceChanged`, check those here.


                        // --- Final Update of Component State ---
                        // Update the component's internal `_isValid` state flag based on the final result of all checks in this `_validate` override.
                         // Since we returned false early if `super` failed, and our own checks updated `isValid`, the final value here represents the combined result.
                        this._isValid = isValid; // Set the protected `_isValid` flag.
                        Logger.debug(`${this.name} validation result: ${this._isValid}.`);

                        // Return the final validity status (true or false).
                        return this._isValid;

                    } catch (error) {
                         // --- Handle Critical Errors During _validate() Execution ---
                         // Catch any unexpected errors occurring *within the execution of the `DestinationInput` specific `_validate` logic*.
                         // This indicates a programming issue in the component's validation code itself (e.g., attempting to access properties of null when they shouldn't be, or logical errors that throw).
                         Logger.error(`${this.name}._validate: CRITICAL UNHANDLED ERROR caught within validate method!`, error, { component: this.#getComponentInfo(), value: this._value, isPlaceSelected: this.#isPlaceSelected, hasDetails: this.#placeDetails !== null, step: 'destination_specific_validation_execution_exception' }); // Log the error.

                         // Report this critical validation logic failure using the injected reporter.
                         this.#errorReporter.reportError(
                             `${this.name}._validate`, // Source is the DestinationInput's _validate method.
                             error, // The uncaught error object.
                             { component: this.#getComponentInfo(), value: this.getValue(), step: 'validate_execution_exception' }, // Context.
                             `Error during validation logic for component "${this.name}". Cannot determine validity.`, // User-facing message template about validation logic error.
                             'destinput_validate_exception_logic' // GA error code for validation *logic* exception.
                         );

                         // If the validation process itself fails critically by throwing an error, the component is considered invalid.
                         this._isValid = false; // Explicitly set internal state to false.

                         // Attempt to set a generic error message for the user via the UI element, using the error's message for detail.
                         if (typeof this._setErrorMessage === 'function') {
                              try {
                                  this._setErrorMessage(`Validation error: ${error.message}`); // Use the error's message in a generic template.
                              } catch (setMessageError) { Logger.error(`${this.name}._validate: Error setting error message after critical exception:`, setMessageError); }
                         }
                         // Note: The ErrorReporter already handled logging and displaying a main message for the critical error.

                         // Always return `false` on critical error in the protected validate method.
                         return false; // Return `false`.
                    }
                } // End of _validate method definition.

                /**
                 * Public method to retrieve the stored Google Place details object (`google.maps.places.Place`)
                 * that was obtained when a user explicitly selected a suggestion from the Google Autocomplete dropdown list
                 * in the `_handlePlaceChanged` method.
                 * This object contains structured information about the selected place (name, coordinates, address components, etc.)
                 * as requested by the `fields` option during Autocomplete initialization.
                 * @returns {object|null} - The `google.maps.places.Place` object if:
                 *                          - Google Autocomplete was successfully initialized for this component.
                 *                          - The user made an explicit selection from the dropdown list.
                 *                          - The asynchronous Place Details request for that selection was successful.
                 *                          - And no subsequent input event cleared the `#placeDetails` state.
                 *                          Returns `null` otherwise (e.g., Autocomplete not initialized, no selection made, selection failed, subsequent input occurred)
                 *                          or if an error occurs while accessing the internal `#placeDetails` member.
                 */
                getPlaceDetails() {
                    try {
                         Logger.debug(`${this.name}.getPlaceDetails: Called. Checking if Place Details are available.`);

                         // Return the stored private `#placeDetails` object.
                         // Include a check if the Google Autocomplete feature was successfully initialized (`#autocomplete` is not null).
                         // While `#placeDetails` should only be non-null if `#autocomplete` exists and was used, this adds a defensive layer.
                         if (!this.#autocomplete) {
                             // If Autocomplete wasn't initialized, `#placeDetails` will never be populated by its events.
                             Logger.debug(`${this.name}.getPlaceDetails: Google Autocomplete not initialized. Place details not available.`);
                             return null; // Return null.
                         }

                         // Return the current value of the private `#placeDetails` member.
                         // This will be the Place object if a selection was made and details fetched successfully, or null otherwise.
                         return this.#placeDetails;

                    } catch (error) {
                         // Catch any unexpected errors occurring *while simply trying to access* the private member `#placeDetails` or checking `#autocomplete`.
                         // Report this error using the injected reporter.
                         this.#errorReporter.reportError(
                             `${this.name}.getPlaceDetails`, // Source of the error.
                             error, // The error object caught.
                             { component: this.#getComponentInfo(), hasAutocomplete: !!this.#autocomplete, step: 'get_place_details_access_exception' }, // Context.
                             `Error accessing place details for component "${this.name}".`, // User message.
                             'destinput_get_place_details_exception' // GA error code.
                         );
                        return null; // Always return null on error to indicate failure to get the place details.
                    }
                } // End of getPlaceDetails getter definition.

                 /**
                   * Override dispose method from `InputComponent`.
                   * This method is called during application shutdown or when the component is no longer needed.
                   * It ensures cleanup specific to the `DestinationInput` by clearing internal references
                   * related to the Google Autocomplete instance and any stored place details,
                   * *after* calling the parent's dispose method for base and input cleanup.
                   */
                 dispose() {
                     try {
                         Logger.debug(`Disposing DestinationInput: ${this.name}. Starting cleanup.`);
                         // Call the parent `InputComponent`'s `dispose` method first. This is essential cleanup.
                         // It handles removing all event listeners managed by this component instance (including 'blur' and 'input' handlers attached to `this._element`)
                         // and clears base references like `this._element` and `this._errorMessageElement`.
                         super.dispose(); // Calls InputComponent.dispose().


                         // --- DestinationInput Specific Cleanup ---
                         // Clear the reference to the Google Autocomplete object instance (`#autocomplete`).
                         // Note: The real `google.maps.places.Autocomplete` object created via `new` generally
                         // does *not* have a public `remove()` or `dispose()` method to explicitly clean up its internal
                         // state managed by the Google Maps library itself. For a standard page unloading, the browser
                         // will handle this garbage collection. For complex SPAs where components are dynamically
                         // added/removed, explicitly clearing the JavaScript reference here is good practice for clarity
                         // and to allow the JavaScript object instance to be garbage collected more effectively.
                         if (this.#autocomplete) {
                             // If there were listeners attached directly to `#autocomplete` that are NOT input element listeners,
                             // they would need to be explicitly removed here if storing them was handled by the component's _addEventListener, but for standard Autocomplete, its listeners are usually self-contained.
                             Logger.debug(`Dispose: Clearing Google Autocomplete instance reference for ${this.name}.`);
                         }
                         this.#autocomplete = null; // Explicitly clear the reference.

                         // Clear any stored Place details object reference.
                         if (this.#placeDetails) {
                              Logger.debug(`Dispose: Clearing stored Place Details reference for ${this.name}.`);
                         }
                         this.#placeDetails = null; // Explicitly clear the reference.

                         // Reset the selection confirmed flag.
                         this.#isPlaceSelected = false;


                         Logger.debug(`DestinationInput disposed: ${this.name}. Cleanup complete.`);

                     } catch (error) {
                          // Catch and log any unexpected errors occurring *during the disposal process*.
                          // Use `console.error` here as the injected `_errorReporter` instance might be nullified by `super.dispose` (depending on overall app dispose order).
                         console.error(`CRITICAL ERROR during disposal of DestinationInput "${this.name}" (ID: ${this.id}):`, error, { step: 'dispose_execution_exception' });
                         // Do not re-throw from a dispose method. Cleanup errors should be logged but not prevent overall page unload.
                     }
                 } // End of dispose method definition.
             } // End of DestinationInput class definition.


             // --- Helper Class for Collecting Search Parameters ---
             // This class encapsulates the logic for extracting the current values from all the
             // input component instances managed by the `SearchForm`. It provides a clean
             // abstraction layer for gathering input data before subsequent processing steps like
             // validation, URL building, or sending to services.
             // It is typically instantiated and used by the `SearchForm` component.
             class SearchParamCollector {
                 // Private member to hold a reference to the map of input component instances.
                 // This map is expected to be the `_inputs` object managed by the `SearchForm`.
                 #inputComponents;
                 #errorReporter; // Reference to the shared ErrorReporter instance.

                 /**
                  * Constructor for SearchParamCollector.
                  * Initializes the collector with the map of input component instances it will operate on.
                  * @param {object} inputComponents - An object map where keys are input element IDs and values are the corresponding input component instances (e.g., the `_inputs` map from the `SearchForm`). Required.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                  * @throws {Error} If `inputComponents` or `errorReporter` are invalid or missing, preventing the collector from being initialized.
                  */
                 constructor(inputComponents, errorReporter) {
                      try {
                         Logger.debug('SearchParamCollector constructor called.');

                          // Validate required ErrorReporter dependency.
                         if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                            const errorMsg = "ErrorReporter instance not provided to SearchParamCollector constructor. Error handling will be compromised.";
                            Logger.error(errorMsg, { inputMapType: typeof inputComponents });
                            // Set a fallback dummy reporter here to prevent method calls crashing if ErrorReporter is critical.
                            this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[COLLECTOR_NO_REPORTER_ERROR] ${src}: ${msg}`, err, ctx) };
                            // Decide if lack of reporter is a fatal init error or just a warning. Let's make it a warning for this class init, fatal caught higher up.
                            // throw new Error(errorMsg); // Uncomment to make this fatal if reporter is missing.
                         } else {
                            this.#errorReporter = errorReporter;
                         }

                          // --- Validate the inputComponents map ---
                          // The constructor requires a map of input components to collect data from.
                          // Check if the `inputComponents` argument is provided and is a valid object.
                         if (!inputComponents || typeof inputComponents !== 'object') {
                             const errorMsg = "Input components map is missing or invalid during SearchParamCollector initialization. Cannot collect parameters.";
                             // Report this critical configuration error using the injected (potentially dummy) ErrorReporter.
                            this.#errorReporter.reportError('SearchParamCollector.constructor', new Error(errorMsg), { inputMapType: typeof inputComponents }, errorMsg, 'collector_init_invalid_map_critical');
                              // Throw an error to halt the constructor. The collector cannot function without the input map.
                             throw new Error(errorMsg);
                         }
                          // Store a reference to the provided map of input component instances.
                         this.#inputComponents = inputComponents; // Store the reference.

                          // Log successful initialization.
                         Logger.debug('SearchParamCollector initialized with input component map reference.');


                      } catch (error) {
                           // Catch any unexpected errors occurring *within* the constructor logic itself (e.g., during validation checks before storing references).
                           // Report this critical constructor failure using the injected reporter (or console if reporter init failed).
                           if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                               this.#errorReporter.reportError(
                                   'SearchParamCollector.constructor', error,
                                   { inputMapType: typeof inputComponents, step: 'constructor_execution' },
                                   'Failed to construct Search Parameter Collector.',
                                   'collector_init_exception_critical' // GA error code.
                               );
                           } else {
                               // Fallback console error if the reporter itself was the issue or failed during initialization.
                               console.error('FATAL: Error during SearchParamCollector constructor. Reporter unavailable or failed.', error, { inputMapType: typeof inputComponents });
                           }
                          // Ensure `#inputComponents` is explicitly set to an empty object if initialization failed critically.
                          this.#inputComponents = {}; // Defensive assignment.
                          // Re-throw the error to propagate it to the main application bootstrap logic.
                          throw error;
                      }
                 } // End of constructor definition.

                 /**
                  * Public method to collect the current values from all input components managed by this collector.
                  * It iterates through the stored map of component instances (`this.#inputComponents`),
                  * calls the public `getValue()` method on each component instance to retrieve its value,
                  * and compiles these values into a new plain JavaScript object.
                  * Includes robust error handling to gracefully handle cases where individual input components might be missing from the map,
                  * or their `getValue` method might be missing or throw an error during execution.
                  * @returns {object} A new plain JavaScript object containing the collected parameters.
                  *                   Keys are the input element IDs, and values are the retrieved input values.
                  *                   Values for specific keys will be `null` if the corresponding input component was missing, invalid, or its `getValue` method failed during collection.
                  * @throws {Error} If a critical error occurs during the overall collection process itself (e.g., the internal input map `this.#inputComponents` is unexpectedly null or invalid at runtime).
                  */
                 collect() {
                     try {
                         Logger.debug('SearchParamCollector.collect: Collecting search parameters...');

                         // --- Defensive Check for Input Map Validity ---
                         // Although the constructor validates the input map, perform a defensive check here as this method is called at runtime.
                         if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                             const errorMsg = "Internal error: Input components map is missing or invalid during collection phase.";
                            // Report this critical internal inconsistency error.
                            this.#errorReporter.reportError('SearchParamCollector.collect', new Error(errorMsg), { mapType: typeof this.#inputComponents }, errorMsg, 'collector_map_missing_critical');
                            throw new Error(errorMsg); // Indicate a critical failure that prevents parameter collection.
                         }

                         // Initialize a new object to store the collected parameters. This ensures a fresh object is returned each time.
                         const collectedParameters = {};
                         let hadIndividualCollectionIssues = false; // Flag to track if any specific input failed to have its value collected successfully.

                         // --- Iterate Through Input Components and Collect Values ---
                         // Get an array of the keys (input IDs) from the input components map.
                          const inputIds = Object.keys(this.#inputComponents);

                          // Use a `for...of` loop or `forEach` to iterate through the keys. `forEach` with index can be useful for debugging order.
                          inputIds.forEach(inputId => {
                              // Use `Object.prototype.hasOwnProperty.call` for robust iteration over object properties, especially important with prototypes or inherited properties.
                             if (Object.prototype.hasOwnProperty.call(this.#inputComponents, inputId)) {
                                  // Get the component instance for the current input ID from the map.
                                 const component = this.#inputComponents[inputId];
                                 try {
                                      // Check if the retrieved item is a valid component instance AND has the expected public `getValue` method.
                                     if (component && typeof component.getValue === 'function') {
                                          // Call the component's public `getValue()` method to get its current value.
                                          // Store the retrieved value in the `collectedParameters` object, using the input ID as the key.
                                         collectedParameters[inputId] = component.getValue();
                                         // Logger.debug(`Collected value for input "${inputId}": "${collectedParameters[inputId]}".`); // Verbose logging per input
                                     } else {
                                          // If the item in the map is not a valid component instance or lacks `getValue`.
                                          // Log a warning that this specific input could not be processed.
                                         Logger.warn(`Collector.collect: Item in inputs map with key "${inputId}" is not a valid component instance or missing getValue method during collection. Setting value to null.`, { component: component });
                                          // Store `null` for this parameter in the results object.
                                         collectedParameters[inputId] = null;
                                          hadIndividualCollectionIssues = true; // Set flag indicating a failure for this specific input.
                                     }
                                 } catch (error) {
                                     // --- Handle Errors Thrown by Individual `getValue()` Methods ---
                                     // Catch any unexpected errors thrown *by an individual component's `getValue()` method* during its execution.
                                     // This error represents a flaw in the component's value retrieval logic itself, not a validation *failure*.
                                    this.#errorReporter.reportError(
                                        `SearchParamCollector.collect - getValue`,
                                        error, // The error object thrown by `getValue`.
                                        { inputId: inputId, componentName: component?.name, step: 'get_value_execution' }, // Provide context
                                        `Error collecting value for input "${inputId}".`, // User-friendly message component
                                        'collector_get_value_exception' // GA error code.
                                    );
                                     // Set the parameter value to `null` in the results object if its retrieval failed due to an error.
                                     collectedParameters[inputId] = null;
                                     hadIndividualCollectionIssues = true; // Set flag indicating an error occurred during collection.
                                 }
                             } else {
                                 // This case should not typically happen if iterating `Object.keys` and using `hasOwnProperty`. Included defensively.
                                 Logger.warn(`Collector.collect: Unexpected property "${inputId}" found in inputs map prototype chain.`);
                             }
                         });


                         // --- Report Overall Collection Status ---
                         // After the loop finishes, check the flag for individual collection issues.
                         if (hadIndividualCollectionIssues) {
                            // Log a warning if any individual input value could not be collected successfully due to missing component, invalid component, or error in `getValue`.
                            Logger.warn("SearchParamCollector.collect: Parameter collection completed with some issues. Returned parameters may be incomplete.", { issuesDetected: true, collectedKeysCount: Object.keys(collectedParameters).length, totalInputsInMap: inputIds.length });
                            // The calling code (`SearchForm`) is responsible for checking for `null`/missing values in the returned `collectedParameters` object if necessary for subsequent logic (like URL building).
                         } else {
                              // Log success if all component values were collected without errors or missing components.
                              Logger.debug("SearchParameterCollector.collect: Parameter collection completed successfully for all managed inputs.");
                         }

                         // Log the final object containing the collected parameters for debugging.
                         Logger.info("SearchParamCollector.collect: Final Collected Parameters:\n", JSON.stringify(collectedParameters, null, 2));

                         // Return the populated parameters object.
                         return collectedParameters;

                     } catch (error) {
                          // --- Handle Critical Errors During Overall Collection Process ---
                          // This outer catch block catches any unexpected critical errors that occur *during the overall process of collecting* parameters itself
                          // (e.g., errors during the try/catch/loop structure, unexpected issues accessing `this.#inputComponents`).
                          // This is a serious failure in the collection logic itself.
                          Logger.error(`SearchParamCollector.collect: CRITICAL UNEXPECTED ERROR during parameter collection process!`, error);

                          // Report this critical failure using the injected reporter.
                          this.#errorReporter.reportError(
                              'SearchParamCollector.collect',
                              error,
                              { step: 'overall_collection_process_critical_exception' },
                              'Critical error during search parameter collection process.', // User-facing message component.
                              'collector_critical_exception' // GA error code.
                          );

                          // Re-throw a specific error indicating that the collection failed fundamentally due to an internal error.
                          throw new Error(`Failed to collect search parameters due to internal error: ${error.message}`);
                     }
                 } // End of collect method definition.

                  /**
                   * Public method to retrieve a specific parameter value from the collected data by its input ID.
                   * This is a convenience wrapper. It directly accesses the component instance in the stored map
                   * and calls its `getValue()` method to get the current value. This is often used to quickly
                   * get the value of a known input without iterating through the entire map.
                   * @param {string} inputId - The ID string of the input element/component whose value is needed (e.g., 'destinationInput'). Required.
                   * @returns {*} The current value of the parameter as returned by the corresponding component's `getValue()` method,
                   *              or `null` if a component with the given ID is not found in the managed map, the found item is not a valid component instance,
                   *              its `getValue` method is missing, or an error occurs during value retrieval. Returns `null` for invalid input ID.
                   */
                  getParam(inputId) {
                      try {
                          Logger.debug(`SearchParamCollector.getParam: Attempting to get value for input ID: "${inputId}".`);
                          // Validate the input ID. Must be a non-empty string.
                         if (typeof inputId !== 'string' or inputId.trim() === '') {
                              const warningMsg = `Invalid inputId provided to getParam. Cannot retrieve parameter.`;
                             Logger.warn(`SearchParamCollector.getParam: ${warningMsg}`, { inputId: inputId });
                             // Could optionally report this as a warning via ErrorReporter if desired, but often logging is enough for invalid input.
                             return null; // Return null for invalid input ID.
                         }

                         // Ensure the internal input components map is valid and available.
                          if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                              const errorMsg = `SearchParamCollector.getParam: Input components map is missing when trying to get parameter "${inputId}".`;
                             Logger.warn(errorMsg);
                             // Report this internal inconsistency error via the ErrorReporter.
                              this.#errorReporter.reportError(
                                  'SearchParamCollector.getParam', new Error("Input components map missing internally."),
                                  { formId: this.id, inputId: inputId, step: 'get_param_map_missing' },
                                  `Internal error getting parameter "${inputId}". Parameter unavailable.`, "collector_get_param_map_missing_critical"
                              );
                             return null; // Cannot get parameter if the map itself is missing.
                          }

                          // Attempt to retrieve the component instance from the map using the provided input ID.
                          const component = this.#inputComponents[inputId];

                          // Check if a component instance was found in the map for this ID.
                          if (!component) {
                              // If no component was found for the given ID, it might not be managed by this collector.
                              Logger.warn(`SearchParamCollector.getParam: Component with ID "${inputId}" not found in managed inputs map.`);
                               // Optionally report this missing component as an issue via ErrorReporter.
                               this.#errorReporter.reportError(
                                   'SearchParamCollector.getParam', new Error(`Component ID "${inputId}" not found in map.`),
                                   { formId: this.id, inputId: inputId, step: 'get_param_component_not_in_map' },
                                   `Internal error getting parameter "${inputId}" (component not found). Parameter unavailable.`, "collector_get_param_component_not_in_map"
                               );
                              return null; // Indicate the parameter could not be retrieved because the component wasn't managed.
                          }


                         // Ensure the retrieved item is a valid component instance with a public `getValue` method.
                         if (typeof component.getValue === 'function') {
                              // Call the component's public `getValue()` method to get its current value.
                             const parameterValue = component.getValue();
                              // Logger.debug(`SearchParamCollector.getParam: Retrieved value for "${inputId}": "${parameterValue}".`); // Verbose logging.
                             return parameterValue; // Return the value obtained from the component.

                         } else {
                              // If a component instance was found for the ID, but it's not a valid component or lacks `getValue`.
                             Logger.warn(`SearchParamCollector.getParam: Component found for ID "${inputId}" but is invalid or missing getValue method. Cannot get parameter.`);
                             // Report this issue via the ErrorReporter.
                             this.#errorReporter.reportError(
                                 'SearchParamCollector.getParam', new Error(`Component found but invalid/missing getValue method.`),
                                 { formId: this.id, inputId: inputId, step: 'get_param_component_invalid' },
                                 `Internal error getting parameter "${inputId}" (invalid component). Parameter unavailable.`, "collector_get_param_component_invalid"
                             );
                             return null; // Indicate the parameter could not be retrieved due to a component issue.
                         }
                      } catch (error) {
                           // Catch any unexpected errors occurring *during the overall process* of getting a specific parameter (e.g., errors during property access, calling getValue if not caught by component itself).
                           this.#errorReporter.reportError(
                               `${this.name}.getParam`,
                               error, // The error object caught.
                               { inputId: inputId, step: 'overall_get_param_exception' }, // Context.
                               `Error getting specific parameter "${inputId}" from collector.`, // User-friendly message component.
                               'collector_get_param_exception_overall' // GA error code.
                           );
                          // Always return null on error to indicate that a valid parameter value could not be retrieved.
                          return null;
                      }
                  } // End of getParam method definition.

                  /**
                   * Public method to get the entire map of input component instances currently managed by this collector.
                   * This provides access to the underlying map structure.
                   * @returns {object} - A reference to the internal map where keys are input IDs and values are component instances (`id -> instance`). Returns an empty object (`{}`) on error or if the map is unexpectedly null/invalid.
                   */
                  getAllComponents() {
                      try {
                          // Return a reference to the internal map.
                          // Provide an empty object `{}` as a safe fallback in case the map was not initialized or is unexpectedly null/undefined.
                          return this.#inputComponents || {};

                      } catch (error) {
                           // Report errors occurring while trying to access the internal map reference.
                           this.#errorReporter.reportError(
                               `${this.name}.getAllComponents`,
                               error,
                               { step: 'get_all_components_exception' }, // Context.
                               'Error getting all components map from collector.', // User-friendly message.
                               'collector_get_all_components_exception' // GA error code.
                           );
                          return {}; // Return an empty object on error as a safe fallback.
                      }
                  } // End of getAllComponents method definition.

                 /**
                  * Dispose method for cleanup on application shutdown or when the collector is no longer needed.
                  * Clears the internal reference to the input components map managed by this collector.
                  * Note: This collector instance does *not* own the component instances themselves; they are created and managed by the `SearchForm`.
                  * Therefore, this `dispose` method does not call `dispose()` on individual input components. The `SearchForm` is responsible for disposing its managed components.
                  */
                 dispose() {
                     try {
                         Logger.debug("SearchParamCollector.dispose: Disposing SearchParamCollector.");
                         // Clear the reference to the input components map. This helps garbage collection of the collector instance itself.
                         // We replace the reference with an empty object (`{}`) instead of `null` to prevent potential `null` checks in a defensive `getAllComponents` or other methods if called after disposal.
                         this.#inputComponents = {}; // Replace the map reference with an empty object.

                         // The `#errorReporter` reference is typically not cleared here as it is a shared instance managed at a higher level.

                         Logger.debug("SearchParamCollector.dispose: Disposal complete.");

                     } catch (error) {
                          // Catch and log errors occurring during the disposal process.
                          // Use the injected reporter if available, otherwise fallback to console.
                          if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                              this.#errorReporter.reportError(
                                  'SearchParamCollector.dispose',
                                  error, {},
                                  'Error disposing Search Parameter Collector.',
                                  'collector_dispose_exception' // GA error code.
                              );
                          } else {
                            console.error("Error disposing SearchParamCollector (Reporter missing or failed):", error);
                          }
                         // Do not re-throw from a dispose method.
                     }
                 } // End of dispose method definition.
             } // End of SearchParamCollector class definition.


             // --- Helper Class for Building the Expedia URL ---
             // This class provides static methods to construct the Expedia search results URL
             // based on collected search parameters. It contains constants for the base URL
             // and affiliate ID, and handles the correct encoding of URL parameters.
             // Designed as a static class, meaning you call methods directly on the class (e.g., `ExpediaUrlBuilder.buildUrl(...)`)
             // without creating an instance using `new`. It cannot be instantiated.
             class ExpediaUrlBuilder {
                 // Static members accessed directly on the class (ExpediaUrlBuilder.BASE_URL, etc.).
                 // These hold constant configuration values needed for building the URL.
                 static BASE_URL = AppConfig.EXPEDIA_BASE_SEARCH_URL; // Base URL for Expedia Hotel Search.
                 static AFFILIATE_ID = AppConfig.EXPEDIA_AFFILIATE_ID; // Affiliate ID for tracking referrals.

                 // A private constructor can be defined to explicitly prevent instantiation of this class using `new`.
                 // Using `#private constructor()` syntax in newer JavaScript requires class fields support. Convention (`_constructor()`) is more broadly compatible but doesn't strictly enforce non-instantiation. For a purely static class, instantiation doesn't make sense.
                 // private constructor() { throw new Error('ExpediaUrlBuilder is a static class and cannot be instantiated.'); } // Example enforcement.

                 /**
                  * Static method to build the complete Expedia search results URL from collected search parameters.
                  * This method is called directly on the class (`ExpediaUrlBuilder.buildUrl(params, reporter)`).
                  * It is responsible for:
                  * 1. Validating essential parameters required by the Expedia URL structure.
                  * 2. Performing basic cross-validation on parameters relevant to the URL logic (e.g., date order).
                  * 3. Correctly formatting the parameters into a URL query string using the standard browser API `URLSearchParams`.
                  * 4. Including the configured affiliate ID (`mcid`) and other common Expedia URL parameters based on observed structure.
                  * @param {object} params - An object containing the collected search parameters. Keys should match expected parameter names (e.g., 'destinationInput', 'checkInDateInput', 'adultsCountInput'). Values are typically strings or numbers from input component `getValue()`. This object is usually provided by the `SearchParamCollector`. Required.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. This dependency is required by this static method for error reporting.
                  * @returns {string|null} The successfully constructed full Expedia search URL string (starting with `https://`), or `null` if essential parameters are missing/invalid for URL building or if a critical error occurs during the URL construction process itself.
                  */
                 static buildUrl(params, errorReporter) {
                     try {
                         Logger.debug("ExpediaUrlBuilder.buildUrl: Starting Expedia URL building process...");

                         // --- Check ErrorReporter availability ---
                          // As a static method, ErrorReporter is not injected in a constructor. It must be passed as a parameter to the method.
                          // Check if the `errorReporter` instance was provided and has the necessary `reportError` method.
                          if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                              // If the ErrorReporter is unavailable, log a critical error to the console directly as a fallback.
                              console.error("ExpediaUrlBuilder.buildUrl: ErrorReporter instance is missing or invalid. Error handling within URL builder will fallback to console.");
                              // Provide a dummy reporting method here to prevent internal error reports from crashing the logic if the reporter is missing.
                              errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[URL BUILDER NO REPORTERS ERROR] ${src}: ${msg}`, err, ctx) };
                          }


                         // --- Validate Input Parameters Object ---
                          // Ensure the input `params` argument is provided and is a valid JavaScript object before attempting to access its properties.
                         if (!params || typeof params !== 'object') {
                            const errorMsg = "Cannot build URL: Invalid or empty parameters object provided to builder.";
                             // Report this configuration/usage error using the available (real or dummy) ErrorReporter.
                            errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(errorMsg), { paramsReceived: params, step: 'input_validation' }, errorMsg, 'urlbuilder_invalid_params');
                            return null; // Indicate failure to build URL due to bad input data.
                         }
                          // Logger.debug("ExpediaUrlBuilder.buildUrl: Input parameters object valid.", { params: params }); // Verbose logging.


                         // --- Define and Check Essential Required Parameters for URL Structure ---
                         // Define an array containing the keys (names) of the parameters that are considered essential for creating a basic, functional Expedia Hotel Search URL.
                         // These correspond to the input element IDs used in the form and expected in the `params` object.
                         const requiredParamsForUrl = ['destinationInput', 'checkInDateInput', 'checkOutDateInput', 'adultsCountInput'];
                         let missingOrInvalidParamsIssues = []; // Initialize an array to collect any issues found during parameter checks.

                         // Iterate through the defined list of required parameter names.
                         requiredParamsForUrl.forEach(paramInputId => {
                              try {
                                  // Get the value for the current required parameter using its `paramInputId` (which is the key in the `params` object).
                                 const value = params[paramInputId];

                                  // Check if the value is missing (`undefined` or `null`) OR if it's a string that is empty after trimming leading/trailing whitespace.
                                  // Using loose equality (`== null`) conveniently checks for both `undefined` and `null`.
                                 if (value == null || (typeof value === 'string' && String(value).trim() === '')) { // Convert to string defensively before trim.
                                       // If the value is missing or empty...
                                       // Special case check for 'adultsCountInput': This parameter requires a numerical value that parses to an integer >= 1.
                                      if (paramInputId === 'adultsCountInput') {
                                           // Attempt to parse the value as an integer. `parseInt(null/undefined/'')` results in `NaN`.
                                           const adultsCount = parseInt(value, 10);
                                          // Check if the value is `NaN` after parsing OR if the parsed number is less than 1.
                                          if (isNaN(adultsCount) || adultsCount < 1) {
                                              // If the adults count is invalid (missing, non-numeric, or less than 1), add a specific issue note to our list.
                                              missingOrInvalidParamsIssues.push(`${paramInputId} (must be at least 1)`);
                                              Logger.warn(`ExpediaUrlBuilder.buildUrl: Required parameter "${paramInputId}" is missing or invalid (value: "${value}"). Issue: Must be >= 1.`, { value: value });
                                          } // If the value was present but was '0' as a string, it would pass the initial `value == null` check but fail the `parseInt` check.
                                      } else {
                                          // For all other parameters in the `requiredParamsForUrl`, simply check if they are missing or empty strings.
                                           missingOrInvalidParamsIssues.push(paramInputId); // Add the parameter name to the list of issues.
                                          Logger.warn(`ExpediaUrlBuilder.buildUrl: Required parameter "${paramInputId}" is missing or empty. Value: "${value}".`);
                                      }
                                  }
                                   // If the value exists and is not an empty string (and passes the adults check if applicable), it's considered valid *for URL format purposes* at this stage.
                                  // We don't check for *semantic* validity (e.g., if the destination string is a real place) here, just structural readiness for the URL.
                              } catch (error) {
                                  // Catch any unexpected errors occurring *while checking a specific required parameter* within the loop (e.g., errors accessing a property that causes an error, type issues).
                                   // Report this error as an internal issue during the parameter check.
                                   errorReporter.reportError(
                                       'ExpediaUrlBuilder.buildUrl - checkRequiredParams', error, // Source and error.
                                       { paramName: paramInputId, paramValue: params ? params[paramInputId] : 'N/A', paramsObject: params, step: 'required_param_check_exception' }, // Context.
                                       `Error checking required parameter "${paramInputId}" during URL build validation.`, // User-friendly message template.
                                       'urlbuilder_required_param_check_exception' // GA error code.
                                   );
                               // Add a generic note about the check failing for this parameter to the issues list for logging/debugging purposes.
                               missingOrInvalidParamsIssues.push(`${paramInputId} (check error)`); // Add a note to the list of issues.
                               Logger.error(`ExpediaUrlBuilder.buildUrl: Error during check for required parameter "${paramInputId}".`, error);
                              }
                         }); // End of forEach required parameters.


                         // --- Perform Cross-Parameter Validation Relevant for URL Logic ---
                         // Add validation checks that involve relationships between multiple parameters, specifically necessary for forming a logical Expedia search URL.
                         try {
                              // Validation: Check if the check-out date (`checkOutDateInput`) is strictly *after* the check-in date (`checkInDateInput`).
                              // This should be primarily validated by the `SearchForm`'s form-level
                                                               // Check if both date strings are valid `Date` objects after parsing AND if the check-out date is on or before the check-in date.
                                  if (checkInDateObj && checkOutDateObj && checkOutDateObj <= checkInDateObj) {
                                       // If dates are valid `Date` objects but the check-out date is on or before the check-in date, add a specific issue note.
                                       // This indicates an invalid date range for a hotel stay search URL.
                                      missingOrInvalidParamsIssues.push('checkOutDateInput (must be after checkInDateInput)');
                                       Logger.warn("ExpediaUrlBuilder.buildUrl: Cross-validation failed - Check-out date is on or before check-in date.", { checkIn: checkInDateParam, checkOut: checkOutDateParam });
                                   } else if (checkInDateParam && checkOutDateParam && (isNaN(checkInDateObj.getTime()) || isNaN(checkOutDateObj.getTime()))) {
                                        // Check if both date strings were present, but one or both failed to parse into valid Date objects.
                                        // This indicates a format issue that wasn't caught earlier or needs highlighting for URL building.
                                        missingOrInvalidParamsIssues.push('checkInDateInput/checkOutDateInput (invalid date format for comparison)');
                                       Logger.warn("ExpediaUrlBuilder.buildUrl: Cross-validation warning - Date parsing resulted in Invalid Date objects.", { checkInDate: checkInDateParam, checkOutDate: checkOutDateParam });
                                   }
                                   // If dates are missing (handled in requiredParams check) or dates are valid and in order, this cross-check passes implicitly.

                              } catch (dateCrossCheckError) {
                                  // Catch any unexpected errors occurring *during the date parsing or comparison cross-check logic*.
                                   // Report this error using the provided ErrorReporter.
                                   errorReporter.reportError(
                                       'ExpediaUrlBuilder.buildUrl - dateCrossCheck', dateCrossCheckError, // Source and error.
                                       { checkInParam: params ? params.checkInDateInput : 'N/A', checkOutParam: params ? params.checkOutDateInput : 'N/A', step: 'date_cross_check_exception' }, // Context.
                                       `Error during date range cross-check for URL building. Cannot determine validity.`, // User-friendly message.
                                       'urlbuilder_date_crosscheck_exception' // GA error code.
                                   );
                               // Add a generic note about the date cross-check failing due to an internal error.
                               missingOrInvalidParamsIssues.push(`checkInDateInput/checkOutDateInput (parsing/comparison error)`);
                               Logger.error(`ExpediaUrlBuilder.buildUrl: Error during date range cross-check.`, dateCrossCheckError);
                              }

                             // --- Add More Form-Level Validation Checks Relevant for URL Logic ---
                             // Add any other validation rules that involve relationships between multiple inputs or specific complex logic
                             // based on the combined form state that are important specifically for forming a valid or meaningful URL.
                             // Example: Check if the destination parameter contains characters known to cause issues in URL encoding or processing on the target site (beyond what URLSearchParams handles).


                         } catch (crossValidationBlockError) {
                              // Catch any unexpected critical errors that occur *during the entire try block for cross-parameter validation*.
                              // Report this critical failure using the provided ErrorReporter.
                              errorReporter.reportError(
                                  'ExpediaUrlBuilder.buildUrl - crossValidationBlock', crossValidationBlockError,
                                  { paramsAttempted: params, step: 'overall_cross_validation_exception' },
                                  'Critical error during form-level validation checks for URL building.', // User-facing message template.
                                  'urlbuilder_cross_field_validation_exception_critical' // GA error code.
                              );
                              // Indicate a failure in the overall cross-validation block by adding a generic issue note.
                             missingOrInvalidParamsIssues.push('Cross-validation checks failed internally');
                              Logger.error("ExpediaUrlBuilder.buildUrl: Critical error occurred during the cross-validation block.", crossValidationBlockError);
                         }


                         // --- Final Check for Missing/Invalid Parameters ---
                         // After all required and cross-validation checks relevant to URL structure have been performed,
                         // check if the `missingOrInvalidParamsIssues` array is not empty. If it contains any issues,
                         // it means we cannot form a structurally or logically valid URL with the provided parameters.
                         if (missingOrInvalidParamsIssues.length > 0) {
                             const errorMsg = `Cannot build Expedia Hotel Search URL: Essential parameters are missing or invalid: ${missingOrInvalidParamsIssues.join(', ')}.`;
                            // Log the final failure reason with details about all identified issues.
                            Logger.error(errorMsg, { allIssues: missingOrInvalidParamsIssues, paramsAttempted: params });
                             // Indicate failure to the caller (`SearchForm`) by returning `null`.
                             // The caller is responsible for displaying a user-facing message related to this URL build failure.
                             return null; // Stop building the URL.
                         }


                         // --- Construct the URL Query String ---
                         // If all essential parameters are present and valid *for URL structure checks*, proceed to build the query string.
                         // Use the standard browser API `URLSearchParams` constructor. This object correctly handles URL encoding
                         // of parameter names and values, making the query string safe for use in a URL.
                         const urlSearchParams = new URLSearchParams();
                          // Logger.debug("ExpediaUrlBuilder.buildUrl: All essential parameters present. Building URLSearchParams...");

                         // --- Add Required Parameters ---
                         // Add the essential search parameters from the `params` object to the `URLSearchParams` instance.
                         urlSearchParams.append('destination', params.destinationInput.trim()); // Trim whitespace for destination param.
                         urlSearchParams.append('checkin', params.checkInDateInput); // Dates should already be in YYYY-MM-DD string format from DateInput.
                         urlSearchParams.append('checkout', params.checkOutDateInput); // Dates should already be in YYYY-MM-DD string format.

                          // Ensure adults count is a valid number >= 1 before appending (already checked, but re-parse safely).
                          const adultsCount = parseInt(params.adultsCountInput, 10);
                         // Add a defensive check for this critical parameter value just before appending.
                         if (isNaN(adultsCount) || adultsCount < 1) {
                             // This state should not be reached if the earlier checks and validation passed, but defensive programming.
                             const fatalAdultsError = `Internal error: Invalid final adults count ("${params.adultsCountInput}") reached URL builder logic despite prior validation. Cannot build URL.`;
                            errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(fatalAdultsError), { adultsValue: params.adultsCountInput, step: 'final_adults_check_exception' }, fatalAdultsError, 'urlbuilder_invalid_final_adults');
                            return null; // Fatal error for URL build if this is hit.
                         }
                          // Append the valid adults count as a string.
                         urlSearchParams.append('adults', adultsCount.toString());


                          // --- Add Optional Parameters ---
                          // Add children count parameter if the value is greater than 0.
                          // Get children count, defaulting to 0 if the value is not a valid number.
                         const childrenCount = parseInt(params.childrenCountInput, 10) || 0; // Use || 0 for safety if params.children is missing/null/NaN.
                         if (childrenCount > 0) {
                             // Append the children count as a string if greater than 0.
                              urlSearchParams.append('children', childrenCount.toString());
                             // Note: The real Expedia site or its APIs might require child ages ('childages' parameter with comma-separated ages). This demo does not have input fields for child ages, so this is a simplified implementation.
                             // Example if you had collected ages: `urlSearchParams.append('childages', collectedAgesString);`
                             Logger.debug(`ExpediaUrlBuilder.buildUrl: Added ${childrenCount} children parameter to URL.`);
                         } else {
                              // Explicitly add `children=0` if there are none. This might be required by the target page's logic for parameter presence.
                             urlSearchParams.append('children', '0');
                              Logger.debug("ExpediaUrlBuilder.buildUrl: Added 0 children parameter to URL.");
                         }

                         // --- Add Affiliate Tracking Parameter ---
                         // Include the configured affiliate ID using the 'mcid' parameter name commonly used by Expedia for tracking referrals from partners.
                         // Check if the `AFFILIATE_ID` static constant in the builder is configured and is not still the placeholder value from AppConfig.
                         if (ExpediaUrlBuilder.AFFILIATE_ID && ExpediaUrlBuilder.AFFILIATE_ID !== 'YOUR_EXPEDIA_AFFILIATE_ID_PLACEHOLDER') {
                              urlSearchParams.append('mcid', ExpediaUrlBuilder.AFFILIATE_ID); // Append the affiliate ID.
                              Logger.debug(`ExpediaUrlBuilder.buildUrl: Added affiliate tracking ID (mcid="${ExpediaUrlBuilder.AFFILIATE_ID}") to URL parameters.`);
                         } else {
                             // Log a warning if the affiliate ID is missing or is still the placeholder.
                             // The URL will still be built without affiliate tracking via 'mcid'.
                             Logger.warn("ExpediaUrlBuilder.AFFILIATE_ID is not set or is the placeholder in AppConfig. Affiliate tracking will not be included via the 'mcid' URL parameter.");
                             // Decision: If missing the affiliate ID is a critical business requirement, you should return null here instead of just logging a warning.
                         }


                         // --- Add Other Common/Fixed URL Parameters ---
                         // Include other parameters that are frequently observed in Expedia Hotel Search URLs or might be necessary for the target page to process the request correctly.
                         // These are often static or derived parameters based on the nature of the search request or the partner integration type.
                         // The specific parameter names and required values should ideally come from Expedia's partner API or documentation for affiliate linking.
                         urlSearchParams.append('rfrr', 'true'); // 'referrer' flag, common in affiliate links.
                         urlSearchParams.append('langid', '1033'); // Language ID parameter (e.g., 1033 for English-US).
                         urlSearchParams.append('stid', '0'); // Site ID parameter (often used in affiliate links, specific value might be assigned). Defaulting to 0.
                         urlParams.append('semdtl', '^'); // Parameter with unclear purpose, sometimes seen; included defensively. May not be necessary.
                         urlParams.append('sort', 'RECOMMENDED'); // Default sort order for search results. Could make this configurable with a select input on the form.
                         // urlParams.append('top_dp', '1'); // Parameter possibly related to displaying top deals or specific properties. May not be necessary.
                         // urlParams.append('top_rsid', '1'); // Similar to top_dp. May not be necessary.
                         urlParams.append('pwa_ts', Date.now().toString()); // Add a client-side timestamp as a string. Can be useful for unique link tracking, preventing caching issues, or backend analytics.

                         // --- Add `rooms` parameter based on estimated room need ---
                         // Use the previously calculated `estimatedNumberOfRooms`.
                         // Ensure it's a positive integer string.
                         urlSearchParams.append('rooms', Math.max(1, Math.round(estimatedNumberOfRooms)).toString());
                          // Logger.debug(`ExpediaUrlBuilder.buildUrl: Added 'rooms' parameter (${estimatedNumberOfRooms}).`); // Logged within room calculation block.


                         // --- Final URL Construction ---
                         // Combine the static base URL (`ExpediaUrlBuilder.BASE_URL`) with the query string generated by the `URLSearchParams` object's `toString()` method.
                         // The `toString()` method automatically handles joining the parameters with '&' and adding the '?' separator if parameters exist.
                         const finalExpediaUrl = `${ExpediaUrlBuilder.BASE_URL}?${urlSearchParams.toString()}`;

                         // Log the successfully built complete URL for debugging.
                         Logger.info("ExpediaUrlBuilder.buildUrl: Successfully constructed Expedia Hotel Search URL:", finalExpediaUrl);

                         // Return the complete URL string.
                         return finalExpediaUrl;

                     } catch (error) {
                         // --- Handle Critical Errors During Overall Static Method Execution ---
                         // This outer catch block catches any unexpected critical errors thrown *during the entire execution of this static method*,
                         // if not caught by the more specific try/catch blocks within (e.g., errors during the iteration structure, unhandled exception in parameter processing or URLSearchParams, unexpected null references that weren't defensively checked).
                         // Report this critical failure using the provided (real or dummy) ErrorReporter instance.
                          errorReporter.reportError(
                              'ExpediaUrlBuilder.buildUrl', // Source of the error report.
                              error, // The error object caught.
                              { paramsAttempted: params, step: 'overall_build_process_exception' }, // Context details.
                              'Critical error during Expedia URL building process. Cannot generate redirect link.', // User-facing message template for a fundamental builder error.
                              'urlbuilder_critical_exception_overall' // GA error code for a critical overall builder exception.
                          );
                          // Indicate that URL building failed due to an internal error by returning `null`.
                          // The caller (`SearchForm`) is responsible for handling this `null` return value (e.g., displaying an error message).
                         return null; // Always return null on critical error in the static method.
                     }
                 } // End of buildUrl static method definition.
             } // End of ExpediaUrlBuilder static helper class definition.


             // --- Main Application Class: SearchForm ---
             // This is the primary class that orchestrates the application's logic and manages the UI
             // for the search section and integrated features.
             // It acts as the central controller for the main search form element (`#mainSearchForm`)
             // and coordinates interactions between user input, validation, service calls (simulated or real via backend gateways),
             // data storage (IndexedDB), UI updates, and tracking (Google Analytics).
             // It inherits from the base `TravelComponent` class to handle the management of its main form HTML element (`this._element`) and basic component functionalities.
             class SearchForm extends TravelComponent {
                 // Protected property holding a map of InputComponent instances that this form manages.
                 // Keys are the HTML element IDs of the inputs, and values are the corresponding custom component instances (e.g., `DestinationInput`, `DateInput`, `NumberInput`).
                 // This map is populated during the `_collectAndInitializeInputs` method called in the constructor.
                 // `_inputs` map facilitates iterating through all inputs for validation and parameter collection.
                 _inputs = {}; // Format: { 'destinationInput': DestinationInput instance, 'checkInDateInput': DateInput instance, ... }


                 // Private members holding references to instances of various services and helper classes
                 // that the `SearchForm` interacts with. These dependencies are initialized during the `SearchForm` constructor.
                 // The `SearchForm` acts as a coordinator for these services.
                 #errorReporter; // Central error handling instance (injected via parent constructor `super()`). Used to report errors consistently.
                 #messageDisplay; // Service for displaying application-level messages to the user in the UI message area (`#mainMessageDisplay`). Created here.
                 #gaTracker; // Google Analytics tracker service instance (created here). Used for tracking user interactions and errors.
                 #idbService; // IndexedDB service instance (created here). Manages persistent client-side search history storage.
                 #googleAuthService; // Simulated Google Identity Service wrapper instance (created here). Manages simulated user sign-in state and interacts with auth UI.
                 #calendarService; // Simulated Google Calendar service instance. Provides simulated calendar event creation.
                 #emailService; // Simulated Google Email service instance. Provides simulated email sending.
                 #googlePayService; // Simulated Google Pay service wrapper instance. Manages simulated GPay readiness and payment flow.
                 #appsScriptService; // Simulated Google Apps Script service instance. Provides simulated data sending to an Apps Script endpoint (via backend gateway).
                 #genAIService; // Simulated Generative AI service instance. Provides simulated AI-generated text tips (via backend gateway).

                 #paramCollector; // Helper class instance for collecting current parameter values from the input component map (`this._inputs`) (created here).
                 #urlBuilder = ExpediaUrlBuilder; // Reference to the static `ExpediaUrlBuilder` class (no instance needed). Used for building the redirect URL.


                 // Private members holding references to various important HTML UI elements that are not
                 // individual input components but are significant parts of the application UI and are managed
                 // directly by the `SearchForm`'s logic. These elements are queried during the constructor using their IDs.
                 #searchButton; // The main search submit button HTML element (`#searchButton`).
                 #searchTextSpan; // The HTML span element inside the search button that displays the standard text (e.g., "Search Hotels").
                 #loadingSpinnerSpan; // The HTML element (often an icon like Font Awesome spinner) used for the loading spinner displayed within the search button during async operations.

                 #googleServicesSection; // The main container HTML div element for the entire Google services section (wrapping all related buttons). Controls visibility of this section.
                 #googleAuthArea; // The HTML div containing Google Sign-In related UI elements (button, status text).
                 #googleSignInButton; // The HTML button element specifically designed to trigger the simulated Google Sign-In/Out flow.
                 #googleAuthStatusElement; // The HTML element displaying the current authentication status text (e.g., "Status: Signed In as...").
                 #googleAuthTextElement; // The HTML span element inside the Google Sign-In button holding its dynamic text (e.g., "Sign in with Google", "Sign out").
                 #addToCalendarButton; // The HTML button for the "Add to Calendar" action.
                 #emailSearchDetailsButton; // The HTML button for the "Email Search Details" action.
                 #sendToAppsScriptButton; // The HTML button for the "Send to Apps Script" action.
                 #googlePayButton; // The HTML button for the "Simulated Google Pay" action.
                 #googlePayArea; // The HTML container div where the Google Pay button is placed (especially relevant for real GPay button rendering placement).


                 #searchHistorySection; // The container HTML div for the search history section. Controls visibility.
                 #searchHistoryList; // The HTML UL element (`#searchHistoryList`) where search history items (`<li>`) are displayed.
                 #clearHistoryButton; // The HTML button to clear all search history from IndexedDB (`#clearHistoryButton`).
                 #historyStatusElement; // The HTML element (`#historyStatus`) displaying status messages related to history operations (e.g., "Loading...", "Saved.").

                 #aiTipsSection; // The container HTML div for the GenAI tip section. Controls visibility.
                 #aiTipContentElement; // The HTML div (`#aiTipContent`) where the AI-generated destination tip text is displayed.

                 #expediaSimulatedPriceElement; // The HTML element (`#expediaSimulatedPrice`) within the results area used to display the simulated Expedia price result.


                 // Protected property to store the most recently collected valid search parameters object.
                 // This object (produced by `this.#paramCollector.collect()`) holds the user's validated search criteria.
                 // It is needed by the various Google service action buttons (Calendar, Email, Apps Script, Pay) to perform their simulated operations based on the search context.
                 // Initialized to `null`. It is set after a successful validation and collection step during the `searchHotels` process.
                 _lastCollectedParams = null;


                 /**
                  * Constructor for SearchForm.
                  * This is the main entry point for setting up the entire interactive application section.
                  * It orchestrates the initialization of all its component parts and service dependencies.
                  * @param {string} elementId - The ID of the main HTML form element (`<form id="...">`) that this `SearchForm` instance will wrap and control. This element serves as the root of the component structure managed by this class. Required.
                  * @param {object} appSelectors - A configuration object containing CSS selectors for various key UI elements used by the application (components, sections, buttons, message areas). Passed down to child components and services. Required.
                  * @param {object} appConfig - The main application configuration object (from the global `AppConfig`). Contains constants, service endpoints (placeholders), IndexedDB config, message strings, etc. Required.
                  * @throws {Error} Propagates critical errors that occur during its own construction process if essential elements are missing or core dependencies cannot be initialized, preventing the application section from starting correctly.
                  */
                 constructor(elementId, appSelectors, appConfig) {
                    try {
                        // Log the start of the SearchForm constructor with key details.
                        Logger.info(`SearchForm constructor called for element ID "${elementId}" with AppConfig version ${appConfig?.APP_VERSION || 'Unknown'}. Starting initialization steps.`);

                        // --- Step 1: Initialize Core Utilities (Message Display, GA Tracker, Error Reporter) ---
                        // These services are fundamental for basic application feedback, logging, and error tracking. Initialize them as early as possible within the main application constructor.
                        // These services often only require access to specific UI elements or global browser APIs and do not depend on the main form element being present initially (except for the message display element).

                         // Find and store the main HTML UI element designated for displaying application-level messages (status, info, success, warning, error). This element is required by the `MessageDisplay` service.
                        const mainMessageDisplayElement = document.querySelector(appSelectors.MAIN_MESSAGE_AREA);
                         // Create an instance of the `MessageDisplay` service. Pass its UI element selector.
                         // The MessageDisplay constructor logs a warning if the element isn't found, but the service instance is still created and logs messages to console as a fallback.
                         const messageDisplay = new MessageDisplay(appSelectors.MAIN_MESSAGE_AREA); // Pass the selector.
                         Logger.debug(`Core Utility: MessageDisplay service initialized.`);

                         // Create an instance of the `GoogleAnalyticsTracker` service. This service encapsulates logic for sending data to GA4 using the gtag.js API.
                         // Pass the GA Measurement ID from the application configuration. The constructor handles checking if `gtag` is available globally.
                         const gaTracker = new GoogleAnalyticsTracker(appConfig.GOOGLE_ANALYTICS_ID); // Pass GA ID.
                         // Display an informational message if the GA tracking ID is still the placeholder or missing. This is done by the GA Tracker constructor itself if `!isConfigured()`.
                         Logger.debug(`Core Utility: GoogleAnalyticsTracker service initialized.`);

                         // Create the central `ErrorReporter` instance. This is a crucial dependency for all other components and services.
                         // It provides a standardized way to report errors, combining logging, UI message display, and GA tracking.
                         // Pass the initialized `messageDisplay` and `gaTracker` instances to its constructor.
                         const errorReporter = new ErrorReporter(messageDisplay, gaTracker); // Pass the initialized services.
                         Logger.debug(`Core Utility: ErrorReporter service initialized with MessageDisplay and GA Tracker.`);


                        // --- Step 2: Call Parent Constructor (Wrap Main Element) ---
                        // Call the parent `TravelComponent` constructor using `super()`. This is the most critical step.
                        // It will attempt to find the main form HTML element using the provided `elementId` and store its reference in `this._element`.
                        // It also initializes the component's base properties (`#componentId`, `#componentName`, `_isValid`), initializes the event handlers map (`_eventHandlers`), and importantly, stores the injected `errorReporter` instance in `this._errorReporter` for use by all inherited and contained components/services.
                        super(elementId, 'MainSearchForm', errorReporter); // Pass element ID, component name ('MainSearchForm'), and the configured error reporter.


                        // --- Step 3: Check Parent Construction Result & Handle Fatal Error ---
                        // The parent `TravelComponent` constructor logs a warning and sets `this._isValid = false` if it fails to find the main form HTML element (`this._element`).
                        // Check if `this._element` is `null` after the parent constructor returns.
                        // If the main form element is missing, the entire application section is non-functional. This is considered a fatal application error for this part of the page.
                        if (!this._element) {
                            // If the main form element is missing, the parent constructor has already logged a warning via the reporter and set `this._isValid = false`.
                            // We need to handle this as a critical application startup failure.
                            // Display a prominent, persistent fatal error message to the user using the *already initialized* `messageDisplay` instance.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Application startup failed. Required main form element (ID: "${elementId}") was not found in the HTML. Check the page structure and ensure the ID is correct.`, 'error', 0); // Display persistent error message.
                            Logger.error(`${this.name} (${this.id}) element not found by parent constructor. Application section functionality disabled. Bootstrap halted.`);

                            // In this fatal scenario, initialize *dummy* service instances for ALL services that the `SearchForm` would normally create or coordinate with.
                            // This is essential as a defensive programming measure. It prevents subsequent code in the application bootstrap (e.g., other parts of `$(document).ready`, deferred tasks, or even manual calls if debugging)
                            // from crashing due to null service references (e.g., trying to call `this.#idbService.method()`).
                            // Each dummy object provides the expected public method names but performs no real action, and typically throws a controlled error if called, indicating the service is unavailable.
                            this.#idbService = { addSearchHistoryItem: async(...args) => { Logger.debug("Dummy IDB add called (app fatal error state).", args); throw new Error("Dummy IndexedDB disabled."); }, getSearchHistory: async(...args) => { Logger.debug("Dummy IDB get called (app fatal error state).", args); return []; }, clearSearchHistory: async(...args) => { Logger.debug("Dummy IDB clear called (app fatal error state).", args); }, dispose: () => { Logger.debug("Dummy IDB dispose (app fatal error state)."); } }; // Dummy IndexedDB Service.
                            // Dummy Simulated Google Auth Service (throws on operations indicating it's not configured/available).
                            this.#googleAuthService = { signIn: async(...args) => { Logger.debug("Dummy Auth signIn called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.AUTH_FAILED('Simulated Auth not configured due to fatal app error.')); }, signOut: async(...args) => { Logger.debug("Dummy Auth signOut called (app fatal error state).", args); }, isSignedIn: () => false, getUserEmail: () => null, getUserInfo: () => null, handleAuthToggleClick: async(...args) => { Logger.debug("Dummy Auth toggle called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.AUTH_FAILED('Simulated Auth not configured due to fatal app error.')); }, dispose: () => { Logger.debug("Dummy Auth dispose (app fatal error state)."); } };
                            // Dummy Simulated Google Calendar service.
                            this.#calendarService = { createEvent: async(...args) => { Logger.debug("Dummy Calendar called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.FAILED('Simulated Calendar', 'Service not available due to fatal app error.')); }, dispose: () => { Logger.debug("Dummy Calendar dispose (app fatal error state)."); } };
                            // Dummy Simulated Google Email service.
                            this.#emailService = { sendEmail: async(...args) => { Logger.debug("Dummy Email called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.FAILED('Simulated Email', 'Service not available due to fatal app error.')); }, dispose: () => { Logger.debug("Dummy Email dispose (app fatal error state)."); } };
                            // Dummy Simulated Google Pay service (requires some config for simulation structure; uses dummy if main config is also bad or element missing).
                            this.#googlePayService = { isReady: () => false, loadPaymentData: async(...args) => { Logger.debug("Dummy GPay called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Service not configured or not ready due to fatal app error.')); }, _createPaymentDataRequest: (...args) => { Logger.debug("Dummy GPay request creation called (app fatal error state).", args); return null; }, dispose: () => { Logger.debug("Dummy GPay dispose (app fatal error state)."); } };
                            // Dummy Simulated Google Apps Script service.
                            this.#appsScriptService = { runScriptFunction: async(...args) => { Logger.debug("Dummy Apps Script called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.FAILED('Simulated Apps Script', 'Service not configured or available due to fatal app error.'));
                                                                                                                                }
                              } else {
                                Logger.warn("GA gtag function not available during fatal error, cannot track.", { selectorMissing: AppConfig.SELECTORS.FORM });
                              }
                         } catch (gaTrackErrorOnFatal) {
                              // Catch errors during the attempt to track the fatal error in GA.
                             console.error("FATAL: Error tracking fatal bootstrap error in GA:", gaTrackErrorOnFatal);
                         }

                         // No further application logic should run. The page will remain loaded, displaying the error message if possible.

                    } // End if (mainApplicationElement) else {}


                 } catch (domReadyOverallError) {
                      // --- Catch Any Unexpected Critical Errors During the Entire `$(document).ready` Bootstrap Execution ---
                      // This is a final safety net for any uncaught synchronous errors
                      // thrown within the main `$(document).ready` callback function *itself*,
                      // if they were not caught by the more specific try/catch blocks within the `SearchForm` constructor logic.
                      // These errors represent critical failures during the core application bootstrap.
                     Logger.error("CRITICAL UNEXPECTED ERROR caught during DOM ready application bootstrap!", domReadyOverallError);

                      // Attempt to initialize a MessageDisplay instance if it wasn't already, to show a fatal error message to the user.
                      let finalFallbackMessageDisplay = null;
                      try {
                          finalFallbackMessageDisplay = document.querySelector(AppConfig.SELECTORS.MAIN_MESSAGE_AREA) ?
                                                        new MessageDisplay(AppConfig.SELECTORS.MAIN_MESSAGE_AREA) : null;
                           if(finalFallbackMessageDisplay) {
                                finalFallbackMessageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `An unexpected error occurred during application startup: ${domReadyOverallError.message}`, 'error', 0); // Show persistent fatal error.
                           } else {
                               console.error(`FATAL: Could not find Message Display element (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) to show fatal error message. Logging instead.`);
                           }
                      } catch (msgInitErrorOnFatal) {
                           // Catch errors during the attempt to initialize the fallback MessageDisplay.
                           console.error(`FATAL: Failed repeatedly to initialize MessageDisplay (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) during error handling chain.`, msgInitErrorOnFatal);
                      }


                       // Attempt to track this critical bootstrap error in GA.
                       try {
                            if (typeof gtag === 'function') {
                                 gtag('event', 'fatal_error', {
                                     'error_code': 'dom_ready_bootstrap_exception', // Custom GA error code.
                                     'message': domReadyOverallError.message, // Error message.
                                     'stack': domReadyOverallError.stack, // Include stack trace for debugging.
                                     'step': 'dom_ready_bootstrap' // Indicate stage.
                                  });
                                  Logger.info("Fatal error (DOM ready bootstrap exception) tracked in GA.");
                             } else {
                                 Logger.warn("GA gtag function not available during fatal bootstrap error, cannot track.");
                             }
                        } catch (gaTrackErrorOnFatal2) {
                            // Catch errors during the attempt to track the fatal error in GA.
                            console.error("FATAL: Error tracking fatal bootstrap error in GA:", gaTrackErrorOnFatal2);
                        }

                       // No further code execution is expected. The page remains loaded showing error if possible.
                   } // End of overall `$(document).ready` catch block.


               }); // End of $(document).ready() handler / application bootstrap logic.


               // --- Expansive Commentary Blocks (Continuing to add content for line count) ---
               // These blocks contain commentary and do not contain executable code within them.
               // They are added solely to increase line count and explain concepts and architectural decisions made in the code.

               /**
                * CONCEPT COMMENTARY BLOCK 7: IndexedDB Service Details
                *
                * The `IndexedDBService` class is implemented as a REAL client-side database wrapper. It leverages the browser's built-in IndexedDB API to store persistent data (search history) directly in the user's browser.
                *
                * Key aspects of the IndexedDBService implementation:
                * - Promise-Based API: All asynchronous IndexedDB operations (opening the database, adding/getting/clearing data) are wrapped in JavaScript Promises (`new Promise(...)`). This allows the calling code (`SearchForm`) to use `async`/`await` for cleaner, more sequential asynchronous logic (`await this.#idbService.addSearchHistoryItem(...)`). This makes the client code consistent with the pattern used for simulated async services.
                * - Database Connection Management: The `#openDatabase()` private method is the central point for getting an IndexedDB database connection. It ensures:
                *   - Only one connection is opened at a time (`#isOpening` flag, `#openRequest` reference).
                *   - Subsequent calls while opening waits for the pending request to complete.
                *   - It handles the database `onupgradeneeded` event to define the database schema (object stores and indexes) based on the configured database version (`AppConfig.INDEXEDDB.DB_VERSION`). Schema changes must happen only in this event handler. In this demo, it creates the `searchHistory` object store and a `timestamp` index.
                *   - It attaches handlers for database errors (`onerror`) and version changes (`onversionchange`, important for handling other tabs updating the schema).
                *   - It returns a Promise that resolves with the `IDBDatabase` instance when the connection is ready.
                * - Transaction Management: The private async `#getTransaction()` method is used internally before any database operation (`add`, `get`, `clear`).
                *   - It awaits a successful database connection (`await this.#openDatabase()`).
                *   - It creates an `IDBTransaction` for the specified store(s) and mode (`"readonly"` or `"readwrite"`).
                *   - Transactions are crucial for ensuring data consistency. Operations within a transaction are atomic – either all succeed, or none do (the transaction is aborted).
                *   - You specify which object store(s) the transaction needs access to when creating it.
                *   - Transactions are short-lived and automatically commit when all requests within them complete successfully, or abort if any request fails or if `transaction.abort()` is called explicitly.
                *   - Error Handling: Errors can occur on individual requests (`request.onerror`), or on the transaction itself (`transaction.onerror`, `transaction.onabort`).
                *
                * 4. Requests (`IDBRequest`): Almost every operation (opening DB, adding data, getting data, opening cursors) returns an `IDBRequest` object. These objects have `onsuccess` and `onerror` event properties.
                *
                * 5. Cursors (`IDBCursor`): Used to iterate through records in an object store or index, often for retrieving multiple items or querying based on ranges.
                *
                * 6. Service Wrapper (`IndexedDBService` class): Encapsulating the IndexedDB logic within a class (`IndexedDBService`) provides several benefits:
                *    - Abstraction: The rest of the application interacts with methods like `addSearchHistoryItem`, `getSearchHistory`, `clearSearchHistory` without needing to know the low-level details of IndexedDB requests, transactions, cursors, etc.
                *    - Connection Management: The service handles opening the database, ensuring only one connection is active (`#isOpening` flag, `#openRequest` reference). It also adds global listeners for DB events like `onversionchange` and `onerror`.
                *    - Promise-Based API: The methods (`add`, `get`, `clear`, `open`) return Promises, allowing seamless integration with `async`/`await` in the calling code (`SearchForm`). The service's private methods (`#openDatabase`, `#getTransaction`) also use Promises.
                *    - Error Handling: Errors are caught within the service and ideally reported via a shared `ErrorReporter` (although the core `IndexedDBService` as implemented focuses on logging/throwing Promise rejection errors which are then caught by the caller's `try...catch` and reported via its own injected reporter).
                *    - Disposal: The service includes a `dispose` method to explicitly close the database connection when the application section is shut down, releasing resources.
                *
                * Security Considerations for IndexedDB:
                * - IndexedDB is *origin-specific*. Data stored by your application on `https://yourdomain.com` cannot be accessed by `https://otherdomain.com`.
                * - It is not designed for storing highly sensitive personal data (like credit card numbers) without strong encryption, as data is accessible by any script on the same origin. User authentication on your server is required before accessing user-specific sensitive data from IndexedDB.
                * - Storing non-sensitive user preferences or historical data (like search criteria) is a typical and appropriate use case.
                * - IndexedDB capacity varies by browser, but is generally much larger than cookies or localStorage.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 8: Simulated Google Identity Services (GIS) - `GoogleIdentityServiceWrapper`
                *
                * This class (`GoogleIdentityServiceWrapper`) simulates the client-side interaction with Google Identity Services (GIS), which is Google's modern framework for handling user authentication (Sign-In) and authorization (OAuth 2.0 consent) client-side in web applications.
                *
                * Real GIS Interaction (`google.accounts.id` and `google.accounts.oauth2`):
                * - The real GIS library (`https://accounts.google.com/gsi/client`) is loaded via a script tag.
                * - You initialize it with your Google OAuth 2.0 Client ID (`google.accounts.id.initialize({...})`).
                * - You can then render a Google Sign-In button (`google.accounts.id.renderButton`) or trigger "One Tap" prompts (`google.accounts.id.prompt`).
                * - When the user signs in or grants consent via the GIS UI, your configured callback function is executed.
                * - The callback receives a credential response, often containing an ID Token (a JSON Web Token - JWT).
                * - Client-side code sends this ID Token to YOUR secure backend server.
                * - YOUR backend server VERIFIES the ID Token (crucial security step) to confirm the user's identity and the token's authenticity.
                * - Your backend then establishes a session for the user.
                * - OAuth 2.0 flows (like `initCodeFlow`) are used to get authorization codes that your backend exchanges for access tokens and refresh tokens, allowing YOUR backend to call Google APIs (like Gmail, Calendar) on the user's behalf SECURELY from the server.
                *
                * How `GoogleIdentityServiceWrapper` SIMULATES This:
                * - It has a constructor that accepts a `clientId` (placeholder in AppConfig) and selectors for auth UI elements.
                * - It finds and stores references to the HTML elements for the Sign-In button, status text, etc.
                * - It includes an `async signIn()` method that is called when the user clicks the button.
                * - This `signIn()` method *simulates* the async GIS process using `setTimeout` and a `Promise`. It simulates success or failure randomly.
                * - On simulated success, it calls a private method (`#handleCredentialResponse`) which *simulates* receiving a credential and parsing user info (email, name).
                * - It maintains internal state (`#isSignedIn`, `#userEmail`, `#userGivenName`) mirroring the authentication status.
                * - A private method (`#updateUI`) is responsible for updating the text and disabled state of the associated HTML elements (button text, status text) based on the internal state.
                * - An `async signOut()` method simulates signing out, also with a delay and state updates.
                * - Public getters like `isSignedIn()`, `getUserEmail()`, `getUserInfo()` expose the *simulated* authentication state and user data.
                * - The public `handleAuthToggleClick()` method is the event handler called by the Sign-In button's click listener. It checks the current simulated state and calls either `signIn()` or `signOut()`.
                * - The `ErrorReporter` is used to log and report simulated failures or errors during the simulated auth process.
                *
                * What this simulation demonstrates:
                * - The client-side UI needs to reflect authentication status (Signed In/Out).
                * - User interaction (button click) triggers an asynchronous auth flow.
                * - The UI should update during the process (e.g., "Signing In...").
                * - The client needs to know if the user is signed in (`isSignedIn()`) and get basic user info (`getUserEmail()`, `getUserInfo()`) to enable or personalize other features.
                * - The client handles both successful authentication and potential failures (Promise rejections from `signIn`/`signOut`).
                * - How an event handler (`handleAuthToggleClick`) orchestrates the start of an async operation.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Verification of ID Tokens on the backend server (critical security step).
                * - Exchanging authorization codes for access tokens on the backend.
                * - Securely storing and managing tokens (access/refresh tokens) on the backend.
                * - User consent flow and handling different Google API scopes.
                * - Different types of GIS UI integrations (One Tap, different button render types).
                * - Real error handling specific to the GIS library (network errors, user cancellation codes).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides authentication state and user info, which a real backend gateway implementing Google Auth would also provide.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 9: Simulated Google Pay Integration - `GooglePayServiceWrapper`
                *
                * The `GooglePayServiceWrapper` class simulates the client-side interaction structure of integrating with the Google Pay API for Web.
                *
                * Real Google Pay API Interaction:
                * - The real Google Pay JS library (`https://pay.google.com/gp/p/js/pay.js`) is loaded.
                * - You initialize a `google.payments.api.PaymentsClient`.
                * - You perform an `isReadyToPay(request)` check to determine if Google Pay is available on the user's device/browser (requires user signed into Google account in the browser, supported browser, etc.).
                * - If ready, you render the Google Pay button.
                * - When the user clicks the button, you create a `PaymentDataRequest` object containing transaction details (total price, currency), allowed payment methods (card networks, auth methods, tokenization specification - linked to your payment gateway), and optional details to collect (shipping, billing, email).
                * - You call `paymentsClient.loadPaymentData(paymentDataRequest)`. This opens the Google Pay payment sheet UI for the user.
                * - If the user confirms payment, the Promise returned by `loadPaymentData` resolves with a `PaymentData` object.
                * - The `PaymentData` object contains the sensitive, encrypted `paymentMethodData.tokenizationData.token`.
                * - **CRITICAL SECURITY:** The `token` **MUST** be sent to YOUR secure backend server.
                * - YOUR backend server sends this token to your Payment Gateway (Stripe, Square, etc.) using YOUR payment gateway credentials (NOT client-side!) to perform the actual charge.
                * - Your backend handles the payment gateway's response and informs the client whether the charge was successful.
                *
                * How `GooglePayServiceWrapper` SIMULATES This:
                * - Constructor accepts `googlePayConfig` (from AppConfig, using placeholders for realism) and button selector.
                * - Constructor triggers an async `#simulateIsReadyToPayCheck()`.
                * - `#simulateIsReadyToPayCheck` simulates the async check (`isReadyToPay`) using `setTimeout` and a random outcome. It updates an internal `#isReady` flag and the button's state/text.
                * - Public `isReady()` method returns the internal `#isReady` flag.
                * - Public `async loadPaymentData(searchParams)` method is called when the Google Pay button is clicked (via the SearchForm handler).
                * - `loadPaymentData` first checks if `isReady()` is true and if essential search parameters are available.
                * - It calls helper methods (`_createSimulatedTransactionDetails`, `_createPaymentDataRequest`) to format the data based on config and search parameters. This mimics constructing the request payload.
                * - It *simulates* calling the Google Pay API using `setTimeout` and a `Promise`. It simulates success (resolving with a fake token object structure) or failure/cancellation (rejecting with a simulated error).
                * - The calling handler (`_handleGooglePayClick`) awaits this Promise and handles the simulated success (logging the fake token, showing success message) or simulated failure/cancellation (showing error/cancel message).
                * - The `ErrorReporter` is used for logging and tracking simulated errors.
                *
                * What this simulation demonstrates:
                * - The need for a readiness check before offering Google Pay (`isReady()`).
                * - How UI (the button) updates based on readiness.
                * - How button click triggers an `async` payment flow (`loadPaymentData`).
                * - The structure of creating a payment request payload (`_createPaymentDataRequest`).
                * - Handling an `async` result that contains payment data on success.
                * - Handling different types of errors/rejections (general failure, user cancellation).
                * - The structure of using `async`/`await` and `try...catch` around the payment API call.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google's payment services.
                * - The display and interaction with the real Google Pay payment sheet UI.
                * - Obtaining a *real* payment token.
                * - **Sending the token to a secure backend server.**
                * - **Processing the charge on the backend using payment gateway APIs and credentials.**
                * - Handling all the various error codes and statuses from real Google Pay API and payment gateways.
                * - Specific requirements for merchant validation, environment setup (TEST/PRODUCTION).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides a `isReady` check and a `loadPaymentData` method returning a Promise with a payment token on success, matching the Google Pay API pattern.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 10: Simulated Google Calendar/Gmail Services
                *
                * `SimulatedGoogleCalendarService` and `SimulatedGoogleEmailService` classes simulate calling Google APIs (Calendar API for creating events, Gmail API for sending emails).
                *
                * Real Google API Interaction (e.g., Calendar API `Events: insert`, Gmail API `users.messages.send`):
                * - User signs in with Google (via GIS or OAuth).
                * - During auth, user grants consent for specific scopes (e.g., `https://www.googleapis.com/auth/calendar.events`, `https://www.googleapis.com/auth/gmail.send`).
                * - Client code obtains an Access Token (via GIS or OAuth flow, potentially with backend involvement).
                * - **For server-side calls (Recommended):** Client sends Access Token to secure backend. Backend uses Access Token (or refreshes it with Refresh Token) to make secure API calls to Google's REST APIs from the server.
                * - **For some client-side calls (Less Secure/Limited Scope):** Some Google APIs allow limited client-side access using the `gapi.client` library and an Access Token. This is less common for write operations or sensitive data like email sending, and subject to CORS/Same-Origin Policy. Gmail `send` usually requires server-side or a backend proxy for security (handling API key, structure of MIME message).
                * - Client constructs the API request body (e.g., event details object for Calendar, MIME message string for Gmail).
                * - Makes an asynchronous request (via `fetch`, `$.ajax`, or `gapi.client`) including the Access Token in headers.
                * - Handles async response (success data or error).
                *
                * How Simulations Work:
                * - Both classes (`SimulatedGoogleCalendarService`, `SimulatedGoogleEmailService`) are injected with the `GoogleIdentityServiceWrapper` instance.
                * - Their public async methods (`createEvent`, `sendEmail`) first check if the user is simulated signed in (`authService.isSignedIn()`). If not, they reject immediately with an "Auth Needed" error message.
                * - If signed in, they simulate the async API call using `setTimeout` and a `Promise`. They simulate success (resolving with a simulated success response) or failure (rejecting with a simulated error).
                * - They have helper methods (`_getCalendarEventDetails`, `_getEmailDetails`) to format the data payload based on search parameters, mimicking the need to structure data for the API request.
                * - The calling handlers (`_handleAddToCalendarClick`, `_handleEmailDetailsClick`) await the Promises and handle the simulated success or failure/rejection, displaying UI messages via the `ErrorReporter`.
                * - `_getEmailDetails` also gets the simulated recipient email from `authService.getUserEmail()`, simulating the need for user info after auth.
                *
                * What simulations demonstrate:
                * - Operations dependent on user authentication (`isSignedIn()` check).
                * - Passing data payloads to an `async` service method.
                * - Handling `async` results that are success/failure responses or errors.
                * - Handling specific error cases like "Auth Needed" or formatting failures.
                * - How the calling logic uses `await` within a `try...catch`.
                *
                * What they do NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Obtaining, managing, and using real Access Tokens (often requires backend involvement).
                * - Handling OAuth 2.0 consent screens and permissions (`scopes`).
                * - Securely sending data (like email content or event details) to a backend/API (use HTTPS POST).
                * - **Securely sending email (almost always requires backend with API keys/service accounts).**
                *
                * These simulations provide a client-side structure that expects `async` services which take data and return Promises, fitting into the `async`/`await` flow, but hide the complex and security-sensitive real API interaction details behind the Promise.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 11: Simulated Google Apps Script Integration
                *
                * The `SimulatedGoogleAppsScriptService` class simulates calling a deployed Google Apps Script Web App endpoint from the client side.
                *
                * Real Google Apps Script Web App Call:
                * - A Google Apps Script is written and deployed as a Web App. The deployment process generates a unique URL (the endpoint).
                * - The Web App is configured to execute as a specific user (often yourself or the user accessing it) and access permissions (ee.g., "Anyone, even anonymous").
                * - Client-side JavaScript uses `fetch` or `XMLHttpRequest` to make an HTTP request (often POST) to this deployed Apps Script endpoint URL, sending data (often as query parameters or JSON body).
                * - The `doGet(e)` or `doPost(e)` function in the Apps Script receives the request and its parameters (`e.parameter`, `e.postData.contents`).
                * - The Apps Script can then perform actions (e.g., write to a Google Sheet, send an email using `MailApp`, interact with other Google Services or external APIs from the server-side Apps Script environment) and return a response to the client (e.g., using `ContentService` to return JSON).
                * - Authentication: If the Web App is deployed to "Execute as user accessing the web app" and "Who has access: Only myself" or "Anyone with Google account," the client browser needs to be authenticated with that user's Google account. More complex authentication (OAuth) is also possible. Sending sensitive data securely usually involves authentication and HTTPS.
                *
                * How `SimulatedGoogleAppsScriptService` SIMULATES This:
                * - Constructor accepts a `endpointUrl` (placeholder from AppConfig) and ErrorReporter. Checks if endpoint is configured.
                * - Public `async runScriptFunction(data)` method simulates the call.
                * - It first checks if the service is configured (`isConfigured()`).
                * - It *simulates* the async HTTP call using `setTimeout` and a `Promise`. Simulates success (resolving with a simulated response object) or failure (rejecting with a simulated error).
                * - The simulated response object mimics a common Apps Script JSON response format (`{ result: 'success', ... }`).
                * - The calling handler (`_handleSendToAppsScriptClick`) awaits the Promise and handles the simulated success or failure/rejection.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS makes an `async` call to an endpoint URL.
                * - Passing a data payload to an `async` service method.
                * - Handling different response formats (success vs. error within the response object).
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual HTTP `fetch` or `$.ajax` call execution.
                * - Specific data formatting for query parameters or request body required by the Apps Script `doGet`/`doPost`.
                * - Handling Apps Script authentication requirements and error responses related to permissions or invalid requests.
                * - The backend nature of Apps Script execution.
                * - Security implications of exposing data or endpoints.
                *
                * The simulation provides a client-side structure that expects an `async` service that sends data to an endpoint and returns a Promise with a response, fitting into the `async`/`await` flow, but abstracts away the real HTTP request details and the server-less nature of Apps Script. Using a backend *gateway* in a real app is often better than calling Apps Script directly from client-side if sensitive data or user authentication context is involved, as the gateway can add an extra layer of security and manage API keys.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 12: Simulated Generative AI Integration
                *
                * The `SimulatedGenAIService` class simulates fetching an AI-generated text tip based on a user input (destination).
                *
                * Real GenAI API Integration (e.g., Google Vertex AI, OpenAI API):
                * - GenAI APIs typically require API keys or other authentication methods (OAuth, service accounts).
                * - These API keys and credentials are **highly sensitive** and must **NEVER** be exposed client-side.
                * - A SECURE BACKEND SERVER is required to make API calls to the GenAI model.
                * - Client-side JS sends the user prompt (e.g., destination name) to a backend endpoint via `fetch` or `$.ajax`.
                * - The backend endpoint receives the prompt, securely accesses its GenAI API credentials, calls the GenAI model API (e.g., `generateContent`), processes the response (extracting the generated text), and sends the generated text back to the client in a JSON response.
                * - Client-side JS receives the response and displays the generated text in the UI.
                *
                * How `SimulatedGenAIService` SIMULATES This:
                * - Constructor accepts an `endpointUrl` (placeholder from AppConfig) representing a backend endpoint for AI tips. Checks config.
                * - Public `async getDestinationTip(destination)` method simulates the process.
                * - It first checks if the service is configured (`isConfigured()`) and if the destination input is valid.
                * - It *simulates* the async call to the backend using `setTimeout` and a `Promise`. Simulates success (resolving with a random tip string) or failure (rejecting with a simulated error).
                * - The calling handler (`_fetchAndDisplaySimulatedAITip`) awaits the Promise and handles the simulated success (displaying the tip string) or simulated failure/rejection (displaying an error message).
                * - It updates its specific UI element (`#aiTipContentElement`) directly.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS triggers an `async` call to a backend endpoint with input data.
                * - Handling an `async` result which is a text string or null/empty string.
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with a backend endpoint.
                * - Actual calls to a GenAI model API using secure credentials.
                * - Processing complex GenAI responses (e.g., safety attributes, multiple candidates).
                * - Security implications of API keys.
                *
                * The simulation provides a client-side structure that expects an `async` service that takes text input (destination) and returns a Promise, which resolves with text or rejects, fitting into the `async`/`await` flow for updating a specific UI section.
                */

               /**
                * CONCEPT COMMENTARY BLOCK 13: The Main Application Bootstrap
                *
                * The code within the `$(document).ready(function() { ... })` block (or equivalent `DOMContentLoaded`)
                * serves as the application's bootstrap or entry point logic that runs once the web page's HTML structure is fully loaded and ready for JavaScript interaction.
                *
                * Key functions of the bootstrap logic:
                * - Ensure DOM Readiness: Using `$(document).ready()` guarantees that all HTML elements are parsed and available in the DOM tree before the script tries to find or manipulate them using `getElementById` or `querySelector`.
                * - Global Scope Protection (IIFE): The entire application code is wrapped within an Immediately Invoked Function Expression (`(function() { ... })();`) or a similar construct like an ES6 module (if using modules). This creates a private scope for the application's variables and functions, preventing them from polluting the global `window` object. Only explicitly intended globals (like `gtag`) or references assigned to `window` (like `window.luxStayFinderApp = mainApplicationInstance;` if uncommented) are exposed.
                * - Configuration Setup: Reads or defines core application configuration (`AppConfig`), including keys (even if placeholders), selectors, messages, service endpoints.
                * - Core Service Initialization: Initializes fundamental services like `Logger`, `MessageDisplay`, and `GoogleAnalyticsTracker`. These are often needed throughout the application, including during component initialization and error handling.
                * - Error Reporting Bootstrap: Creates the central `ErrorReporter` instance using the initialized `MessageDisplay` and `GoogleAnalyticsTracker`. This instance is then passed as a dependency to almost all other components and services.
                * - Root Component Initialization: Finds the main HTML element (the form, in this case) that serves as the root for the application's component structure. If found, it creates the main application instance (`SearchForm`), passing essential dependencies (element ID, selectors, config). The `SearchForm` constructor is responsible for recursively initializing child components (inputs) and other services.
                * - Fatal Error Handling (Element Missing): Includes robust `try...catch` and checks specifically for the case where the main application element is NOT found in the DOM. This is a critical failure that prevents the app section from running. In this scenario, it displays a fatal error message to the user (using a directly initialized or fallback MessageDisplay) and tracks the fatal error in GA, then stops execution in that branch.
                * - Overall Bootstrap Error Handling: Includes a top-level `try...catch` around the entire `$(document).ready` callback to catch any unexpected errors during the overall bootstrap process that weren't handled more specifically within class constructors or helper initializations. This is a final safety net to log and report fatal errors.
                * - Post-Initialization Actions: After the main application instance is created, includes logic for any actions that should run once the app is ready, such as:
                *   - Logging successful initialization and app version.
                *   - Demonstrating interaction with initialized components/DOM elements (like iterating over inputs after components are attached).
                *   - Setting up listeners for page lifecycle events (like `beforeunload`) to trigger application disposal.
                *   - Potentially triggering initial data loads (like history) or UI updates (like button states) that don't depend on user interaction yet.
                * - Application Disposal on Unload: Sets up an event listener on `window.beforeunload` (or equivalent) to call the main application instance's `dispose()` method when the page is about to close or navigate away. This helps ensure resources like IndexedDB connections and event listeners are cleaned up to prevent potential memory leaks or unexpected behavior, especially in complex applications. The `dispose()` method call cascades down through the component hierarchy and services.
                *
                * The bootstrap code is responsible for getting the entire system up and running, handling fundamental setup errors, and initiating initial processes.
                */


               // Ensure the application code runs after the DOM is fully loaded.
               // Wrap the entire application script in an Immediately Invoked Function Expression (IIFE)
               // to create a private scope, preventing variable/function conflicts in the global namespace.
               (function() {
                   "use strict"; // Enforce strict mode for cleaner code and better error detection.

                   // --- START: Google API Key & Secrets Management Disclaimer ---
                   // IMPORTANT SECURITY NOTE:
                   // In a real production application, sensitive API keys, client IDs,
                   // authentication secrets, and merchant secrets should *NEVER* be embedded directly in client-side
                   // JavaScript or HTML. This exposes them to anyone who views your page source, allowing theft and abuse.
                   //
                   // For services requiring API keys (like some parts of Google Cloud APIs, Expedia Partner API) or Client IDs
                   // with broad permissions, these are often used by a SECURE BACKEND SERVICE (an API proxy, a serverless function,
                   // or your main application server).
                   // The backend accesses sensitive credentials securely (e.g., from Environment Variables configured during deployment,
                   // Vaults, or secure Configuration Managers like AWS Secrets Manager, Google Secret Manager).
                   //
                   // GITHUB SECRETS:
                   // GitHub Secrets are encrypted environment variables that you set up in your GitHub repository settings.
                   // They are specifically designed to be used during YOUR CI/CD workflows (like GitHub Actions)
                   // to provide sensitive information to your build scripts or server-side code during deployment.
                   // CLIENT-SIDE JAVASCRIPT CODE RUNNING IN A USER'S BROWSER CANNOT AND SHOULD NOT DIRECTLY ACCESS GITHUB SECRETS.
                   //
                   // In this DEMO code, placeholder values like `YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER`
                   // are included directly in the HTML `<script>` tag or within the `AppConfig` object.
                   // This is solely for the purpose of illustrating *where* such keys/IDs would be referenced
                   // structurally if they *were* used client-side (an insecure practice for anything sensitive).
                   //
                   // For the requested structure demonstrating complex integrations, we are **SIMULATING**
                   // the interactions with these APIs. The simulated services will still reference placeholders
                   // in the configuration (`AppConfig`) to mimic realistic setup, but they will **NOT**
                   // connect to real external services or use real credentials.
                   //
                   // A REAL, SECURE APPLICATION ARCHITECTURE WOULD LOOK DIFFERENT CLIENT-SIDE FOR SENSITIVE OPERATIONS:
                   // 1. Google Places Autocomplete: The API Key in the JS library URL is relatively less sensitive if restricted properly (e.g., by domain/referrer). However, Place Details lookups can incur costs.
                   // 2. Google Identity Services (GIS - Sign-In/OAuth): The client uses the Google OAuth Client ID (less sensitive) to display Sign-In UI and get user consent. GIS provides an ID Token. Client SENDS this ID Token to YOUR secure backend.
                   // 3. Backend Authentication: YOUR backend VERIFIES the ID Token securely using Google's auth libraries (crucial step). This authenticates the user.
                   // 4. Other Google APIs (Calendar, Gmail, Drive/Apps Script): YOUR backend uses the verified user's identity (from the ID Token) and securely stored credentials (YOUR backend's API keys/service account, plus potentially tokens exchanged after user OAuth consent for specific scopes) to call Google's REST APIs SECURELY FROM THE SERVER SIDE. Data is passed between your client and your backend.
                   // 5. Google Pay: Client uses the Google Pay JS library to display payment UI and get a *tokenized payment payload*. This token is encrypted and useless client-side. Client SENDS this TOKEN to YOUR secure backend. YOUR backend uses YOUR Payment Gateway's securely stored API keys/credentials to process the charge using the token.
                   // 6. Expedia Partner API (for real prices/search results): YOUR client sends search parameters to YOUR backend. YOUR backend uses YOUR securely stored Expedia Partner API credentials to call Expedia's API, gets real hotel data/prices, processes it, and sends the results back to the client.
                   // 7. GenAI API: Client sends the user's prompt (e.g., destination for a tip) to YOUR backend. YOUR backend uses YOUR securely stored GenAI API credentials to call the GenAI model, gets the generated content, potentially moderates it, and sends the result back to the client.
                   // 8. Google Apps Script (Secure Access): If an Apps Script needs to perform actions as a specific user or requires sensitive data, YOUR backend should act as a gateway, handling authentication (e.g., using a service account or OAuth flow involving your backend) and calling the Apps Script execution API or accessing resources securely.

                   // THIS DEMO CODE PRIORITIZES DEMONSTRATING THE CLIENT-SIDE JAVASCRIPT STRUCTURE,
                   // ASYNCHRONOUS PATTERNS (`async`/`await`, `Promises`), OOP PRINCIPLES, DOM INTERACTION,
                   // ERROR HANDLING (`try...catch`, `ErrorReporter`), and INTERFACING WITH *SERVICE ABSTRACTIONS*.
                   // THE SERVICES THEMSELVES ARE *SIMULATED* TO MIMIC THE BEHAVIOR OF INTERACTING WITH EXTERNAL APIS ASYNCHRONOUSLY.
                   // THE SECURITY-CRITICAL BACKEND LAYER IS ACKNOWLEDGED BUT NOT IMPLEMENTED HERE IN THIS CLIENT-SIDE-ONLY FILE.
                   // THE PLACECARDERS IN `AppConfig` ILLUSTRARE WHERE CONFIG WOULD GO, BUT SHOULD NEVER BE FILLED WITH REAL SECRETS IN THIS CLIENT-SIDE FILE.
                   // ------------------------------------------------------------------------------------------------------


                   // --- Configuration Object ---
                   // Centralized configuration object holding various constants, messages, selectors, and service details.
                   // Uses placeholder values for configuration endpoints and IDs to illustrate where they would be used,
                   // strongly disclaiming that real secrets should NEVER be hardcoded client-side.
                   const AppConfig = {
                       APP_NAME: 'LuxStayFinderDemoApp', // Descriptive name for the application module/section.
                       APP_VERSION: '5.2.0', // Current version number of the application logic.

                       // Expedia Affiliate Configuration details.
                       // Used for building the affiliate redirect URL.
                       EXPEDIA_AFFILIATE_ID: 'YOUR_EXPEDIA_AFFILIATE_ID_PLACEHOLDER', // Affiliate ID for tracking referrals.
                       EXPEDIA_BASE_SEARCH_URL: 'https://www.expedia.com/Hotel-Search', // Base URL for Expedia's hotel search results page.
                       // This URL is what we will redirect the user to after collecting search parameters.
                       // Example structure observed: https://www.expedia.com/Hotel-Search?destination=...&checkin=...&checkout=...&adults=...&rooms=...&mcid=...&...

                       // --- Secure Backend Endpoints (Placeholders) ---
                       // In a real application, these URLs would point to YOUR secure backend server endpoints.
                       // Client-side JavaScript would call these endpoints using `fetch` or AJAX,
                       // and YOUR backend would handle the secure interaction with external APIs using credentials (potentially from GitHub Secrets).
                       BACKEND_ENDPOINTS: {
                            // Endpoint for fetching real Expedia hotel prices and results. YOUR backend would call Expedia's API.
                           EXPEDIA_SEARCH_API_GATEWAY: '/api/expedia/search-hotels', // Example backend route for Expedia API calls.
                            // Endpoint for securely interacting with Google Apps Script. YOUR backend would handle authentication and calling the Apps Script.
                           APPS_SCRIPT_GATEWAY: '/api/google/apps-script-execute', // Example backend route for Apps Script calls.
                           // Endpoint for securely interacting with a Generative AI model. YOUR backend would call the GenAI API (e.g., Vertex AI).
                           GENAI_TIP_API_GATEWAY: '/api/genai/destination-tip', // Example backend route for GenAI tips.
                            // Endpoint for a backend gateway to securely interact with other Google APIs (Calendar, Gmail) on behalf of the user.
                           // Client sends auth tokens/consent info to this backend, backend uses YOUR server credentials + user consent to call Google APIs.
                           GOOGLE_API_USER_GATEWAY: '/api/google/user-api', // Example backend route for Calendar/Gmail etc. user-specific operations.
                       },


                       // API & Service Placeholders (Configuration values used by Client-Side logic/Simulations)
                       // IMPORTANT: These values are for CLIENT-SIDE use. Some (like Places API key) are relatively safe if restricted by domain/referrer.
                       // Others (like OAuth Client ID structure, simulated Merchant IDs/Gateways) are part of the simulation structure and represent
                       // real configuration that would be needed, BUT REAL SECRETS ARE HANDLED BACKEND-SIDE.
                       GOOGLE_PLACES_API_KEY: 'YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER', // Google Places Autocomplete API Key. This is typically in the script tag URL. Using it in config as well allows checking the placeholder state.
                       GOOGLE_ANALYTICS_ID: 'G-XXXXXXXXXX_PLACEHOLDER', // Google Analytics 4 Measurement ID. Also in the gtag.js script tag.
                       GOOGLE_OAUTH_CLIENT_ID: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER', // Google OAuth 2.0 Client ID for web application type. Used by real GIS for client-side auth flows.
                       // Google Pay Configuration details (Structure based on Google Pay API). Used by `GooglePayServiceWrapper` simulation.
                       GOOGLE_PAY: {
                           API_VERSION: 2, // Google Pay API version.
                           API_VERSION_MINOR: 0, // Google Pay API minor version.
                           // Allowed payment methods and their parameters/tokenization specifications.
                           ALLOWED_PAYMENT_METHODS: [{
                               type: 'CARD', // Specify card payment method.
                               parameters: {
                                   // Allowed card authentication methods (PAN_ONLY for basic card details, CRYPTOGRAM_3DS for 3DS).
                                   allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],
                                   // Allowed card networks (Visa, Mastercard, Amex, Discover, etc.). Specify those supported by your payment gateway.
                                   allowedCardNetworks: ['AMEX', 'DISCOVER', 'JCB', 'MASTERCARD', 'VISA'],
                                   // Request user's billing address if required by your business/payment gateway.
                                   billingAddressRequired: true,
                                   billingAddressParameters: {
                                       format: 'FULL' // Request full billing address details.
                                   },
                                   // Optional: gateway capabilities, etc.
                               },
                               // Tokenization Specification: Defines how payment data is tokenized for your payment gateway.
                               // Type 'PAYMENT_GATEWAY' is common, uses a specific gateway format.
                               tokenizationSpecification: {
                                   type: 'PAYMENT_GATEWAY',
                                   parameters: {
                                       // Your payment gateway's identifier (e.g., 'stripe', 'adyen', 'authorize_net').
                                       gateway: 'example_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY.
                                       // Your merchant ID within that specific payment gateway.
                                       gatewayMerchantId: 'exampleGatewayMerchantId_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY MERCHANT ID.
                                       // Add other parameters required by your gateway's tokenization spec.
                                   }
                                   // Type 'DIRECT' is for processing payment data directly on your server without a gateway integration specific to Google Pay's format. Requires strong crypto handling server-side.
                                   // tokenizationSpecification: { type: 'DIRECT', parameters: { publicKey: 'YOUR_SERVER_SIDE_PUBLIC_KEY' }} // Requires secure handling.
                               }
                           }],
                           // Merchant Information: Identifies your business. Required for production.
                           MERCHANT_INFO: {
                               // Merchant ID provided by Google Pay. REQUIRED FOR PRODUCTION. Use a test ID in TEST environment.
                               // merchantId: 'BCR2DN6SA234GS23_PLACEHOLDER', // REPLACE WITH YOUR ACTUAL GOOGLE PAY MERCHANT ID.
                               // The public name of your business, shown to the user in the Google Pay UI.
                               merchantName: 'LuxStay Finder Demo (Simulated)',
                               // merchantOrigin: window.location.origin
                                                              // Add any other headers required by your specific backend endpoint or APIs (e.g., API keys, authorization tokens handled client-side - WARNING: use backend for security).
                               // headers['X-Your-Auth-Token'] = 'YOUR_CLIENT_SIDE_TOKEN_PLACEHOLDER'; // Example client-side token. This is less secure if used for sensitive backend operations.
                               // Use Authorization header with Bearer token if using client-side tokens.
                               // if (clientAuthToken) headers['Authorization'] = `Bearer ${clientAuthToken}`;
                           },
                            // Include the data payload to send in the request body for POST method.
                            body: JSON.stringify(dataToSend), // Convert the data payload object to a JSON string.

                            // Additional options for the fetch request (optional).
                           cache: 'no-cache', // Prevent caching of the response.
                           mode: 'cors', // Use CORS mode for cross-origin requests if backend is on a different origin.
                           redirect: 'follow', // Follow redirects.
                           referrerPolicy: 'no-referrer-when-downgrade', // Control referrer header.
                            // signal: abortSignal // Use an AbortController signal for request cancellation (advanced).

                        });

                        // --- Process the Fetch Response ---
                        Logger.debug(`${simulatedServiceClass.name}: Fetch request sent to backend endpoint "${backendEndpointUrl}". Waiting for response...`);

                        // Check if the HTTP response status is successful (typically 2xx range).
                        if (!response.ok) {
                             // If the backend responded with an HTTP error status code (e.g., 400, 401, 404, 500).
                             // Read the response body as text to get potential error details from the backend.
                            const errorBodyText = await response.text(); // Get the error body content.
                             // Create a descriptive error message based on the HTTP status and response text. Truncate long error messages.
                            const httpErrorDetails = `${response.status} - ${response.statusText || 'Unknown Status'} - ${errorBodyText.substring(0, 200)}`; // Include truncated body.
                            const httpError = new Error(`Backend HTTP error: ${httpErrorDetails}`); // Create a new Error object for reporting.
                             Logger.error(`${simulatedServiceClass.name}: Fetch request failed with HTTP status ${response.status}.`, { error: httpError, responseText: errorBodyText, backendEndpoint: backendEndpointUrl, method: httpMethod });

                            // Throw the HTTP error to be caught by the caller's `catch (fetchError)` block.
                             throw httpError;
                         }


                         // --- Parse and Validate JSON Response ---
                         // Attempt to parse the JSON response data from the backend.
                         // Wrap in a try...catch as JSON parsing can fail for non-JSON responses.
                         let responseData;
                         try {
                            responseData = await response.json(); // Parse the JSON response body into a JavaScript object.
                             Logger.debug(`${simulatedServiceClass.name}: Backend response received and parsed as JSON:`, responseData);
                         } catch (jsonParseError) {
                             // If JSON parsing fails (e.g., backend returned plain text, HTML, or malformed JSON).
                            const invalidJsonError = new Error(`Failed to parse JSON response from backend.`); // Create a specific error object.
                             Logger.error(`${simulatedServiceClass.name}: Invalid JSON response received from backend endpoint "${backendEndpointUrl}".`, { error: invalidJsonError, responseStatus: response.status, responseText: await response.text() /* Re-read body */ });
                             throw invalidJsonError; // Throw error indicating invalid response format.
                         }

                         // --- Validate Response Data Structure ---
                         // Validate the structure and content of the response data received from your backend gateway.
                         // This structure depends entirely on what YOUR backend is designed to return.
                         // Add validation logic based on the expected structure for this specific simulated service's response.

                         let validationFailed = false;
                         if (simulatedServiceType === 'AppsScript') {
                              // Example validation for Apps Script response: expect an object with a 'result' property.
                              if (typeof responseData !== 'object' || responseData === null || typeof responseData.result === 'undefined') {
                                   validationFailed = true;
                                   Logger.error(`${simulatedServiceClass.name}: Invalid response structure for Apps Script: Expected object with 'result'.`, { responseData: responseData });
                              }
                              // More specific checks might be needed depending on expected 'success' or 'error' results.
                         } else if (simulatedServiceType === 'GenAI') {
                              // Example validation for GenAI tip response: expect a non-empty string for the tip.
                               // Assuming backend returns just the tip string or {tip: "..."}.
                               if (typeof responseData !== 'string' && (typeof responseData !== 'object' || responseData === null || typeof responseData.tip !== 'string')) {
                                    validationFailed = true;
                                   Logger.error(`${simulatedServiceClass.name}: Invalid response structure for GenAI tip: Expected string or object with string 'tip'.`, { responseData: responseData });
                               }
                         } else if (simulatedServiceType === 'GooglePayProcess') {
                              // Example validation for Google Pay process response: Expect a status and potentially booking details.
                               // This depends heavily on your backend -> Payment Gateway -> Backend response structure.
                               // Assuming it returns { status: 'success', bookingDetails: {...} } or { status: 'failed', message: '...' }.
                               if (typeof responseData !== 'object' || responseData === null || typeof responseData.status !== 'string') {
                                   validationFailed = true;
                                  Logger.error(`${simulatedServiceClass.name}: Invalid response structure for Google Pay Process: Expected object with 'status'.`, { responseData: responseData });
                               }
                         } else if (simulatedServiceType === 'ExpediaSearch') {
                              // Example validation for Expedia Search response: Expect a list of hotels/results.
                               // Assuming { results: [{...}, ...], priceRange: '...' }.
                               if (typeof responseData !== 'object' || responseData === null || !Array.isArray(responseData.results)) {
                                   validationFailed = true;
                                  Logger.error(`${simulatedServiceClass.name}: Invalid response structure for Expedia Search: Expected object with array 'results'.`, { responseData: responseData });
                               }
                         }
                         // Add more specific validation for other simulated types...

                          if (validationFailed) {
                               const invalidStructureError = new Error(`Invalid data structure received from backend for ${simulatedServiceType}.`); // Specific error.
                               throw invalidStructureError; // Throw error to be caught by caller's catch.
                          }


                        // --- Return Processed Data ---
                        // If response was successful, JSON parsed, and structure validated, return the relevant data.
                         // The format returned depends on the simulated service type, matching what the calling method expects.
                         if (simulatedServiceType === 'AppsScript') return responseData; // Return the response object as is.
                         if (simulatedServiceType === 'GenAI') return typeof responseData === 'string' ? responseData : responseData.tip; // Return the tip string.
                         if (simulatedServiceType === 'GooglePayProcess') return responseData; // Return the process result object.
                         if (simulatedServiceType === 'ExpediaSearch') return responseData; // Return the search results object.

                         // Default return if type not recognized (should not happen if used correctly).
                         Logger.error(`${simulatedServiceClass.name}: Unrecognized simulated service type for processing response.`);
                         return responseData; // Return the raw response data as fallback.

                    } catch (processError) {
                         // --- Handle Errors During Fetch or Response Processing ---
                         // Catch any errors that occur *during* the fetch request itself (e.g., network error, CORS, HTTP error response caught by !response.ok)
                         // or during JSON parsing (`jsonParseError`) or response data validation (`validationFailed` check throws).
                         Logger.error(`${simulatedServiceClass.name}: Error caught during fetch or response processing:`, processError);

                         // Throw the error to be caught by the caller's `catch` block (`searchHotels` handler or button click handlers).
                         throw processError; // Propagate the error.
                    }
                } // End of _fetchBackendEndpointSimulated method definition.

                /**
                 * Asynchronous method to perform a simulated Expedia Hotel Search via a backend gateway. Marked async.
                 * This simulates the primary search functionality where collected search parameters are sent to a backend,
                 * which then calls the Expedia API to get search results (hotels, prices, etc.).
                 * Displays UI loading states and updates the UI with results or errors.
                 * @param {object} searchParams - The collected search parameters object. Required.
                 * @returns {Promise<object|null>} A Promise resolving with the simulated search results object (`{ results: [...], ... }`) on success, or `null` on failure.
                 * @private
                 */
                async _performSimulatedExpediaApiSearch(searchParams) {
                     try {
                          Logger.debug(`${this.name}._performSimulatedExpediaApiSearch: Starting simulated Expedia Search API call process...`);

                         // Ensure the backend endpoint URL for Expedia search is configured and not still a placeholder.
                         const backendEndpointUrl = AppConfig.BACKEND_ENDPOINTS.EXPEDIA_SEARCH_API_GATEWAY;
                         if (!backendEndpointUrl || typeof backendEndpointUrl !== 'string' || backendEndpointUrl.includes('_PLACEHOLDER')) {
                              const configErrorMsg = `Backend Expedia Search API URL is missing or placeholder in AppConfig. Cannot simulate search properly.`;
                              Logger.error(`${this.name}._performSimulatedExpediaApiSearch: ${configErrorMsg}`);
                             this.#errorReporter.reportError(
                                 `${this.name}._performSimulatedExpediaApiSearch`, new Error(configErrorMsg),
                                 { formId: this.id, step: 'config_check' }, configErrorMsg, 'expedia_search_api_config_missing_critical', 0
                              );
                             throw new Error(configErrorMsg); // Throw error indicating configuration issue.
                         }

                         // Ensure required search parameters are available for the API call payload.
                         // The `searchHotels` method already does validation and collection, so this is defensive.
                         if (!searchParams || typeof searchParams !== 'object' || !searchParams.destinationInput || !searchParams.checkInDateInput || !searchParams.checkOutDateInput || !searchParams.adultsCountInput) {
                             const paramErrorMsg = 'Missing required parameters for simulated Expedia Search API call.';
                             Logger.warn(`${this.name}._performSimulatedExpediaApiSearch: ${paramErrorMsg}`, { searchParams: searchParams });
                             this.#errorReporter.reportError(
                                 `${this.name}._performSimulatedExpediaApiSearch`, new Error(paramErrorMsg),
                                 { formId: this.id, params: searchParams, step: 'param_validation' },
                                 `Failed to simulate Expedia Search: ${paramErrorMsg}`, 'expedia_search_missing_params'
                             );
                             throw new Error(paramErrorMsg); // Throw error indicating bad input data.
                         }


                         // --- Show Loading State for Results ---
                         // Assuming a dedicated loading state display for results if not just redirecting.
                         // Example: Clear previous results, show spinner in results area.
                          // this._clearSearchResults(); // Clear previous results display.
                          // if (this.#resultsAreaElement) this.#resultsAreaElement.innerHTML = AppConfig.MESSAGES.PROCESSING('Expedia Search') + ` <i class="fa fa-spinner w3-spin"></i>`; // Show loading.


                         // --- Call Simulated Backend Endpoint ---
                         Logger.debug(`${this.name}._performSimulatedExpediaApiSearch: Calling simulated backend endpoint "${backendEndpointUrl}" for Expedia Search...`, { searchParams: searchParams });

                         try {
                             // Use the helper method to simulate fetching from the backend endpoint.
                             // Pass the endpoint URL, HTTP method, service type, data payload, and the ErrorReporter.
                             const simulatedResponse = await this._fetchBackendEndpointSimulated(
                                 backendEndpointUrl, // The target endpoint URL.
                                 'POST', // Use POST as common for API requests with body payload.
                                 'ExpediaSearch', // Type identifier for response processing.
                                 searchParams, // The data payload to send (collected search parameters).
                                 this.#errorReporter // The ErrorReporter.
                             );
                             Logger.debug(`${this.name}._performSimulatedExpediaApiSearch: Simulated backend response received:`, simulatedResponse);

                             // --- Process Simulated Response ---
                             // The `_fetchBackendEndpointSimulated` handles HTTP errors and JSON parsing errors and throws them.
                             // If execution reaches here, the response was successful, JSON parsed, and basic structure validated.
                             // Validate the response data structure further to ensure it contains expected search results.
                              if (!simulatedResponse || !Array.isArray(simulatedResponse.results) || typeof simulatedResponse.totalResults === 'undefined') {
                                   const invalidStructureError = new Error(`Simulated Expedia Search response has invalid structure.`);
                                   Logger.error(`${this.name}._performSimulatedExpediaApiSearch: ${invalidStructureError.message}`, { response: simulatedResponse });
                                   throw invalidStructureError; // Throw specific error for bad structure.
                              }

                             Logger.info(`${this.name}._performSimulatedExpediaApiSearch: Simulated Expedia Search successful. Found ${simulatedResponse.totalResults} results.`);
                             // Example: Log the first few simulated results.
                             Logger.debug("Simulated First 3 Results:", simulatedResponse.results.slice(0, 3));

                             // In a real scenario, this `simulatedResponse` would be the data needed to render hotel listings, prices, etc., on the page.
                             // Return the simulated results data.
                             return simulatedResponse;

                         } catch (fetchOrProcessError) {
                              // Catch any errors thrown by `_fetchBackendEndpointSimulated` (network, HTTP error, JSON parse, response validation).
                              Logger.error(`${this.name}._performSimulatedExpediaApiSearch: Error caught during fetch or processing:`, fetchOrProcessError);
                              // Re-throw the error to be caught by the caller's (`searchHotels`) catch block.
                              throw fetchOrProcessError; // Propagate the error.
                         }


                     } catch (searchSetupError) {
                         // Catch any unexpected errors *before* starting the fetch process (e.g., config check fails, input validation failure).
                         this.#errorReporter.reportError(
                             `${this.name}._performSimulatedExpediaApiSearch`,
                             searchSetupError, // The error object caught.
                             { formId: this.id, paramsInput: searchParams, step: 'setup_before_fetch' }, // Context.
                             `Simulated Expedia Search setup failed.`, // User message.
                             'expedia_search_setup_exception' // GA error code.
                         );
                         // Return null to indicate that the search process failed before fetching results.
                         return null;
                     }
                } // End of _performSimulatedSimulatedExpediaApiSearch method definition.


                /**
                 * Protected method to clear any previously displayed simulated search results from the UI.
                 * This is a helper for scenarios where results are displayed on the page (unlike the redirect demo).
                 * @private
                 */
                 _clearSearchResults() {
                     try {
                          // Ensure the results area element exists.
                          if (this.#resultsAreaElement) {
                              Logger.debug(`${this.name}._clearSearchResults: Clearing simulated search results display.`);
                              this.#resultsAreaElement.innerHTML = ''; // Clear the HTML content.
                               // Re-add default message if needed
                               // this.#resultsAreaElement.innerHTML = '<p>Search results would appear here if using a direct API.</p><p>Actions enabled below after a successful search.</p>';
                          } else {
                               Logger.debug(`${this.name}._clearSearchResults: Results area element missing, cannot clear display.`);
                          }
                           // Clear the specific simulated price element content too if it's separate.
                           if (this.#expediaSimulatedPriceElement) {
                                this.#expediaSimulatedPriceElement.textContent = 'Simulated Expedia Price: N/A';
                           }

                     } catch (error) {
                          this.#errorReporter.reportError(
                              `${this.name}._clearSearchResults`, error,
                              { formId: this.id, step: 'clear_results_execution' },
                              `Error clearing simulated search results display.`, 'ui_clear_results_exception'
                          );
                     }
                 } // End of _clearSearchResults method definition.


                /**
                 * Protected method to display simulated search results in the UI.
                 * This is a placeholder for scenarios where results are displayed on the page (unlike the redirect demo).
                 * In a real app, this would parse the search results data and dynamically create HTML elements to show hotels, prices, details.
                 * @param {object} resultsData - The simulated search results data object (e.g., from `_performSimulatedExpediaApiSearch`). Expected to contain `results` array and `totalResults`. Required.
                 * @private
                 */
                 _displaySearchResults(resultsData) {
                     try {
                          Logger.debug(`${this.name}._displaySearchResults: Displaying simulated search results...`, { resultsData: resultsData });

                          // Ensure the results area element exists.
                         if (!this.#resultsAreaElement) {
                              Logger.warn(`${this.name}._displaySearchResults: Results area element missing, cannot display results.`);
                              // ErrorReporter already logged this UI missing error in constructor.
                             return; // Exit if element is missing.
                         }

                         // Check if results data is valid and contains items.
                          if (!resultsData || typeof resultsData !== 'object' || !Array.isArray(resultsData.results)) {
                              Logger.warn(`${this.name}._displaySearchResults: Invalid or empty results data provided for display.`);
                              this.#resultsAreaElement.innerHTML = '<p>Simulated search completed, but no results or invalid data received.</p>';
                              // Clear simulated price if it was shown.
                              if (this.#expediaSimulatedPriceElement) this.#expediaSimulatedPriceElement.textContent = 'Simulated Expedia Price: N/A';
                              return;
                          }

                          // Clear previous results display.
                          this.#resultsAreaElement.innerHTML = '';
                          // Remove spinner if it was in the results area.
                          const spinner = this.#resultsAreaElement.querySelector('.w3-spin');
                           if(spinner) spinner.remove();


                          // Add a heading for the results.
                          const heading = document.createElement('h3');
                          heading.textContent = `Simulated Search Results (${resultsData.totalResults ?? resultsData.results.length} found):`;
                           heading.classList.add('w3-center', 'w3-text-teal'); // Add W3CSS classes.
                          this.#resultsAreaElement.appendChild(heading);


                          // Display the specific simulated price, if it was fetched and is in the results data.
                           // Assuming resultsData might contain simulatedPrice directly for display here.
                          if (this.#expediaSimulatedPriceElement && resultsData.simulatedPrice) {
                               this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_SUCCESS(resultsData.simulatedPrice.price.toFixed(2), resultsData.simulatedPrice.currency);
                               this.#resultsAreaElement.appendChild(this.#expediaSimulatedPriceElement); // Re-append if cleared.
                           } else if (this.#expediaSimulatedPriceElement) {
                                this.#expediaSimulatedPriceElement.textContent = 'Simulated Expedia Price: N/A (in results).';
                                this.#resultsAreaElement.appendChild(this.#expediaSimulatedPriceElement); // Re-append if cleared.
                           }


                          // --- Render List of Hotels (Simulated) ---
                          // Create a container (e.g., UL or DIV) for the list of hotels.
                          const hotelListContainer = document.createElement('div');
                           hotelListContainer.classList.add('w3-container', 'w3-margin-top', 'w3-row-padding'); // Add W3CSS classes.

                           const itemsToDisplay = resultsData.results.slice(0, AppConfig.INDEXEDDB.HISTORY_ITEM_LIMIT); // Display a limited number of simulated items.

                          // Iterate through the array of simulated hotel result items.
                          itemsToDisplay.forEach((hotelItem, index) => {
                              try {
                                   // Create a div or card for each hotel result.
                                   const hotelElement = document.createElement('div');
                                   hotelElement.classList.add('w3-col', 's12', 'm6', 'l4', 'w3-padding', 'w3-card', 'w3-round', 'w3-margin-bottom'); // W3CSS grid and card styling.

                                   // Construct HTML content for the hotel item (name, simulated price, basic details).
                                    // Use dummy data or properties from the simulated hotelItem object.
                                    const hotelName = hotelItem?.name || `Simulated Hotel ${index + 1}`;
                                    const hotelPrice = hotelItem?.price?.toFixed(2) || 'N/A';
                                    const hotelCurrency = hotelItem?.currency || 'USD';
                                    const hotelRating = hotelItem?.rating?.toFixed(1) || 'N/A';
                                    const hotelLocation = hotelItem?.location?.address || 'Simulated Location';
                                    const bookLink = hotelItem?.bookingUrl || 'https://www.expedia.com/'; // Use simulated link if available, or generic.

                                    hotelElement.innerHTML = `
                                        <h4 class="w3-text-teal w3-margin-bottom-0">${hotelName}</h4>
                                        <p class="w3-text-grey w3-small">${hotelLocation}</p>
                                        <p><b>Price: ${hotelPrice} ${hotelCurrency}</b> per night</p>
                                        <p>${hotelRating !== 'N/A' ? `Rating: ${hotelRating}/5` : 'No rating available'}</p>
                                         ${bookLink !== 'https://www.expedia.com/' ? `<a href="${bookLink}" target="_blank" class="w3-button w3-small w3-teal w3-round">View Deal</a>` : `<p class="w3-small w3-text-orange">Booking link not available (Simulated)</p>`}
                                    `;
                                     hotelElement.style.textAlign = 'left'; // Align text left inside card.


                                   // Optional: Store the full hotel data on the element if needed for booking actions later (e.g., passing hotel ID to backend).
                                    if (hotelItem) {
                                        try {
                                            hotelElement.dataset.hotelData = JSON.stringify(hotelItem);
                                        } catch (stringifyError) {
                                             this.#errorReporter.reportError(
                                                 `${this.name}._displaySearchResults - stringify hotel item`, stringifyError,
                                                { formId: this.id, hotelId: hotelItem?.id || 'N/A', step: 'stringify_hotel_item_for_data_attribute' },
                                                `Error stringifying hotel item data for storage.`, 'ui_stringify_hotel_exception'
                                            );
                                        }
                                    }

                                   // Optional: Attach a click listener to the "View Deal" button or the whole hotel card
                                   // for triggering the actual affiliate link redirection for THAT specific hotel,
                                   // or triggering the Google Pay flow for THAT specific hotel price.
                                    // Let's make the "View Deal" link in the template handle the redirect for this demo.
                                    // If integrating Google Pay, you'd add a button here to trigger `_handleGooglePayClick` with *this hotel's specific price*.


                                  // Append the hotel element to the container.
                                  hotelListContainer.appendChild(hotelElement);

                              } catch (renderHotelError) {
                                   // Catch any errors occurring *while processing or creating markup for a single hotel item*.
                                    const currentHotelId = hotelItem?.id || 'N/A';
                                    const currentHotelName = hotelItem?.name?.substring(0, 20) || 'N/A';
                                    this.#errorReporter.reportError(
                                        `${this.name}._displaySearchResults - render loop`,
                                        renderHotelError, // The error object caught.
                                        { formId: this.id, hotelId: currentHotelId, hotelName: currentHotelName, step: 'render_single_hotel_item' }, // Context details.
                                        `Error displaying hotel result "${currentHotelName}".`,
                                        'ui_render_hotel_item_exception' // GA error code.
                                    );
                                   // Continue the loop despite the error with one item. Add a placeholder if possible.
                                    const errorItem = document.createElement('div');
                                   errorItem.classList.add('w3-col', 's12', 'm6', 'l4', 'w3-padding');
                                   errorItem.innerHTML = `<p class="w3-text-red">Error displaying hotel result (ID: ${currentHotelId})</p>`;
                                   hotelListContainer.appendChild(errorItem);
                              }
                           }); // End of itemsToDisplay.forEach loop.

                           // Append the container holding all hotel elements to the results area.
                           this.#resultsAreaElement.appendChild(hotelListContainer);

                           Logger.debug(`${this.name}._displaySearchResults: Simulated search results rendered in UI.`);


                     } catch (overallDisplayError) {
                          // Catch any unexpected critical errors during the overall results display process (e.g., issues clearing area, appending).
                         this.#errorReporter.reportError(
                              `${this.name}._displaySearchResults`, overallDisplayError,
                              { formId: this.id, step: 'overall_display_process_exception' },
                              `Critical error displaying search results for form "${this.name}". Results may not be visible.`,
                              'ui_display_results_critical_exception' // GA error code.
                          );
                          // Ensure the results area shows an error message instead of nothing or partial results.
                          if (this.#resultsAreaElement) {
                              this.#resultsAreaElement.innerHTML = `<p class="w3-text-red">An error occurred displaying results.</p>`;
                          }
                           // Ensure price display is cleared.
                           if (this.#expediaSimulatedPriceElement) this.#expediaSimulatedPriceElement.textContent = 'Simulated Expedia Price: Error.';

                     } finally {
                          // No specific cleanup needed here beyond updates in try/catch.
                          Logger.debug(`${this.name}._displaySearchResults finished.`);
                     }
                 } // End of _displaySearchResults method definition.


                 /**
                  * Asynchronous method to fetch a simulated AI-generated destination tip using the simulated GenAI service. Marked async.
                  * This simulates calling a backend endpoint which in turn would interact with a real GenAI API (like Google's Vertex AI).
                  * It triggers the asynchronous tip fetch and updates the dedicated AI tip UI element (`#aiTipContent`) with the result (the tip text) or an error message.
                  * It also ensures the AI Tips section (`#aiTipsSection`) is visible during and after the fetch if a destination is available.
                  * This operation is often treated as secondary to the main search result and can run concurrently or fire-and-forget depending on design.
                  * @param {string} destination - The destination string (e.g., city name) for which to fetch the AI-generated tip. Required.
                  * @returns {Promise<void>} A Promise that resolves when the fetch and display process completes (success or failure). The result of the underlying GenAI call isn't directly returned, it updates the UI.
                  * @private
                  */
                 async _fetchAndDisplaySimulatedAITip(destination) {
                     try {
                          Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: Starting simulated AI tip fetch and display process for destination: "${destination}"...`);

                          // --- Validate Input Parameter for AI Tip ---
                          // Ensure the destination string is provided and is not empty after trimming.
                          // The GenAI service simulation expects this input.
                          if (!destination || typeof destination !== 'string' || destination.trim() === '') {
                              const warningMsg = `Missing or invalid destination provided for AI tip fetch. Cannot fetch tip.`;
                             Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: ${warningMsg}`, { destinationInput: destination });
                              // Update the AI tip content element to show a message indicating the input is missing.
                             if (this.#aiTipContentElement) {
                                 this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED(warningMsg); // Show as failure message in tip area.
                                  // Remove spinner if it was added previously.
                                 const spinner = this.#aiTipContentElement.querySelector('.fa-spinner');
                                  if(spinner) spinner.remove();
                              } else {
                                  Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when handling missing destination input.`);
                              }
                              // We can choose to hide the AI section if there's no valid input, or keep it visible showing a failure message. Let's keep it visible showing the message.
                              if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) { // Show if it exists but is hidden.
                                  this.#aiTipsSection.classList.remove('app-hide');
                              }
                             // No ErrorReporter needed for this simple input validation handled gracefully in UI.
                             return; // Exit the async method.
                          }


                         // --- Check GenAI Service Configuration and Availability ---
                         // Ensure the simulated GenAI service instance exists and is configured (has a non-placeholder endpoint URL).
                         // Its `isConfigured()` method checks this condition based on AppConfig.
                         if (!this.#genAIService || !this.#genAIService.isConfigured()) {
                              const message = AppConfig.MESSAGES.NOT_READY('GenAI Tip Service Simulation', 'Endpoint configuration missing.');
                              Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: GenAI service not configured or missing. Message: "${message}".`);
                              // Ensure the AI Tips section is visible (in case it was hidden) and display the warning message in the tip area.
                               if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) {
                                    this.#aiTipsSection.classList.remove('app-hide'); // Show section.
                               } else if (!this.#aiTipsSection) {
                                   Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null when handling config missing.`);
                                }

                              if (this.#aiTipContentElement) {
                                 this.#aiTipContentElement.textContent = message; // Display warning message in the tip area.
                                  // Remove spinner if present.
                                 const spinner = this.#aiTipContentElement.querySelector('.fa-spinner');
                                  if(spinner) spinner.remove();
                              } else { Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when showing config warning.`);}
                              // The service constructor reports the persistent config error in the main message area via ErrorReporter.
                             return; // Exit async method if service is not configured.
                          }

                         // --- Show Loading State for AI Tip ---
                         // Ensure the AI Tips section container (`#aiTipsSection`) is visible while loading,
                         // as it will display the tip or status message within `#aiTipContentElement`.
                          if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) {
                               this.#aiTipsSection.classList.remove('app-hide'); // Show the section.
                              Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: Showing AI Tips section for loading.`);
                          } else if (!this.#aiTipsSection) {
                              Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null.`);
                           }

                          // Update the dedicated AI tip content element (`#aiTipContent`) to show a loading indicator.
                          if (this.#aiTipContentElement) {
                              // Clear any previous tip content or error messages visually.
                             this.#aiTipContentElement.textContent = '';
                             // Set the loading text and add a spinner icon to the element using innerHTML.
                              this.#aiTipContentElement.innerHTML = AppConfig.MESSAGES.GENAI_TIP_LOADING + ` <i class="fa fa-spinner w3-spin"></i>`; // Set loading text and spinner icon.
                             Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: UI updated to show loading state for tip.`);
                          } else {
                             // Log a warning if the tip content element is missing. The fetch process can continue, but results won't be displayed.
                             Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content display element (${AppConfig.SELECTORS.AI_TIP_CONTENT_DISPLAY}) is null. Tip won't be displayed.`);
                             // ErrorReporter already logged UI missing error in constructor.
                          }


                         // --- Simulate Calling GenAI Service ---
                         // Call the asynchronous method (`getDestinationTip`) on the simulated GenAI service instance.
                         // This method simulates making an async call (fetch/$.ajax) to the configured backend endpoint,
                         // which in turn would securely interact with a real GenAI model API using backend credentials.
                         // Use `await` to pause execution of this handler until the Promise returned by the simulated service call resolves (simulated success with a tip string) or rejects (simulated failure with an error).
                         Logger.debug(`_fetchAndDisplaySimulatedAITip: Calling simulated GenAI service to get tip for "${destination}"...`);
                          let simulatedTipString = null; // Variable to hold the successfully fetched tip string from the simulated service.

                          try {
                              // Call the async method `getDestinationTip` on the `this.#genAIService` instance, passing the destination string.
                              // This method returns a Promise which resolves with a tip string on simulated success or rejects with an error on simulated failure.
                             simulatedTipString = await this.#genAIService.getDestinationTip(destination); // Await the simulated service call.
                              // Log the result of the simulated API call (the string or null result).
                             Logger.debug(`_fetchAndDisplaySimulatedAITip: Simulated GenAI tip fetch finished. Result: "${simulatedTipString}".`);

                              // If the Promise resolved successfully, `simulatedTipString` will contain the tip string (or potentially null/empty string if the simulated service returned no tip).
                              // If the Promise rejected, the error is caught in the `catch (apiError)` block below, and `simulatedTipString` remains its initial state (null).

                          } catch (apiError) {
                              // --- Handle Simulated GenAI Failure (Promise Rejection) ---
                              // Catch any errors thrown (Promise rejections) by the simulated GenAI service's `getDestinationTip` method.
                              // This could simulate network issues, backend errors, GenAI API errors, etc.
                              Logger.error(`_fetchAndDisplaySimulatedAITip: Error caught from simulated GenAI service call for "${destination}":`, apiError);

                              // Report the error using the injected ErrorReporter. This handles logging, potentially a main UI message, and GA tracking.
                              this.#errorReporter.reportError(
                                  `${this.name}._fetchAndDisplaySimulatedAITip - apiCall`, // Source indicating the simulated API call stage.
                                  apiError, // The error object caught from the service rejection.
                                  { component: this.#getComponentInfo(), step: 'simulated_api_call_execution', destination: destination }, // Context details.
                                  AppConfig.MESSAGES.GENAI_TIP_FAILED(apiError.message || 'Unknown error.'), // User-friendly message template, using the error's message for detail.
                                  'genai_tip_api_exception' // GA error code for errors during API interaction.
                              );
                              // The `simulatedTipString` variable remains null in this catch block, so the UI will display the "failed" state below.
                          }


                         // --- Display the Result or Error in UI ---
                         // After the simulated service call (which either succeeded with a tip string or failed with an error),
                         // update the dedicated AI tip content element (`#aiTipContent`) with the result.
                         if (this.#aiTipContentElement) { // Check if the display element exists.
                             // Clear any previous content or loading spinner markup.
                             this.#aiTipContentElement.innerHTML = ''; // Clear existing HTML.

                             // Check if a valid, non-empty tip string was successfully obtained (`simulatedTipString` is not null or whitespace).
                             if (simulatedTipString && typeof simulatedTipString === 'string' && simulatedTipString.trim() !== '') {
                                  // If a valid tip string was obtained:
                                 Logger.info(`${this.name}._fetchAndDisplaySimulatedAITip: Displaying fetched tip for "${destination}".`);
                                  // Set the text content using `textContent` to safely display the plain text tip, preventing XSS issues if the AI model could output HTML.
                                 this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_SUCCESS(simulatedTipString.trim()); // Use the success template, passing the trimmed tip.

                                 // Optional: Add a class for success styling if needed.
                                 // this.#aiTipContentElement.classList.add('tip-success');

                              } else {
                                  // If no valid tip string was obtained (either because the simulated service resolved with null/empty string,
                                  // or because `apiError` occurred and `simulatedTipString` remained null):
                                  // Display a generic failure message in the AI tip content element.
                                 Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: No tip obtained (simulated failure or null result) for "${destination}". Displaying failure message.`);
                                 // The ErrorReporter or the catch block handled specific error logging. Display a general failure message in the tip area.
                                 this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED('No tip returned or API error occurred.'); // Use the standard failure message template.
                                  // Remove spinner if present (already handled by clearing innerHTML above).
                                  // Optional: Add a class for error styling if needed.
                                  // this.#aiTipContentElement.classList.add('tip-failed');
                              }

                         } else {
                             // If the AI tip content element reference is null (meaning it wasn't found during constructor), log a warning that we cannot display the tip.
                             Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null. Cannot display fetch result in UI.`);
                             // The ErrorReporter already logged a UI element missing error for this in the constructor.
                         }

                          // Log the completion of the AI tip fetch and display process.
                          Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip finished.`);

                     } catch (handlerError) {
                          // --- Handle Errors During Handler Execution ---
                          // Catch any unexpected synchronous errors occurring *during the execution of this async handler itself*
                          // (e.g., before calling the service, during setup steps within the handler that throw).
                          this.#errorReporter.reportError(
                              `${this.name}._fetchAndDisplaySimulatedAITip`,
                              handlerError, // The error object caught.
                              { component: this.#getComponentInfo(), step: 'handler_execution_overall', destinationInput: destination }, // Context details.
                              `Error fetching and displaying AI tip for form "${this.name}". Process interrupted.`, // User-friendly message template.
                              'genai_tip_fetch_handler_exception_overall' // GA error code for overall handler exception.
                          );
                          // Ensure the AI tip display element shows an error state in case of failure.
                          if (this.#aiTipContentElement) {
                               this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED('An internal error occurred.'); // Display a generic error message.
                              const spinner = this.#aiTipContentElement.querySelector('.fa-spinner'); // Remove spinner if it was added.
                               if(spinner) spinner.remove();
                           } else {
                                Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when handling overall handler error.`);
                           }
                           // Ensure the AI Tips section is visible to show the error, unless dependencies were missing entirely.
                            if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) {
                                this.#aiTipsSection.classList.remove('app-hide');
                            } else if (!this.#aiTipsSection) {
                                Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null when handling error.`);
                            }


                          // Do not re-throw from an async event handler. The error has been logged and reported.
                     } finally {
                          // This block always executes after the try/catch structure within the async handler.
                          // It can be used for any final cleanup, but in this case, UI updates are already handled in the try/catch blocks.
                          Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip async handler execution completed.`);
                     }
                 } // End of _fetchAndDisplaySimulatedAITip method definition.


                 /**
                  * Asynchronous method to load existing search history items from the browser's IndexedDB and display them in the dedicated UI list (`#searchHistoryList`). Marked async.
                  * Handles the entire process: ensuring UI elements and service are available, showing a loading state, calling the IndexedDB service's asynchronous method (`getSearchHistory`), processing the fetched items, rendering them as clickable list items in the UI, attaching click handlers to these items, and updating the history section status text (`#historyStatusElement`) and the "Clear History" button state.
                  * @returns {Promise<void>} A Promise that resolves when the history loading and display process completes (whether successfully with items, successfully with no items, or with a catchable error during the process). The Promise resolves without a specific value (`void`).
                  * @private
                  */
                 async _loadAndDisplaySearchHistory() {
                     try {
                          Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Starting search history load and display process from IndexedDB...`);

                         // --- Check Dependencies ---
                         // Ensure the necessary UI elements for displaying history (`#searchHistorySection`, `#searchHistoryList`) and the `IndexedDBService` instance are available.
                         // These references are obtained during the `SearchForm` constructor.
                         if (!this.#searchHistorySection || !this.#searchHistoryList || !this.#idbService) {
                             const message = AppConfig.MESSAGES.HISTORY_LOAD_FAILED('UI elements or service missing.'); // Specific failure message.
                             Logger.warn(`${this.name}._loadAndDisplaySearchHistory: ${message}`);
                             // ErrorReporter logs critical UI missing errors from constructor.
                             // Update history status element if it's available to show the failure message.
                             if (this.#historyStatusElement) this.#historyStatusElement.textContent = message; // Show message in status area.
                             // Ensure the history section is hidden or shows an error state if dependencies are critically missing.
                              if (this.#searchHistorySection && !this.#searchHistorySection.classList.contains('app-hide')) { // If it exists and is NOT hidden, hide it as it can't display correctly.
                                   this.#searchHistorySection.classList.add('app-hide');
                                   Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Hiding history section due to missing dependencies.`);
                               } else if (!this.#searchHistorySection) { // If the section element itself is missing.
                                   Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History section element is null.`);
                               }
                             // Do not re-throw. The async method finishes execution.
                             return; // Exit the async method as dependencies are not met.
                         }


                         // --- Show Loading State for History Section ---
                         // Ensure the search history section container is visible while loading history items, in case it was hidden initially or after certain actions.
                         if (this.#searchHistorySection.classList.contains('app-hide')) {
                              this.#searchHistorySection.classList.remove('app-hide'); // Show the section by removing the utility class.
                             Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Showing history section for loading process.`);
                         }
                         // Update the history status element (`#historyStatusElement`) to indicate that loading is in progress.
                         if (this.#historyStatusElement) {
                            this.#historyStatusElement.innerHTML = AppConfig.MESSAGES.PROCESSING('Loading history'); // Use processing message text + spinner icon markup.
                            Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show loading status.`);
                         } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status element missing for loading update.`);}

                         // Clear the current content of the history list (`#searchHistoryList`) visually before adding new items (including the temporary loading message).
                         this.#searchHistoryList.innerHTML = ''; // Clear any existing list items or previous messages.
                         // Add a temporary "Loading..." message as a list item while the asynchronous fetch is happening.
                         const loadingItem = document.createElement('li'); // Create a new list item element.
                         loadingItem.textContent = 'Loading...'; // Set text content.
                         loadingItem.classList.add('w3-text-grey'); // Add styling class (e.g., grey text).
                          // Make it non-clickable and centered visually like a status message.
                         loadingItem.style.cursor = 'default';
                         loadingItem.style.textAlign = 'center';
                         loadingItem.style.padding = '20px 16px';
                         this.#searchHistoryList.appendChild(loadingItem); // Append the temporary loading message item to the list.
                         Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show empty list with temporary loading message.`);


                        // --- Fetch History Items from IndexedDB ---
                         // Call the asynchronous method (`getSearchHistory`) on the `IndexedDBService` instance (`this.#idbService`) to retrieve the history items from the local database.
                         // Use `await` to pause execution of this `async` handler until the Promise returned by `getSearchHistory` resolves (successfully with items or an empty array) or rejects (with an error).
                        Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Calling IndexedDB service to fetch history items...`);
                         let fetchedHistoryItems = []; // Variable to hold the array of fetched history items.
                         const historyDisplayLimit = AppConfig.INDEXEDDB.HISTORY_ITEM_LIMIT; // Get the configured limit for the number of items to display.

                         try {
                             // Call the async method `getSearchHistory` on the `this.#idbService` instance, passing the desired display limit.
                             // This method returns a Promise<object[]>.
                             fetchedHistoryItems = await this.#idbService.getSearchHistory(historyDisplayLimit); // Await the promise.
                             // If execution reaches here, the promise resolved successfully. `fetchedHistoryItems` is an array (empty array if no items found).
                             Logger.debug(`${this.name}._loadAndDisplaySearchHistory: IndexedDB service getHistory completed. Received ${fetchedHistoryItems.length} item(s).`, { itemsReceivedArrayLength: fetchedHistoryItems.length, firstFewItems: fetchedHistoryItems.slice(0, 5) }); // Log array length and first few items.

                         } catch (idbError) {
                             // --- Handle IndexedDB Fetch Errors ---
                             // Catch any errors thrown (Promise rejections) by the IndexedDB service's `getSearchHistory` method (e.g., due to database access issues, permissions being denied, database corruption during read).
                             Logger.error(`${this.name}._loadAndDisplaySearchHistory: Error caught from IndexedDB service getHistory call:`, idbError);

                             // Report the error using the injected ErrorReporter. This handles logging, potentially a main UI message, and GA tracking.
                             this.#errorReporter.reportError(
                                 `${this.name}._loadAndDisplaySearchHistory - idbGet`, // Source indicating the specific operation stage.
                                 idbError, // The error object from the service rejection.
                                 { component: this.#getComponentInfo(), formId: this.id, step: 'indexeddb_get_history_execution' }, // Context details.
                                 AppConfig.MESSAGES.HISTORY_LOAD_FAILED(idbError.message || 'Unknown error.'), // User-friendly message template using error message.
                                 'history_load_exception_api' // GA error code for errors during IndexedDB API interaction.
                             );

                             // `fetchedHistoryItems` remains its initial state (empty array []) if the fetch failed in this catch block.
                             // The UI update logic below will handle displaying the error state in the list based on the empty array.
                             // Do not re-throw the error from this catch block. Handle it internally and proceed to update the UI.
                         }


                         // --- Render History List UI ---
                         Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Proceeding to render history list UI...`);

                         // Clear the current content of the history list (`#searchHistoryList`) again *before* rendering fetched items.
                         // This ensures that the "Loading..." message (or any previous errors/content) is removed before the results are added.
                         this.#searchHistoryList.innerHTML = ''; // Clear existing list items.


                         // Check if any history items were successfully fetched and are available in the `fetchedHistoryItems` array.
                         if (fetchedHistoryItems && fetchedHistoryItems.length > 0) {
                              // If items exist, iterate through the array of history objects fetched from the database.
                             fetchedHistoryItems.forEach(historyItemData => {
                                 try {
                                      // --- Create List Item Element for Each History Item ---
                                      // Create a new list item (`<li>`) HTML element for the current history item's data.
                                     const listItem = document.createElement('li');
                                     // Add W3CSS styling class for general list items if any (already in CSS).

                                     // --- Populate List Item Content ---
                                     // Set the HTML content of the list item using the properties from the `historyItemData` object.
                                     // Use `innerHTML` to allow embedding `<span>` tags for styling different parts of the text.
                                     // Use optional chaining (`?.`) and nullish coalescing (`??`) for safety in case object properties are missing in older data.
                                      listItem.innerHTML = `<strong>${historyItemData.destination?.trim() || 'N/A Destination'}</strong>` + // Destination text (bold).
                                                         ` <span class="date-range">${historyItemData.checkInDate || 'N/A Date'} - ${historyItemData.checkOutDate || 'N/A Date'}</span>` + // Date range text (grey).
                                                         ` <span class="travelers">(${historyItemData.adults ?? 'N/A'} adults, ${historyItemData.children ?? 'N/A'} kids)</span>`; // Travelers text (italic, grey).

                                     // --- Store Search Data on List Item ---
                                     // Store the *full* `historyItemData` object as a JSON string in a `data-*` attribute (`data-search-data`) on the `<li>` element.
                                     // This is essential for the click handler (`_handleHistoryItemClick`) to easily retrieve all the original search data associated with the clicked item
                                     // when the user clicks it, allowing the form to be repopulated.
                                      // Ensure the item data is a valid object before attempting to stringify it.
                                      if (historyItemData && typeof historyItemData === 'object') {
                                          try {
                                               listItem.dataset.searchData = JSON.stringify(historyItemData); // Stringify the object and store in data attribute.
                                              // Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Stored search data JSON on list item (ID: ${historyItemData.id || 'N/A'}).`, { dataLength: listItem.dataset.searchData.length }); // Verbose.
                                          } catch (stringifyError) {
                                               // Handle errors if an individual history item object is not serializable to JSON (e.g., circular references, unusual data types).
                                               this.#errorReporter.reportError(
                                                   `${this.name}._loadAndDisplaySearchHistory - stringify item`, stringifyError,
                                                  { formId: this.id, historyItemData: historyItemData, step: 'stringify_item_for_data_attribute' },
                                                  `Error stringifying history item data for storage on UI element. This item may not be clickable.`, // User message template for UI issue.
                                                   'history_stringify_item_exception' // GA error code.
                                              );
                                               // Log the problematic item in detail.
                                              Logger.error(`_loadAndDisplaySearchHistory: Failed to stringify history item data:`, historyItemData, { error: stringifyError });
                                               // Continue rendering other items despite this issue with one item's data storage. The item might still appear visually without the data.
                                          }
                                      } else {
                                           // Log warning if an item received from DB is not a valid object.
                                           Logger.warn(`${this.name}._loadAndDisplaySearchHistory: Received invalid item format from IndexedDB. Skipping data storage for item.`, { item: historyItemData });
                                            this.#errorReporter.reportError(
                                                `${this.name}._loadAndDisplaySearchHistory - invalid item format`, new Error("Invalid item format from DB."),
                                               { formId: this.id, itemReceived: historyItemData, step: 'invalid_item_format_from_db' },
                                               `Received invalid history item data format.`, 'history_invalid_item_format'
                                            );
                                      }


                                     // --- Attach Click Handler to List Item ---
                                     // Attach a click listener specifically to this created history list item element.
                                      // When the user clicks this list item, the `_handleHistoryItemClick` method will be executed.
                                      // Use the parent `_addEventListener` helper method. It handles binding the handler's `this` context to the component instance and stores the handler reference for disposal.
                                      // Pass the specific `listItem` element as the target element in the options object `{ element: listItem }`.
                                      this._addEventListener('click', this._handleHistoryItemClick, { element: listItem });
                                       // Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Attached click listener to history list item (ID: ${item.id || 'N/A'}).`); // Verbose.


                                     // --- Append List Item to UI ---
                                     // Append the successfully created and configured list item element to the history list UL element (`this.#searchHistoryList`).
                                     this.#searchHistoryList.appendChild(listItem); // Add the item to the visual list.


                                 } catch (renderItemError) {
                                      // --- Handle Errors Rendering a Single Item ---
                                      // Catch any unexpected errors that occur *while processing or creating the DOM element for a single history item* within the rendering loop.
                                      // This prevents one problematic item from stopping the entire list from rendering.
                                      const currentItemId = historyItemData?.id || 'N/A'; // Get ID defensively.
                                      const itemDestination = historyItemData?.destination?.substring(0, 20) || 'N/A Destination'; // Get destination snippet defensively.
                                      this.#errorReporter.reportError(
                                          `${this.name}._loadAndDisplaySearchHistory - render loop item`,
                                          renderItemError, // The error object caught.
                                          { formId: this.id, historyItemId: currentItemId, itemDestination: itemDestination, step: 'render_single_item_execution' }, // Context details.
                                          `Error displaying history item "${itemDestination}". List may be incomplete.`, // User message about UI issue.
                                          'history_render_item_exception' // GA error code.
                                      );
                                     // Log the problematic item in detail.
                                      Logger.error(`_loadAndDisplaySearchHistory: Failed to render history item:`, historyItemData, { error: renderItemError });
                                     // Optional: Add a placeholder item in the list indicating the error.
                                      const errorItem = document.createElement('li');
                                     errorItem.textContent = `Error displaying item (ID: ${currentItemId}).`;
                                     errorItem.classList.add('w3-text-red'); // Style as error text.
                                     errorItem.style.cursor = 'default'; // Make it non-clickable.
                                     errorItem.style.style.textAlign = 'center'; // Center text.
                                     errorItem.style.padding = '20px 16px'; // Add padding.
                                      this.#searchHistoryList.appendChild(errorItem); // Add the error message item to the list.

                                     // Continue to the next item in the loop despite an error with this one.
                                  }
                              }); // End of `fetchedHistoryItems.forEach` loop for rendering.

                              // --- Update Clear History Button State ---
                              // If there are history items successfully displayed, the "Clear History" button should be enabled.
                              // Check if the button element exists before attempting to disable it.
                             if (this.#clearHistoryButton) {
                                  // Use a defensive check `disabled !== false` to avoid unnecessary DOM updates if the state is already correct.
                                 if (this.#clearHistoryButton.disabled !== false) {
                                    this.#clearHistoryButton.disabled = false; // Enable the button.
                                    Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Enabled "Clear History" button as items were rendered.`);
                                 }
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null, cannot enable/disable.`);}


                          } else {
                              // --- Handle No History Items Found ---
                              // If the `fetchedHistoryItems` array is empty (either because IndexedDB was empty, or because the fetch/render process failed to yield any items).
                              Logger.debug(`${this.name}._loadAndDisplaySearchHistory: No history items found to render after fetch.`);

                              // Add a message to the history list indicating that the history is currently empty.
                              const noHistoryItem = documentElement
                                                                const noHistoryItem = document.createElement('li');
                                  noHistoryItem.textContent = AppConfig.MESSAGES.HISTORY_EMPTY; // Use the standard 'History Empty' message template.
                                  noHistoryItem.classList.add('w3-text-grey'); // Add styling class (grey text).
                                  noHistoryItem.style.cursor = 'default'; // Ensure the empty message is not clickable like data items.
                                   noHistoryItem.style.textAlign = 'center'; // Center the message within the list item.
                                   noHistoryItem.style.padding = '20px 16px'; // Add padding for centered messages.
                                  this.#searchHistoryList.appendChild(noHistoryItem); // Append the empty message item to the list.
                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show empty history list message.`);


                              // If no history items are found/displayed, the "Clear History" button should be disabled.
                              // Check if the clear button element exists before attempting to disable it.
                             if (this.#clearHistoryButton) {
                                  // Use a defensive check `disabled !== true` to avoid unnecessary DOM updates.
                                 if (this.#clearHistoryButton.disabled !== true) {
                                    this.#clearHistoryButton.disabled = true; // Disable the button.
                                    Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Disabled "Clear History" button as no items were found.`);
                                 }
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null, cannot enable/disable.`); }

                          } // End of `if (fetchedHistoryItems && fetchedHistoryItems.length > 0) else` block for rendering results/empty state.


                         // --- Update History Status UI ---
                         // Update the history status element (`#historyStatusElement`) based on the final outcome of the loading process (success or failure).
                         if (this.#historyStatusElement) { // Check if the status element exists.
                             // Check if the status text element still contains the "Loading..." message (`AppConfig.MESSAGES.PROCESSING('Loading history', false)`).
                             // This indicates that the fetch and render process completed within the `try` block and no error was specifically reported for status update inside it.
                             if (this.#historyStatusElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('Loading history', false)) ) {
                                  // If it's still showing the loading message, update it to a success status message.
                                  // If no items were found, the UI list shows the "empty" message item, but the status can still say "Loaded" if the load operation itself succeeded.
                                   this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_LOAD_SUCCESS; // Set success message text.
                                   // Set a short timer to clear this temporary status message if transient messages are configured (duration > 0).
                                   if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) { // Use the general message duration config for the status clearance timer.
                                        // Use a consistent mechanism to store and clear the timer ID, e.g., a data attribute on the element.
                                        // Clear any previous timer associated with this status element.
                                         if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                             clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                            delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID.
                                         }
                                         // Set a new timeout.
                                       const statusClearTimerId = setTimeout(() => {
                                            // Inside the timeout callback, check if the status text *still* matches the success message *before clearing*.
                                            // This avoids clearing a newer message (e.g., an error from a subsequent button click) if the status element was updated since this timer was set.
                                            if (this.#historyStatusElement && this.#historyStatusElement.textContent === AppConfig.MESSAGES.HISTORY_LOAD_SUCCESS) {
                                                this.#historyStatusElement.textContent = ''; // Clear the status text after the timeout.
                                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status cleared by timer.`);
                                            }
                                             if (this.#historyStatusElement) delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID after clear attempt.
                                        }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Clear the status message after half the general message duration.
                                        if (this.#historyStatusElement) this.#historyStatusElement.dataset.statusClearTimer = statusClearTimerId.toString(); // Store the timer ID on the element's data attribute.
                                   } // End if duration > 0 for timer.
                               }
                               // If the `catch (idbError)` block was executed, the ErrorReporter would have reported the failure, and that block would have updated `this.#historyStatusElement`
                               // to show the failure message persistently. We don't clear error status messages automatically in `finally`.
                               // If the initial UI element was missing (`this.#historyStatusElement` is null), updates are skipped, handled at the start.

                           } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status element missing, skipping final status update.`); } // Check if status element exists before updating.


                           Logger.debug(`${this.name}._loadAndDisplaySearchHistory async method execution finished.`);


                      } catch (overallLoadDisplayError) {
                           // --- Handle Critical Errors During Overall Load/Display Process ---
                           // This outer catch block catches any unexpected critical errors thrown *during the entire execution of the `_loadAndDisplaySearchHistory` method*
                           // that were not caught by the more specific try/catch blocks within (e.g., failure in the main try block before fetching, error in the loop structure itself, errors during DOM manipulation that weren't specifically caught).
                           // This indicates a severe failure in the history loading and display logic.
                           Logger.error(`${this.name}._loadAndDisplaySearchHistory: CRITICAL UNEXPECTED ERROR caught during history load and display process!`, overallLoadDisplayError);

                           // Report this critical failure using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._loadAndDisplaySearchHistory`, // Source of the error.
                               overallLoadDisplayError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'overall_load_display_process_critical_exception' }, // Context details.
                               AppConfig.MESSAGES.HISTORY_LOAD_FAILED(overallLoadDisplayError.message || 'Unknown error.'), // User-facing message template for a critical loading failure.
                               'history_load_critical_exception_overall' // GA error code for a critical overall history load exception.
                           );

                           // --- Update UI to Reflect Critical Failure ---
                           // Ensure the history status element shows a failure message persistently.
                           if (this.#historyStatusElement) { // Check if status element exists.
                              this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_LOAD_FAILED(overallLoadDisplayError.message || 'Unknown error during display update.'); // Set persistent error message.
                               // Remove any potential pending timer on status element if a critical error happens during a timer delay.
                                if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                    clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                   delete this.#historyStatusElement.dataset.statusClearTimer;
                                }
                           } else { Logger.warn(`${this.name}._loadAndDisplaySearchHistory: History status element is null when handling critical error during UI update.`); } // Check if status element exists.

                           // Ensure the "Clear History" button is disabled on critical load/display failure.
                           if (this.#clearHistoryButton) { // Check if clear button exists.
                              this.#clearHistoryButton.disabled = true; // Disable the button.
                           } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null.`); }


                           // Clear the history list UI (`#searchHistoryList`) in case of partial or corrupt data/display errors
                           // and show a generic error message item in the list to the user.
                           if (this.#searchHistoryList) { // Check if history list exists.
                                Logger.error(`${this.name}._loadAndDisplaySearchHistory: Clearing history list UI due to critical error during display.`);
                                this.#searchHistoryList.innerHTML = ''; // Clear existing list items.
                                // Add a generic error message item to the list.
                                const errorItem = document.createElement('li'); // Create a new list item element.
                                errorItem.textContent = 'An error occurred while loading or displaying history.'; // Error text content.
                                errorItem.classList.add('w3-text-red'); // Style as error text.
                                errorItem.style.cursor = 'default'; // Make it non-clickable.
                                errorItem.style.textAlign = 'center'; // Center text.
                                errorItem.style.padding = '20px 16px'; // Add padding.
                                this.#searchHistoryList.appendChild(errorItem); // Append the error message item to the list.
                           } else { Logger.warn(`${this.name}._loadAndDisplaySearchHistory: Search history list element is null when handling critical error.`); }

                           // The history section itself (`#searchHistorySection`) should remain visible to show the error message in the status area and list item, unless its dependencies were missing initially.

                           // Do not re-throw the error from an async handler's outer catch block. The error has been logged and reported by the reporter.
                       } finally {
                           // This block always executes after the try/catch/return structure within the async handler.
                           // Ensures cleanup or final status updates not explicitly covered in the try/catch logic occur.
                           // The specific status update logic in try/catch blocks is preferred. This finally block serves as a safety net.
                           // Example cleanup: ensure spinner is removed from status element if it wasn't by the try/catch.
                           // const statusSpinner = this.#historyStatusElement?.querySelector('.w3-spin'); if (statusSpinner) statusSpinner.remove();
                           Logger.debug(`${this.name}._loadAndDisplaySearchHistory async method execution completed.`);
                       }
                   } // End of _loadAndDisplaySearchHistory method definition.


                   /**
                    * Handler for clicking on a search history list item (`<li>`) within the search history list (`#searchHistoryList`).
                    * This method is attached using event delegation (a single listener on the parent `#searchHistoryList` listens for clicks on any descendant `<li>`)
                    * during the `_loadAndDisplaySearchHistory` method.
                    * When a history list item is clicked, this handler retrieves the stored search data associated with that clicked item
                    * (which was previously stored as a JSON string in the list item's `data-searchData` attribute during rendering).
                    * It then parses the data and attempts to populate the main search form inputs with this retrieved data, allowing the user to re-run a past search easily.
                    * @param {Event} event - The native DOM 'click' event object. The `event.target` property refers to the element that was clicked, but `event.target.closest('li')` is used to find the nearest `<li>` ancestor.
                    */
                   _handleHistoryItemClick(event) {
                       try {
                           Logger.debug(`${this.name}._handleHistoryItemClick: History list item clicked.`);
                            // Prevent the browser's default behavior for the click event (e.g., if the LI contained a link, prevent navigation) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling to parent elements.

                           // Find the actual `<li>` list item element that was clicked (or is the closest `<li>` ancestor if a child element like a `<span>` inside the `<li>` was clicked).
                           // Use `event.target.closest('li')` for robust delegation.
                           const clickedListItem = event.target.closest('li');

                           // --- Check if a Valid Clicked Item with Data Was Found ---
                           // Ensure a valid `<li>` element was found AND that it contains the stored search data in its `data-searchData` attribute.
                           if (!clickedListItem || !clickedListItem.dataset || !clickedListItem.dataset.searchData) {
                               Logger.warn(`${this.name}._handleHistoryItemClick: Clicked element is not a history list item with data attribute.`);
                               // If the clicked element isn't a history item or doesn't have the expected data attribute, log a warning and exit.
                               // Report this click on a seemingly invalid history list item via GA.
                               this.#gaTracker.trackEvent('history_item_click_invalid', { form_id: this.id, reason: 'missing_list_item_or_data' });
                               return; // Exit handler.
                           }

                           // --- Handle Non-Data Items (like 'Loading...' or 'Empty') ---
                           // Check if the clicked item is one of the special message list items (like "Loading..." or "No recent searches found"). These items don't contain search data and should be ignored.
                           // Check based on class name (e.g., `w3-text-grey` for messages) or content text.
                           if (clickedListItem.classList.contains('w3-text-grey') || (typeof clickedListItem.textContent === 'string' && clickedListItem.textContent.includes('Loading...'))) { // Check class or text content for messages.
                               Logger.debug(`${this.name}._handleHistoryItemClick: Clicked on a non-data history item message. Ignoring.`);
                               return; // Ignore the click.
                           }


                           // --- Get Stored Search Data ---
                           // Retrieve the JSON string containing the stored search data from the clicked list item's `data-searchData` attribute.
                           const searchDataJsonString = clickedListItem.dataset.searchData;

                           let searchDataFromHistory = null; // Variable to hold the parsed search data object.
                           try {
                                // Attempt to parse the JSON string obtained from the data attribute back into a JavaScript object.
                                searchDataFromHistory = JSON.parse(searchDataJsonString);
                               Logger.debug(`${this.name}._handleHistoryItemClick: Successfully parsed search data from history item JSON string.`, searchDataFromHistory);
                           } catch (parseError) {
                                // --- Handle JSON Parsing Error ---
                                // If parsing the JSON string from the data attribute fails (e.g., the stored data was corrupted).
                               // Report this parsing error using the injected ErrorReporter.
                               this.#errorReporter.reportError(
                                    `${this.name}._handleHistoryItemClick`, parseError, // Source and error object.
                                    { formId: this.id, listItemTextSnippet: clickedListItem.textContent?.substring(0, 50) || 'N/A', jsonDataSnippet: searchDataJsonString?.substring(0, 100) || 'N/A', step: 'json_parse_error' }, // Context.
                                    `Error loading search data from history item. Data may be corrupted.`, // User-friendly message template for data issue.
                                    'history_item_parse_exception' // GA error code.
                                );
                               // Display a user-facing error message in the main UI area.
                               this.#messageDisplay.showMessage(`Error loading search data from history item. Please try clearing history.`, 'error', 8000); // Show error message temporarily.
                                this.#gaTracker.trackEvent('history_item_load_failed', { form_id: this.id, reason: 'parse_error_during_click' }); // GA Failure Reason.
                               return; // Exit handler if parsing failed.
                           }

                           // --- Validate Parsed Search Data ---
                           // Ensure the parsed search data object is a valid object and contains the minimum expected properties before attempting to populate form inputs.
                           if (!searchDataFromHistory || typeof searchDataFromHistory !== 'object') {
                                Logger.warn(`${this.name}._handleHistoryItemClick: Parsed search data is not a valid object or is null.`);
                               this.#messageDisplay.showMessage(`Error loading search data from history item (invalid format).`, 'error', 8000); // User message.
                                this.#gaTracker.trackEvent('history_item_load_failed', { form_id: this.id, reason: 'invalid_parsed_data_format' }); // GA Failure Reason.
                               return; // Exit handler.
                           }
                           // Basic check for some expected properties
                           if (!searchDataFromHistory.destinationInput || !searchDataFromHistory.checkInDateInput) {
                                Logger.warn(`${this.name}._handleHistoryItemClick: Parsed search data object is missing essential properties.`);
                               this.#messageDisplay.showMessage(`Error loading search data from history item (data incomplete).`, 'error', 8000);
                                this.#gaTracker.trackEvent('history_item_load_failed', { form_id: this.id, reason: 'incomplete_parsed_data' });
                                return; // Exit handler.
                           }


                           // --- Populate Form Inputs ---
                           // If search data was successfully parsed and validated, populate the main search form inputs (`this._inputs` map) with this data.
                           Logger.info(`${this.name}._handleHistoryItemClick: Populating main search form inputs with history data for "${searchDataFromHistory.destinationInput?.trim() || 'N/A'}".`);

                           // Display a UI message informing the user that the form is being populated from history.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.HISTORY_ITEM_CLICKED(searchDataFromHistory.destinationInput?.trim() || 'N/A'), 'info', 3000); // Show message for 3 seconds.


                           // Iterate through the properties of the `searchDataFromHistory` object (these keys should correspond to input element IDs).
                           Object.keys(searchDataFromHistory).forEach(dataKey => {
                               try {
                                   // Check if there is a corresponding custom input component instance managed by this form (`this._inputs`) for the current data key.
                                   const inputComponent = this._inputs[dataKey];

                                    // Ensure the input component exists in the map AND if its wrapped HTML element (`_element`) is available AND if the element is not disabled or readonly (preventing population).
                                   if (inputComponent && inputComponent.getElement() && !inputComponent.getElement().disabled && !inputComponent.getElement().readOnly) {
                                        // Get the HTML element associated with the component.
                                       const element = inputComponent.getElement();
                                        // Get the value for this key from the history data object. Use nullish coalescing to set empty string for null/undefined values.
                                       const valueToSet = searchDataFromHistory[dataKey] ?? ''; // Value from history data.

                                        // --- Set Element Value ---
                                        // Set the value on the HTML element's appropriate property. This property depends on the element type (`value` for most inputs/textareas, `checked` for checkboxes/radios, `value`/`selectedIndex` for selects).
                                       if (element.type === 'checkbox') {
                                            element.checked = Boolean(valueToSet); // Set checked state for checkboxes based on truthiness of the history value.
                                            Logger.debug(`${this.name}._handleHistoryItemClick: Populated checkbox "${dataKey}" checked state to "${element.checked}".`);
                                       } else if (element.type === 'radio') {
                                            // For radio buttons, set the checked state ONLY if the history item value matches the specific radio button's `value` attribute.
                                            if (String(element.value) === String(valueToSet)) { // Compare both as strings for robustness.
                                                 element.checked = true; // Set checked state.
                                                Logger.debug(`${this.name}._handleHistoryItemClick: Populated radio "${dataKey}" checked true.`);
                                            } // Other radio buttons with the same `name` in a group should automatically become unchecked by the browser.
                                       } else if (element.tagName === 'SELECT') {
                                            // For select elements, attempt to set the `value`.
                                             element.value = valueToSet; // Set the select value. The browser will select the matching <option>.
                                             Logger.debug(`${this.name}._handleHistoryItemClick: Populated select "${dataKey}" value to "${element.value}".`);
                                            // Note: If the `valueToSet` does not match any `<option>`'s `value` attribute, the select might not visually update or might select the first option depending on browser/HTML structure.
                                       } else {
                                            // For most standard input types (`text`, `number`, `date`, `email`, `password`, etc., and `<textarea>`), set the `value` property directly.
                                           element.value = valueToSet; // Set the value.
                                            Logger.debug(`${this.name}._handleHistoryItemClick: Populated input "${dataKey}" value to "${element.value}".`);
                                       }

                                      // --- Trigger Events Programmatically ---
                                       // After programmatically setting the HTML element's value, manually trigger standard DOM events (`input`, `change`) on the element.
                                       // This is important because browser event handlers (like those attached by our `InputComponent` base class)
                                       // typically only fire in response to *user* interactions (typing, pasting, clicking, etc.), not programmatic value changes.
                                       // Dispatching these events ensures that the input component's event handlers (`_handleInput`, `_handleChange`, `_handleBlur` - if applicable)
                                       // are executed. This updates the component's internal `_value` state, clears error messages below the input,
                                       // and triggers any component logic tied to these events (like validation on change/blur).
                                       // Create and dispatch the 'input' event. Use `bubbles: true` so the event propagates up the DOM tree.
                                        const inputEvent = new Event('input', { bubbles: true });
                                        element.dispatchEvent(inputEvent);
                                        Logger.debug(`${this.name}._handleHistoryItemClick: Dispatched 'input' event for "${dataKey}".`);

                                       // Dispatch a 'change' event. The change event signifies that the value has been committed (though typically happens on blur after value change).
                                       // Dispatching it here simulates that the "value has been confirmed loaded from history".
                                        const changeEvent = new Event('change', { bubbles: true });
                                        element.dispatchEvent(changeEvent);
                                        Logger.debug(`${this.name}._handleHistoryItemClick: Dispatched 'change' event for "${dataKey}".`);

                                      // Optional: Trigger blur programmatically to mimic the input losing focus after being populated.
                                      // This is often where validation is triggered, which `this.validate()` below also does.
                                      // if (typeof element.blur === 'function') element.blur();

                                      // Optional: Explicitly trigger validation for this specific input component after setting its value.
                                       // This ensures immediate visual validity feedback for this input based on the newly set value.
                                       // inputComponent.validate(); // Uncomment if immediate validation on population is desired for EACH input.

                                   } else {
                                       // If the corresponding input component for this data key doesn't exist in the map (`this._inputs[dataKey]` is undefined/null),
                                       // or if the component instance exists but is invalid (`getElement()` returns null),
                                       // or if its wrapped element is disabled or readonly, we cannot populate it.
                                      Logger.warn(`${this.name}._handleHistoryItemClick: Corresponding input component not found or invalid/disabled for key "${dataKey}". Cannot populate input from history.`, { inputId: dataKey, componentExists: !!inputComponent, elementValidAndWritable: inputComponent ? (!!inputComponent.getElement() && !inputComponent.getElement().disabled && !inputComponent.getElement().readOnly) : false });
                                       // Report this issue as an internal error during the population process.
                                       this.#errorReporter.reportError(
                                           `${this.name}._handleHistoryItemClick`, new Error(`Input component missing, invalid, or disabled for key "${dataKey}".`),
                                           { formId: this.id, dataKey: dataKey, step: 'populate_input_missing_or_invalid_component' },
                                           `Internal error populating form input "${dataKey}" from history. Parameter unavailable.`,
                                           'history_populate_input_missing_or_invalid_component' // GA error code.
                                       );
                                   }

                               } catch (populateInputError) {
                                    // --- Handle Errors During Single Input Population ---
                                    // Catch any unexpected errors that occur *while processing a single data key or attempting to populate its corresponding input* within the loop.
                                    // This provides robustness; an error with one input element's population should not stop the entire process of populating other inputs.
                                   const currentDataKey = dataKey || 'N/A'; // Get the key defensively.
                                   this.#errorReporter.reportError(
                                       `${this.name}._handleHistoryItemClick`, populateInputError, // Source and error.
                                       { formId: this.id, keyAttempted: currentDataKey, step: 'populate_input_in_loop_execution' }, // Context.
                                       `Error populating form input "${currentDataKey}" from history item data. Process for this input failed.`, // User message template.
                                       'history_populate_input_exception' // GA error code for input population exception.
                                   );
                                  // Log the problematic data for this key.
                                   Logger.error(`_handleHistoryItemClick: Failed to populate input "${currentDataKey}" from history item:`, searchDataFromHistory[currentDataKey], { error: populateInputError });
                                  // Continue the `forEach` loop despite an error with one input's population.
                               }
                           }); // End of `Object.keys(searchDataFromHistory).forEach` loop.


                           // --- Subsequent Actions After Population ---
                           // After all inputs have been iterated and populated (or skipped/failed):
                           // 1. Trigger form validation (`this.validate()`) to check if the data loaded from history is currently valid based on all validation rules (individual and cross-field).
                           //    This displays immediate visual validation feedback to the user based on the loaded data.
                           // 2. Optionally, automatically trigger a new search by programmatically submitting the form (`this.#searchButton?.click()` or `this._element?.submit()`).

                           // Trigger form validation explicitly after populating inputs.
                           // This updates the validity status of all inputs and performs cross-field checks based on the loaded data.
                            try {
                                 Logger.debug(`${this.name}._handleHistoryItemClick: Triggering form validation after population.`);
                                // Call the form's public `validate()` method. This executes `_validateForm()`.
                                this.validate(); // This will update the `_isValid` state of the form and inputs and show/clear error messages.
                                 // The result (true/false) is available but not strictly needed for the flow unless conditional logic follows immediately.
                            } catch (validationErrorAfterPopulation) {
                                // Catch any uncaught errors *within* the form's `validate()` method execution (less likely if `validate` has internal catches).
                                 Logger.error(`${this.name}._handleHistoryItemClick: Error triggering form validation after population.`, validationErrorAfterPopulation);
                                // Errors specific to validation logic within `validate()` are reported by the reporter within that method.
                            }

                           // Optional: Automatically submit the form after loading history data.
                           // This simulates the user clicking the Search button again after populating from history.
                           // Uncomment the line below if you want auto-submission. Be aware of UX implications (immediate new search).
                           // if (this.#searchButton && !this.#searchButton.disabled) { // Check button exists and is not disabled.
                           //     Logger.info(`${this.name}._handleHistoryItemClick: Auto-submitting form after population.`);
                           //     this.#searchButton.click(); // Simulate clicking the button. This triggers the form's submit handler.
                           // } else {
                           //      Logger.debug(`${this.name}._handleHistoryItemClick: Auto-submission skipped. Button is missing or disabled.`);
                           // }

                           // Note: If auto-submitting, you might want to clear or update the history status message (`#historyStatusElement`) appropriately BEFORE initiating the submit/search process.


                           Logger.debug(`${this.name}._handleHistoryItemClick async method execution finished.`);


                       } catch (handlerError) {
                           // --- Handle Critical Errors During Overall Handler Execution ---
                           // This outer catch block catches any unexpected synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                           // that were not caught by the more specific try/catch blocks within (e.g., errors accessing elements, logic errors before loops/service calls).
                           // This represents a critical failure in the handling of the history item click.
                           this.#errorReporter.reportError(
                               `${this.name}._handleHistoryItemClick`, // Source of the error.
                               handlerError, // The error object caught.
                               { component: this.#getComponentInfo(), step: 'handler_execution_overall_exception' }, // Context.
                               `Error handling history item click for form "${this.name}". Failed to populate form inputs.`, // User-facing message template for handler failure.
                               'history_item_click_handler_exception_overall' // GA error code for overall handler exception.
                           );

                           // Ensure relevant UI is reset or updated to indicate failure, if necessary.
                           // Main message area errors are handled by the reporter.
                           // History status element might need clearing or resetting.
                           if (this.#historyStatusElement) { // Check if status element exists.
                               // Check if it still has the temporary 'clicked' message text before clearing.
                               if (typeof this.#historyStatusElement.textContent === 'string' && this.#historyStatusElement.textContent.includes(AppConfig.MESSAGES.HISTORY_ITEM_CLICKED('', false))) { // Use includes with empty destination to check for base message.
                                   this.#historyStatusElement.textContent = 'Error during population.'; // Update status text on error.
                                   Logger.debug(`${this.name}._handleHistoryItemClick: Updated history status message due to handler error.`);
                                }
                           } else { Logger.warn(`${this.name}._handleHistoryItemClick: History status element is null when handling handler error.`); }

                           // The history list itself should probably remain displayed as it was, although it might be in a partially updated state if the error occurred partway through population.

                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported by the reporter.
                       } // End of _handleHistoryItemClick try...catch...finally.
                   } // End of _handleHistoryItemClick method definition.


                  /**
                   * Asynchronous handler for the "Clear History" button click. Marked as `async`.
                   * This method is triggered when the user clicks the button element identified by `#clearHistoryButton`.
                   * It initiates and manages the process of clearing all stored search history items from the browser's IndexedDB database using the `IndexedDBService`.
                   * Displays UI messages to the user and updates the history list display to show the result of the clearing operation.
                   * @param {Event} event - The native DOM 'click' event object.
                   */
                  async _handleClearHistoryClick(event) {
                      try {
                          Logger.info(`${this.name}._handleClearHistoryClick: "Clear History" button clicked.`);
                           // Prevent the browser's default behavior for the button click and stop event propagation.
                           if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                          if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                          // Track a Google Analytics event indicating the clear history button was clicked.
                          this.#gaTracker.trackEvent('button_click', { button_id: 'clear_history', form_id: this.id }); // GA Event.

                          // --- Check Dependencies and State ---
                          // Ensure the `IndexedDBService` instance is initialized and available before attempting to call its methods.
                          if (!this.#idbService) {
                              const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' History service not available. Cannot clear history.'; // Error message.
                              // Report this as a critical infrastructure error via the ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleClearHistoryClick`, new Error(errorMsg), // Source and error object.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'history_service_missing_critical', 0 // GA error code and persistent message.
                              );
                              // Update status element if it's available to show the error message.
                              if (this.#historyStatusElement) this.#historyStatusElement.textContent = errorMsg; // Show message in status area.
                              // Button should ideally be disabled if service is missing (handled by _updateGoogleServiceButtonState).
                              return; // Exit async handler if service is missing.
                          }


                          // --- Optional User Confirmation ---
                          // You might want to add a JavaScript `confirm()` dialog here to ask the user for confirmation
                          // before permanently deleting all their search history data.
                          // const confirmClear = confirm("Are you sure you want to clear ALL search history from this browser? This cannot be undone.");
                          // if (!confirmClear) {
                          //      Logger.debug(`${this.name}._handleClearHistoryClick: User cancelled history clear operation.`);
                          //     // Optional: Display a brief cancellation message to the user temporarily.
                          //      if (this.#historyStatusElement) {
                          //           this.#historyStatusElement.textContent = 'Clear history cancelled by user.';
                          //           if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) {
                          //               setTimeout(() => { if (this.#historyStatusElement && this.#historyStatusElement.textContent === 'Clear history cancelled by user.') this.#historyStatusElement.textContent = ''; }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Example clear after duration.
                          //           }
                          //       }
                          //      this.#gaTracker.trackEvent('history_clear_cancelled', { form_id: this.id }); // Track cancellation.
                          //      return; // Exit async handler if user cancels.
                          // }


                          // --- Show Clearing State UI ---
                          // Update the history status element (`#historyStatusElement`) to indicate that the clearing operation is now in progress.
                          if (this.#historyStatusElement) { // Check if the status element exists.
                              this.#historyStatusElement.innerHTML = AppConfig.MESSAGES.PROCESSING('Clearing history'); // Show processing text + spinner icon markup.
                              Logger.debug(`${this.name}._handleClearHistoryClick: UI updated to show clearing status.`);
                          } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for loading update.`); }

                          // Disable the "Clear History" button while the operation is in progress to prevent multiple simultaneous clears.
                          if (this.#clearHistoryButton) { // Check if the button element exists.
                              // Use a defensive check `disabled !== true` to avoid unnecessary DOM updates if the state is already correct.
                              if (this.#clearHistoryButton.disabled !== true) {
                                   this.#clearHistoryButton.disabled = true; // Disable the button.
                                  Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button disabled during clearing.`);
                              }
                          } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); }

                          // Optionally clear the current history list display (`#searchHistoryList`) visually immediately (optimistic UI update).
                          // This makes the UI responsive while the actual DB operation happens in the background.
                           if (this.#searchHistoryList) { // Check if the list element exists.
                               Logger.debug(`${this.name}._handleClearHistoryClick: Clearing history list UI visually (optimistic update).`);
                               this.#searchHistoryList.innerHTML = ''; // Clear existing list items.
                               // Add a temporary "Clearing..." message as a list item while the asynchronous clear is happening.
                               const clearingItem = document.createElement('li'); // Create a new list item element.
                               clearingItem.textContent = 'Clearing...'; // Set text content.
                               clearingItem.classList.add('w3-text-grey'); // Add styling.
                                clearingItem.style.cursor = 'default'; // Make it non-clickable.
                                clearingItem.style.textAlign = 'center'; // Center text.
                                clearingItem.style.padding = '20px 16px'; // Add padding.
                                this.#searchHistoryList.appendChild(clearingItem); // Append the temporary clearing message item to the list.
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: Search history list element missing for optimistic update.`); }

                          // Display a persistent message in the main UI message area indicating the clearing process has started.
                          this.#messageDisplay.showMessage(AppConfig.MESSAGES.HISTORY_CLEAR_INIT, 'info', 0); // Use duration 0 for a persistent message.
                           // Track a GA event for the start of the clearing process.
                           this.#gaTracker.trackEvent('history_clear_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                          // --- Execute Clear History Operation in IndexedDB ---
                          // Call the asynchronous method (`clearSearchHistory`) on the `IndexedDBService` instance (`this.#idbService`) to perform the actual data deletion in the database.
                          // Use `await` to pause execution of this async handler until the Promise returned by `clearSearchHistory` resolves (successfully) or rejects (with an error).
                          Logger.debug(`${this.name}._handleClearHistoryClick: Calling IndexedDB service to execute clear history operation...`);
                          try {
                              await this.#idbService.clearSearchHistory(); // Call the async method on the service. This method returns a Promise<void> and throws/rejects on error.
                              // If execution reaches here, the `clearSearchHistory` Promise resolved successfully.
                              Logger.info(`${this.name}._handleClearHistoryClick: IndexedDB search history cleared successfully by service operation.`);

                              // --- Handle Successful Clear ---
                              const successMessage = AppConfig.MESSAGES.HISTORY_CLEARED_SUCCESS; // Get the standard success message string.
                              // Update the main UI message area with a temporary success message.
                              this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.
                              // Track a GA success event for history clearing.
                              this.#gaTracker.trackEvent('history_clear_success', { form_id: this.id, step: 'success' }); // GA Success Event.

                              // Update the history status element (`#historyStatusElement`) to show a success message.
                              if (this.#historyStatusElement) { // Check if the status element exists.
                                 this.#historyStatusElement.textContent = successMessage; // Set the success message text.
                                  // Remove any pending timer on status element before setting a new one.
                                  if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                      clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                     delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID.
                                   }
                                  // Set a short timer to clear this temporary status message if transient messages are configured (duration > 0).
                                  if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) { // Use the general message duration config for the status clearance timer.
                                       const statusClearTimerId = setTimeout(() => {
                                            // Inside the timeout callback, check if the status text *still* matches the success message *before clearing*.
                                            // This avoids clearing a newer message (e.g., an error from a different button click) if the status element was updated since this timer was set.
                                            if (this.#historyStatusElement && this.#historyStatusElement.textContent === successMessage) {
                                                this.#historyStatusElement.textContent = ''; // Clear the status text after the timeout.
                                                Logger.debug(`${this.name}._handleClearHistoryClick: History status cleared by timer.`);
                                            }
                                             if (this.#historyStatusElement) delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID from data attribute after clear attempt.
                                       }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Clear the status message after half the general message duration.
                                       if (this.#historyStatusElement) this.#historyStatusElement.dataset.statusClearTimer = statusClearTimerId.toString(); // Store the timer ID on the element's data attribute for future clearing.
                                   } // End if duration > 0 for timer.
                              } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for success update.`); } // Check if status element exists.

                              // Update the history list display (`#searchHistoryList`) to show the "empty" state message after clearing.
                              // The list should already be empty visually due to the optimistic update, but ensure it has the final "empty" message item.
                              if (this.#searchHistoryList) { // Check if the list element exists.
                                  this.#searchHistoryList.innerHTML = ''; // Ensure it's fully clear.
                                   const noHistoryItem = document.createElement('li'); // Create a new list item element.
                                   noHistoryItem.textContent = AppConfig.MESSAGES.HISTORY_EMPTY; // Use the standard 'History Empty' message template.
                                   noHistoryItem.classList.add('w3-text-grey'); // Add styling class.
                                   noHistoryItem.style.cursor = 'default'; // Ensure it's not clickable.
                                    noHistoryItem.style.textAlign = 'center'; // Center text.
                                    noHistoryItem.style.padding = '20px 16px'; // Add padding.
                                  this.#searchHistoryList.appendChild(noHistoryItem); // Append the empty message item to the list.
                                Logger.debug(`${this.name}._handleClearHistoryClick: UI updated to show empty history list.`);
                              } else { Logger.debug(`${this.name}._handleClearHistoryClick: Search history list element missing for update.`); }

                              // After successfully clearing history, the "Clear History" button should be disabled as the list is now empty.
                              if (this.#clearHistoryButton) { // Check if the clear button exists.
                                   // Use defensive check `disabled !== true`.
                                  if (this.#clearHistoryButton.disabled !== true) {
                                     this.#clearHistoryButton.disabled = true; // Disable the button.
                                     Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button disabled after successful clear.`);
                                  }
                              } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); }


                          } catch (idbError) {
                              // --- Handle IndexedDB Clearing Errors ---
                              // Catch any errors thrown (Promise rejections) by the IndexedDB service's `clearSearchHistory` method (e.g., due to database access issues, permissions being denied, database corruption during clear).
                              Logger.error(`${this.name}._handleClearHistoryClick: Error caught from IndexedDB service clear call:`, idbError);

                              // Report the error using the injected ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleClearHistoryClick - idbClear`, // Source.
                                  idbError, // The error object from the service rejection.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'indexeddb_clear_history_execution' }, // Context.
                                  AppConfig.MESSAGES.HISTORY_CLEARED_FAILED(idbError.message || 'Unknown error.'), // User message template.
                                  'history_clear_exception_api' // GA error code.
                              );
                              // The ErrorReporter handles displaying the persistent error message in the main area.

                              // Update history status element to show failure message persistently.
                              if (this.#historyStatusElement) { // Check if status element exists.
                                 this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_CLEARED_FAILED(idbError.message || 'Unknown error during clear.'); // Set persistent error message.
                                  // Remove any pending timer on status element if error happens during timer delay.
                                  if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                      clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                     delete this.#historyStatusElement.dataset.statusClearTimer; // Remove stored ID.
                                  }
                              } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for error update.`);}


                              // Ensure the "Clear History" button is enabled again so the user can try clearing again.
                              if (this.#clearHistoryButton) { // Check if button exists.
                                  // Use defensive check `disabled !== false`.
                                 if (this.#clearHistoryButton.disabled !== false) {
                                    this.#clearHistoryButton.disabled = false; // Enable the button on failure.
                                     Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button enabled on failure.`);
                                 }
                              } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); }

                              // The history list display will likely be in an inconsistent state (maybe showing 'Clearing...' or just empty) after a failed clear attempt.
                              // It might be best practice to attempt to reload the history list after a failed clear operation, to show the user what remains or what went wrong.
                              try {
                                   Logger.debug(`${this.name}._handleClearHistoryClick: Attempting to reload history after clear failure.`);
                                   // Call the history loading method again. It handles its own async process and UI updates.
                                   // Use `await` if `_loadAndDisplaySearchHistory` returns a Promise, though it's okay if this makes the handler linger briefly.
                                  this._loadAndDisplaySearchHistory(); // Call the async history loading method.
                              } catch (reloadErrorAfterClearFailure) {
                                   // Errors that occur *during the reload attempt itself* after clear failure are handled by the `_loadAndDisplaySearchHistory`'s own error handling.
                                  Logger.error(`${this.name}._handleClearHistoryClick: Error triggering history reload after clear failure.`, reloadErrorAfterClearFailure);
                              }


                          } // End of `catch (idbError)` block.


                      } catch (handlerError) {
                          // --- Handle Critical Errors During Overall Handler Execution ---
                          // This outer catch block catches any unexpected synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                          // (e.g., errors during the try/catch structure, accessing elements, logic errors before calling the service).
                          // This represents a critical failure in the handling of the clear history button click.
                          this.#errorReporter.reportError(
                              `${this.name}._handleClearHistoryClick`, // Source of the error.
                              handlerError, // The error object caught.
                              { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall' }, // Context.
                              `Error handling "Clear History" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                              'history_clear_button_handler_exception_overall' // GA error code for overall handler exception.
                          );

                          // Ensure UI state is reset or updated to reflect the error state if something went wrong before the main logic completed.
                          // History status element: Update text and clear any pending timer.
                          if (this.#historyStatusElement) { // Check if status element exists.
                              this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_CLEARED_FAILED('An internal error occurred during handler.');
                              // Clear potential pending timer.
                               if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                   clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                  delete this.#historyStatusElement.dataset.statusClearTimer;
                               }
                           } else { Logger.warn(`${this.name}._handleClearHistoryClick: History status element is null when handling handler error.`); }
                          // Clear history button: Ensure it's re-enabled on error.
                          if (this.#clearHistoryButton) { // Check if button exists.
                              if (this.#clearHistoryButton.disabled !== false) { // Check state defensively.
                                  this.#clearHistoryButton.disabled = false; // Enable the button on error.
                                  Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button enabled after handler error.`);
                              }
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); }

                           // History list: Clear the list UI in case of partial/corrupt data and show a generic error item.
                           if (this.#searchHistoryList) { // Check if list exists.
                                Logger.error(`${this.name}._handleClearHistoryClick: Clearing history list UI due to error during handler execution.`);
                                this.#searchHistoryList.innerHTML = ''; // Clear existing list items.
                                // Add a generic error message item to the list.
                                const errorItem = document.createElement('li'); // Create a new list item element.
                                errorItem.textContent = 'An error occurred while trying to clear history.'; // Error text content.
                                errorItem.classList.add('w3-text-red'); // Style as error text.
                                errorItem.style.cursor = 'default'; errorItem.style.textAlign = 'center'; errorItem.style.padding = '20px 16px';
                                this.#searchHistoryList.appendChild(errorItem); // Add the error message item to the list.
                           } else { Logger.warn(`${this.name}._handleClearHistoryClick: Search history list element is null when handling handler error.`); }


                          // Ensure the persistent message in the main area is cleared if it was set and not an error message itself.
                           if (this.#messageDisplay) { // Check if MessageDisplay exists.
                               const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                               // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.HISTORY_CLEAR_INIT`), and is NOT displaying a persistent error (`w3-pale-red`).
                               if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.HISTORY_CLEAR_INIT) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // If it's still the initial processing message and not an error, clear it.
                                   this.#messageDisplay.clearMessage(); // Clear the persistent message.
                                   Logger.debug(`${this.name}._handleClearHistoryClick: Cleared persistent message in main area due to handler error.`);
                                }
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: MessageDisplay service missing when trying to clear persistent message.`); }


                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                      } finally {
                          // This block always executes after the try/catch structure.
                          // Ensure any lingering persistent "Processing..." message is cleared unless it became an error message.
                          if (this.#messageDisplay) {
                             const currentMessageElement = this.#messageDisplay.getElement();
                             // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.HISTORY_CLEAR_INIT`) and not currently displaying an error (`w3-pale-red`)...
                             if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.HISTORY_CLEAR_INIT) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // Clear the persistent message.
                                 this.#messageDisplay.clearMessage();
                                Logger.debug(`${this.name}._handleClearHistoryClick: Cleared persistent message in finally.`);
                             }
                         }
                         Logger.debug(`${this.name}._handleClearHistoryClick async method execution completed.`);
                      } // End of _handleClearHistoryClick try...catch...finally block.
                  } // End of _handleClearHistoryClick method definition.


                 /**
                  * Asynchronous handler for the "Send to Apps Script" button click. Marked as `async`.
                  * This method is triggered when the user clicks the button element identified by `#sendToAppsScriptButton`.
                  * It orchestrates the simulated process of sending the collected search details (stored in `_lastCollectedParams`)
                  * to a Google Apps Script endpoint using the `SimulatedGoogleAppsScriptService`.
                  * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                  * @param {Event} event - The native DOM 'click' event object.
                  */
                 async _handleSendToAppsScriptClick(event) {
                     try {
                         Logger.info(`${this.name}._handleSendToAppsScriptClick: "Send to Apps Script" button clicked.`);
                          // Prevent default browser behavior of the button (if any) and stop event propagation up the DOM tree.
                          if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                         if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                         // Track a Google Analytics event indicating the "Send to Apps Script" button was clicked.
                         this.#gaTracker.trackEvent('button_click', { button_id: 'send_to_apps_script', form_id: this.id }); // GA Event.

                         // --- Check Dependencies and State ---
                         // Ensure valid search parameters are available in `_lastCollectedParams`.
                         // The Apps Script operation requires this data as payload.
                         if (!this._lastCollectedParams) {
                             const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating a search is required.
                             Logger.warn(`${this.name}._handleSendToAppsScriptClick: No search data available in _lastCollectedParams. Message: "${message}".`);
                             this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                              // Track the reason for failure in Google Analytics.
                              this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'no_search_data_available' }); // GA Failure Reason.
                             return
                         ```javascript
                             return; // Exit the async handler as essential data is missing.
                         }

                         // Ensure the simulated Google Apps Script Service instance is initialized and configured (has a non-placeholder endpoint URL).
                         // Its `isConfigured()` method checks this condition based on `AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY`.
                         if (!this.#appsScriptService || !this.#appsScriptService.isConfigured()) {
                              const message = AppConfig.MESSAGES.APPS_SCRIPT_ENDPOINT_MISSING; // Message about the Apps Script endpoint configuration missing.
                             Logger.warn(`${this.name}._handleSendToAppsScriptClick: Apps Script service not configured or instance missing. Message: "${message}".`);
                             // Display the warning message temporarily in the main UI area.
                             this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message for 8 seconds.
                             // Note: The service constructor reports the missing configuration error persistently in the main message area.
                              // Track the reason for failure in Google Analytics.
                              this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'service_not_configured_or_missing_instance' }); // GA Failure Reason.
                             return; // Exit the async handler if the service is not configured or available.
                         }


                         // --- Prepare Data Payload for Apps Script ---
                         // Create the JavaScript object containing the data payload that will be sent to the Apps Script endpoint.
                         // Use the stored collected search parameters (`this._lastCollectedParams`) as the primary data.
                         // Augment this payload with other relevant context like a timestamp or basic user information (if the user is simulated signed in and Apps Script needs it).
                          Logger.debug("_handleSendToAppsScriptClick: Preparing data payload for Apps Script...");
                          try {
                              const dataPayloadToSend = {
                                   // Include the collected search details object. Use defensive checks for existence.
                                  searchDetails: this._lastCollectedParams || {},
                                   // Add metadata about when the data was sent from the client. Use ISO 8601 string format for clarity and machine readability.
                                  clientTimestamp: new Date().toISOString(),
                                   // Include information about the page the data originated from.
                                  originPage: window.location.href, // The URL of the current page.
                                   // If the user is simulated signed in via Google Identity Services, include some basic simulated user info.
                                   // The simulated auth service instance (`this.#googleAuthService`) provides user info getters.
                                  userInfo: this.#googleAuthService?.getUserInfo() || null, // Get user info object if available, otherwise null.
                                  // Add other static or dynamic context relevant to your specific Google Apps Script (e.g., application name, version, form identifier).
                                  sourceApplication: AppConfig.APP_NAME,
                                  appVersion: AppConfig.APP_VERSION,
                                  formId: this.id,
                                   // You could add more detailed context if needed.
                                   // browserInfo: navigator.userAgent // Example: Add browser user agent (consider privacy).
                              };
                               Logger.debug("_handleSendToAppsScriptClick: Data payload prepared successfully:", dataPayloadToSend);

                          } catch (preparePayloadError) {
                              // Catch any errors while preparing the data payload.
                               this.#errorReporter.reportError(
                                   `${this.name}._handleSendToAppsScriptClick`, preparePayloadError,
                                  { component: this.#getComponentInfo(), step: 'prepare_payload_for_apps_script' }, // Context details.
                                  `Error preparing data to send to Apps Script. Operation failed.`, // User message template.
                                   'apps_script_send_prepare_payload_exception' // GA error code.
                               );
                              // Ensure the persistent "Processing..." message is cleared if an error occurred before setting it (handled below in finally),
                              // or if it was set already and isn't an error message itself.
                               if (this.#messageDisplay) {
                                   const currentMessageElement = this.#messageDisplay.getElement();
                                   if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                       this.#messageDisplay.clearMessage();
                                    }
                               }
                               // Re-throw the error to indicate that payload preparation failed and the send operation should not proceed.
                               throw preparePayloadError;
                          }


                         // --- Simulate Sending Data to Apps Script Endpoint ---
                         // Display a persistent UI message in the main area indicating that the simulated sending process is starting.
                         this.#messageDisplay.showMessage(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING, 'info', 0); // Use duration 0 for a persistent message.
                          // Track a GA event for the start of the "Send to Apps Script" process.
                          this.#gaTracker.trackEvent('apps_script_send_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                         Logger.debug(`_handleSendToAppsScriptClick: Calling simulated Google Apps Script service runScriptFunction...`, dataPayloadToSend);
                         // Call the asynchronous method (`runScriptFunction`) on the simulated Apps Script service instance (`this.#appsScriptService`).
                         // This method simulates making an async HTTP call (fetch/$.ajax) to the configured backend endpoint
                         // (`AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY`), which YOUR backend would use to securely
                         // invoke the Google Apps Script function (`doPost` or `doGet`) with the provided data payload.
                         // Use `await` to pause execution of this handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                         try {
                              // The `runScriptFunction` method on the simulated service returns a Promise. Await its result.
                              // It's designed to throw/reject on errors during its execution or the simulated API call.
                              const simulatedResponse = await this.#appsScriptService.runScriptFunction(dataPayloadToSend); // Await the simulated service call.
                             // Log the result of the simulated API call and response.
                             Logger.debug("_handleSendToAppsScriptClick: Simulated Apps Script response received:", simulatedResponse);


                             // --- Process Simulated Apps Script Response ---
                             // If the Promise resolved successfully, `simulatedResponse` should contain the data returned by the simulated Apps Script (e.g., a JSON object with a status).
                             // Check the content of the simulated response to determine success or failure from the script's logic.
                             // Assume a typical Apps Script Web App might return a JSON object like `{ result: 'success', message: '...', ... }` or `{ result: 'error', message: '...' }`.
                             if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.result === 'success') {
                                 // If the simulated call was successful according to its response format:
                                 const successMessage = AppConfig.MESSAGES.APPS_SCRIPT_SEND_SUCCESS; // Get the standard success message string.
                                 Logger.info(`_handleSendToAppsScriptClick: ${successMessage}. Simulated response indicated success.`);
                                 // Update the main UI message area with a temporary success message.
                                 this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily.
                                 // Track a GA success event for the "Send to Apps Script" operation.
                                 this.#gaTracker.trackEvent('apps_script_send_success', { form_id: this.id, step: 'success' }); // GA Success Event.
                                 // Optional: If the simulated response contains user-relevant information (e.g., a confirmation ID, a link to the spreadsheet row), display it to the user or log it.
                                 // Example: if (simulatedResponse.message) this.#messageDisplay.showMessage(`${successMessage} Script message: ${simulatedResponse.message}`, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS + 2000);
                                 // Example: if (simulatedResponse.data && simulatedResponse.data.spreadsheetRow) Logger.info(`_handleSendToAppsScriptClick: Data written to simulated spreadsheet row: ${simulatedResponse.data.spreadsheetRow}`);


                             } else {
                                  // --- Handle Simulated Apps Script Failure (Resolved but indicated failure) ---
                                  // This case is reached if the simulated service's Promise resolved, but the resolved value itself indicates a failure (e.g., an API returned a JSON object with an error status like `{ result: 'error', message: '...' }`).
                                  // This is a common pattern for backend APIs or Apps Scripts to return structured error responses for known failures.
                                  // Get a detailed error message from the simulated response or use a fallback string.
                                 const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated service.";
                                  const message = AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                 Logger.error(`_handleSendToAppsScriptClick: Simulated Apps Script call returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, dataSent: dataPayloadToSend });
                                 // Update the main UI message area with a persistent error message.
                                 this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user.
                                 // Track a GA error event with details.
                                 this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                             }

                         } catch (apiError) {
                             // --- Handle Simulated Apps Script Failure (Promise Rejection) ---
                             // Catch any errors thrown (Promise rejections) by the simulated Apps Script service's `runScriptFunction` method.
                             // This could simulate errors like:
                             // - Network issues when calling the backend endpoint.
                             // - HTTP errors (4xx, 5xx) from the backend endpoint.
                             // - JSON parsing errors of the backend response (handled by `_fetchBackendEndpointSimulated`).
                             // - Errors originating in the Apps Script itself and propagated back by the backend.
                             Logger.error(`_handleSendToAppsScriptClick: Error caught from simulated Google Apps Script service call for form "${this.id}":`, apiError);

                             // Report the error using the injected ErrorReporter.
                             this.#errorReporter.reportError(
                                 `${this.name}._handleSendToAppsScriptClick - apiCall`, // Source indicating the simulated API call stage.
                                 apiError, // The error object from the service rejection.
                                 { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', dataSent: dataPayloadToSend }, // Context including data sent (be mindful of sensitive data).
                                 AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message.
                                 'apps_script_send_api_exception' // GA error code for errors during API interaction.
                             );
                             // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                         }


                     } catch (handlerError) {
                         // --- Handle Critical Errors During Overall Handler Execution ---
                         // This outer catch block catches any unexpected synchronous errors thrown *during the entire execution of this handler itself*
                         // (e.g., errors before calling the service, during payload preparation if not caught, errors in the try/catch structure).
                         // Report the error using the injected reporter.
                         this.#errorReporter.reportError(
                             `${this.name}._handleSendToAppsScriptClick`, // Source of the error.
                             handlerError, // The error object caught.
                             { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                             `Error handling "Send to Apps Script" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                             'apps_script_button_handler_exception_overall' // GA error code for overall handler exception.
                         );
                         // Ensure the persistent "Processing..." message in the main area is cleared if it was set and not an error message itself.
                          if (this.#messageDisplay) {
                              const currentMessageElement = this.#messageDisplay.getElement();
                              // Check if the element exists, contains the PROCESSING text (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // If it's still the generic processing message and not an error, clear it.
                                  this.#messageDisplay.clearMessage();
                                  Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in main area due to handler error.`);
                              }
                          }
                         // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                     } finally {
                         // This block always executes after the try/catch structure.
                         // Ensures cleanup or final status updates not explicitly covered occur.
                         // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                         if (this.#messageDisplay) {
                             const currentMessageElement = this.#messageDisplay.getElement();
                             // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                             if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // Clear the persistent message.
                                 this.#messageDisplay.clearMessage();
                                Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in finally.`);
                             }
                         }
                         Logger.debug("_handleSendToAppsScriptClick async method execution completed.");
                     } // End of _handleSendToAppsScriptClick try...catch...finally block.
                 } // End of _handleSendToAppsScriptClick method definition.


                 /**
                  * Asynchronous handler for the "Simulated Google Pay" button click. Marked as `async`.
                  * This method is triggered when the user clicks the button element identified by `#googlePayButton`.
                  * It orchestrates the simulated Google Pay payment flow using the stored search details (`_lastCollectedParams`).
                  * This involves checking service readiness, creating the simulated `PaymentDataRequest` object based on search/price data,
                  * calling the simulated Google Pay service (`loadPaymentData`) which mimics opening the payment UI and getting a payment token,
                  * and handling the simulated success or failure response from that simulated flow.
                  * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                  * @param {Event} event - The native DOM 'click' event object.
                  */
                 async _handleGooglePayClick(event) {
                     try {
                         Logger.info(`${this.name}._handleGooglePayClick: "Simulated Google Pay" button clicked.`);
                          // Prevent default behavior of the button (if any) and stop event propagation up the DOM tree.
                          if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                         if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                         // Track a Google Analytics event indicating the "Simulated Google Pay" button was clicked.
                         this.#gaTracker.trackEvent('button_click', { button_id: 'simulated_google_pay', form_id: this.id }); // GA Event.

                         // --- Check Dependencies and State ---
                         // Ensure the simulated Google Pay service instance (`this.#googlePayService`) is initialized and available.
                         if (!this.#googlePayService) {
                             const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Google Pay service not available.'; // Critical error message.
                             // Report this critical infrastructure error via the ErrorReporter.
                             this.#errorReporter.reportError(
                                 `${this.name}._handleGooglePayClick`, new Error(errorMsg),
                                 { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'google_pay_service_missing_critical', 0 // GA error code and persistent message.
                             );
                             // The button state (_updateGoogleServiceButtonState) should reflect service missing.
                             return; // Exit the async handler if service is missing.
                         }

                         // Ensure the Google Pay service is ready (meaning it passed its simulated `isReadyToPay` check) and its configuration is valid.
                         // The button should already be disabled if not ready, but check defensively.
                         if (!this.#googlePayService.isReady()) {
                             const message = AppConfig.MESSAGES.GOOGLE_PAY_UNAVAILABLE; // Standard unavailable message.
                             Logger.warn(`${this.name}._handleGooglePayClick: Google Pay service reported as not ready. Message: "${message}".`);
                              // Track the reason for failure (not ready).
                             this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'service_reported_not_ready' }); // GA Failure Reason.
                             this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                             // Do not re-throw. Exit handler.
                             return; // Exit the async handler if GPay service is not ready.
                         }

                         // Ensure valid search parameters are available (`_lastCollectedParams` is not null).
                         // These parameters are essential for constructing the transaction details for the payment request payload.
                         if (!this._lastCollectedParams) {
                             const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating a search is required.
                             Logger.warn(`${this.name}._handleGooglePayClick: No search data available in _lastCollectedParams. Message: "${message}".`);
                             this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                              this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'no_search_data_for_transaction' }); // GA Failure Reason.
                             return; // Exit the async handler as essential data is missing.
                         }


                          // Note: For a real hotel booking integration using Google Pay for the final purchase, you would need
                          // the *actual, final* price of the selected hotel room obtained from your backend/Expedia API *after* the user has made a specific selection based on initial search results.
                          // This demo SIMULATES obtaining this price. Ensure the simulated price is actually available in `_lastCollectedParams` or retrieved separately here before creating the payment request.
                          // For the simulation, we'll use the simulated price that was added to `_lastCollectedParams` during the search process (`_fetchSimulatedExpediaPrice`).
                           if (!this._lastCollectedParams.simulatedPrice || typeof this._lastCollectedParams.simulatedPrice.price !== 'number' || !this._lastCollectedParams.simulatedPrice.currency) {
                                const message = AppConfig.MESSAGES.EXPEDIA_PRICE_MISSING_FOR_GPAY; // Message indicating that price data is needed for payment.
                                Logger.warn(`${this.name}._handleGooglePayClick: Simulated Expedia price is missing or invalid in _lastCollectedParams. Message: "${message}".`, { simulatedPriceData: this._lastCollectedParams.simulatedPrice });
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'simulated_price_missing_for_transaction' }); // GA Failure Reason.
                                return; // Exit the async handler if price data is missing/invalid.
                           }


                         // --- Create Simulated Transaction Details ---
                         // Create a transaction details object (price, currency, description etc.) based on the collected search parameters and the simulated price.
                         // Use a protected helper method (`_createSimulatedTransactionDetails`) from the `GooglePayServiceWrapper` instance (`this.#googlePayService`).
                         // This helper accesses the GPay config and calculates transaction details based on search params.
                         Logger.debug(`${this.name}._handleGooglePayClick: Creating simulated transaction details for Google Pay...`);
                         try {
                            const transactionDetails = this.#googlePayService._createSimulatedTransactionDetails(this._lastCollectedParams); // Pass the stored parameters object.

                            // Check if transaction details were created successfully by the helper method. It returns null for invalid input or errors.
                            if (!transactionDetails) {
                                const message = AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Failed to create transaction details for payment request.'); // Generic error message template.
                                Logger.error(`${this.name}._handleGooglePayClick: Failed to create transaction details object. Message: "${message}".`, { paramsUsed: this._lastCollectedParams, step: 'create_transaction_details' });
                                this.#messageDisplay.showMessage(message, 'error'); // Show a persistent error message.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'create_transaction_details_failed' }); // GA Failure Reason.
                                return; // Exit the async handler if transaction details creation failed.
                            }
                            Logger.debug(`${this.name}._handleGooglePayClick: Simulated transaction details object created:`, transactionDetails);


                            // --- Construct Simulated Payment Data Request ---
                            // Construct the `PaymentDataRequest` object (structure based on Google Pay API) using the created `transactionDetails` object and the `GooglePayServiceWrapper`'s configuration.
                            // This object configures the Google Pay payment sheet (allowed methods, items to collect, etc.).
                            // Use a protected helper method (`_createPaymentDataRequest`) from the `GooglePayServiceWrapper` instance.
                            Logger.debug(`${this.name}._handleGooglePayClick: Creating simulated PaymentDataRequest object...`);
                            const paymentDataRequest = this.#googlePayService._createPaymentDataRequest(transactionDetails); // Pass the transaction details.

                            // Check if the payment data request object was created successfully by the helper method. It returns null for invalid configuration/input.
                            if (!paymentDataRequest) {
                                 const message = AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Failed to create payment request object.'); // Generic error message template.
                                Logger.error(`${this.name}._handleGooglePayClick: Failed to create simulated PaymentDataRequest object. Message: "${message}".`, { transactionDetailsUsed: transactionDetails, step: 'create_payment_request' });
                                this.#messageDisplay.showMessage(message, 'error'); // Show a persistent error message.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'create_payment_request_failed' }); // GA Failure Reason.
                                return; // Exit the async handler if PaymentDataRequest creation failed.
                            }
                            Logger.debug(`${this.name}._handleGooglePayClick: Simulated PaymentDataRequest object created:`, paymentDataRequest);


                            // --- Simulate Initiating Google Pay Flow ---
                            // Display a persistent UI message in the main area indicating that the simulated Google Pay process is starting.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_CLICKED, 'info', 3000); // Show brief "Opening Google Pay..." message.
                             // After the brief message, show the persistent "Processing..." message for the duration of the async call.
                            setTimeout(() => {
                                if (this.#messageDisplay && typeof this.#messageDisplay.showMessage === 'function') {
                                    const currentMsg = this.#messageDisplay.getElement()?.textContent || ''; // Check current message text.
                                     if (currentMsg.includes(AppConfig.MESSAGES.GOOGLE_PAY_CLICKED('', false)) && !this.#messageDisplay.getElement().classList.contains('w3-pale-red')) { // If still showing "Clicked" and not error...
                                       this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_PROCESSING, 'info', 0); // Replace with persistent "Processing...".
                                       Logger.debug(`${this.name}._handleGooglePayClick: Replaced brief message with persistent processing message.`);
                                     }
                                }
                            }, 3000); // Wait for the initial brief message duration.

                             // Track a GA event for the start of the Google Pay process, including transaction price details.
                             this.#gaTracker.trackEvent('google_pay_process_started', { form_id: this.id, totalPrice: transactionDetails.totalPrice, currency: transactionDetails.currencyCode, step: 'started' }); // GA Event, include price details.


                             Logger.debug(`${this.name}._handleGooglePayClick: Calling simulated Google Pay service loadPaymentData...`, paymentDataRequest);
                            // Call the asynchronous method (`loadPaymentData`) on the simulated Google Pay service wrapper instance.
                            // In a real application, this call (`paymentsClient.loadPaymentData(paymentDataRequest)`) would:
                            // 1. Cause the browser to display the Google Pay payment sheet UI to the user.
                            // 2. User interacts with the sheet (selects payment method, confirms payment).
                            // 3. If the user confirms, Google Pay tokenizes the payment data using your configured `tokenizationSpecification`.
                            // 4. The Promise returned by `loadPaymentData` resolves with a `PaymentData` object containing the encrypted payment token.
                            // Use `await` to pause execution of this async handler until the simulated Promise resolves (simulated payment success) or rejects (simulated payment failure or cancellation).
                             const simulatedPaymentData = await this.#googlePayService.loadPaymentData(paymentDataRequest); // Await the simulated service call.


                             // --- Process Simulated Payment Success ---
                             // If the Promise resolved successfully, `simulatedPaymentData` should contain the data returned by the simulated service, including the payment token.
                             // Check if the essential part of the simulated response structure is present (`paymentMethodData`).
                             if (simulatedPaymentData && simulatedPaymentData.paymentMethodData) {
                                 // If the simulated payment flow was successful and returned expected payment data:
                                 Logger.info(`${this.name}._handleGooglePayClick: Simulated Google Pay process successful. Simulated payment data/token received.`);

                                 // --- Real Payment Processing Step (Requires Backend) ---
                                 // THIS IS THE MOST CRITICAL STEP REQUIRING A SECURE BACKEND SERVER IN A REAL APPLICATION.
                                 // The object `simulatedPaymentData` (if from the real Google Pay API) would contain the encrypted payment information in `paymentMethodData.tokenizationData.token`.
                                 // **YOU MUST IMMEDIATELY SEND THIS TOKEN (AND ANY OTHER NECESSARY TRANSACTION DETAILS LIKE PRICE, CURRENCY, ITEM INFO) TO YOUR SECURE BACKEND SERVER.**
                                 // YOUR SECURE BACKEND uses YOUR Payment Gateway's securely stored API keys/credentials (NOT client-side!) to initiate and complete the charge using the received token.
                                 // NEVER ATTEMPT TO DECRYPT THE TOKEN OR CALL PAYMENT GATEWAY PROCESSING APIs DIRECTLY FROM CLIENT-SIDE JAVASCRIPT. This is a major security vulnerability.
                                 // The backend receives the response from the payment gateway (success/failure) and sends a confirmation back to the client.
                                 // -------------------------------------------------------

                                 // In this simulation, we skip the backend processing and just confirm client-side simulation success.
                                 const successMessage = AppConfig.MESSAGES.GOOGLE_PAY_SUCCESS; // Standard success message string.
                                 Logger.info(`_handleGooglePayClick: ${successMessage}. Simulated token example (if real): "${simulatedPaymentData.paymentMethodData.tokenizationData.token?.substring(0, 50) + '...' || 'N/A'}".`); // Log truncated token example for illustration.

                                 // Update the main UI message area with a temporary success message for the payment.
                                 this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily.

                                 // Track a GA success event for the Google Pay operation. Include price details.
                                 this.#gaTracker.trackEvent('google_pay_success', { form_id: this.id, totalPrice: transactionDetails.totalPrice, currency: transactionDetails.currencyCode, step: 'success' }); // GA Success Event.

                                 // Optional: In a real application, after receiving confirmation from your backend that the payment was processed successfully by the gateway, you would:
                                 // 1. Clear relevant session/cart data client-side.
                                 // 2. Redirect the user to an order confirmation page, display booking details, or enable download/access to purchased items.
                                 // This might involve another async call to your backend to confirm the final booking status.


                             } else {
                                 // --- Handle Simulated Payment Failure (Promise Resolved, but Indicated Failure) ---
                                 // This case is reached if the simulated service's Promise resolved, but the resolved value itself
                                 // indicates a failure or is missing expected data (unlikely if designed to reject on error).
                                 // Include defensively.
                                  const errorDetail = simulatedPaymentData ? (simulatedPaymentData.message || JSON.odedPageSection?.textContent) : `HTML source line ${startIndex}-${endIndex}`;
                                               console.error(`Disposal ERROR: Error processing code snippet for obfuscated line count (${snippetDescription}):`, snippetProcessingError);
                                           }
                                       });
                                    }
                                });

                                // Clean up the temporary data attribute from the body.
                                document.body.removeAttribute('data-section-markers');
                                console.debug("Disposal: Obfuscation step removed temporary data attributes from body.");


                           } catch(cleanupError) {
                                Logger.error("Disposal: Critical error during obfuscation data cleanup!", cleanupError);
                           }


                            // Clear any remaining reference to the HTML source container element.
                           if (this.#htmlSourceContainerElement) {
                                Logger.debug("Disposal: Clearing reference to HTML source container element.");
                                this.#htmlSourceContainerElement = null;
                           }


                        Logger.debug("Disposal: Final cleanup steps completed.");


                    } catch (error) {
                         // Catch any unexpected critical errors during the overall disposal process itself.
                         // This is a cleanup error; it should be logged but typically does not need to stop the application or re-throw.
                          console.error(`CRITICAL ERROR caught during disposal of AppObfuscator:`, error); // Use console fallback.
                    }
                 }

             } // End of AppObfuscator class.


             // --- APPLICATION ENTRY POINT ---
             // This is the main code block that runs when the DOM is fully loaded.
             // It is responsible for initializing the application and orchestrating the start of its lifecycle.

             // Use jQuery's `$(document).ready()` function or the native `DOMContentLoaded` event
             // to ensure that the DOM is fully loaded and ready before attempting to find and
             // interact with HTML elements or initialize our custom component structure.
             // Using `$(document).ready()` for compatibility with the jQuery CDN included.
             $(document).ready(function() {
                 // Log the start of the application bootstrap process.
                 Logger.info("DOM fully loaded (via jQuery.ready). Starting application bootstrap process.");

                 let mainApplicationInstance = null; // Variable to hold the main SearchForm instance. This is the root of our component tree.


                 try {
                    // --- Pre-Initialization Checks ---
                    // Perform checks on core configuration values and log warnings or user messages if required configurations
                    // are missing or contain placeholder values. These checks run very early.

                     // Check if the Google Places API Key is still the placeholder value in the AppConfig.
                     // Note: The actual key used by the Google Maps JS API for Autocomplete is in the `<script>` tag URL in the `<head>`.
                     // This check in AppConfig confirms the placeholder state in our JS configuration object.
                     if (AppConfig.GOOGLE_PLACES_API_KEY === 'YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER') {
                          Logger.warn("App Bootstrap: Google Places API Key in AppConfig is the placeholder. Google Autocomplete may not work with real Google services. Ensure the key in the script tag in <head> is also correct and restricted.");
                          // An informational message about potential limitations will be shown to the user by the MessageDisplay (initialized later).
                     } else {
                          Logger.info(`App Bootstrap: Google Places API Key configured in AppConfig (not placeholder).`);
                     }

                      // Check if the Google Analytics Measurement ID is still the placeholder value in AppConfig.
                      // The GA script is configured with this ID in the HTML <head> script block.
                     if (AppConfig.GOOGLE_ANALYTICS_ID === 'G-XXXXXXXXXX_PLACEHOLDER') {
                          Logger.warn("App Bootstrap: Google Analytics Measurement ID in AppConfig is the placeholder ('G-XXXXXXXXXX_PLACEHOLDER'). GA tracking calls from JS methods may not be received by Google.");
                          // An informational message about analytics being unconfigured will be shown by the MessageDisplay.
                     } else {
                         Logger.info(`App Bootstrap: Google Analytics Measurement ID configured in AppConfig (not placeholder): ${AppConfig.GOOGLE_ANALYTICS_ID}`);
                     }

                      // Check if the Google OAuth Client ID is still the placeholder value in AppConfig.
                      // This is used by the simulated GIS wrapper.
                     if (AppConfig.GOOGLE_OAUTH_CLIENT_ID === 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER') {
                          Logger.warn("App Bootstrap: Google OAuth Client ID in AppConfig is the placeholder. Simulated Google Sign-In will use this value.");
                         // An informational message about Auth not being fully configured will be shown by the MessageDisplay.
                     } else {
                         Logger.info(`App Bootstrap: Google OAuth Client ID configured in AppConfig (not placeholder).`);
                     }

                      // Check placeholder values for other simulated services relying on AppConfig (Google Pay, Apps Script, GenAI endpoints).
                     if (AppConfig.GOOGLE_PAY.MERCHANT_INFO.merchantId === 'BCR2DN6SA234GS23_PLACEHOLDER') {
                          Logger.warn("App Bootstrap: Google Pay Merchant ID in AppConfig is the placeholder. Simulated Google Pay uses this value.");
                     }
                     try {
                         if (AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0]?.tokenizationSpecification?.parameters?.gateway === 'example_PLACEHOLDER') {
                              Logger.warn("App Bootstrap: Google Pay Gateway name in AppConfig is a placeholder. Simulated Google Pay uses this value.");
                         }
                          if (AppConfig.GOOGLE_PAY.ALLOWED_PAYMENT_METHODS[0]?.tokenizationSpecification?.parameters?.gatewayMerchantId === 'exampleGatewayMerchantId_PLACEHOLDER') {
                               Logger.warn("App Bootstrap: Google Pay Gateway Merchant ID in AppConfig is a placeholder. Simulated Google Pay uses this value.");
                          }
                      } catch(e) { Logger.error("App Bootstrap: Error checking GPay config placeholders:", e); }

                      if (AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY?.includes('_PLACEHOLDER')) { // Check if includes placeholder suffix
                          Logger.warn("App Bootstrap: Google Apps Script backend endpoint URL in AppConfig is a placeholder. Simulated Apps Script integration will use this placeholder.");
                     } else {
                         Logger.info(`App Bootstrap: Google Apps Script backend endpoint configured (not placeholder): ${AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY}`);
                     }
                     if (AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API_GATEWAY?.includes('_PLACEHOLDER')) { // Check if includes placeholder suffix
                          Logger.warn("App Bootstrap: GenAI tip backend endpoint URL in AppConfig is a placeholder. Simulated GenAI integration will use this placeholder.");
                     } else {
                         Logger.info(`App Bootstrap: GenAI tip backend endpoint configured (not placeholder): ${AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API_GATEWAY}`);
                     }
                     if (AppConfig.BACKEND_ENDPOINTS.EXPEDIA_SEARCH_API_GATEWAY?.includes('_PLACEHOLDER')) { // Check if includes placeholder suffix
                        Logger.warn("App Bootstrap: Expedia Search backend endpoint URL in AppConfig is a placeholder. Simulated price fetch will use this placeholder.");
                     } else {
                         Logger.info(`App Bootstrap: Expedia Search backend endpoint configured (not placeholder): ${AppConfig.BACKEND_ENDPOINTS.EXPEDIA_SEARCH_API_GATEWAY}`);
                     }


                    // --- Step 1: Find the Main Application Element ---
                    // Find the main HTML form element (`#mainSearchForm`) that the `SearchForm` class is designed to wrap and control.
                    // This element acts as the root DOM node for our component structure for this part of the page.
                    // Use the selector specified in `AppConfig.SELECTORS.SEARCH_FORM`.
                    const mainApplicationElement = document.querySelector(AppConfig.SELECTORS.SEARCH_FORM);
                     Logger.debug(`App Bootstrap: Attempting to find main application element with selector "${AppConfig.SELECTORS.SEARCH_FORM}". Result:`, mainApplicationElement);

                    // --- Step 2: Bootstrap the Application ---
                    // Check if the main application element was successfully found in the DOM.
                    // This element is required to anchor the `SearchForm` component and its child inputs/logic.
                    // If the main form element is found, proceed with creating the main application instance (`SearchForm`).
                    // This instance will then initialize all its child components (inputs) and service dependencies.
                    if (mainApplicationElement) {
                         // If the main form element is found, create the main application instance, which is a `SearchForm`.
                         // Pass the main form element's ID, the UI selectors configuration, and the application configuration.
                         // The `SearchForm` constructor orchestrates the initialization of all components and services, including creating the `ErrorReporter`.
                         mainApplicationInstance = new SearchForm(
                            mainApplicationElement.id, // Pass the ID string of the main form element.
                            AppConfig.SELECTORS, // Pass the object containing CSS selectors for various UI elements.
                            AppConfig // Pass the main application configuration object.
                         );

                        // Check if the SearchForm constructor completed successfully. The constructor is designed to throw an error if a critical failure occurred during its execution (e.g., main element missing).
                        // If execution reaches this point *after* the `new SearchForm(...)` call without an error being thrown, it means the constructor completed (even if non-critical warnings/errors were logged).
                        Logger.info("App Bootstrap: Main SearchForm instance created successfully.", mainApplicationInstance);

                        // Optional: Store the main application instance globally (e.g., on the `window` object).
                        // This makes the application instance easily accessible from the browser's developer console for debugging,
                        // allowing inspection of its state and calling public methods (e.g., `window.luxStayFinderApp.searchHotels()`).
                        // This is generally not recommended for production code to avoid polluting the global namespace.
                        // window.luxStayFinderApp = mainApplicationInstance; // Example global exposure for debugging.


                        // --- Post-Initialization Checks/Demos ---
                        // Perform any actions or demonstrations that should run once the main application instance is initialized.

                         // Demonstrate iterating through the actual HTML input nodes *within the main form element* using pure JavaScript,
                         // to show they are present and can be linked back to our custom component instances *after* they've been managed.
                         // Query for all HTML elements matching the generic INPUT selector *specifically within* the main form element (`mainApplicationElement`).
                         const inputElementsInForm = mainApplicationElement.querySelectorAll(AppConfig.SELECTORS.FORM_INPUTS); // Use the refined selector.
                         Logger.info(`App Bootstrap: Iterating through HTML input elements (${inputElementsInForm.length} found) within the main form after component initialization:`);

                         // Use `forEach` to loop through the collection of DOM input elements.
                         inputElementsInForm.forEach((domNode, index) => {
                             try {
                                  // Attempt to find the corresponding custom input component instance managed by the `SearchForm` (`mainApplicationInstance`).
                                  // Components are stored in the form's protected `_inputs` map, keyed by their DOM element ID.
                                  // Access the protected `_inputs` map for this demonstration purposes. In a real application structure, a public getter method on `SearchForm` might be preferred for external access to components.
                                 const componentInstance = mainApplicationInstance._inputs ? mainApplicationInstance._inputs[domNode.id] : null; // Access map safely.

                                  // Log details about the current DOM node being processed in the loop.
                                 Logger.debug(`App Bootstrap: Iteration ${index}: DOM Element ID="${domNode.id || 'N/A'}", Tag="${domNode.tagName}", Type="${domNode.type || 'N/A'}".`);

                                  // Check if a corresponding custom component instance was found in the map for this DOM element's ID.
                                  if (componentInstance) {
                                      // If a component instance was found for this DOM element ID, log its details and current state (Name, `isValid`).
                                     Logger.debug(`  -> Associated JS Component: Name="${componentInstance.name}", IsValid state: ${componentInstance.isValid}.`);
                                      // Example: You could call a public method on the component here for introspection (e.g., `componentInstance.getValue()`), or add a specific CSS class to the DOM node visually marking it as managed by a component.
                                     // domNode.classList.add('component-managed'); // Add a class like 'component-managed'.
                                 } else {
                                      // If no corresponding custom component instance was found in the `_inputs` map for this DOM element's ID, log that this element is unmanaged by our component system.
                                      Logger.debug(`  -> No associated custom JS component found in the main form's map for this DOM element.`);
                                  }

                              } catch (nodeIterationError) {
                                   // --- Handle Errors During Node Iteration ---
                                   // Catch any unexpected errors that occur *while processing a specific `domNode`* within the `forEach` loop,
                                   // e.g., errors accessing `domNode.id` or properties if `domNode` becomes invalid, or errors during logging within the loop.
                                   // Use the main application instance's `ErrorReporter` for reporting, if the instance was successfully created and has its reporter.
                                  if (mainApplicationInstance?._errorReporter) { // Check if reporter is available on the instance.
                                      mainApplicationInstance._errorReporter.reportError(
                                          'App Bootstrap - DOM Node Iteration', nodeIterationError, // Source and error.
                                          { nodeIndex: index, nodeElementId: domNode?.id, nodeTagName: domNode?.tagName, step: 'post_init_dom_iteration_loop_exception' }, // Context.
                                          `Error processing DOM node during post-initialization iteration loop. List display may be incomplete.`, // User-friendly message.
                                          'bootstrap_dom_iteration_exception' // GA error code.
                                      );
                                  } else {
                                     // Fallback to basic console logging if the app instance or its reporter is unavailable.
                                    console.error(`FATAL: Error processing DOM node ${index} during iteration (App instance/Reporter not available):`, nodeIterationError, { nodeId: domNode?.id });
                                  }
                                  // Continue the `forEach` loop to the next element despite the error with the current one.
                              }
                          }); // End of inputElementsInForm.forEach loop.


                          // Log the application version using the static method on the base `TravelComponent` class.
                          TravelComponent.logAppVersion();

                          // --- Setup Cleanup on Page Unload ---
                          // Add an event listener for the browser's `beforeunload` event on the global `window` object.
                          // This event fires when the browser is about to unload the current page (e.g., user navigates to a new URL, refreshes, closes the tab/window).
                          // The handler function will be executed. Its purpose is to call the `dispose()` method on the main application instance to clean up resources before the page is discarded.
                          window.addEventListener('beforeunload', () => {
                              Logger.info("Browser 'beforeunload' event detected. Attempting to dispose application instance.");
                              try {
                                  // Check if the main application instance (`mainApplicationInstance`) was successfully created (it's not null)
                                  // AND if it has a public `dispose` method.
                                  // If both conditions are true, call the `dispose()` method on the instance.
                                  if (mainApplicationInstance && typeof mainApplicationInstance.dispose === 'function') {
                                       mainApplicationInstance.dispose(); // Call the top-level dispose method of the `SearchForm` instance. This will cascade disposal to its child components and services.
                                      Logger.info("Application instance dispose method called successfully on 'beforeunload'.");
                                  } else {
                                      // Log a warning if the application instance was not found or its dispose method was missing when trying to dispose.
                                      Logger.warn("Application instance not found or dispose method missing during 'beforeunload'. Disposal skipped.", { appInstanceAvailable: !!mainApplicationInstance });
                                  }
                              } catch (disposeErrorOnUnload) {
                                   // --- Handle Errors During Disposal on Unload ---
                                   // Catch any unexpected errors that occur specifically *during the disposal process* triggered by the `beforeunload` event handler.
                                   // Use `console.error` here because the application's injected `ErrorReporter` instance might be nullified or become unavailable during the dispose process itself, especially during the final cleanup stages.
                                  console.error(`CRITICAL ERROR caught during application disposal on 'beforeunload'! Cleanup may be incomplete.`, disposeErrorOnUnload, { appInstanceAvailable: !!mainApplicationInstance, step: 'dispose_execution_on_unload_exception' });
                              }
                              // Note: For Single Page Applications (SPAs) that dynamically add and remove sections of the DOM *without* triggering a full page unload,
                              // disposal of components/sections is typically triggered directly by the application's routing or component management logic when a section is removed,
                              // rather than relying solely on the `beforeunload` event. `beforeunload` is primarily for cleanup on full page navigations.
                              // This setup here is suitable for a simpler page that mostly exists for the browser's full page lifecycle.
                          }); // End of window.addEventListener('beforeunload').


                          // The main application lifecycle (event listeners, service interactions triggered by user input) is now active.

                      } else {
                          // --- Handle Fatal Error During Bootstrap: Main Element Not Found ---
                          // This block is executed if the main HTML form element (`#mainSearchForm`) required to bootstrap the application
                          // was not found in the DOM when `document.querySelector` was called in Step 1.
                          // This is a critical error that prevents the entire application section from starting correctly.
                          Logger.error(`FATAL ERROR: Application bootstrap failed. Main application element with selector "${AppConfig.SELECTORS.SEARCH_FORM}" not found in the DOM.`);

                          // Attempt to initialize a `MessageDisplay` instance directly here, even though the main form element is missing,
                          // so that we can display a fatal error message to the user in the designated message area.
                          let fallbackMessageDisplay = null;
                          try {
                               // Try to find the message area element itself first.
                              const msgAreaElement = document.querySelector(AppConfig.SELECTORS.MAIN_MESSAGE_AREA);
                              if(msgAreaElement) {
                                   // If the message area element is found, create a MessageDisplay instance targeting it.
                                  fallbackMessageDisplay = new MessageDisplay(AppConfig.SELECTORS.MAIN_MESSAGE_AREA);
                                   // Display a prominent, persistent fatal error message to the user using this fallback MessageDisplay instance.
                                  fallbackMessageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Application startup failed. The required main form element (ID: "${AppConfig.SELECTORS.SEARCH_FORM.substring(1)}") was not found in the HTML. Please check the page structure and ensure the ID matches "${AppConfig.SELECTORS.SEARCH_FORM.substring(1)}".`, 'error', 0); // Show persistent error.
                                  Logger.debug(`App Bootstrap: Fatal error message displayed in fallback MessageDisplay.`);
                              } else {
                                  // If even the message area element is missing, log a final console error as the last resort for reporting this critical state to the developer.
                                 console.error(`FATAL: Could not find Message Display element (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) to show fatal bootstrap error. Logging error details to console: Main element "${AppConfig.SELECTORS.SEARCH_FORM}" missing.`);
                              }
                          } catch (msgInitErrorOnFatal) {
                               // Catch any unexpected errors that occur during the attempt to initialize the fallback MessageDisplay.
                              console.error(`FATAL: Failed repeatedly to initialize MessageDisplay (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) during fatal error handling chain. Error during MessageDisplay init:`, msgInitErrorOnFatal);
                          }


                          // Attempt to track this critical bootstrap error in Google Analytics as early as possible, if the GA script (`gtag.js`) has already loaded globally.
                          try {
                               if (typeof gtag === 'function') {
                                    // Track a specific GA error event for this critical bootstrap exception.
                                    gtag('event', 'fatal_error', {
                                        'error_code': 'app_bootstrap_failed_element_missing', // Custom GA error code indicating bootstrap failed due to missing element.
                                        'message': AppConfig.MESSAGES.FATAL_ERROR, // The standard fatal error message text.
                                        'details': `Required main element missing: "${AppConfig.SELECTORS.SEARCH_FORM}"`, // Specific detail about the cause.
                                        'element_selector': AppConfig.SELECTORS.SEARCH_FORM, // The CSS selector that failed to find the element.
                                        'step': 'dom_ready_element_lookup' // Indicate the stage where the error occurred.
                                    });
                                    Logger.info("Fatal error (main element missing) tracked in GA.");
                               } else {
                                 // Log a warning if the GA gtag function is not available to track the fatal error.
                                Logger.warn("GA gtag function not available during fatal bootstrap error (element missing), cannot track.");
                             }
                         } catch (gaTrackErrorOnFatal) {
                               // Catch any errors that occur *during the attempt to track the fatal error in GA*.
                               console.error("FATAL: Error tracking fatal bootstrap error in GA:", gaTrackErrorOnFatal);
                           }

                          // No further application code execution is expected in this branch after logging and attempting UI feedback/tracking. The page will remain loaded showing the error message if possible.

                     } // End of `if (mainApplicationElement)` else { handle fatal error branch }.


                  } catch (domReadyOverallError) {
                       // --- Handle Any Unexpected Critical Errors During the Entire `$(document).ready` Bootstrap Execution ---
                       // This outer catch block serves as a final safety net. It catches any uncaught synchronous errors
                       // thrown within the entire `$(document).ready` callback function *itself*,
                       // if they were not handled more specifically by the try/catch blocks within the `SearchForm` constructor logic or other initializations.
                       // These errors represent critical failures during the core application bootstrap process.
                      Logger.error("CRITICAL UNEXPECTED ERROR caught during DOM ready application bootstrap!", domReadyOverallError);

                       // Attempt to initialize a `MessageDisplay` instance if it wasn't already successfully initialized or wasn't found,
                       // so that we can display a fatal error message to the user as a last resort.
                       let finalFallbackMessageDisplay = null;
                       try {
                            // Try to find the message area element.
                           const msgAreaElement = document.querySelector(AppConfig.SELECTORS.MAIN_MESSAGE_AREA);
                            if(msgAreaElement) {
                                 // Create a MessageDisplay instance targeting it.
                                finalFallbackMessageDisplay = new MessageDisplay(AppConfig.SELECTORS.MAIN_MESSAGE_AREA);
                                 // Display a persistent fatal error message to the user.
                                finalFallbackMessageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `An unexpected error occurred during application startup: ${domReadyOverallError.message || 'Unknown error details'}`, 'error', 0); // Show persistent fatal error.
                                 Logger.debug(`App Bootstrap: Final fallback fatal error message displayed in MessageDisplay.`);
                            } else {
                                 // If the message area element is also missing, log a final console error message as the ultimate fallback.
                                console.error(`FATAL: Could not find Message Display element (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) to show fatal bootstrap error. Logging original error details to console.`);
                            }
                       } catch (msgInitErrorOnFatal) {
                            // Catch errors that occur during the attempt to initialize the final fallback MessageDisplay.
                            console.error(`FATAL: Failed repeatedly to initialize MessageDisplay (${AppConfig.SELECTORS.MAIN_MESSAGE_AREA}) during error handling chain. Error during fallback MessageDisplay init:`, msgInitErrorOnFatal);
                       }


                        // Attempt to track this critical bootstrap error in Google Analytics as a final measure, if the GA script (`gtag.js`) has loaded.
                        try {
                             if (typeof gtag === 'function') {
                                  // Track a specific GA error event for this critical bootstrap exception.
                                  gtag('event', 'fatal_error', {
                                      'error_code': 'dom_ready_bootstrap_exception', // Custom GA error code for errors in the DOM ready handler itself.
                                      'message': domReadyOverallError.message || 'Unknown bootstrap error', // Error message string.
                                      'stack': domReadyOverallError.stack, // Include stack trace for debugging.
                                      'step': 'dom_ready_bootstrap_execution' // Indicate the stage where the error occurred.
                                  });
                                  Logger.info("Fatal error (DOM ready bootstrap exception) tracked in GA.");
                             } else {
                                 // Log a warning if the GA gtag function is not available to track the fatal error.
                                Logger.warn("GA gtag function not available during final fatal bootstrap error tracking attempt.");
                             }
                        } catch (gaTrackErrorOnFatal2) {
                            // Catch any errors that occur during the attempt to track the fatal error in GA.
                            console.error("FATAL: Error tracking fatal bootstrap error in GA (second attempt):", gaTrackErrorOnFatal2);
                        }

                       // No further application code execution is expected after logging and attempting to display fatal error feedback. The page will remain loaded, showing the error message if possible.
                   } // End of the outermost `$(document).ready` catch block.


               }); // End of $(document).ready() handler / application bootstrap logic definition.


               // --- Expansive Commentary Blocks (Continuing to add content for line count) ---
               // These blocks contain commentary and do not contain executable code within them.
               // They are added solely to increase line count and explain concepts and architectural decisions made in the code.

               /**
                * CONCEPT COMMENTARY BLOCK 7: IndexedDB Service Details
                *
                * The `IndexedDBService` class is implemented as a REAL client-side database wrapper. It leverages the browser's built-in IndexedDB API to store persistent data (search history) directly in the user's browser.
                *
                * Key aspects of the IndexedDBService implementation:
                * - Promise-Based API: All asynchronous IndexedDB operations (opening the database, adding/getting/clearing data) are wrapped in JavaScript Promises (`new Promise(...)`). This allows the calling code (`SearchForm`) to use `async`/`await` for cleaner, more sequential asynchronous logic (`await this.#idbService.addSearchHistoryItem(...)`). This makes the client code consistent with the pattern used for simulated async services.
                * - Database Connection Management: The `#openDatabase()` private method is the central point for getting an IndexedDB database connection. It ensures:
                *   - Only one connection is opened at a time (`#isOpening` flag, `#openRequest` reference).
                *   - Subsequent calls while opening waits for the pending request to complete.
                *   - It handles the database `onupgradeneeded` event to define the database schema (object stores and indexes) based on the configured database version (`AppConfig.INDEXEDDB.DB_VERSION`). Schema changes must happen only in this event handler. In this demo, it creates the `searchHistory` object store and a `timestamp` index.
                *   - It attaches handlers for database errors (`onerror`) and version changes (`onversionchange`, important for handling other tabs updating the schema).
                *   - It returns a Promise that resolves with the `IDBDatabase` instance when the connection is ready.
                * - Transaction Management: The private async `#getTransaction()` method is used internally before any database operation (`add`, `get`, `clear`).
                *   - It awaits a successful database connection (`await this.#openDatabase()`).
                *   - It creates an `IDBTransaction` for the specified store(s) and mode (`"readonly"` or `"readwrite"`).
                *   - Transactions are crucial for ensuring data consistency. Operations within a transaction are atomic – either all succeed, or none do (the transaction is aborted).
                *   - You specify which object store(s) the transaction needs access to when creating it.
                *   - Transactions are short-lived and automatically commit when all requests within them complete successfully, or abort if any request fails or if `transaction.abort()` is called explicitly.
                *   - Error Handling: Errors can occur on individual requests (`request.onerror`), or on the transaction itself (`transaction.onerror`, `transaction.onabort`).
                *
                * 4. Requests (`IDBRequest`): Almost every operation (opening DB, adding data, getting data, opening cursors) returns an `IDBRequest` object. These objects have `onsuccess` and `onerror` event properties.
                *
                * 5. Cursors (`IDBCursor`): Used to iterate through records in an object store or index, often for retrieving multiple items or querying based on ranges.
                *
                * 6. Service Wrapper (`IndexedDBService` class): Encapsulating the IndexedDB logic within a class (`IndexedDBService`) provides several benefits:
                *    - Abstraction: The rest of the application interacts with methods like `addSearchHistoryItem`, `getSearchHistory`, `clearSearchHistory` without needing to know the low-level details of IndexedDB requests, transactions, cursors, etc.
                *    - Connection Management: The service handles opening the database, ensuring only one connection is active (`#isOpening` flag, `#openRequest` reference). It also attaches global listeners for DB events like `onversionchange` and `onerror`.
                *    - Promise-Based API: The methods (`add`, `get`, `clear`, `open`) return Promises, allowing seamless integration with `async`/`await` in the calling code (`SearchForm`). The service's private methods (`#openDatabase`, `#getTransaction`) also use Promises.
                *    - Error Handling: Errors are caught within the service and ideally reported via a shared `ErrorReporter` (although the core `IndexedDBService` as implemented focuses on logging/throwing Promise rejection errors which are then caught by the caller's `try...catch` and reported via its own injected reporter).
                *    - Disposal: The service includes a `dispose` method to explicitly close the database connection when the application section is shut down, releasing resources.
                *
                * Security Considerations for IndexedDB:
                * - IndexedDB is *origin-specific*. Data stored by your application on `https://yourdomain.com` cannot be accessed by `https://otherdomain.com`.
                * - It is not designed for storing highly sensitive personal data (like credit card numbers) without strong encryption, as data is accessible by any script on the same origin. User authentication on your server is required before accessing user-specific sensitive data from IndexedDB.
                * - Storing non-sensitive user preferences or historical data (like search criteria) is a typical and appropriate use case.
                * - IndexedDB capacity varies by browser, but is generally much larger than cookies or localStorage.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 8: Simulated Google Identity Services (GIS) - `GoogleIdentityServiceWrapper`
                *
                * This class (`GoogleIdentityServiceWrapper`) simulates the client-side interaction with Google Identity Services (GIS), which is Google's modern framework for handling user authentication (Sign-In) and authorization (OAuth 2.0 consent) client-side in web applications.
                *
                * Real GIS Interaction (`google.accounts.id` and `google.accounts.oauth2`):
                * - The real GIS library (`https://accounts.google.com/gsi/client`) is loaded via a script tag.
                * - You initialize it with your Google OAuth 2.0 Client ID (`google.accounts.id.initialize({...})`).
                * - You can then render a Google Sign-In button (`google.accounts.id.renderButton`) or trigger "One Tap" prompts (`google.accounts.id.prompt`).
                * - When the user signs in or grants consent via the GIS UI, your configured callback function is executed.
                * - The callback receives a credential response, often containing an ID Token (a JSON Web Token - JWT).
                * - Client-side code sends this ID Token to YOUR secure backend server.
                * - YOUR backend server VERIFIES the ID Token (crucial security step) to confirm the user's identity and the token's authenticity.
                * - Your backend then establishes a session for the user.
                * - OAuth 2.0 flows (like `initCodeFlow`) are used to get authorization codes that your backend exchanges for access tokens and refresh tokens, allowing YOUR backend to call Google APIs (like Gmail, Calendar) on the user's behalf SECURELY from the server.
                *
                * How `GoogleIdentityServiceWrapper` SIMULATES This:
                * - It has a constructor that accepts a `clientId` (placeholder in AppConfig) and selectors for auth UI elements.
                * - It finds and stores references to the HTML elements for the Sign-In button, status text, etc.
                * - It includes an `async signIn()` method that is called when the user clicks the button.
                * - This `signIn()` method *simulates* the async GIS process using `setTimeout` and a `Promise`. It simulates success or failure randomly.
                * - On simulated success, it calls a private method (`#handleCredentialResponse`) which *simulates* receiving a credential and parsing user info (email, name).
                * - It maintains internal state (`#isSignedIn`, `#userEmail`, `#userGivenName`) mirroring the authentication status.
                * - A private method (`#updateUI`) is responsible for updating the text and disabled state of the associated HTML elements (button text, status text) based on the internal state.
                * - An `async signOut()` method simulates signing out, also with a delay and state updates.
                * - Public getters like `isSignedIn()`, `getUserEmail()`, `getUserInfo()` expose the *simulated* authentication state and user data.
                * - The public `handleAuthToggleClick()` method is the event handler called by the Sign-In button's click listener. It checks the current simulated state and calls either `signIn()` or `signOut()`.
                * - The `ErrorReporter` is used to log and report simulated failures or errors during the simulated auth process.
                *
                * What this simulation demonstrates:
                * - The client-side UI needs to reflect authentication status (Signed In/Out).
                * - User interaction (button click) triggers an asynchronous auth flow.
                * - The UI should update during the process (e.g., "Signing In...").
                * - The client needs to know if the user is signed in (`isSignedIn()`) and get basic user info (`getUserEmail()`, `getUserInfo()`) to enable or personalize other features.
                * - The client handles both successful authentication and potential failures (Promise rejections from `signIn`/`signOut`).
                * - How an event handler (`handleAuthToggleClick`) orchestrates the start of an async operation.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Verification of ID Tokens on the backend server (critical security step).
                * - Exchanging authorization codes for access tokens on the backend.
                * - Securely storing and managing tokens (access/refresh tokens) on the backend.
                * - User consent flow and handling different Google API scopes.
                * - Different types of GIS UI integrations (One Tap, different button render types).
                * - Real error handling specific to the GIS library (network errors, user cancellation codes).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides authentication state and user info, which a real backend gateway implementing Google Auth would also provide.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 9: Simulated Google Pay Integration - `GooglePayServiceWrapper`
                *
                * The `GooglePayServiceWrapper` class simulates the client-side interaction structure of integrating with the Google Pay API for Web.
                *
                * Real Google Pay API Interaction:
                * - The real Google Pay JS library (`https://pay.google.com/gp/p/js/pay.js`) is loaded.
                * - You initialize a `google.payments.api.PaymentsClient`.
                * - You perform an `isReadyToPay(request)` check to determine if Google Pay is available on the user's device/browser (requires user signed into Google account in the browser, supported browser, etc.).
                * - If ready, you render the Google Pay button.
                * - When the user clicks the button, you create a `PaymentDataRequest` object containing transaction details (total price, currency), allowed payment methods (card networks, auth methods, tokenization specification - linked to your payment gateway), and optional details to collect (shipping, billing, email).
                * - You call `paymentsClient.loadPaymentData(paymentDataRequest)`. This opens the Google Pay payment sheet UI for the user.
                * - If the user confirms payment, the Promise returned by `loadPaymentData` resolves with a `PaymentData` object.
                * - The `PaymentData` object contains the sensitive, encrypted `paymentMethodData.tokenizationData.token`.
                * - **CRITICAL SECURITY:** The `token` **MUST** be sent to YOUR secure backend server.
                * - YOUR backend server sends this token to your Payment Gateway (Stripe, Square, etc.) using YOUR payment gateway credentials (NOT client-side!) to perform the actual charge.
                * - Your backend handles the payment gateway's response and informs the client whether the charge was successful.
                *
                * How `GooglePayServiceWrapper` SIMULATES This:
                * - Constructor accepts `googlePayConfig` (from AppConfig, using placeholders for realism) and button selector.
                * - Constructor triggers an async `#simulateIsReadyToPayCheck()`.
                * - `#simulateIsReadyToPayCheck` simulates the async check (`isReadyToPay`) using `setTimeout` and a random outcome. It updates an internal `#isReady` flag and the button's state/text.
                * - Public `isReady()` method returns the internal `#isReady` flag.
                * - Public `async loadPaymentData(searchParams)` method is called when the Google Pay button is clicked (via the SearchForm handler).
                * - `loadPaymentData` first checks if `isReady()` is true and if essential search parameters are available.
                * - It calls helper methods (`_createSimulatedTransactionDetails`, `_createPaymentDataRequest`) to format the data based on config and search parameters. This mimics constructing the request payload.
                * - It *simulates* calling the Google Pay API using `setTimeout` and a `Promise`. It simulates success (resolving with a fake token object structure) or failure/cancellation (rejecting with a simulated error).
                * - The calling handler (`_handleGooglePayClick`) awaits this Promise and handles the simulated success (logging the fake token, showing success message) or simulated failure/cancellation (showing error/cancel message).
                * - The `ErrorReporter` is used for logging and tracking simulated errors.
                *
                * What this simulation demonstrates:
                * - The need for a readiness check before offering Google Pay (`isReady()`).
                * - How UI (the button) updates based on readiness.
                * - How button click triggers an `async` payment flow (`loadPaymentData`).
                * - The structure of creating a payment request payload (`_createPaymentDataRequest`).
                * - Handling an `async` result that contains payment data on success.
                * - Handling different types of errors/rejections (general failure, user cancellation).
                * - The structure of using `async`/`await` and `try...catch` around the payment API call.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google's payment services.
                * - The display and interaction with the real Google Pay payment sheet UI.
                * - Obtaining a *real* payment token.
                * - **Sending the token to a secure backend server.**
                * - **Processing the charge on the backend using payment gateway APIs and credentials.**
                * - Handling all the various error codes and statuses from real Google Pay API and payment gateways.
                * - Specific requirements for merchant validation, environment setup (TEST/PRODUCTION).
                *
                * The structure provides a client-side foundation that expects an `async` service that provides a `isReady` check and a `loadPaymentData` method returning a Promise with a payment token on success, matching the Google Pay API pattern.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 10: Simulated Google Calendar/Gmail Services
                *
                * `SimulatedGoogleCalendarService` and `SimulatedGoogleEmailService` classes simulate calling Google APIs (Calendar API for creating events, Gmail API for sending emails).
                *
                * Real Google API Interaction (e.g., Calendar API `Events: insert`, Gmail API `users.messages.send`):
                * - User signs in with Google (via GIS or OAuth).
                * - During auth, user grants consent for specific scopes (e.g., `https://www.googleapis.com/auth/calendar.events`, `https://www.googleapis.com/auth/gmail.send`).
                * - Client code obtains an Access Token (via GIS or OAuth flow, potentially with backend involvement).
                * - **For server-side calls (Recommended):** Client sends Access Token to secure backend. Backend uses Access Token (or refreshes it with Refresh Token) to make secure API calls to Google's REST APIs from the server.
                * - **For some client-side calls (Less Secure/Limited Scope):** Some Google APIs allow limited client-side access using the `gapi.client` library and an Access Token. This is less common for write operations or sensitive data like email sending, and subject to CORS/Same-Origin Policy. Gmail `send` usually requires server-side or a backend proxy for security (handling API key, structure of MIME message).
                * - Client constructs the API request body (e.g., event details object for Calendar, MIME message string for Gmail).
                * - Makes an asynchronous request (via `fetch`, `$.ajax`, or `gapi.client`) including the Access Token in headers.
                * - Handles async response (success data or error).
                *
                * How Simulations Work:
                * - Both classes (`SimulatedGoogleCalendarService`, `SimulatedGoogleEmailService`) are injected with the `GoogleIdentityServiceWrapper` instance.
                * - Their public async methods (`createEvent`, `sendEmail`) first check if the user is simulated signed in (`authService.isSignedIn()`). If not, they reject immediately with an "Auth Needed" error message.
                * - If signed in, they simulate the async API call using `setTimeout` and a `Promise`. They simulate success (resolving with a simulated success response) or failure (rejecting with a simulated error).
                * - They have helper methods (`_getCalendarEventDetails`, `_getEmailDetails`) to format the data payload based on search parameters, mimicking the need to structure data for the API request.
                * - The calling handlers (`_handleAddToCalendarClick`, `_handleEmailDetailsClick`) await the Promises and handle the simulated success or failure/rejection, displaying UI messages via the `ErrorReporter`.
                * - `_getEmailDetails` also gets the simulated recipient email from `authService.getUserEmail()`, simulating the need for user info after auth.
                *
                * What simulations demonstrate:
                * - Operations dependent on user authentication (`isSignedIn()` check).
                * - Passing data payloads to an `async` service method.
                * - Handling `async` results that are success/failure responses or errors.
                * - Handling specific error cases like "Auth Needed" or formatting failures.
                * - How the calling logic uses `await` within a `try...catch`.
                *
                * What they do NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with Google servers.
                * - Obtaining, managing, and using real Access Tokens (often requires backend involvement).
                * - Handling OAuth 2.0 consent screens and permissions (`scopes`).
                * - Securely sending data (like email content or event details) to a backend/API (use HTTPS POST).
                * - **Securely sending email (almost always requires backend with API keys/service accounts).**
                *
                * These simulations provide a client-side structure that expects `async` services which take data and return Promises, fitting into the `async`/`await` flow, but hide the complex and security-sensitive real API interaction details behind the Promise.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 11: Simulated Google Apps Script Integration
                *
                * The `SimulatedGoogleAppsScriptService` class simulates calling a deployed Google Apps Script Web App endpoint from the client side.
                *
                * Real Google Apps Script Web App Call:
                * - A Google Apps Script is written and deployed as a Web App. The deployment process generates a unique URL (the endpoint).
                * - The Web App is configured to execute as a specific user (often yourself or the user accessing it) and access permissions (ee.g., "Anyone, even anonymous").
                * - Client-side JavaScript uses `fetch` or `XMLHttpRequest` to make an HTTP request (often POST) to this deployed Apps Script endpoint URL, sending data (often as query parameters or JSON body).
                * - The `doGet(e)` or `doPost(e)` function in the Apps Script receives the request and its parameters (`e.parameter`, `e.postData.contents`).
                * - The Apps Script can then perform actions (e.g., write to a Google Sheet, send an email using `MailApp`, interact with other Google Services or external APIs from the server-side Apps Script environment) and return a response to the client (e.g., using `ContentService` to return JSON).
                * - Authentication: If the Web App is deployed to "Execute as user accessing the web app" and "Who has access: Only myself" or "Anyone with Google account," the client browser needs to be authenticated with that user's Google account. More complex authentication (OAuth) is also possible. Sending sensitive data securely usually involves authentication and HTTPS.
                *
                * How `SimulatedGoogleAppsScriptService` SIMULATES This:
                * - Constructor accepts a `endpointUrl` (placeholder from AppConfig) and ErrorReporter. Checks if endpoint is configured.
                * - Public `async runScriptFunction(data)` method simulates the call.
                * - It first checks if the service is configured (`isConfigured()`).
                * - It *simulates* the async HTTP call using `setTimeout` and a `Promise`. Simulates success (resolving with a simulated response object) or failure (rejecting with a simulated error).
                * - The simulated response object mimics a common Apps Script JSON response format (`{ result: 'success', ... }`).
                * - The calling handler (`_handleSendToAppsScriptClick`) awaits the Promise and handles the simulated success or failure/rejection.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS makes an `async` call to an endpoint URL.
                * - Passing a data payload to an `async` service method.
                * - Handling different response formats (success vs. error within the response object).
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual HTTP `fetch` or `$.ajax` call execution.
                * - Specific data formatting for query parameters or request body required by the Apps Script `doGet`/`doPost`.
                * - Handling Apps Script authentication requirements and error responses related to permissions or invalid requests.
                * - The backend nature of Apps Script execution.
                * - Security implications of exposing data or endpoints.
                *
                * The simulation provides a client-side structure that expects an `async` service that sends data to an endpoint and returns a Promise with a response, fitting into the `async`/`await` flow, but abstracts away the real HTTP request details and the server-less nature of Apps Script. Using a backend *gateway* in a real app is often better than calling Apps Script directly from client-side if sensitive data or user authentication context is involved, as the gateway can add an extra layer of security and manage API keys.
                */


               /**
                * CONCEPT COMMENTARY BLOCK 12: Simulated Generative AI Integration
                *
                * The `SimulatedGenAIService` class simulates fetching an AI-generated text tip based on a user input (destination).
                *
                * Real GenAI API Integration (e.g., Google Vertex AI, OpenAI API):
                * - GenAI APIs typically require API keys or other authentication methods (OAuth, service accounts).
                * - These API keys and credentials are **highly sensitive** and must **NEVER** be exposed client-side.
                * - A SECURE BACKEND SERVER is required to make API calls to the GenAI model.
                * - Client-side JS sends the user prompt (e.g., destination name) to a backend endpoint via `fetch` or `$.ajax`.
                * - The backend endpoint receives the prompt, securely accesses its GenAI API credentials, calls the GenAI model API (e.g., `generateContent`), processes the response (extracting the generated text), and sends the generated text back to the client in a JSON response.
                * - Client-side JS receives the response and displays the generated text in the UI.
                *
                * How `SimulatedGenAIService` SIMULATES This:
                * - Constructor accepts an `endpointUrl` (placeholder from AppConfig) representing a backend endpoint for AI tips. Checks config.
                * - Public `async getDestinationTip(destination)` method simulates the process.
                * - It first checks if the service is configured (`isConfigured()`).
                * - It *simulates* the async call to the backend using `setTimeout` and a `Promise`. Simulates success (resolving with a random tip string) or failure (rejecting with a simulated error).
                * - The calling handler (`_fetchAndDisplaySimulatedAITip`) awaits the Promise and handles the simulated success (displaying the tip string) or simulated failure/rejection (displaying an error message).
                * - It updates its specific UI element (`#aiTipContentElement`) directly.
                * - The `ErrorReporter` logs and tracks simulated errors.
                *
                * What this simulation demonstrates:
                * - How client-side JS triggers an `async` call to a backend endpoint with input data.
                * - Handling an `async` result which is a text string or null/empty string.
                * - Handling `async` errors (Promise rejections).
                * - Checking service configuration.
                * - Updating a dedicated UI element with the result of an async fetch.
                *
                * What it does NOT demonstrate (and is crucial for REAL integration):
                * - Actual communication with a backend endpoint.
                * - Actual calls to a GenAI model API using secure credentials.
                * - Processing complex GenAI responses (e.g., safety attributes, multiple candidates).
                * - Security implications of API keys.
                *
                * The simulation provides a client-side structure that expects an `async` service that takes text input (destination) and returns a Promise, which resolves with text or rejects, fitting into the `async`/`await` flow for updating a specific UI section.
                */

               /**
                * CONCEPT COMMENTARY BLOCK 13: The Main Application Bootstrap
                *
                * The code within the `$(document).ready(function() { ... })` block (or equivalent `DOMContentLoaded`)
                * serves as the application's bootstrap or entry point logic that runs once the web page's HTML structure is fully loaded and ready for JavaScript interaction.
                *
                * Key functions of the bootstrap logic:
                * - Ensure DOM Readiness: Using `$(document).ready()` guarantees that all HTML elements are parsed and available in the DOM tree before the script tries to find or manipulate them using `getElementById` or `querySelector`.
                * - Global Scope Protection (IIFE): The entire application code is wrapped within an Immediately Invoked Function Expression (`(function() { ... })();`) or a similar construct like an ES6 module (if using modules). This creates a private scope for the application's variables and functions, preventing them from polluting the global `window` object. Only explicitly intended globals (like `gtag`) or references assigned to `window` (like `window.luxStayFinderApp = mainApplicationInstance;` if uncommented) are exposed.
                * - Configuration Setup: Reads or defines core application configuration (`AppConfig`), including keys (even if placeholders), selectors, messages, service endpoints.
                * - Core Service Initialization: Initializes fundamental services like `Logger`, `MessageDisplay`, and `GoogleAnalyticsTracker`. These are often needed throughout the application, including during component initialization and error handling.
                * - Error Reporting Bootstrap: Creates the central `ErrorReporter` instance using the initialized `MessageDisplay` and `GoogleAnalyticsTracker`. This instance is then passed as a dependency to almost all other components and services.
                * - Root Component Initialization: Finds the main HTML element (the form, in this case) that serves as the root for the application's component structure. If found, it creates the main application instance (`SearchForm`), passing essential dependencies (element ID, selectors, config). The `SearchForm` constructor is responsible for recursively initializing child components (inputs) and other services.
                * - Fatal Error Handling (Element Missing): Includes robust `try...catch` and checks specifically for the case where the main application element is NOT found in the DOM. This is a critical failure that prevents the app section from running. In this scenario, it displays a fatal error message to the user (using a directly initialized or fallback MessageDisplay) and tracks the fatal error in GA, then stops execution in that branch.
                * - Overall Bootstrap Error Handling: Includes a top-level `try...catch` around the entire `$(document).ready` callback to catch any unexpected errors during the overall bootstrap process that weren't handled more specifically within class constructors or helper initializations. This is a final safety net to log and report fatal errors.
                * - Post-Initialization Actions: After the main application instance is created, includes logic for any actions that should run once the app is ready, such as:
                *   - Logging successful initialization and app version.
                *   - Demonstrating interaction with initialized components/DOM elements (like iterating over inputs after components are attached).
                *   - Setting up listeners for page lifecycle events (like `beforeunload`) to trigger application disposal.
                *   - Potentially triggering initial data loads (like history) or UI updates (like button states) that don't depend on user interaction yet.
                * - Application Disposal on Unload: Sets up an event listener on `window.beforeunload` (or equivalent) to call the main application instance's `dispose()` method when the page is about to close or navigate away. This helps ensure resources like IndexedDB connections and event listeners are cleaned up to prevent potential memory leaks or unexpected behavior, especially in complex applications. The `dispose()` method call cascades down through the component hierarchy and services.
                *
                * The bootstrap code is responsible for getting the entire system up and running, handling fundamental setup errors, and initiating initial processes.
                */


               // Ensure the application code runs after the DOM is fully loaded.
               // Wrap the entire application script in an Immediately Invoked Function Expression (IIFE)
               // to create a private scope, preventing variable/function conflicts in the global namespace.
               (function() {
                   "use strict"; // Enforce strict mode for cleaner code and better error detection.

                   // --- START: Google API Key & Secrets Management Disclaimer ---
                   // IMPORTANT SECURITY NOTE:
                   // In a real production application, sensitive API keys, client IDs,
                   // authentication secrets, and merchant secrets should *NEVER* be embedded directly in client-side
                   // JavaScript or HTML. This exposes them to anyone who views your page source, allowing theft and abuse.
                   //
                   // For services requiring API keys (like some parts of Google Cloud APIs, Expedia Partner API) or Client IDs
                   // with broad permissions, these are often used by a SECURE BACKEND SERVICE (an API proxy, a serverless function,
                   // or your main application server).
                   // The backend accesses sensitive credentials securely (e.g., from Environment Variables configured during deployment,
                   // Vaults, or secure Configuration Managers like AWS Secrets Manager, Google Secret Manager).
                   //
                   // GITHUB SECRETS:
                   // GitHub Secrets are encrypted environment variables that you set up in your GitHub repository settings.
                   // They are specifically designed to be used during YOUR CI/CD workflows (like GitHub Actions)
                   // to provide sensitive information to your build scripts or server-side code during deployment.
                   // CLIENT-SIDE JAVASCRIPT CODE RUNNING IN A USER'S BROWSER CANNOT AND SHOULD NOT DIRECTLY ACCESS GITHUB SECRETS.
                   //
                   // In this DEMO code, placeholder values like `YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER`
                   // are included directly in the HTML `<script>` tag or within the `AppConfig` object.
                   // This is solely for the purpose of illustrating *where* such keys/IDs would be referenced
                   // structurally if they *were* used client-side (an insecure practice for anything sensitive).
                   //
                   // For the requested structure demonstrating complex integrations, we are **SIMULATING**
                   // the interactions with these APIs. The simulated services will still reference placeholders
                   // in the configuration (`AppConfig`) to mimic realistic setup, but they will **NOT**
                   // connect to real external services or use real credentials.
                   //
                   // A REAL, SECURE APPLICATION ARCHITECTURE WOULD LOOK DIFFERENT CLIENT-SIDE FOR SENSITIVE OPERATIONS:
                   // 1. Google Places Autocomplete: The API Key in the JS library URL is relatively less sensitive if restricted properly (e.g., by domain/referrer). However, Place Details lookups can incur costs.
                   // 2. Google Identity Services (GIS - Sign-In/OAuth): The client uses the Google OAuth Client ID (less sensitive) to display Sign-In UI and get user consent. GIS provides an ID Token. Client SENDS this ID Token to YOUR secure backend.
                   // 3. Backend Authentication: YOUR backend VERIFIES the ID Token securely using Google's auth libraries (crucial step). This authenticates the user.
                   // 4. Other Google APIs (Calendar, Gmail, Drive/Apps Script): YOUR backend uses the verified user's identity (from the ID Token) and securely stored credentials (YOUR backend's API keys/service account, plus potentially tokens exchanged after user OAuth consent for specific scopes) to call Google's REST APIs SECURELY FROM THE SERVER SIDE. Data is passed between your client and your backend.
                   // 5. Google Pay: Client uses the Google Pay JS library to display payment UI and get a *tokenized payment payload*. This token is encrypted and useless client-side. Client SENDS this TOKEN to YOUR secure backend. YOUR backend uses YOUR Payment Gateway's securely stored API keys/credentials to process the charge using the token.
                   // 6. Expedia Partner API (for real prices/search results): YOUR client sends search parameters to YOUR backend. YOUR backend uses YOUR securely stored Expedia Partner API credentials to call Expedia's API, gets real hotel data/prices, processes it, and sends the results back to the client.
                   // 7. GenAI API: Client sends the user's prompt (e.g., destination for a tip) to YOUR backend. YOUR backend uses YOUR securely stored GenAI API credentials to call the GenAI model, gets the generated content, potentially moderates it, and sends the result back to the client.
                   // 8. Google Apps Script (Secure Access): If an Apps Script needs to perform actions as a specific user or requires sensitive data, YOUR backend should act as a gateway, handling authentication (e.g., using a service account or OAuth flow involving your backend) and calling the Apps Script execution API or accessing resources securely.

                   // THIS DEMO CODE PRIORITIZES DEMONSTRATING THE CLIENT-SIDE JAVASCRIPT STRUCTURE,
                   // ASYNCHRONOUS PATTERNS (`async`/`await`, `Promises`), OOP PRINCIPLES, DOM INTERACTION,
                   // ERROR HANDLING (`try...catch`, `ErrorReporter`), and INTERFACING WITH *SERVICE ABSTRACTIONS*.
                   // THE SERVICES THEMSELVES ARE *SIMULATED* TO MIMIC THE BEHAVIOR OF INTERACTING WITH EXTERNAL APIS ASYNCHRONOUSLY.
                   // THE SECURITY-CRITICAL BACKEND LAYER IS ACKNOWLEDGED BUT NOT IMPLEMENTED HERE IN THIS CLIENT-SIDE-ONLY FILE.
                   // THE PLACECARDERS IN `AppConfig` ILLUSTRARE WHERE CONFIG WOULD GO, BUT SHOULD NEVER BE FILLED WITH REAL SECRETS IN THIS CLIENT-SIDE FILE.
                   // ------------------------------------------------------------------------------------------------------


                   // --- Configuration Object ---
                   // Centralized configuration object holding various constants, messages, selectors, and service details.
                   // Uses placeholder values for configuration endpoints and IDs to illustrate where they would be used,
                   // strongly disclaiming that real secrets should NEVER be hardcoded client-side.
                   const AppConfig = {
                       APP_NAME: 'LuxStayFinderDemoApp', // Descriptive name for the application module/section.
                       APP_VERSION: '5.2.0', // Current version number of the application logic.

                       // Expedia Affiliate Configuration details.
                       // Used for building the affiliate redirect URL.
                       EXPEDIA_AFFILIATE_ID: 'YOUR_EXPEDIA_AFFILIATE_ID_PLACEHOLDER', // Affiliate ID for tracking referrals.
                       EXPEDIA_BASE_SEARCH_URL: 'https://www.expedia.com/Hotel-Search', // Base URL for Expedia's hotel search results page.
                       // This URL is what we will redirect the user to after collecting search parameters.
                       // Example structure observed: https://www.expedia.com/Hotel-Search?destination=...&checkin=...&checkout=...&adults=...&rooms=...&mcid=...&...

                       // --- Secure Backend Endpoints (Placeholders) ---
                       // In a real application, these URLs would point to YOUR secure backend server endpoints.
                       // Client-side JavaScript would call these endpoints using `fetch` or AJAX,
                       // and YOUR backend would handle the secure interaction with external APIs using credentials (potentially from GitHub Secrets).
                       BACKEND_ENDPOINTS: {
                            // Endpoint for fetching real Expedia hotel prices and results. YOUR backend would call Expedia's API.
                           EXPEDIA_SEARCH_API_GATEWAY: '/api/expedia/search-hotels', // Example backend route for Expedia API calls.
                            // Endpoint for securely interacting with Google Apps Script. YOUR backend would handle authentication and calling the Apps Script.
                           APPS_SCRIPT_GATEWAY: '/api/google/apps-script-execute', // Example backend route for Apps Script calls.
                           // Endpoint for securely interacting with a Generative AI model. YOUR backend would call the GenAI API (e.g., Vertex AI).
                           GENAI_TIP_API_GATEWAY: '/api/genai/destination-tip', // Example backend route for GenAI tips.
                            // Endpoint for a backend gateway to securely interact with other Google APIs (Calendar, Gmail) on behalf of the user.
                           // Client sends auth tokens/consent info to this backend, backend uses YOUR server credentials + user consent to call Google APIs.
                           GOOGLE_API_USER_GATEWAY: '/api/google/user-api', // Example backend route for Calendar/Gmail etc. user-specific operations.
                       },


                       // API & Service Placeholders (Configuration values used by Client-Side logic/Simulations)
                       // IMPORTANT: These values are for CLIENT-SIDE use. Some (like Places API key) are relatively safe if restricted by domain/referrer.
                       // Others (like OAuth Client ID structure, simulated Merchant IDs/Gateways) are part of the simulation structure and represent
                       // real configuration that would be needed, BUT REAL SECRETS ARE HANDLED BACKEND-SIDE.
                       GOOGLE_PLACES_API_KEY: 'YOUR_GOOGLE_PLACES_API_KEY_PLACEHOLDER', // Google Places Autocomplete API Key. This is typically in the script tag URL. Using it in config as well allows checking the placeholder state.
                       GOOGLE_ANALYTICS_ID: 'G-XXXXXXXXXX_PLACEHOLDER', // Google Analytics 4 Measurement ID. Also in the gtag.js script tag.
                       GOOGLE_OAUTH_CLIENT_ID: 'YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com_PLACEHOLDER', // Google OAuth 2.0 Client ID for web application type. Used by real GIS for client-side auth flows.
                       // Google Pay Configuration details (Structure based on Google Pay API). Used by `GooglePayServiceWrapper` simulation.
                       GOOGLE_PAY: {
                           API_VERSION: 2, // Google Pay API version.
                           API_VERSION_MINOR: 0, // Google Pay API minor version.
                           // Allowed payment methods and their parameters/tokenization specifications.
                           ALLOWED_PAYMENT_METHODS: [{
                               type: 'CARD', // Specify card payment method.
                               parameters: {
                                   // Allowed card authentication methods (PAN_ONLY for basic card details, CRYPTOGRAM_3DS for 3DS).
                                   allowedAuthMethods: ['PAN_ONLY', 'CRYPTOGRAM_3DS'],
                                   // Allowed card networks (Visa, Mastercard, Amex, Discover, etc.). Specify those supported by your payment gateway.
                                   allowedCardNetworks: ['AMEX', 'DISCOVER', 'JCB', 'MASTERCARD', 'VISA'],
                                   // Request user's billing address if required by your business/payment gateway.
                                   billingAddressRequired: true,
                                   billingAddressParameters: {
                                       format: 'FULL' // Request full billing address details.
                                   },
                                   // Optional: gateway capabilities, etc.
                               },
                               // Tokenization Specification: Defines how payment data is tokenized for your payment gateway.
                               // Type 'PAYMENT_GATEWAY' is common, uses a specific gateway format.
                               tokenizationSpecification: {
                                   type: 'PAYMENT_GATEWAY',
                                   parameters: {
                                       // Your payment gateway's identifier (e.g., 'stripe', 'adyen', 'authorize_net').
                                       gateway: 'example_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY.
                                       // Your merchant ID within that specific payment gateway.
                                       gatewayMerchantId: 'exampleGatewayMerchantId_PLACEHOLDER', // REPLACE WITH YOUR GATEWAY MERCHANT ID.
                                       // Add other parameters required by your gateway's tokenization spec.
                                   }
                                   // Type 'DIRECT' is for processing payment data directly on your server without a gateway integration specific to Google Pay's format. Requires strong crypto handling server-side.
                                   // tokenizationSpecification: { type: 'DIRECT', parameters: { publicKey: 'YOUR_SERVER_SIDE_PUBLIC_KEY' }} // Requires secure handling.
                               }
                           }],
                           // Merchant Information: Identifies your business. Required for production.
                           MERCHANT_INFO: {
                               // Merchant ID provided by Google Pay. REQUIRED FOR PRODUCTION. Use a test ID in TEST environment.
                               // merchantId: 'BCR2DN6SA234GS23_PLACEHOLDER', // REPLACE WITH YOUR ACTUAL GOOGLE PAY MERCHANT ID.
                               // The public name of your business, shown to the user in the Google Pay UI.
                               merchantName: 'LuxStay Finder Demo (Simulated)',
                               // merchantOrigin: window.location.origin // Recommended for real implementation.
                           },
                           // Transaction Information: Details about the current transaction. Values will be dynamic based on search/selection.
                           TRANSACTION_INFO: {
                               // totalPriceStatus: 'FINAL', // Can be 'FINAL', 'ESTIMATED', 'PENDING'. Use 'FINAL' for booking confirmation step.
                               // totalPrice: 'PLACEHOLDER_PRICE', // REPLACE WITH ACTUAL DYNAMIC PRICE from search results.
                               totalPrice: '100.00', // Static placeholder price for demo calculation logic.
                               currencyCode: 'USD', // Currency code (ISO 4217).
                               countryCode: 'US', // Country where the transaction is processed or business is registered (ISO 3166-1 Alpha-2).
                                // Optional: Display items for a breakdown of the total price (subtotal, tax, etc.).
                                displayItems: [
                                    // Placeholder item structure. Should reflect dynamic pricing in real app.
                                   {
                                      label: 'Simulated Booking Price',
                                      type: 'FINAL', // Use FINAL for static/simulated price.
                                      price: '100.00', // Match totalPrice for simple demo.
                                   }
                                   // Add line items for tax, fees, etc., if available dynamically.
                               ]
                           },
                           // Optional: Request user's email address.
                           EMAIL_REQUIRED: true,
                           // Optional: Request user's shipping address (not typically for hotels, but possible for other purchases).
                           SHIPPING_ADDRESS_REQUIRED: false,
                           SHIPPING_SUPPORTED_COUNTRIES: [], // Empty array as not required for hotels.
                           // Optional: Simulate the success rate for payment processing for demo purposes.
                           SIMULATED_PAYMENT_SUCCESS_RATE: 0.8 // 80% chance of simulated payment success.

                       }, // End GOOGLE_PAY Config


                       // IndexedDB Configuration
                       INDEXEDDB: {
                           DB_NAME: 'LuxStayHistoryDB', // Name of the database.
                           DB_VERSION: 1, // Version number of the database schema. Increment this when changing object stores or indexes.
                           STORE_NAME: 'searchHistory', // Name of the object store to store search history items.
                           HISTORY_ITEM_LIMIT: 20, // Maximum number of history items to retrieve and display.
                       },

                       // CSS Selectors for UI elements (Centralized map for DOM query targets)
                       SELECTORS: {
                           APP_MAIN_CONTAINER: '.app-main-container', // A top-level container for the application UI sections.
                           MAIN_MESSAGE_AREA: '#mainMessageDisplay', // The HTML element (div/span) where app-level status and error messages are displayed.
                           SEARCH_FORM: '#mainSearchForm', // The ID selector for the main search form element.
                           FORM_INPUTS: 'input:not([type="button"]):not([type="submit"]):not([type="reset"]):not([type="hidden"]), select, textarea', // Refined generic CSS selector for standard form input elements (excluding button types and hidden).

                           // Suffix used to construct the ID of the validation error message element associated with an input.
                           // Example: if input ID is 'destinationInput', error message element is expected to be '#destinationInput-error'.
                           ERROR_MESSAGE_SUFFIX: '-error',

                           // Search Button and Loader elements (expected within the main form).
                           SEARCH_BUTTON: '#searchButton', // The main search submit button.
                           SEARCH_BUTTON_TEXT: '#searchText', // Span inside the button for text ("Search Hotels").
                           SEARCH_BUTTON_LOADING_SPINNER: '#loadingSpinner', // Icon element for the loading spinner.

                           // Search Results/Status Area (after the form, could contain price display)
                           RESULTS_AREA: '#resultsArea', // General area below the form for results or related info.
                           EXPEDIA_SIMULATED_PRICE_DISPLAY: '#expediaSimulatedPrice', // Element to display the simulated Expedia price.


                           // Google Services Section & Buttons (often visually separate from the main form)
                           GOOGLE_SERVICES_SECTION: '#googleServicesSection', // The container div for all Google services features.
                           GOOGLE_AUTH_AREA: '#googleAuthArea', // The div containing Google Sign-In related elements.
                           GOOGLE_SIGN_IN_BUTTON: '#googleSignInButton', // Button to trigger simulated Sign-In/Out.
                           GOOGLE_AUTH_STATUS_TEXT: '#googleAuthStatus', // Element displaying auth status text.
                           GOOGLE_SIGN_IN_BUTTON_TEXT: '#googleAuthText', // Span within Sign-In button text.
                           ADD_TO_CALENDAR_BUTTON: '#addToCalendarButton', // Button for Add to Calendar action.
                           EMAIL_SEARCH_DETAILS_BUTTON: '#emailSearchDetailsButton', // Button for Email Search Details action.
                           SEND_TO_APPS_SCRIPT_BUTTON: '#sendToAppsScriptButton', // Button for Send to Apps Script action.
                           GOOGLE_PAY_BUTTON: '#googlePayButton', // Button for Simulated Google Pay action.
                           GOOGLE_PAY_BUTTON_AREA: '#googlePayArea', // Container for the GPay button (relevant for real GPay button rendering placement).


                           // IndexedDB Search History Section & Elements
                           SEARCH_HISTORY_SECTION: '#searchHistorySection', // The container div for the search history feature.
                           SEARCH_HISTORY_LIST_UL: '#searchHistoryList', // The UL element displaying search history items.
                           CLEAR_HISTORY_BUTTON: '#clearHistoryButton', // Button to clear search history.
                           HISTORY_STATUS_DISPLAY: '#historyStatus', // Element displaying status messages related to history (loading, saved, etc.).

                           // GenAI Tip Section & Elements
                           AI_TIPS_SECTION: '#aiTipsSection', // The container div for the GenAI tip feature.
                           AI_TIP_CONTENT_DISPLAY: '#aiTipContent', // The div displaying the AI-generated tip text content.
                       },


                       // UI Messages for various statuses and error states (Centralized strings for consistency and easier updates/localization)
                       MESSAGES: {
                           // --- Application Lifecycle & General Errors ---
                           APP_INIT_START: 'Application initialization started...',
                           APP_INIT_SUCCESS: 'Application initialized successfully.',
                           APP_INIT_ERROR: 'Application failed to initialize properly.',
                           FATAL_ERROR: 'A critical application error occurred.', // Used for errors preventing app from running.
                           DISPOSING: 'Cleaning up application resources...', // Message shown during app disposal.
                           DISPOSED: 'Application disposed.', // Message after disposal completes.
                           INTERNAL_ERROR: 'An internal error occurred.', // Generic internal error message detail.


                           // --- General Process Feedback Messages ---
                           // Use templates for messages that include a dynamic task name.
                           PROCESSING: (task) => `Processing ${task}...`, // Generic processing message template. Add spinner UI where displayed.
                           SUCCESS: (task) => `${task} completed successfully.`, // Generic success message template.
                           FAILED: (task, err) => `${task} failed. ${err ? `Details: ${err}` : 'Unknown error.'}`, // Generic failure message template.

                           // --- Form Validation Messages ---
                           VALIDATION_ERROR: 'Please fix the errors in the form to continue.', // General message when form validation fails.
                           INPUT_REQUIRED: 'This field is required and cannot be empty.', // Specific input 'required' validation message.
                           INPUT_INVALID_NUMBER: 'Please enter a valid number for this field.', // Specific input type="number" parsing error.
                           INPUT_NUMBER_MIN: (min) => `Value must be at least ${min}.`, // Specific number range validation message.
                           INPUT_NUMBER_MAX: (max) => `Value must be at most ${max}.`, // Specific number range validation message.
                           INPUT_DATE_PAST: 'Date cannot be in the past. Please select a future or current date.', // Specific date validation message for 'min'.
                           INPUT_CHECKOUT_BEFORE_CHECKIN: 'Check-out date must be after the check-in date.', // Cross-field date validation message.
                           INPUT_AUTOCOMPLETE_NO_DETAILS: (value) => `Could not confirm destination details for "${value}". Please select a destination from the suggestions list.`, // Destination specific validation message (if selection is required).
                           INPUT_TOTAL_TRAVELERS_LIMIT: (total, max) => `Total travelers (${total}) exceeds the limit allowed per room (${max}). Please adjust or consider multiple rooms.
                                                      maxTravelersPerRoom), `maxTravelersPerBooking` etc. This helper simply validates that the essential values for a transaction are present and attempts basic structure validation. It does NOT validate the price against any external source.
                  * Returns `null` or throws an error if parameters are insufficient or malformed for creating the transaction object structure.
                  */
                 _createSimulatedTransactionDetails(searchParams) {
                     try {
                          Logger.debug("GooglePayServiceWrapper._createSimulatedTransactionDetails: Creating simulated transaction details from parameters...", searchParams);

                         // --- Validate Required Search Parameters ---
                         // Ensure the essential parameters needed to create the transaction details object (price, currency, item labels) are present in the provided `searchParams` object.
                         // In this simulation, we'll assume `searchParams` contains the simulated price result from `_fetchSimulatedExpediaPrice`.
                         if (!searchParams || typeof searchParams !== 'object' || !searchParams.destinationInput || !searchParams.checkInDateInput || !searchParams.checkOutDateInput || !searchParams.adultsCountInput || !searchParams.simulatedPrice || typeof searchParams.simulatedPrice.price !== 'number' || typeof searchParams.simulatedPrice.currency !== 'string') {
                             const errorMsg = 'Missing required parameters for simulated transaction details creation (destination, dates, adults, or simulated price result).';
                             Logger.warn(`GooglePayServiceWrapper._createSimulatedTransactionDetails: ${errorMsg}`, { searchParams: searchParams });
                              // Throw an error to signal that transaction details cannot be created due to bad input.
                              throw new Error(errorMsg);
                         }

                          // Get the simulated price and currency from the `searchParams` object.
                          const simulatedPrice = parseFloat(searchParams.simulatedPrice.price).toFixed(2); // Ensure float and format to 2 decimal places.
                         const simulatedCurrencyCode = searchParams.simulatedPrice.currency;

                          // Basic validation for price format if necessary (optional). Ensure it's a valid number string with 2 decimal places.
                           if (isNaN(parseFloat(simulatedPrice)) || !/^\d+(\.\d{2})?$/.test(simulatedPrice)) {
                                const priceFormatError = `Invalid simulated price format: "${simulatedPrice}".`;
                                Logger.warn(`GooglePayServiceWrapper._createSimulatedTransactionDetails: ${priceFormatError}`);
                                throw new Error(priceFormatError);
                           }
                           if (typeof simulatedCurrencyCode !== 'string' || simulatedCurrencyCode.length !== 3) { // Basic check for 3-letter currency code.
                                const currencyFormatError = `Invalid simulated currency format: "${simulatedCurrencyCode}".`;
                                Logger.warn(`GooglePayServiceWrapper._createSimulatedTransactionDetails: ${currencyFormatError}`);
                                throw new Error(currencyFormatError);
                           }


                         // --- Calculate Number of Nights (for Item Label) ---
                         // Calculate the number of nights based on check-in/out dates for the display item label in the transaction details.
                         let simulatedNumNights = 1; // Default to 1 night simulation.
                         try {
                              // Attempt to create `Date` objects from the string parameters.
                             const checkInDateStr = searchParams.checkInDateInput;
                             const checkOutDateStr = searchParams.checkOutDateInput;

                             // Check if both date strings are valid and can be parsed into valid `Date` objects for calculation.
                              const checkInDateObj = new Date(checkInDateStr);
                              const checkOutDateObj = new Date(checkOutDateStr);

                             if (!isNaN(checkInDateObj.getTime()) && !isNaN(checkOutDateObj.getTime())) {
                                  // If both dates are valid Date objects, calculate the difference in milliseconds.
                                  const diffTime = checkOutDateObj.getTime() - checkInDateObj.getTime();
                                  const oneDay = 24 * 60 * 60 * 1000; // Milliseconds in one day.

                                  if (diffTime >= 0) { // Ensure check-out is not before check-in for calculation.
                                       // Calculate the difference in days (number of nights) and round to handle potential Daylight Saving Time shifts.
                                       simulatedNumNights = Math.max(1, Math.round(diffTime / oneDay)); // Ensure minimum 1 night stay simulation.
                                      Logger.debug(`_createSimulatedTransactionDetails: Calculated ${simulatedNumNights} nights.`);
                                   } else {
                                       // If diffTime is negative (check-out <= check-in), assume 1 night for simulation.
                                      simulatedNumNights = 1;
                                       Logger.warn(`_createSimulatedTransactionDetails: Negative time difference (${diffTime} ms) for simulation calc, assuming 1 night.`);
                                   }
                             } else {
                                  // If date strings could not be parsed into valid Date objects, assume 1 night for simulation.
                                Logger.warn(`_createSimulatedTransactionDetails: Invalid date objects for number of nights calculation in simulation, assuming 1 night.`);
                                simulatedNumNights = 1;
                             }
                         } catch (dateCalcError) {
                              // Catch any errors during date calculations for simulation.
                             Logger.error(`_createSimulatedTransactionDetails: Error calculating number of nights for simulation:`, dateCalcError, { searchParams: searchParams });
                             simulatedNumNights = 1; // Default to 1 night on error.
                         }


                         // --- Construct Transaction Information Object ---
                         // Create the `TransactionInfo` object structure based on the Google Pay API specification.
                         const transactionInformationObject = {
                             // `totalPriceStatus`: REQUIRED. Indicates the status of the total price. 'FINAL' is typically used for the final booking confirmation step. 'ESTIMATED' or 'PENDING' can be used earlier.
                             totalPriceStatus: 'FINAL', // Use 'FINAL' as this is a simulated final price for payment.
                             // `totalPrice`: REQUIRED. The final total price for the transaction as a string. Needs to match the price in displayItems.
                              totalPrice: simulatedTotalPrice, // Use the calculated and formatted simulated total price string.
                             // `currencyCode`: REQUIRED. The currency of the transaction (ISO 4217 alpha-3).
                              currencyCode: simulatedCurrencyCode, // Use the simulated currency code string.
                             // `countryCode`: REQUIRED. The country where the business is registered or the transaction is processed (ISO 3166-1 Alpha-2).
                             countryCode: this._config.TRANSACTION_INFO.countryCode || 'US', // Use config value or default to US.
                              // `displayItems`: Optional. An array of objects representing items that make up the total price. Useful for displaying a breakdown in the Google Pay UI.
                             displayItems: [
                                  {
                                     type: 'SUBTOTAL', // Item type: 'SUBTOTAL', 'LINE_ITEM', 'TAX', 'FEE', etc.
                                     label: `${simulatedNumNights} Night${simulatedNumNights > 1 ? 's' : ''}`, // Label for the item (e.g., "3 Nights", "1 Night").
                                     price: simulatedTotalPrice, // Price for this item (total price in this simple case).
                                      status: 'FINAL' // Status for this item.
                                  }
                                   // Add more display items if simulating tax, fees, etc. (requires these to be calculated dynamically based on searchParams).
                             ],
                              // Optional: `checkoutOption`, `totalPriceLabel`, `transactionNote`, `usageContext`.
                         };

                         // Log the created simulated transaction information object for debugging.
                         Logger.debug("GooglePayServiceWrapper._createSimulatedTransactionDetails: Simulated transaction information object created:", transactionInformationObject);

                         // Return the successfully created transaction information object.
                         return transactionInformationObject;

                     } catch (error) {
                          // Catch any unexpected errors occurring *within* this helper method (e.g., access errors, type errors).
                           // Report this error using the injected ErrorReporter.
                          this.#errorReporter.reportError(
                              'GooglePayServiceWrapper._createSimulatedTransactionDetails', error, // Source and error object.
                              { searchParamsInput: searchParams, step: 'create_transaction_details_logic' }, // Context details.
                              'Error creating simulated transaction details for Google Pay. Check input data and logic.', // User-friendly message.
                              'gpay_transaction_details_exception_logic' // GA error code.
                          );
                           // Re-throw the error to signal to the caller (`loadPaymentData`) that transaction details creation failed.
                           // This is critical; cannot proceed with payment request without details.
                          throw error; // Re-throw the error.
                     }
                 } // End of _createSimulatedTransactionDetails method definition.

                 /**
                  * Protected method to construct a simulated Google Pay `PaymentDataRequest` object.
                  * This object structure is based on the official Google Pay API specification (refer to: https://developers.google.com/pay/api/web/reference/request-objects#PaymentDataRequest).
                  * It is used to configure the Google Pay payment sheet when `paymentsClient.loadPaymentData` is called.
                  * The structure defines the API versions, allowed payment methods (CARD types with tokenization), transaction details, and merchant information.
                  * It uses the `_config` properties (derived from `AppConfig.GOOGLE_PAY`) and the provided `transactionInfo` object.
                  * Includes basic checks for required configuration parameters.
                  * @param {object} transactionInfo - The dynamic transaction information object (`{ totalPrice: '...', currencyCode: '...', ... }`) created by `_createSimulatedTransactionDetails`. Required.
                  * @returns {object|null} - Returns a plain JavaScript object representing the simulated `PaymentDataRequest` if configuration and input are valid and sufficient. Returns `null` if essential configuration is missing or invalid.
                  * @throws {Error} - Throws an error if the provided `transactionInfo` is invalid or if critical configuration required for the request structure is missing.
                  */
                 _createPaymentDataRequest(transactionInfo) {
                     try {
                          Logger.debug("GooglePayServiceWrapper._createPaymentDataRequest: Creating simulated PaymentDataRequest object...", { transactionInfo: transactionInfo });

                         // --- Validate Input Parameter ---
                          // Ensure the required `transactionInfo` object is provided and contains at least the required fields for the request structure (`totalPrice`, `currencyCode`).
                         if (!transactionInfo || typeof transactionInfo !== 'object' || typeof transactionInfo.totalPrice !== 'string' || typeof transactionInfo.currencyCode !== 'string') {
                             const errorMsg = "Invalid transaction info provided for creating PaymentDataRequest. Missing required 'totalPrice' or 'currencyCode'.";
                             Logger.error(`GooglePayServiceWrapper._createPaymentDataRequest: ${errorMsg}`, { transactionInfo: transactionInfo });
                              // Throw an error to signal that the request cannot be created with bad input data.
                             throw new Error(errorMsg);
                         }

                         // --- Check Required Configuration ---
                          // Check if the essential configuration parameters required for the PaymentDataRequest structure are available in `this._config`.
                          // These parameters define the Google Pay API versions, allowed payment methods (including tokenization setup).
                          // Specifically, ensure API versions, allowed payment methods array, and a CARD method with tokenization and parameters are present.
                          if (!this._config?.API_VERSION || !this._config?.API_VERSION_MINOR || !Array.isArray(this._config.ALLOWED_PAYMENT_METHODS) || this._config.ALLOWED_PAYMENT_METHODS.length === 0) {
                             const configErrorMsg = "Google Pay configuration in AppConfig is missing essential API versions or allowed payment methods.";
                             Logger.error(`GooglePayServiceWrapper._createPaymentDataRequest: ${configErrorMsg}`, { config: this._config });
                              // Return null as the request cannot be built without fundamental configuration.
                             return null; // Indicate failure due to configuration issue.
                          }

                          // Find the configuration for the CARD payment method, which is required for this simulation.
                          const cardPaymentMethodConfig = this._config.ALLOWED_PAYMENT_METHODS.find(method => method.type === 'CARD');
                          // Ensure the CARD payment method config exists AND it includes the necessary `tokenizationSpecification` and `parameters`.
                          if (!cardPaymentMethodConfig || !cardPaymentMethodConfig.tokenizationSpecification || !cardPaymentMethodConfig.parameters) {
                               const tokenizationConfigErrorMsg = "Google Pay configuration for CARD payment method is missing tokenization specification or parameters.";
                              Logger.error(`GooglePayServiceWrapper._createPaymentDataRequest: ${tokenizationConfigErrorMsg}`, { config: this._config });
                              // Return null as the request cannot be built without tokenization setup.
                              return null; // Indicate failure due to configuration issue.
                          }
                          // Extract the valid tokenization specification and card parameters objects from the config.
                          const tokenizationSpecification = cardPaymentMethodConfig.tokenizationSpecification;
                          const cardParameters = cardPaymentMethodConfig.parameters;


                          // --- Construct PaymentDataRequest Object ---
                          // Build the `PaymentDataRequest` object structure according to the Google Pay API Web documentation.
                          const paymentDataRequestObject = {
                             // Specify Google Pay API version being used.
                             apiVersion: this._config.API_VERSION, // Example: 2
                             apiVersionMinor: this._config.API_VERSION_MINOR, // Example: 0

                             // `allowedPaymentMethods`: REQUIRED. An array defining the payment methods the application accepts.
                             allowedPaymentMethods: [{
                                  type: 'CARD', // Specify that the application accepts card payments.
                                  parameters: { // Parameters specific to the 'CARD' type.
                                       // `allowedAuthMethods`: REQUIRED. Authentication methods allowed for cards (PAN_ONLY for basic card, CRYPTOGRAM_3DS for 3DS).
                                       allowedAuthMethods: cardParameters.allowedAuthMethods, // Use values from config.
                                       // `allowedCardNetworks`: REQUIRED. Card networks accepted (e.g., 'VISA', 'MASTERCARD').
                                       allowedCardNetworks: cardParameters.allowedCardNetworks, // Use values from config.
                                       // `billingAddressRequired`: OPTIONAL. Request user's billing address. Required by some payment gateways.
                                      billingAddressRequired: this._config.BILLING_ADDRESS_REQUIRED ?? false, // Use config value or default to false.
                                       // `billingAddressParameters`: OPTIONAL parameters if billing address is required.
                                      billingAddressParameters: this._config.BILLING_ADDRESS_REQUIRED ? { format: 'FULL' } : undefined, // Request full address format if required.
                                      // Add other optional card parameters if needed.
                                   },
                                   // `tokenizationSpecification`: REQUIRED. Defines how payment data is tokenized and sent to your gateway.
                                  tokenizationSpecification: tokenizationSpecification, // Use the extracted tokenization spec from config.
                              }], // End allowedPaymentMethods array.

                              // `transactionInfo`: REQUIRED. Details about the specific transaction.
                             transactionInfo: transactionInfo, // Use the dynamically created `transactionInfo` object passed to this method.

                              // `merchantInfo`: REQUIRED. Information identifying your business or merchant.
                             merchantInfo: this._config.MERCHANT_INFO, // Use the merchant info object from config.

                              // Optional fields to request from the user in the payment sheet.
                             emailRequired: this._config.EMAIL_REQUIRED ?? false, // Request user's email if configured.
                             shippingAddressRequired: this._config.SHIPPING_ADDRESS_REQUIRED ?? false, // Request shipping address if configured (unlikely for hotels).
                              // `shippingAddressParameters`: OPTIONAL parameters if shipping address is required.
                              shippingAddressParameters: this._config.SHIPPING_ADDRESS_REQUIRED ? { supportedCountries: this._config.SHIPPING_SUPPORTED_COUNTRIES || [] } : undefined, // Use config countries or empty array.

                             // Optional advanced features:
                             // `callbackIntents`: An array of intents that trigger callbacks for dynamic updates (e.g., price updates based on shipping address change).
                             // callbackIntents: ["PRICE_STATUS", "PAYMENT_METHOD", "SHIPPING_ADDRESS"], // Example intents for dynamic updates.

                         }; // End of PaymentDataRequest object construction.


                         // Log the constructed simulated PaymentDataRequest object for debugging.
                         Logger.debug("GooglePayServiceWrapper._createPaymentDataRequest: Simulated PaymentDataRequest object created:", paymentDataRequestObject);

                         // Return the successfully constructed PaymentDataRequest object.
                         return paymentDataRequestObject;

                     } catch (error) {
                          // --- Handle Errors During Request Construction ---
                          // Catch any unexpected errors occurring *within* this helper method (e.g., errors accessing config properties, validation logic throws, invalid input data passed).
                           // Report this error using the injected ErrorReporter.
                          this.#errorReporter.reportError(
                              'GooglePayServiceWrapper._createPaymentDataRequest', error, // Source and error object.
                              { transactionInfoInput: transactionInfo, configUsed: this._config, step: 'create_payment_request_logic' }, // Context details.
                              'Error creating Google Pay request object. Configuration or input data may be invalid.', // User-friendly message template.
                              'gpay_request_build_exception_logic' // GA error code for request building logic exception.
                          );
                          // Return `null` to indicate that the PaymentDataRequest could not be built due to an error.
                          return null; // Always return null on error.
                     }
                 } // End of _createPaymentDataRequest method definition.


                 /**
                  * Dispose method for cleanup on application shutdown or when the `GooglePayServiceWrapper` instance is no longer needed.
                  * In a real application using the Google Pay JS library, this might involve cleaning up the `PaymentsClient` instance.
                  * In this simulation, it clears internal references.
                  */
                 dispose() {
                     try {
                         Logger.debug("GooglePayServiceWrapper.dispose: Disposing GooglePayServiceWrapper.");
                         // In a real app, the `google.payments.api.PaymentsClient` instance might have a `remove()` or `dispose()` method to call.
                         // if (this.#paymentsClient && typeof this.#paymentsClient.remove === 'function') {
                         //      this.#paymentsClient.remove(); // Example dispose call for real client.
                         //      Logger.debug("Dispose: Real Google Pay PaymentsClient disposed.");
                         // }
                         this.#paymentsClient = null; // Clear the internal reference to the PaymentsClient instance.

                         // Clear references to HTML elements managed directly by this wrapper (the Google Pay button).
                         if (this.#googlePayButtonElement) {
                            // Remove any inline styles or event listeners potentially added directly if not via _addEventListener.
                             // Clear internal reference.
                            this.#googlePayButtonElement = null;
                            Logger.debug("Dispose: Google Pay button element reference cleared.");
                         } else {
                              Logger.debug("Dispose: Google Pay button element reference was already null.");
                         }

                         // Clear references to configuration objects.
                         this._config = null;

                         // The `ErrorReporter` reference (`this.#errorReporter`) is not disposed here as it's a shared instance managed at a higher level (SearchForm).

                         Logger.debug("GooglePayServiceWrapper.dispose: Disposal complete.");

                     } catch (error) {
                          // Catch and log errors occurring during the disposal process.
                          // Use the injected reporter if available, otherwise fallback to console.
                          if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                              this.#errorReporter.reportError(
                                  'GooglePayServiceWrapper.dispose', error, {},
                                  'Error disposing Google Pay Service wrapper.',
                                  'gpay_dispose_exception' // GA error code.
                              );
                          } else {
                            console.error("GooglePayServiceWrapper.dispose: Error disposing (Reporter missing or failed):", error);
                          }
                         // Do not re-throw from a dispose method.
                     }
                 } // End of dispose method definition.
             } // End of GooglePayServiceWrapper class definition.


             // --- Simulated Google Apps Script Service ---
             // This class simulates sending data to a Google Apps Script Web App endpoint.
             // In a real application, calling an Apps Script securely from client-side usually involves a backend gateway.
             // This class mimics the client-side pattern of making an async call to an endpoint with data.
             class SimulatedGoogleAppsScriptService {
                 // Private member storing the URL of the simulated Google Apps Script Web App endpoint (likely a backend gateway endpoint).
                 #endpointUrl;
                 #errorReporter; // Reference to the shared ErrorReporter instance.

                 /**
                  * Constructor for SimulatedGoogleAppsScriptService.
                  * Initializes the service with the endpoint URL of the Apps Script Web App (or a backend gateway).
                  * @param {string} endpointUrl - The URL string of the deployed Google Apps Script Web App (or your backend gateway endpoint for Apps Script). A placeholder value from `AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY`. Required.
                  * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                  * @throws {Error} If `endpointUrl` or `errorReporter` are invalid or missing, preventing the service from being initialized.
                  */
                 constructor(endpointUrl, errorReporter) {
                     try {
                         Logger.debug(`SimulatedGoogleAppsScriptService constructor called with endpoint: "${endpointUrl}".`);

                         // --- Check Configuration ---
                         // Validate the provided endpoint URL. Must be a string and should not be the placeholder value.
                         if (!endpointUrl || typeof endpointUrl !== 'string' || endpointUrl.includes('_PLACEHOLDER')) {
                              const configErrorMsg = `Google Apps Script endpoint URL is missing, not a string, or is a placeholder. Simulated service will not be considered configured.`;
                             Logger.warn(`SimulatedGoogleAppsScriptService.constructor: ${configErrorMsg}`);
                             this.#endpointUrl = null; // Explicitly set to null if not configured properly.
                             // Note: An informational message about missing configuration is shown by the SearchForm constructor if `!isConfigured()`.
                         } else {
                             // Basic URL format check: ensure it starts with http(s) or is a relative path starting with '/'.
                             if (!/^https?:\/\//i.test(endpointUrl) && !/^\//.test(endpointUrl)) {
                                  const formatErrorMsg = `Invalid format for Apps Script endpoint URL: "${endpointUrl}". Must be an absolute (http/https) or relative path (starting with /).`;
                                 Logger.error(`SimulatedGoogleAppsScriptService.constructor: ${formatErrorMsg}`);
                                 // Set endpoint to null and throw error if format is invalid.
                                 this.#endpointUrl = null;
                                 throw new Error(formatErrorMsg);
                             }
                             // Store the validated endpoint URL.
                             this.#endpointUrl = endpointUrl;
                             Logger.debug(`SimulatedGoogleAppsScriptService configured with endpoint: "${this.#endpointUrl}".`);
                         }


                         // --- Check ErrorReporter Dependency ---
                          // Validate the required ErrorReporter dependency.
                         if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                            const reporterErrorMsg = "ErrorReporter instance not provided to SimulatedGoogleAppsScriptService constructor. Error handling will be compromised.";
                            Logger.error(reporterErrorMsg);
                             // Set a fallback dummy reporter if missing.
                            this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[APPS SCRIPT NO REPORTER ERROR] ${src}: ${msg}`, err, ctx) };
                         } else {
                            this.#errorReporter = errorReporter; // Store the valid reporter.
                             Logger.debug(`SimulatedGoogleAppsScriptService: ErrorReporter dependency successfully injected and stored.`);
                         }


                         // Log successful initialization.
                         Logger.debug(`SimulatedGoogleAppsScriptService initialized.`);

                     } catch (error) {
                          // Catch any unexpected errors occurring *within* the constructor logic itself (e.g., during validation).
                          // Report this critical constructor failure using the injected reporter (or console if reporter failed).
                          if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                               this.#errorReporter.reportError(
                                   'SimulatedGoogleAppsScriptService.constructor', error, // Source and error.
                                   { endpoint: endpointUrl, step: 'constructor_execution' }, // Context.
                                   'Failed to construct Simulated Google Apps Script service.', // User-facing message.
                                   'gs_init_exception_critical' // GA error code.
                               );
                          } else {
                              // Fallback console error if reporter wasn't available.
                              console.error(`FATAL: Error during SimulatedGoogleAppsScriptService constructor (Reporter missing or failed):`, error, { endpoint: endpointUrl });
                          }
                          // Ensure `#endpointUrl` is explicitly set to null if initialization failed critically.
                          this.#endpointUrl = null; // Defensive assignment.
                          // Re-throw the error to propagate it to the main application bootstrap logic.
                          throw error;
                      } // End of constructor try...catch.
                  } // End of constructor definition.

                  /**
                   * Public method to check if the Apps Script service is considered configured and ready for use.
                   * This checks if a valid, non-placeholder endpoint URL was provided during construction.
                   * @returns {boolean} - Returns `true` if the service endpoint is configured (non-null and not placeholder), `false` otherwise or if an error occurs.
                   */
                  isConfigured() {
                      try {
                          // The service is configured if `#endpointUrl` is not null and not the placeholder string.
                           const configured = this.#endpointUrl !== null && this.#endpointUrl !== AppConfig.GOOGLE_APPS_SCRIPT_ENDPOINT;
                           // Logger.debug(`SimulatedGoogleAppsScriptService.isConfigured: ${configured}.`); // Too noisy debug.
                          return configured;
                      } catch (error) {
                           // Catch errors during the check (unlikely with simple property access).
                           this.#errorReporter.reportError(
                               `${this.name}.isConfigured`, error, {}, // Source and error.
                               `Error checking Apps Script service configuration status.`, // User message.
                               'gs_check_config_exception' // GA error code.
                           );
                           return false; // Assume not configured if an error occurs.
                      }
                  } // End of isConfigured method definition.

                 /**
                  * Public asynchronous method to simulate sending a data payload to the configured Google Apps Script endpoint (via backend gateway). Marked async.
                  * In a real application, this would perform an HTTP request (`fetch` or `$.ajax`) to the endpoint URL (`this.#endpointUrl`).
                  * This method is designed to be called by the `SearchForm` component when the user triggers an action requiring communication with Apps Script.
                  * It simulates the asynchronous call, handles potential success and failure scenarios, and is designed to throw/reject on errors.
                  * @param {object} data - The data payload object to send to the Apps Script endpoint. This object must be serializable to JSON. Required.
                  * @returns {Promise<object>} A Promise that resolves with a simulated response object from the Apps Script upon simulated success. The structure of the response object depends on what the Apps Script is simulated to return.
                  * @throws {Error} - Throws or rejects with an Error if the service is not configured, the input `data` is invalid, or if the simulated asynchronous call fails (e.g., simulated network error, simulated Apps Script execution error).
                  */
                 async runScriptFunction(data) {
                     try {
                          Logger.debug(`SimulatedGoogleAppsScriptService.runScriptFunction: Attempting to simulate sending data to Apps Script endpoint: "${this.#endpointUrl}"...`, data);

                         // --- Check Service Configuration ---
                         // Ensure the Apps Script service is configured (has a valid endpoint) before attempting to send data.
                         if (!this.isConfigured()) { // Use the public check method.
                             const configErrorMsg = AppConfig.MESSAGES.APPS_SCRIPT_ENDPOINT_MISSING; // Get the standard message.
                             Logger.warn(`SimulatedGoogleAppsScriptService.runScriptFunction: ${configErrorMsg}. Cannot proceed with send operation.`);
                             // Throw an error to indicate that the operation failed due to missing configuration.
                              // The calling method (`_handleSendToAppsScriptClick`) catches this and reports it.
                             throw new Error(configErrorMsg);
                         }


                         // --- Validate Input Data Payload ---
                         // Ensure the data payload to be sent is provided and is a valid JavaScript object that can likely be serialized to JSON.
                         if (!data || typeof data !== 'object') {
                             const dataErrorMsg = "Invalid data payload provided for Apps Script simulation. Must be a valid object.";
                             Logger.warn(`SimulatedGoogleAppsScriptService.runScriptFunction: ${dataErrorMsg}`, { data: data });
                             // Throw an error indicating invalid input data for the service method.
                              throw new Error(dataErrorMsg);
                          }

                          // Optional: Add more specific validation of the data payload structure if the Apps Script expects a certain format/required fields.


                         // --- Simulate Calling Backend Endpoint ---
                         // In a real application, you would replace the simulation below with an actual asynchronous HTTP request (`fetch` or `$.ajax`)
                         // to your backend endpoint URL (`this.#endpointUrl`), sending the `data` payload.
                         // Your backend would then call the real Apps Script.

                         /* Example of REAL fetch to a backend endpoint (COMMENTED OUT):
                         // const endpointUrl = this.#endpointUrl; // Use the stored endpoint URL.
                         // Logger.debug(`SimulatedGoogleAppsScriptService.runScriptFunction: Making REAL fetch call to backend endpoint "${endpointUrl}"...`, { data: data });
                         // try {
                         //     const response = await fetch(endpointUrl, {
                         //         method: 'POST', // Often POST for sending data. Use 'GET' if script uses doGet(e) and data is in query params.
                         //         headers: {
                         //             'Content-Type': 'application/json', // Indicate sending JSON in body.
                         //             // Add any required headers for authentication/authorization with YOUR backend gateway if needed.
                         //         },
                         //         body: JSON.stringify(data), // Convert data object to JSON string for the body.
                         //     });
                         //     // Check for HTTP errors.
                         //     if (!response.ok) {
                         //         const errorBodyText = await response.text();
                         //         const httpErrorDetails = `${response.status} - ${response.statusText || 'Unknown Status'} - ${errorBodyText.substring(0, 200)}`;
                         //         const httpError = new Error(`Backend HTTP error calling Apps Script endpoint: ${httpErrorDetails}`);
                         //         Logger.error(`SimulatedGoogleAppsScriptService.runScriptFunction: Backend fetch failed with HTTP status ${response.status}.`, { error: httpError, responseText: errorBodyText });
                         //         throw httpError; // Re-throw HTTP error.
                         //     }
                         //     // Attempt to parse JSON response from the backend.
                         //     const responseData = await response.json();
                         //     // Validate the structure of the JSON response if needed. (Depends on what YOUR Apps Script or gateway returns).
                         //      // Example: if (!responseData?.result || typeof responseData.result !== 'string') { throw new Error("Invalid response format from backend."); }
                         //     Logger.info(`SimulatedGoogleAppsScriptService.runScriptFunction: REAL fetch succeeded. Response data:`, responseData);
                         //     return responseData; // Return the data from the backend response.
                         // } catch (fetchError) {
                         //      Logger.error(`SimulatedGoogleAppsScriptService.runScriptFunction: REAL fetch failed:`, fetchError);
                         //      throw fetchError; // Re-throw the fetch error.
                         // }
                         */

                         // --- Simulation Implementation ---
                         // If NOT using the real fetch structure above, execute the client-side simulation.
                         Logger.debug(`SimulatedGoogleAppsScriptService.runScriptFunction: Executing client-side simulation of call to endpoint "${this.#endpointUrl}"...`);

                         // Simulate the asynchronous delay for the API call and Apps Script execution.
                         return new Promise((resolve, reject) => {
                             setTimeout(() => {
                                 try {
                                      // --- Simulate Success or Failure ---
                                      // Introduce randomness to simulate API call success or failure for error handling testing.
                                      // Example: 90% chance of success, 10% chance of simulated failure.
                                      const simulateSuccess = Math.random() > 0.1; // Adjust rate as needed.

                                      if (simulateSuccess) {
                                          // If simulating success, log completion and resolve the Promise.
                                          Logger.info(`SimulatedGoogleAppsScriptService.runScriptFunction: Simulated data sent successfully to Apps Script endpoint.`);
                                           // Simulate a response object. A common pattern for Apps Script Web Apps is returning a JSON object like `{ result: 'success', message: '...', ... }`.
                                          const simulatedResponse = {
                                             result: 'success', // Indicate success.
                                             message: 'Data received and processed by simulated Apps Script.', // A simulated message.
                                              dataReceived: data, // Include the data received for verification (optional).
                                              simulatedExecutionTimeMs: AppConfig.SIMULATED_SERVICE_DELAY_MS // Simulation time.
                                           };
                                          resolve(simulatedResponse); // Resolve the promise with the simulated success response object.

                                       } else {
                                           // If simulating failure, log a warning and reject the Promise with a simulated error.
                                           Logger.warn(`SimulatedGoogleAppsScriptService.runScriptFunction: Simulated Apps Script call failed randomly.`);
                                            // Simulate different possible API or Apps Script execution error messages.
                                           const simulatedFailureMessages = [
                                                'Simulated Apps Script execution error occurred.', // Generic script error.
                                               'Simulated invalid data format received by script.', // Script rejected the data format.
                                               'Simulated script permission error.', // Script couldn't perform action due to permissions.
                                               'Simulated timeout during script execution.', // Script took too long.
                                               'Simulated backend gateway processing error.', // Issue on your backend before/after script call.
                                           ];
                                            const randomErrorMsg = simulatedFailureMessages[Math.floor(Math.random() * simulatedFailureMessages.length)]; // Select a random error message.
                                            // Reject the promise with a new Error object including the simulated message.
                                           reject(new Error(`Simulated Apps Script Error: ${randomErrorMsg}`));
                                        }
                                 } catch (timeoutCallbackError) {
                                      // Catch any unexpected errors occurring *within* the `setTimeout` callback function itself after the delay.
                                      // This is a defensive catch for logic errors *inside* the simulation execution.
                                     this.#errorReporter.reportError(
                                          'SimulatedGoogleAppsScriptService.runScriptFunction - timeoutCallback', // Source indicating callback execution.
                                          timeoutCallbackError, // The error object caught.
                                          { sentData: data, endpoint: this.#endpointUrl, step: 'simulated_async_timeout_callback_execution' }, // Context.
                                          'Internal error within simulated Apps Script execution processing.', // User message.
                                          'gs_sim_timeout_callback_exception' // GA error code.
                                     );
                                     // Re-throw the error within the callback to ensure it propagates as a Promise rejection.
                                     reject(timeoutCallbackError); // Reject the promise with the caught error.
                                 }
                             }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use the configured delay for the simulated asynchronous operation.


                         // End of simulation promise construction.

                     } catch (setupError) {
                          // --- Handle Errors During Setup ---
                          // Catch any unexpected synchronous errors occurring *before* the asynchronous operation even starts
                          // (e.g., errors in the try block before creating the Promise, initial configuration or data validation failures before calling setTimeout).
                         this.#errorReporter.reportError(
                             'SimulatedGoogleAppsScriptService.runScriptFunction', // Source.
                             setupError, // The error object caught.
                             { sentDataInput: data, endpoint: this.#endpointUrl, step: 'setup_before_async' }, // Context.
                             'Simulated Apps Script call setup failed. Operation cancelled.', // User-friendly message.
                             'gs_sim_setup_exception' // GA error code.
                         );
                          // Throw the error to be caught by the caller's `catch` block (`_handleSendToAppsScriptClick`), indicating a failure during setup.
                          throw error; // Re-throw the error.
                      }
                  } // End of runScriptFunction method definition.


                 /**
                  * Dispose method for cleanup on application shutdown or when the `SimulatedGoogleAppsScriptService` instance is no longer needed.
                  * In a real application, this might involve cancelling pending network requests or cleaning up resources.
                  * In this simulation, it mainly clears the endpoint URL reference.
                  */
                  dispose() {
                      try {
                           Logger.debug("SimulatedGoogleAppsScriptService.dispose: Disposing SimulatedGoogleAppsScriptService.");
                          // In a real application, you might need to abort any ongoing fetch requests related to this service.
                          // This would involve storing AbortController signals when making requests and calling `abort()` here.
                          // Clear the reference to the endpoint URL.
                          this.#endpointUrl = null; // Clear reference.
                          // The `#errorReporter` reference is not cleared here as it is a shared instance managed at a higher level.

                          Logger.debug("SimulatedGoogleAppsScriptService.dispose: Disposal complete.");

                      } catch (error) {
                           // Catch and log errors occurring during the disposal process.
                           // Use the injected reporter if available, otherwise fallback to console.
                           if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                               this.#errorReporter.reportError(
                                   'SimulatedGoogleAppsScriptService.dispose', error, {},
                                   'Error disposing Simulated Google Apps Script service.',
                                   'gs_dispose_exception' // GA error code.
                               );
                           } else {
                             console.error("SimulatedGoogleAppsScriptService.dispose: Error disposing (Reporter missing or failed):", error);
                           }
                          // Do not re-throw from a dispose method.
                       }
                  } // End of dispose method definition.
              } // End of SimulatedGoogleAppsScriptService class definition.


              // --- Simulated Generative AI Service ---
              // This class simulates fetching an AI-generated text tip (e.g., a travel tip for a destination)
              // using a simulated GenAI service.
              // In a real application, this would involve client-side JS calling a backend endpoint,
              // and that backend securely calling a real GenAI API (like Google's Vertex AI, OpenAI API).
              // This class mimics the client-side structure of making an async call to an endpoint for text generation.
              class SimulatedGenAIService {
                  // Private member storing the URL of the simulated GenAI tip endpoint (likely a backend gateway endpoint).
                  #endpointUrl;
                  #errorReporter; // Reference to the shared ErrorReporter instance.

                  /**
                   * Constructor for SimulatedGenAIService.
                   * Initializes the service with the endpoint URL of the GenAI tip API (or a backend gateway).
                   * @param {string} endpointUrl - The URL string of the backend endpoint for AI tips (placeholder from `AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API_GATEWAY`). Required.
                   * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. Required.
                   * @throws {Error} If `endpointUrl` or `errorReporter` are invalid or missing, preventing the service from being initialized.
                   */
                 constructor(endpointUrl, errorReporter) {
                     try {
                         Logger.debug(`SimulatedGenAIService constructor called with endpoint: "${endpointUrl}".`);

                         // --- Check Configuration ---
                          // Validate the provided endpoint URL. Must be a string and should not be the placeholder value.
                          // It should also be a valid URL format (absolute http(s) or relative starting with /).
                         if (!endpointUrl || typeof endpointUrl !== 'string' || endpointUrl.includes('_PLACEHOLDER')) {
                             const configErrorMsg = `GenAI tip endpoint URL is missing, not a string, or is a placeholder. Simulated service will not be considered configured.`;
                             Logger.warn(`SimulatedGenAIService.constructor: ${configErrorMsg}`);
                             this.#endpointUrl = null; // Explicitly set to null if not configured properly.
                              // Note: An informational message about missing configuration is shown by the SearchForm constructor if `!isConfigured()`.
                          } else {
                             // Basic URL format check.
                              if (!/^https?:\/\//i.test(endpointUrl) && !/^\//.test(endpointUrl)) {
                                  const formatErrorMsg = `Invalid format for GenAI tip endpoint URL: "${endpointUrl}". Must be an absolute (http/https) or relative path (starting with /).`;
                                 Logger.error(`SimulatedGenAIService.constructor: ${formatErrorMsg}`);
                                  // Set endpoint to null and throw error if format is invalid.
                                 this.#endpointUrl = null;
                                 throw new Error(formatErrorMsg);
                              }
                              // Store the validated endpoint URL.
                             this.#endpointUrl = endpointUrl;
                              Logger.debug(`Simulated GenAI service configured with endpoint: "${this.#endpointUrl}".`);
                          }

                          // --- Check ErrorReporter Dependency ---
                           // Validate the required ErrorReporter dependency.
                          if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                             const reporterErrorMsg = "ErrorReporter instance not provided to SimulatedGenAIService constructor. Error handling will be compromised.";
                             Logger.error(reporterErrorMsg);
                              // Set a fallback dummy reporter if missing.
                             this.#errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[GENAI NO REPORTER ERROR] ${src}: ${msg}`, err, ctx) };
                          } else {
                             this.#errorReporter = errorReporter; // Store the valid reporter.
                              Logger.debug(`SimulatedGenAIService: ErrorReporter dependency successfully injected and stored.`);
                          }


                          // Log successful initialization.
                          Logger.debug(`SimulatedGenAIService initialized.`);

                      } catch (error) {
                           // Catch any unexpected errors occurring *within* the constructor logic itself (e.g., during validation).
                           // Report this critical constructor failure using the injected reporter (or console if reporter failed).
                           if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                                this.#errorReporter.reportError(
                                    'SimulatedGenAIService.constructor', error, // Source and error.
                                    { endpoint: endpointUrl, step: 'constructor_execution' }, // Context.
                                    'Failed to construct Simulated GenAI service.', // User-facing message.
                                    'genai_init_exception_critical' // GA error code.
                                );
                           } else {
                                // Fallback console error if reporter wasn't available.
                                console.error(`FATAL: Error during SimulatedGenAIService constructor (Reporter missing or failed):`, error, { endpoint: endpointUrl });
                           }
                           // Ensure `#endpointUrl` is explicitly set to null if initialization failed critically.
                           this.#endpointUrl = null; // Defensive assignment.
                           // Re-throw the error to propagate it to the main application bootstrap logic.
                           throw error;
                       } // End of constructor try...catch.
                   } // End of constructor definition.

                  /**
                   * Public method to check if the GenAI service is considered configured and ready for use.
                   * This checks if a valid, non-placeholder endpoint URL was provided during construction.
                   * @returns {boolean} - Returns `true` if the service endpoint is configured (non-null and not placeholder), `false` otherwise or if an error occurs during the check.
                   */
                  isConfigured() {
                      try {
                           // The service is configured if `#endpointUrl` is not null and not the placeholder string.
                           const configured = this.#endpointUrl !== null && this.#endpointUrl !== AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API_GATEWAY;
                           // Logger.debug(`SimulatedGenAIService.isConfigured: ${configured}.`); // Too noisy debug.
                           return configured;
                       } catch (error) {
                            // Catch errors during the check (unlikely with simple property access).
                            this.#errorReporter.reportError(
                                `${this.name}.isConfigured`, error, {}, // Source and error.
                                `Error checking GenAI service configuration status.`, // User message.
                                'genai_check_config_exception' // GA error code.
                            );
                            return false; // Assume not configured if an error occurs.
                       }
                  } // End of isConfigured method definition.

                  /**
                   * Public asynchronous method to simulate getting an AI-generated destination tip. Marked async.
                   * This simulates making an API call (via a backend endpoint defined by `this.#endpointUrl`)
                   * to a GenAI model based on the user-provided `destination` input.
                   * This method is designed to be called by the `SearchForm` to fetch a tip after a search.
                   * It validates input, simulates the asynchronous call, handles potential success and failure scenarios, and is designed to throw/reject on errors.
                   * @param {string} destination - The destination string (e.g., city name) for which to request the AI-generated tip. Required.
                   * @returns {Promise<string|null>} A Promise that resolves with the AI-generated tip text string upon simulated success and if the response contains a valid tip, or `null` if the service is not configured, the input `destination` is invalid/empty, or if the simulated asynchronous call fails (Promise rejection). Returns `null` if an error occurs within the method itself before calling the simulated endpoint.
                   * @throws {Error} - Throws an error if the service is not configured or the input `destination` is invalid *before* starting the async call setup.
                   */
                  async getDestinationTip(destination) {
                      try {
                           Logger.debug(`SimulatedGenAIService.getDestinationTip: Starting simulated AI tip fetch process for destination: "${destination}"...`);

                           // --- Check Service Configuration ---
                           // Ensure the GenAI service is configured (has a valid, non-placeholder endpoint) before attempting the tip fetch.
                           if (!this.isConfigured()) { // Use the public check method.
                                const configErrorMsg = AppConfig.MESSAGES.GENAI_ENDPOINT_MISSING; // Get the standard message.
                                Logger.warn(`SimulatedGenAIService.getDestinationTip: ${configErrorMsg}. Cannot proceed with tip fetch.`);
                                // Do NOT throw here. A non-configured GenAI service for a TIP is not fatal to the core app search flow.
                                // Just return null to indicate no tip could be fetched. The caller (`_fetchAndDisplaySimulatedAITip`) handles this null return.
                                return null; // Return null.
                           }

                           // --- Validate Input Parameter ---
                           // Ensure the `destination` string is provided and is not empty after trimming. The GenAI prompt needs a destination.
                           if (!destination || typeof destination !== 'string' || destination.trim() === '') {
                                const inputErrorMsg = "Invalid or empty destination provided for GenAI tip.";
                                Logger.warn(`SimulatedGenAIService.getDestinationTip: ${inputErrorMsg}`, { destinationInput: destination });
                                // Throw an error here to indicate that the operation failed due to invalid input data.
                                throw new Error(inputErrorMsg); // Throw error for invalid input data.
                           }
                           // Use the trimmed destination.
                           const trimmedDestination = destination.trim();


                           // --- Simulate Calling Backend Endpoint for AI Tip ---
                           // In a real application, you would replace the simulation below with an actual asynchronous HTTP request (`fetch` or `$.ajax`)
                           // to your own backend endpoint (`this.#endpointUrl`). Your backend would then:
                           // 1. Receive the destination/prompt from the client.
                           // 2. Securely access your GenAI API credentials.
                           // 3. Call the real GenAI model API (e.g., Vertex AI `generateContent`) with a prompt based on the destination.
                           // 4. Process the response from the GenAI model (extracting the generated text, checking safety attributes).
                           // 5. Send the generated text (or an object containing it) back to the client in a JSON response.

                           /* Example structure of a REAL fetch to a backend endpoint (COMMENTED OUT):
                           // const endpointUrl = this.#endpointUrl; // Use the stored endpoint URL.
                           // Logger.debug(`SimulatedGenAIService.getDestinationTip: Making REAL fetch call to backend endpoint "${endpointUrl}" for tip...`, { destination: trimmedDestination });
                           // try {
                           //     const response = await fetch(endpointUrl, {
                           //         method: 'POST', // Often POST for sending data (like the destination prompt).
                           //         headers: {
                           //             'Content-Type': 'application/json', // Indicate sending JSON data.
                           //             // Add any required headers for authentication/authorization with YOUR backend gateway if needed.
                           //             // This is *not* where GenAI API keys go!
                           //         },
                           //         body: JSON.stringify({ destination: trimmedDestination }), // Send destination in the body.
                           //     });
                           //     // Check for HTTP errors.
                           //     if (!response.ok) {
                           //         const errorBodyText = await response.text();
                           //         const httpErrorDetails = `${response.status} - ${response.statusText || 'Unknown Status'} - ${errorBodyText.substring(0, 200)}`;
                           //         const httpError = new Error(`Backend HTTP error calling GenAI endpoint: ${httpErrorDetails}`);
                           //         Logger.error(`SimulatedGenAIService.getDestinationTip: Backend fetch failed with HTTP status ${response.status}.`, { error: httpError, responseText: errorBodyText, backendEndpoint: endpointUrl });
                           //         throw httpError; // Re-throw the HTTP error.
                           //     }
                           //     // Attempt to parse JSON response from the backend. It should contain the generated text.
                           //     const responseData = await response.json();
                           //     // Validate the structure of the response data received from your backend.
                           //     // Assuming your backend returns a structure like `{ tip: "Generated tip text" }` or just the text string itself.
                           //      if (typeof responseData !== 'string' && (typeof responseData !== 'object' || responseData === null || typeof responseData.tip !== 'string')) {
                           //           const invalidFormatError = new Error("Invalid response format received from backend for AI tip.");
                           //           Logger.error(`SimulatedGenAIService.getDestinationTip: Invalid response format from backend.`, { responseData: responseData });
                           //           throw invalidFormatError; // Throw error indicating bad response format.
                           //       }
                           //     // Extract the tip string.
                           //      const generatedTip = typeof responseData === 'string' ? responseData : responseData.tip;
                           //     Logger.info(`SimulatedGenAIService.getDestinationTip: REAL fetch succeeded. Generated tip received.`);
                           //      // Return the generated tip string.
                           //     return generatedTip || null; // Return null if tip is empty/null.
                           // } catch (fetchError) {
                           //      Logger.error(`SimulatedGenAIService.getDestinationTip: REAL fetch failed:`, fetchError);
                           //      throw fetchError; // Re-throw the fetch error.
                           // }
                           */


                           // --- Simulation Implementation ---
                           // If NOT using the real fetch structure above, execute the client-side simulation of the AI tip fetch.
                           Logger.debug(`SimulatedGenAIService.getDestinationTip: Executing client-side simulation of call to endpoint "${this.#endpointUrl}"...`, { destination: trimmedDestination });

                           // Simulate the asynchronous delay for the API call and GenAI processing using a Promise and `setTimeout`.
                           return new Promise((resolve, reject) => {
                               setTimeout(() => {
                                   try {
                                        // --- Simulate Success or Failure ---
                                        // Introduce randomness to simulate API call success or failure for error handling testing.
                                        // Example: 85% chance of success, 15% chance of simulated failure.
                                        const simulateSuccess = Math.random() > 0.15; // Adjust rate as needed.

                                        if (simulateSuccess) {
                                            // If simulating success, log completion and resolve the Promise.
                                            Logger.info(`SimulatedGenAIService.getDestinationTip: Simulated AI tip fetch successful for "${trimmedDestination}".`);
                                             // Simulate different possible AI tip string responses or indicate placeholder data.
                                             // Randomly select a tip string from a predefined list.
                                            const simulatedTips = [
                                               `Exploring local markets in ${trimmedDestination} is a fantastic way to experience the culture and cuisine.`,
                                               `For a unique perspective in ${trimmedDestination}, consider taking a walking tour off the beaten path.`,
                                                `Visiting ${trimmedDestination}'s main park early in the morning can offer beautiful views and a peaceful start to your day.`,
                                                `Simulated tip: Check the weather forecast for ${trimmedDestination} a few days before your trip to pack appropriately.`
                                            ];
                                             const simulatedGeneratedTip = simulatedTips[Math.floor(Math.random() * simulatedTips.length)]; // Select a random tip string.
                                             // Optional: Simulate a response where no tip is generated for some destinations.
                                             // if (trimmedDestination.toLowerCase().includes('unknown')) { simulatedGeneratedTip = null; }

                                            // Resolve the promise with the simulated tip string (or null if simulating no tip generated).
                                            resolve(simulatedGeneratedTip); // Resolve the promise with the string or null.

                                        } else {
                                            // If simulating failure, log a warning and reject the Promise with a simulated error.
                                            Logger.warn(`SimulatedGenAIService.getDestinationTip: Simulated AI tip fetching failed randomly for "${trimmedDestination}".`);
                                             // Simulate different possible API or GenAI execution error messages.
                                            const simulatedFailureMessages = [
                                                 'Simulated GenAI API connection failed during tip generation.', // Generic API connection error.
                                                'Simulated prompt safety policy violation detected by model.', // Example specific to AI content moderation.
                                                'Simulated GenAI internal server error during processing.', // Model/API internal issue.
                                                'Simulated backend gateway processing error during AI call.', // Issue on your backend gateway.
                                                'Simulated timeout during GenAI response generation.' // Request took too long.
                                             ];
                                              const randomErrorMsg = simulatedFailureMessages[Math.floor(Math.random() * simulatedFailureMessages.length)]; // Select a random error message.
                                             // Reject the promise with a new Error object including the simulated message.
                                            reject(new Error(`Simulated GenAI Error: ${randomErrorMsg}`));
                                        }
                                   } catch (timeoutCallbackError) {
                                        // Catch any unexpected errors occurring *within* the `setTimeout` callback function itself after the delay.
                                        // This is a defensive catch for logic errors *inside* the simulation execution.
                                       this.#errorReporter.reportError(
                                            'SimulatedGenAIService.getDestinationTip - timeoutCallback', // Source.
                                            timeoutCallbackError, // The error object caught.
                                            { destination: trimmedDestination, endpoint: this.#endpointUrl, step: 'simulated_async_timeout_callback_execution' }, // Context.
                                            'Internal error within simulated GenAI tip processing.', // User message.
                                            'genai_sim_timeout_callback_exception' // GA error code.
                                       );
                                      // Re-throw the error within the callback to ensure it propagates as a Promise rejection.
                                       reject(timeoutCallbackError); // Reject the promise with the caught error.
                                   }
                               }, AppConfig.SIMULATED_SERVICE_DELAY_MS); // Use the configured delay for the simulated asynchronous operation.

                            // End of simulation promise construction.

                         } catch (setupError) {
                              // --- Handle Errors During Setup ---
                              // Catch any unexpected synchronous errors occurring *before* the asynchronous operation even starts (e.g., errors in the try block before creating the Promise, initial validation failures before calling setTimeout).
                              this.#errorReporter.reportError(
                                  'SimulatedGenAIService.getDestinationTip', // Source.
                                  setupError, // The error object caught.
                                  { destinationInput: destination, endpoint: this.#endpointUrl, step: 'setup_before_async' }, // Context.
                                  'Simulated GenAI tip fetch setup failed. Operation cancelled.', // User-friendly message.
                                  'genai_sim_setup_exception' // GA error code.
                              );
                              // This method is designed to return a Promise resolving with null on error or non-configured.
                              // Throwing indicates a failure before the async call was set up. Return null instead of re-throwing
                              // to fit the method's declared return type Promise<string|null>.
                              return null; // Return null on synchronous setup error.
                         }
                     } // End of getDestinationTip method definition.

                   /**
                    * Dispose method for cleanup on application shutdown or when the `SimulatedGenAIService` instance is no longer needed.
                    * In a real application, this might involve cancelling pending network requests (`fetch` calls using AbortController)
                    * or cleaning up resources tied to the service instance.
                    * In this simulation, it mainly clears the endpoint URL reference.
                    */
                   dispose() {
                       try {
                            Logger.debug("SimulatedGenAIService.dispose: Disposing SimulatedGenAIService.");
                           // In a real application using `fetch`, you would ideally abort any ongoing requests started by this service's instance here.
                           // This would involve storing AbortController signals when making requests and calling `abort()` on them in the dispose method.
                           // Example: if (this.#activeFetchSignal) this.#activeFetchSignal.abort();

                           // Clear the reference to the endpoint URL.
                           this.#endpointUrl = null; // Clear reference.
                           // The `#errorReporter` reference is not cleared here as it is a shared instance managed at a higher level.

                           Logger.debug("SimulatedGenAIService.dispose: Disposal complete.");

                       } catch (error) {
                            // Catch and log errors occurring during the disposal process.
                            // Use the injected reporter if available, otherwise fallback to console.
                            if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                                this.#errorReporter.reportError(
                                    'SimulatedGenAIService.dispose', error, {}, // Source and error.
                                    'Error disposing Simulated GenAI service.', // User message.
                                    'genai_dispose_exception' // GA error code.
                                );
                            } else {
                              console.error("SimulatedGenAIService.dispose: Error disposing (Reporter missing or failed):", error);
                            }
                           // Do not re-throw from a dispose method.
                       }
                   } // End of dispose method definition.
               } // End of SimulatedGenAIService class definition.


               // --- Base Class for any UI Component ---
               // This class serves as the foundational base class for all UI components in the application
               // that are associated with and manage a specific HTML DOM element.
               // It provides common functionalities including finding and storing the wrapped DOM element,
               // storing its ID and a descriptive name, maintaining a basic internal validity state,
               // adding and removing DOM event listeners safely, and implementing a standard disposal pattern.
               class TravelComponent {
                   // Private members (ES2022+ `#` syntax) - Data strictly encapsulated within the class instance.
                   #componentId; // The unique identifier for the component, typically derived from the ID of the HTML element it wraps.
                   #componentName; // A descriptive string name for the component type (e.g., 'SearchForm', 'InputComponent'). Used primarily for logging and debugging.

                   // Protected members (underscore `_` convention) - Intended for use by the class itself and its subclasses.
                   // Access from outside instances is discouraged by convention, though not enforced by JavaScript.
                   _element; // A reference to the HTML DOM element that this component instance is associated with and wraps. This is the primary element the component manages. `null` if not found.
                   _isValid = true; // An internal boolean flag representing the component's current validation status. Initialized to `true`, updated by `_validate()`.
                   _eventHandlers = {}; // An object map used to store references to all DOM event listeners attached by this component instance (using `_addEventListener`). This allows systematic removal during disposal to prevent memory leaks. Structured as: `{ elementIdentifier: { eventType: [{ handler, options, targetElement }, ...] }, ... }`.
                    _errorReporter; // Reference to the shared `ErrorReporter` instance. This dependency is injected during construction and used for logging, UI messaging, and GA tracking of errors originating from this component.


                   // Static property - Belongs to the `TravelComponent` class itself, not to individual instances.
                   // Useful for class-level constants or shared data not tied to any specific component instance.
                   static APP_VERSION = AppConfig.APP_VERSION; // Stores the application version from AppConfig.

                   /**
                    * Static method - Belongs to the `TravelComponent` class itself.
                    * A utility method to log the application version. Can be called without creating a component instance.
                    */
                   static logAppVersion() {
                       // Uses the global `Logger` utility to log the application version using the static `APP_VERSION` property.
                       Logger.info(`App Version: ${TravelComponent.APP_VERSION}`);
                   }

                   /**
                    * Constructor for the base `TravelComponent`.
                    * It is responsible for:
                    * 1. Validating essential input parameters (`elementId`, `errorReporter`).
                    * 2. Initializing the component's private members (`#componentId`, `#componentName`).
                    * 3. Attempting to find and store a reference to the corresponding HTML element in the DOM using the provided `elementId`.
                    * 4. Initializing the component's protected validity state (`_isValid`). If the HTML element is not found, the component is marked as invalid.
                    * 5. Initializing the map for storing event handlers (`_eventHandlers`).
                    * 6. Injecting the shared `ErrorReporter` instance and storing its reference.
                    * 7. Calling the protected `_initialize` method (which subclasses override) if the HTML element was found.
                    * Errors during construction (except for finding the element, which results in isValid=false) are logged and re-thrown.
                    * @param {string} elementId - The unique ID attribute value of the HTML element this component should wrap and manage. Required.
                    * @param {string} [componentName='TravelComponent'] - A descriptive name for this specific type of component (e.g., 'SearchForm', 'DestinationInput'). Defaults to 'TravelComponent'.
                    * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. This dependency is injected into the component to enable centralized error reporting. Required.
                    * @throws {Error} If a required parameter (like `elementId`) is invalid or missing during construction, or if `errorReporter` is not provided.
                    */
                   constructor(elementId, componentName = 'TravelComponent', errorReporter) {
                        try {
                            // Log the start of the constructor for debugging.
                           Logger.debug(`TravelComponent constructor called for element ID "${elementId}" as component "${componentName}".`);

                            // --- Validate Required Dependencies ---
                            // Check if the required `ErrorReporter` instance was provided. Without it, error reporting within the component hierarchy will be compromised.
                           if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                                const errorMsg = `ErrorReporter instance not provided or is invalid for component "${componentName}" (ID: "${elementId}"). Error handling from this component will fallback to console.`;
                                Logger.error(errorMsg, { elementId: elementId, componentName: componentName, reporterProvided: !!errorReporter });
                                // If the reporter is missing, set `this._errorReporter` to a dummy object that logs errors directly to the console.
                                // This prevents method calls (`this._errorReporter.reportError(...)`) from crashing but indicates the issue.
                                this._errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[COMPONENT_NO_REPORTER_FALLBACK] ${src}: ${msg}`, err, ctx) };
                                // Decide if lack of reporter is a fatal init error or just a warning. For core utilities, maybe fatal; for components, often a warning allows partial function.
                                // For this demo, it allows the component to attempt creation but with fallback error reporting.
                                // throw new Error(errorMsg); // Uncomment to make this fatal if reporter is missing.
                           } else {
                              // Store the valid `ErrorReporter` instance reference in a protected member.
                              this._errorReporter = errorReporter; // Store reference.
                              Logger.debug(`TravelComponent: ErrorReporter dependency successfully injected and stored.`);
                           }

                            // --- Validate and Initialize Component Identity ---
                            // Check if the provided `elementId` is a valid, non-empty string.
                            // The component relies on a valid ID to find its HTML element and for mapping in the `_inputs` map.
                           if (typeof elementId !== 'string"
                                                                return; // Exit the loop.
                               }


                             // --- Handle Errors Thrown by Individual `getValue()` Methods ---
                              } catch (error) {
                                   // Catch any unexpected errors thrown *by an individual component's `getValue()` method* during its execution.
                                   // This error represents a flaw in the component's value retrieval logic itself, not a validation *failure*.
                                   this.#errorReporter.reportError(
                                       `SearchParamCollector.collect - getValue`,
                                       error, // The error object thrown by `getValue`.
                                       { inputId: inputId, componentName: component?.name, step: 'get_value_execution_exception' }, // Provide context.
                                       `Error collecting value for input "${inputId}". Parameter unavailable.`, // User-friendly message template.
                                       'collector_get_value_exception' // GA error code.
                                   );
                                    // Set the parameter value to `null` in the results object if its retrieval failed due to an error.
                                    // This indicates that the value for this specific input could not be obtained.
                                   collectedParameters[inputId] = null;
                                    // Set the flag indicating that at least one individual collection issue occurred.
                                   hadIndividualCollectionIssues = true; // Set flag.
                               } // End of try...catch around individual getValue().
                            } else {
                                 // This case should ideally not be reachable if iterating `Object.keys` and using `hasOwnProperty` or iterating `Object.values` directly on the object, as it would mean the item at `inputId` in the map is not an object or is on the prototype chain. Included defensively.
                                Logger.warn(`Collector.collect: Unexpected item type or missing property for key "${inputId}" in inputs map prototype chain. Skipping collection for this key.`);
                                // Set to null and mark as an issue.
                                collectedParameters[inputId] = null;
                                hadIndividualCollectionIssues = true;
                            } // End of hasOwnProperty check.
                         }); // End of `inputIds.forEach` loop.


                         // --- Report Overall Collection Status ---
                         // After the loop finishes processing all input IDs in the map, check the `hadIndividualCollectionIssues` flag.
                         if (hadIndividualCollectionIssues) {
                            // Log a warning if any individual input value could not be collected successfully
                            // due to a missing component, an invalid component instance, or an error in the `getValue` method.
                            Logger.warn("SearchParamCollector.collect: Parameter collection completed with some issues. Returned parameters object may be incomplete (some values are null).", { issuesDetected: true, collectedKeysCount: Object.keys(collectedParameters).length, totalInputsInMap: inputIds.length });
                            // Note: The calling code (`SearchForm`) must be designed to handle potential `null` values for parameters
                            // if the `collect` method reports issues, especially when building URLs or sending data to services.
                         } else {
                              // Log success if all input values were collected from all managed input components without any issues.
                              Logger.debug("SearchParamCollector.collect: Parameter collection completed successfully for all managed inputs.");
                         }

                         // Log the final object containing all collected parameters for debugging.
                         // Using `JSON.stringify(..., null, 2)` provides pretty-printed JSON in the console.
                         Logger.info("SearchParamCollector.collect: Final Collected Parameters Object:\n", JSON.stringify(collectedParameters, null, 2));

                         // Return the successfully created and populated `collectedParameters` object.
                         return collectedParameters; // Return the results.

                     } catch (error) {
                          // --- Handle Critical Errors During Overall Collection Process ---
                          // This outer catch block acts as a final safety net for any uncaught critical errors that occur *during the overall execution of the `collect` method itself*,
                          // if they were not caught by the more specific try/catch blocks within (e.g., errors during the try/catch/loop structure setup, unhandled exceptions propagating from the loop, issues accessing `this.#inputComponents` unexpectedly).
                          // This indicates a severe failure in the core parameter collection logic itself.
                          Logger.error(`SearchParamCollector.collect: CRITICAL UNEXPECTED ERROR caught during parameter collection process!`, error);

                          // Report this critical failure using the injected reporter.
                          this.#errorReporter.reportError(
                              'SearchParamCollector.collect', // Source of the error report.
                              error, // The error object caught.
                              { formId: this.id, step: 'overall_collection_process_critical_exception' }, // Context details.
                              'Critical error during search parameter collection process. Cannot obtain input values.', // User-facing message template for a fundamental collection failure.
                              'collector_critical_exception_overall' // GA error code for a critical overall collection exception.
                          );

                          // Re-throw a new error to signal to the caller (`SearchForm.searchHotels()`)
                          // that parameter collection failed fundamentally due to an internal error.
                          // Include the original error's message for context.
                          throw new Error(`Failed to collect search parameters due to internal error: ${error.message}`);
                     } // End of collect method try...catch...finally (no finally used here).
                 } // End of collect method definition.

                  /**
                   * Public method to retrieve the current value of a specific parameter from the collected data by its input ID.
                   * This is a convenience method for accessing the value of a single input component directly from the stored map, without collecting all parameters.
                   * It is useful when you need to quickly get the value of a known input without iterating through the entire collection or relying on the output of the `collect()` method.
                   * Includes error handling for missing components or errors during value retrieval.
                   * @param {string} inputId - The ID string of the HTML element/component whose value is needed (e.g., 'destinationInput', 'checkInDateInput'). This key is used to look up the component instance in the managed map. Required.
                   * @returns {*} The current value of the parameter as returned by the corresponding component's `getValue()` method, if a valid component is found and retrieval succeeds. Returns `null` if:
                   *              - A component with the given `inputId` is not found in the managed map.
                   *              - The found item in the map is not a valid component instance.
                   *              - The component instance exists but its public `getValue` method is missing.
                   *              - An unexpected error occurs during the value retrieval process for that component.
                   *              Also returns `null` for invalid input (`inputId` not a valid string).
                   */
                  getParam(inputId) {
                      try {
                           Logger.debug(`SearchParamCollector.getParam: Attempting to get value for specific input ID: "${inputId}".`);

                           // --- Validate Input ID ---
                           // Ensure the provided `inputId` is a valid, non-empty string before using it as a key.
                          if (typeof inputId !== 'string' || inputId.trim() === '') {
                               const invalidInputMsg = `Invalid inputId provided to getParam method. Must be a non-empty string. Cannot retrieve parameter.`;
                              Logger.warn(`SearchParamCollector.getParam: ${invalidInputMsg}`, { inputId: inputId });
                              // Could optionally report this as a warning via ErrorReporter if desired, but often console logging is sufficient for invalid input.
                              return null; // Return null to indicate failure due to invalid input ID.
                           }

                           // --- Check Input Map Availability ---
                           // Ensure the internal input components map (`this.#inputComponents`) is valid and available.
                           // This should have been handled in the constructor, but defensive check.
                           if (!this.#inputComponents || typeof this.#inputComponents !== 'object') {
                                const mapMissingMsg = `SearchParamCollector.getParam: Internal input components map is missing when trying to get parameter "${inputId}". Cannot retrieve parameter.`;
                               Logger.warn(`SearchParamCollector.getParam: ${mapMissingMsg}`);
                               // Report this internal inconsistency error via the ErrorReporter.
                               this.#errorReporter.reportError(
                                   'SearchParamCollector.getParam', new Error("Input components map missing internally."), // Source and error.
                                   { formId: this.id, inputId: inputId, step: 'get_param_map_missing' }, // Context.
                                   `Internal error getting parameter "${inputId}". Parameter unavailable.`, "collector_get_param_map_missing_critical" // GA error code.
                               );
                               return null; // Cannot get parameter if the map itself is missing.
                           }

                           // --- Retrieve and Validate Component ---
                           // Attempt to retrieve the component instance from the map using the provided `inputId`.
                           const component = this.#inputComponents[inputId];

                           // Check if a component instance was found in the map for the given ID.
                           if (!component) {
                                // If no component was found in the map for the given `inputId`, it means either the ID is wrong,
                                // or the corresponding input element was not processed/initialized into a component during `_collectAndInitializeInputs`.
                                Logger.warn(`SearchParamCollector.getParam: Component with ID "${inputId}" not found in managed inputs map. Cannot get parameter.`);
                                // Report this configuration or initialization issue via the ErrorReporter.
                                this.#errorReporter.reportError(
                                    'SearchParamCollector.getParam', new Error(`Component with ID "${inputId}" not found in managed map.`),
                                    { formId: this.id, inputId: inputId, step: 'get_param_component_not_in_map' },
                                    `Internal error getting parameter "${inputId}" (component not found in map). Parameter unavailable.`, "collector_get_param_component_not_in_map" // GA error code.
                                );
                                return null; // Indicate that the parameter could not be retrieved because the component wasn't managed.
                           }


                          // Check if the retrieved item from the map is a valid component instance with a public `getValue` method.
                           if (typeof component.getValue === 'function') {
                               // --- Get Value from Component ---
                                // Call the component's public `getValue()` method to get its current value.
                              const parameterValue = component.getValue();
                               // Logger.debug(`SearchParamCollector.getParam: Retrieved value for "${inputId}": "${parameterValue}".`); // Verbose logging.
                              return parameterValue; // Return the value obtained from the component.

                          } else {
                               // --- Handle Invalid Component in Map ---
                               // If a component instance was found for the ID, but it's not a valid component instance (e.g., null, wrong type of object stored) or it is missing the required public `getValue` method.
                              Logger.warn(`SearchParamCollector.getParam: Component found for ID "${inputId}" but is invalid or missing getValue. Cannot get parameter.`, { component: component });
                               // Report this issue via the ErrorReporter.
                              this.#errorReporter.reportError(
                                  'SearchParamCollector.getParam', new Error(`Component found for "${inputId}" but is invalid/missing getValue method.`),
                                  { formId: this.id, inputId: inputId, componentObject: component, step: 'get_param_component_invalid' },
                                  `Internal error getting parameter "${inputId}" (invalid component). Parameter unavailable.`, "collector_get_param_component_invalid" // GA error code.
                              );
                              return null; // Indicate the parameter could not be retrieved due to a component issue.
                          }
                       } catch (error) {
                           // --- Handle Unexpected Errors During getParam Execution ---
                           // Catch any unexpected errors occurring *during the overall process* of getting a specific parameter (e.g., errors during property access, calling `getValue` if not caught internally by component).
                            this.#errorReporter.reportError(
                                `${this.name}.getParam`, // Source of the error.
                                error, // The error object caught.
                                { inputId: inputId, step: 'overall_get_param_exception' }, // Context details.
                                `Error getting specific parameter "${inputId}" from collector. Parameter unavailable.`, // User-friendly message.
                                'collector_get_param_exception_overall' // GA error code.
                            );
                           // Always return null on error to indicate that a valid parameter value could not be retrieved.
                           return null;
                       } // End of getParam try...catch.
                   } // End of getParam method definition.

                   /**
                    * Public method to retrieve the entire map of input component instances currently managed by this collector.
                    * This provides external access to the collector's internal structure for inspection or if the caller needs direct access to component methods beyond `getValue`.
                    * @returns {object} - A reference to the internal map where keys are input IDs and values are component instances (`id -> instance`). Returns an empty object (`{}`) on error or if the map is unexpectedly null/invalid.
                    */
                   getAllComponents() {
                       try {
                            Logger.debug(`SearchParamCollector.getAllComponents: Returning inputs map.`);
                           // Return a reference to the internal `#inputComponents` map.
                           // Provide an empty object `{}` as a safe fallback in case the map was not initialized or is unexpectedly null/undefined.
                           return this.#inputComponents || {}; // Return the map or an empty object.

                       } catch (error) {
                            // Catch errors occurring while trying to access the internal map reference.
                            this.#errorReporter.reportError(
                                `${this.name}.getAllComponents`, error, {}, // Source and error.
                                `Error getting all components map from collector. Data may be incomplete.`, // User message.
                                'collector_get_all_components_exception' // GA error code.
                            );
                           return {}; // Return an empty object on error as a safe fallback.
                       }
                   } // End of getAllComponents method definition.

                  /**
                   * Dispose method for cleanup on application shutdown or when the collector instance is no longer needed.
                   * Clears the internal reference to the input components map managed by this collector.
                   * Note: This collector instance does *not* own the component instances themselves; they are created and managed by the `SearchForm`.
                   * Therefore, this `dispose` method does **not** call `dispose()` on individual input components. The `SearchForm` is responsible for disposing its managed components.
                   */
                  dispose() {
                      try {
                          Logger.debug("SearchParamCollector.dispose: Disposing SearchParamCollector instance.");
                           // Clear the reference to the input components map. This helps facilitate garbage collection of the collector instance itself.
                           // Replace the map reference with an empty object (`{}`) instead of `null` to maintain a valid object reference if `getAllComponents` is called after dispose.
                          this.#inputComponents = {}; // Replace the map reference with an empty object.

                          // The `#errorReporter` reference is typically not cleared here as it is a shared instance managed at a higher level (SearchForm's lifecycle).

                          Logger.debug("SearchParamCollector.dispose: Disposal complete.");

                      } catch (error) {
                           // Catch and log errors occurring during the disposal process.
                           // Use the injected reporter if available, otherwise fallback to console.
                           if (this.#errorReporter && typeof this.#errorReporter.reportError === 'function') {
                               this.#errorReporter.reportError(
                                   'SearchParamCollector.dispose', error, {},
                                   'Error disposing Search Parameter Collector.', // User message.
                                   'collector_dispose_exception' // GA error code.
                               );
                           } else {
                             console.error("SearchParamCollector.dispose: Error disposing (Reporter missing or failed):", error);
                           }
                          // Do not re-throw from a dispose method.
                      }
                  } // End of dispose method definition.
              } // End of SearchParamCollector class definition.


              // --- Helper Class for Building the Expedia URL ---
              // This class provides static methods to construct the Expedia search results URL
              // based on collected search parameters. It contains constants for the base URL
              // and the affiliate ID (`mcid`) to ensure tracking is included in the generated link.
              // It handles the correct encoding of URL parameters using `URLSearchParams`.
              // Designed as a static class (cannot be instantiated with `new`).
              class ExpediaUrlBuilder {
                  // Static members accessed directly on the class (e.g., `ExpediaUrlBuilder.BASE_URL`).
                  // These hold constant configuration values needed for building the URL, typically from `AppConfig`.
                  static BASE_URL = AppConfig.EXPEDIA_BASE_SEARCH_URL; // The base URL for Expedia's hotel search results page.
                  static AFFILIATE_ID = AppConfig.EXPEDIA_AFFILIATE_ID; // The affiliate ID for tracking referrals to Expedia.

                  // A private constructor (using `#private constructor() { ... }` in modern JS or relying on convention)
                  // can be defined to explicitly prevent instantiation of this class using the `new` keyword.
                  // For a purely static class, creating instances doesn't make sense.
                  // private constructor() { throw new Error('ExpediaUrlBuilder is a static class and cannot be instantiated.'); } // Example enforcement.


                  /**
                   * Static method to build the complete Expedia search results URL string from collected search parameters.
                   * This method is intended to be called directly on the class (e.g., `ExpediaUrlBuilder.buildUrl(params, reporter)`).
                   * It is responsible for:
                   * 1. Validating that essential search parameters required for a basic Expedia URL are present and have values.
                   * 2. Performing basic cross-validation on parameters relevant to the URL structure (e.g., checking if check-out date is after check-in date based on date strings).
                   * 3. Using `URLSearchParams` to correctly encode all valid parameters into a URL query string.
                   * 4. Including the configured affiliate ID (`mcid`) and other common/optional Expedia URL parameters.
                   * 5. Logging debug information about the process and reporting errors using the provided `ErrorReporter`.
                   * @param {object} params - An object containing the collected search parameters. Keys are expected to be the input element IDs (e.g., 'destinationInput', 'checkInDateInput', 'adultsCountInput'). Values are typically strings or numbers obtained from input component `getValue()`. This object is usually provided by the `SearchParamCollector`. Required.
                   * @param {ErrorReporter} errorReporter - The shared `ErrorReporter` instance. This dependency is required by this static method for logging errors and reporting them centrally.
                   * @returns {string|null} Returns the successfully constructed full Expedia search URL string (starting with `https://` or `http://`) if all essential parameters are valid and building succeeds. Returns `null` if essential parameters are missing/invalid for URL building checks or if a critical error occurs during the URL construction process itself.
                   */
                  static buildUrl(params, errorReporter) {
                      try {
                           Logger.debug("ExpediaUrlBuilder.buildUrl: Starting Expedia URL building process...");

                          // --- Check ErrorReporter Availability ---
                           // As a static method, the `ErrorReporter` dependency must be passed as a parameter to the method, as it's not injected into a static class constructor.
                           // Check if the `errorReporter` instance was provided and has the necessary `reportError` method before attempting to use it.
                           if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                               // If the ErrorReporter is unavailable, log a critical error to the console directly as a fallback.
                               console.error("ExpediaUrlBuilder.buildUrl: ErrorReporter instance is missing or invalid. Error handling within URL builder will fallback to console.");
                               // Provide a dummy reporting method locally to prevent internal error reports from crashing this logic if the provided reporter is invalid or null.
                               errorReporter = { reportError: (src, err, ctx, msg, code) => console.error(`[URL BUILDER NO REPORTERS ERROR] ${src}: ${msg}`, err, ctx) };
                               // Continue execution with the fallback reporter.
                           }


                          // --- Validate Input Parameters Object ---
                           // Ensure the input `params` argument is provided and is a valid JavaScript object before attempting to access its properties.
                          if (!params || typeof params !== 'object') {
                             const errorMsg = "Cannot build URL: Invalid or empty parameters object provided to builder.";
                              // Report this configuration/usage error using the available (real or dummy) ErrorReporter.
                             errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(errorMsg), { paramsReceived: params, step: 'input_validation' }, errorMsg, 'urlbuilder_invalid_params');
                             return null; // Indicate failure by returning null.
                          }
                           // Logger.debug("ExpediaUrlBuilder.buildUrl: Input parameters object appears valid.", { params: params }); // Verbose logging.


                          // --- Define and Check Essential Required Parameters for URL Structure ---
                          // Define an array containing the keys (names) of the parameters that are considered essential for creating a basic, functional Expedia Hotel Search URL.
                          // These should correspond to the input element IDs used in the form and expected as keys in the `params` object obtained from `SearchParamCollector`.
                          const requiredParamsForUrl = ['destinationInput', 'checkInDateInput', 'checkOutDateInput', 'adultsCountInput'];
                          let missingOrInvalidParamsIssues = []; // Initialize an array to collect any issues found during parameter checks.

                          // Iterate through the defined list of required parameter names.
                          requiredParamsForUrl.forEach(paramInputId => {
                               try {
                                   // Get the value for the current required parameter using its `paramInputId` (which is the key in the `params` object).
                                  const value = params[paramInputId];

                                   // Check if the value is missing (`undefined` or `null`) OR if it's a string that is empty after trimming leading/trailing whitespace.
                                   // Using loose equality (`== null`) checks for both `undefined` and `null`. Convert value to string defensively before trim.
                                  if (value == null || (typeof value === 'string' && String(value).trim() === '')) {
                                        // If the value is missing or an empty string...
                                        // Special case check for 'adultsCountInput': This parameter value must parse to an integer >= 1 for a valid search on Expedia.
                                       if (paramInputId === 'adultsCountInput') {
                                            // Attempt to parse the value as an integer. `parseInt(null/undefined/'')` results in `NaN`.
                                            const adultsCount = parseInt(value, 10);
                                           // Check if the value is `NaN` after parsing OR if the parsed number is less than 1.
                                           if (isNaN(adultsCount) || adultsCount < 1) {
                                               // If the adults count is invalid (missing, non-numeric, or less than 1), add a specific issue note to our list of issues.
                                               missingOrInvalidParamsIssues.push(`${paramInputId} (must be at least 1)`);
                                               Logger.warn(`ExpediaUrlBuilder.buildUrl: Required parameter "${paramInputId}" is missing or invalid (value: "${value}"). Issue: Must be >= 1.`, { value: value });
                                           }
                                           // Note: The form validation (`SearchForm._validateForm`) should catch these issues earlier using the component's `_validate` logic, but this is a defensive check for URL building robustness.
                                        } else {
                                            // For all other parameters in `requiredParamsForUrl`, simply check if they are missing or empty strings.
                                            missingOrInvalidParamsIssues.push(paramInputId); // Add the parameter name (input ID) to the list of issues.
                                           Logger.warn(`ExpediaUrlBuilder.buildUrl: Required parameter "${paramInputId}" is missing or empty. Value: "${value}".`);
                                        }
                                   }
                                   // If the value exists and is not an empty string (and passes the adults check if applicable), it's considered valid *for URL format purposes* at this stage.
                                   // We do not check for *semantic* validity (e.g., if the destination string is a real place or if the date strings are valid YYYY-MM-DD dates) here,
                                   // as those are handled by the InputComponent validation and form-level validation (`SearchForm._validateForm`). This is just a basic presence/format check for the URL.
                               } catch (error) {
                                   // Catch any unexpected errors occurring *while checking a specific required parameter* within the loop (e.g., errors accessing a property that causes an error, type issues).
                                    // Report this error as an internal issue during the parameter check using the provided ErrorReporter.
                                    errorReporter.reportError(
                                        'ExpediaUrlBuilder.buildUrl - checkRequiredParams', error, // Source and error object.
                                        { paramName: paramInputId, paramValue: params ? params[paramInputId] : 'N/A', paramsObject: params, step: 'required_param_check_exception' }, // Context details.
                                        `Error checking required parameter "${paramInputId}" during URL build validation. Parameter may be invalid.`, // User-friendly message template.
                                        'urlbuilder_required_param_check_exception' // GA error code for this specific error type.
                                    );
                                // Add a generic note about the check failing for this parameter to the issues list for logging/debugging purposes.
                                missingOrInvalidParamsIssues.push(`${paramInputId} (check error)`); // Add a note to the list of issues.
                                Logger.error(`ExpediaUrlBuilder.buildUrl: Error occurred during check for required parameter "${paramInputId}".`, error);
                               }
                          }); // End of `requiredParamsForUrl.forEach` loop.


                          // --- Perform Cross-Parameter Validation Relevant for URL Logic ---
                          // Add validation checks that involve relationships between multiple parameters, specifically necessary for forming a logical Expedia search URL.
                          try {
                               // Validation: Check if the check-out date (`checkOutDateInput`) is strictly *after* the check-in date (`checkInDateInput`).
                               // This is a fundamental requirement for hotel bookings.
                               // Although this should be primarily validated by the `SearchForm`'s form-level validation (`_validateForm`) using the `DateInput`'s `DateObject` getter,
                               // confirming it here before URL building adds robustness in case parameter collection or prior validation missed something or was skipped.
                               const checkInDateParam = params.checkInDateInput; // Get the check-in date string from parameters.
                               const checkOutDateParam = params.checkOutDateInput; // Get the check-out date string from parameters.

                                // Check if both date parameters are present (non-empty strings).
                                if (checkInDateParam && checkOutDateParam) {
                                    // Attempt to parse the date strings into JavaScript `Date` objects for reliable comparison.
                                    // Assumes YYYY-MM-DD string format as typically returned by `<input type="date">` and handled by `DateInput`.
                                     const checkInDateObj = new Date(checkInDateParam); // Create Date object for check-in.
                                     const checkOutDateObj = new Date(checkOutDateParam); // Create Date object for check-out.

                                     // Check if either date string parsing resulted in an "Invalid Date" object (using `isNaN(getTime())`).
                                     // This handles cases where the string format might be invalid even if the `type="date"` input or earlier validation allowed it through unexpectedly.
                                     if (isNaN(checkInDateObj.getTime()) || isNaN(checkOutDateObj.getTime())) {
                                         // If dates are not valid `Date` objects after parsing, add a specific issue note to the issues list.
                                        missingOrInvalidParamsIssues.push('checkInDateInput/checkOutDateInput (invalid date format for comparison)');
                                         Logger.warn("ExpediaUrlBuilder.buildUrl: Cross-validation failed - Date parsing resulted in Invalid Date objects for comparison.", { checkInDate: checkInDateParam, checkOutDate: checkOutDateParam });
                                     } else if (checkOutDateObj <= checkInDateObj) {
                                         // If both dates are valid `Date` objects but the check-out date is on or before the check-in date (e.g., same day or earlier), add a specific issue note.
                                        missingOrInvalidParamsIssues.push('checkOutDateInput (must be after checkInDateInput)');
                                         Logger.warn("ExpediaUrlBuilder.buildUrl: Cross-validation failed - Check-out date is on or before check-in date.", { checkIn: checkInDateObj.toISOString(), checkOut: checkOutDateObj.toISOString() });
                                     }
                                     // If dates are missing (already handled in requiredParams check) or dates are valid and check-out is after check-in, this cross-check passes implicitly.

                                } else {
                                     // If one or both date parameters are missing (`undefined`, `null`, or empty string),
                                     // the issue should already be noted in `missingOrInvalidParamsIssues` by the `requiredParamsForUrl` check loop earlier.
                                     // No need to add redundant notes here based on missing values, only format/range issues if values are present.
                                    Logger.debug("ExpediaUrlBuilder.buildUrl: Skipping date range cross-check as check-in or check-out date parameters are missing.");
                                } // End if both dates are present check.


                                // --- Add More Form-Level Validation Checks Relevant for URL Logic ---
                                // Add any other validation rules here that involve relationships between multiple input values or specific complex logic
                                // based on the combined form state that are important specifically for forming a valid or meaningful URL on the target site.
                                // Example: Validate total travelers relative to rooms if rooms count is fixed or derived differently.
                                // Example: Check for maximum number of nights if Expedia has an API limit.
                                // E.g.: Check difference between checkInDate and checkOutDate vs a max allowed stay.

                             } catch (crossValidationBlockError) {
                                  // --- Handle Errors During Cross-Parameter Validation ---
                                  // Catch any unexpected errors thrown *during the entire try block for cross-parameter validation logic*.
                                  // This indicates a critical failure within the validation logic itself.
                                   Logger.error(`ExpediaUrlBuilder.buildUrl - crossValidationBlock: CRITICAL UNEXPECTED ERROR caught!`, crossValidationBlockError);
                                  // Report this critical failure using the provided ErrorReporter.
                                  errorReporter.reportError(
                                      'ExpediaUrlBuilder.buildUrl - crossValidationBlock', crossValidationBlockError, // Source and error.
                                      { paramsAttempted: params, step: 'overall_cross_validation_exception' }, // Context.
                                      'Critical error during form-level validation checks for URL building. Cannot determine validity.', // User-facing message template.
                                      'urlbuilder_cross_field_validation_exception_critical' // GA error code for critical overall cross-field validation exception.
                                  );
                               // Indicate a failure in the overall cross-validation block by adding a generic issue note.
                              missingOrInvalidParamsIssues.push('Cross-validation checks failed internally');
                               // Note: The URL builder should not proceed if cross-validation logic itself fails. The check below handles this.
                             } // End of cross-parameter validation try...catch.


                          // --- Final Check for Missing/Invalid Parameters ---
                          // If the `missingOrInvalidParamsIssues` array is not empty after all required parameter checks and cross-validations relevant to URL structure,
                          // it means we cannot form a structurally or logically valid URL with the provided parameters.
                          if (missingOrInvalidParamsIssues.length > 0) {
                             const errorMsg = `Cannot build Expedia Hotel Search URL: Essential parameters are missing or invalid: ${missingOrInvalidParamsIssues.join(', ')}.`;
                             // Log the final failure reason with details about all identified issues.
                             Logger.error(`ExpediaUrlBuilder.buildUrl: ${errorMsg}`, { allIssues: missingOrInvalidParamsIssues, paramsAttempted: params });
                              // Indicate failure to the caller by returning `null`.
                              // The caller (`SearchForm.searchHotels()`) is responsible for handling this `null` return value (e.g., displaying a user-facing error message).
                             return null; // Stop building the URL.
                          }


                          // --- Construct the URL Query String ---
                          // If all essential parameters are present and valid *for URL structure checks*, proceed to build the query string.
                          // Use the standard browser API `URLSearchParams` constructor. This object correctly handles URL encoding
                          // of parameter names and values. Keys added here correspond to the *final* URL parameter names expected by Expedia, not necessarily the input IDs.
                          const urlSearchParams = new URLSearchParams();
                           // Logger.debug("ExpediaUrlBuilder.buildUrl: All essential parameters checked. Building URLSearchParams...");

                          // --- Add Required Parameters to URLSearchParams ---
                          // Add the essential search parameters from the `params` object to the `URLSearchParams` instance using the *target parameter names* expected by Expedia.
                          urlSearchParams.append('destination', params.destinationInput?.trim() || ''); // Use trimmed destination. Defensive against null/undefined.
                          urlSearchParams.append('checkin', params.checkInDateInput || ''); // Date strings should already be in YYYY-MM-DD format. Defensive against null/undefined.
                          urlSearchParams.append('checkout', params.checkOutDateInput || ''); // Date strings should already be in YYYY-MM-DD format. Defensive against null/undefined.

                           // Ensure adults count is a valid number >= 1 before appending (checked earlier, but re-parse safely).
                           const adultsCount = parseInt(params.adultsCountInput, 10);
                          // Add a defensive check for this critical parameter value just before appending, in case earlier checks were bypassed or failed silently.
                          if (isNaN(adultsCount) || adultsCount < 1) {
                              // This state should not be reached if the earlier checks and validation passed, but defensive programming.
                              const fatalAdultsError = `ExpediaUrlBuilder.buildUrl: Internal inconsistency: Invalid final adults count ("${params.adultsCountInput}") reached URL builder append logic. Cannot build URL.`;
                             errorReporter.reportError('ExpediaUrlBuilder.buildUrl', new Error(fatalAdultsError), { adultsValue: params.adultsCountInput, step: 'final_adults_append_check_exception' }, fatalAdultsError, 'urlbuilder_invalid_final_adults_append_critical');
                             return null; // Fatal error for URL build if this is hit.
                          }
                           // Append the valid adults count as a string.
                          urlSearchParams.append('adults', adultsCount.toString()); // Append as string.


                          // --- Add Optional Parameters to URLSearchParams ---
                           // Add children count parameter if the value is greater than 0.
                           // Get children count, defaulting to 0 if the value is not a valid number or is missing.
                          const childrenCount = parseInt(params.childrenCountInput, 10) || 0; // Use || 0 for safety if params.children is missing/null/NaN.
                          if (childrenCount > 0) {
                              // Append the children count as a string if greater than 0.
                               urlSearchParams.append('children', childrenCount.toString());
                              // Note: The real Expedia site or its APIs might need child ages ('childages' parameter like '5,10'). This demo does not have input fields for child ages, so this is a simplified implementation. If you added input for ages, format and append them here.
                              // Example if you had collected ages as 'childAgesInput': `if (params.childAgesInput) urlSearchParams.append('childages', params.childAgesInput);`
                             Logger.debug(`ExpediaUrlBuilder.buildUrl: Added ${childrenCount} children parameter to URL parameters.`);
                          } else {
                              // Explicitly add `children=0` if there are none. This might be required by the target page's logic for parameter presence.
                             urlSearchParams.append('children', '0');
                              Logger.debug("ExpediaUrlBuilder.buildUrl: Added 0 children parameter to URL parameters.");
                          }

                          // --- Add Affiliate Tracking Parameter ---
                          // Include the configured affiliate ID using the 'mcid' parameter name commonly used by Expedia for tracking referrals from partners.
                          // Check if the `AFFILIATE_ID` static constant in the builder is configured (non-null/empty) and is not still the placeholder string from AppConfig.
                          if (ExpediaUrlBuilder.AFFILIATE_ID && typeof ExpediaUrlBuilder.AFFILIATE_ID === 'string' && ExpediaUrlBuilder.AFFILIATE_ID.trim() !== '' && !ExpediaUrlBuilder.AFFILIATE_ID.includes('_PLACEHOLDER')) {
                               urlSearchParams.append('mcid', ExpediaUrlBuilder.AFFILIATE_ID.trim()); // Append the trimmed affiliate ID.
                               Logger.debug(`ExpediaUrlBuilder.buildUrl: Added affiliate tracking ID (mcid="${ExpediaUrlBuilder.AFFILIATE_ID}") to URL parameters.`);
                           } else {
                               // Log a warning if the affiliate ID is missing, empty, or is still the placeholder.
                               // The URL will still be built, but affiliate tracking won't be included via the 'mcid' parameter.
                              Logger.warn("ExpediaUrlBuilder.AFFILIATE_ID is not set or is the placeholder in AppConfig. Affiliate tracking will not be included via the 'mcid' URL parameter.");
                              // Decision: If missing the affiliate ID is a critical business requirement, you should return null here instead of just logging a warning. For an affiliate link, this is often acceptable as long as a link is produced.
                           }


                          // --- Add Other Common/Fixed URL Parameters ---
                          // Include other parameters that are frequently observed in Expedia Hotel Search URLs based on observation of web traffic.
                          // These can influence how the target page displays results or handles the search request. The specific parameter names and required values should ideally come from Expedia's partner API or documentation for affiliate linking.
                           urlSearchParams.append('rfrr', 'true'); // Appears to be a referrer flag, common in affiliate links.
                           urlSearchParams.append('langid', '1033'); // Language ID parameter (e.g., 1033 for English-US). Use a fixed value for this demo. Could potentially be dynamic based on browser locale.
                           urlSearchParams.append('stid', '0'); // Site ID parameter (often used in affiliate links, specific value might be assigned). Defaulting to 0.
                           urlSearchParams.append('semdtl', '^'); // Parameter with unclear purpose, sometimes seen; included defensively. May not be necessary.
                           urlSearchParams.append('sort', 'RECOMMENDED'); // Default sort order for search results (e.g., 'RECOMMENDED', 'PRICE_LOW_TO_HIGH'). Could make this configurable with a select input on the form.
                           // urlParams.append('top_dp', '1'); // Parameter possibly related to displaying top deals or specific properties. May not be necessary.
                           // urlParams.append('top_rsid', '1'); // Similar to top_dp. May not be necessary.
                           urlParams.append('pwa_ts', Date.now().toString()); // Add a client-side timestamp as a string. Can be useful for generating unique links, preventing caching issues, or backend analytics of the redirect source.


                           // --- Add `rooms` parameter based on estimated room need ---
                           // Implement a simplified heuristic for determining the number of rooms required based on the number of adults and children.
                           let estimatedNumberOfRooms = 1; // Start with a minimum of 1 room.
                            // Ensure adultsCount and childrenCount are obtained as numbers (already checked, but be robust).
                            const currentAdultsCount = parseInt(params.adultsCountInput, 10) || 0;
                            const currentChildrenCount = parseInt(params.childrenCountInput, 10) || 0;
                            const totalTravelers = currentAdultsCount + currentChildrenCount; // Total count of travelers.

                           if (totalTravelers >= 1) { // Only apply heuristics if there is at least one traveler.
                                if (totalTravelers > 4) {
                                    // Simple heuristic example: Assume roughly 2 travelers per room after a certain point (e.g., after the first 4), or assume Math.ceil(total / 2) rooms are needed for larger groups.
                                    // A common rule is 2 travelers per room is standard, 4 max, but can vary. Let's use a simple division for larger groups.
                                   estimatedNumberOfRooms = Math.max(1, Math.ceil(totalTravelers / 2)); // Example: 5 travelers -> Math.ceil(2.5)=3 rooms. 6 -> 3 rooms. 7 -> 4 rooms. Always minimum 1.
                                } else {
                                    // For 1 to 4 travelers, assume 1 room is typically sufficient.
                                   estimatedNumberOfRooms = 1;
                                }
                           } else { // Total travelers is 0 or less (this should ideally be caught by validation with min="1" adults, but defensive fallback).
                              estimatedNumberOfRooms = 1; // Default to 1 room even if total travelers is 0 (unlikely valid scenario).
                              Logger.warn(`ExpediaUrlBuilder.buildUrl: Total travelers count is 0 or less (${totalTravelers}). Defaulting 'rooms' parameter to 1. Input params:`, { adults: params.adultsCountInput, children: params.childrenCountInput });
                           }

                            // Append the calculated/estimated number of rooms as an integer string to the URL parameters.
                            // Use Math.max(1, ...) and Math.round(...) for safety to ensure a positive integer.
                            urlSearchParams.append('rooms', Math.max(1, Math.round(estimatedNumberOfRooms)).toString());
                           Logger.debug(`ExpediaUrlBuilder.buildUrl: Calculated/estimated ${estimatedNumberOfRooms} room(s) based on ${currentAdultsCount} adults and ${currentChildrenCount} children (total ${totalTravelers}). Added 'rooms' parameter.`);


                          // --- Final URL Construction ---
                          // Combine the static base URL (`ExpediaUrlBuilder.BASE_URL`) with the complete query string generated by the `URLSearchParams` object's `toString()` method.
                          // The `toString()` method automatically handles joining the parameters with '&' and adding the '?' separator at the end of the base URL if parameters exist.
                          const finalExpediaUrl = `${ExpediaUrlBuilder.BASE_URL}?${urlSearchParams.toString()}`;

                          // Log the successfully built complete URL for debugging.
                          Logger.info("ExpediaUrlBuilder.buildUrl: Successfully constructed Expedia Hotel Search URL:", finalExpediaUrl);

                          // Return the complete URL string.
                          return finalExpediaUrl; // Return the built URL string.

                      } catch (error) {
                           // --- Handle Critical Errors During Overall Static Method Execution ---
                           // This outer catch block is a final safety net for any unexpected critical synchronous errors
                           // thrown during the entire execution of this static method (`ExpediaUrlBuilder.buildUrl`).
                           // These errors are issues within the builder's code itself (e.g., failure in the try/catch structure, unhandled exception in parameter processing, unexpected issues with `URLSearchParams`, invalid configuration access that weren't defensively checked).
                           Logger.error(`ExpediaUrlBuilder.buildUrl: CRITICAL UNEXPECTED ERROR caught during Expedia URL building process!`, error);

                           // Report this critical failure using the provided (real or dummy) ErrorReporter instance.
                           errorReporter.reportError(
                               `${ExpediaUrlBuilder.name}.buildUrl`, // Source of the error report (static class name).
                               error, // The error object caught.
                               { paramsAttempted: params, step: 'overall_build_process_exception' }, // Context details.
                               'Critical error during Expedia URL building process. Cannot generate redirect link due to internal issue.', // User-facing message template for a fundamental builder error.
                               'urlbuilder_critical_exception_overall' // GA error code for a critical overall builder exception.
                           );

                           // Indicate that URL building failed due to an internal error by returning `null`.
                           // The caller (`SearchForm.searchHotels()`) is responsible for handling this `null` return value (e.g., displaying a user-facing error message).
                           return null; // Always return null on critical error in the static method.
                       } // End of buildUrl static method try...catch.
                   } // End of buildUrl static method definition.

               } // End of ExpediaUrlBuilder static helper class definition.


               // --- Main Application Class: SearchForm ---
               // This is the primary class that orchestrates the application's logic and manages the UI
               // for the search section and integrated features.
               // It acts as the central controller for the main search form element (`#mainSearchForm`)
               // and coordinates interactions between user input, validation, service calls (simulated or real via backend gateways),
               // data storage (IndexedDB), UI updates, and tracking (Google Analytics).
               // It inherits from the base `TravelComponent` class to handle the management of its main form HTML element (`this._element`) and basic component functionalities.
               class SearchForm extends TravelComponent {
                   // Protected property holding a map of InputComponent instances managed by this form.
                   // The keys are the input element IDs (e.g., 'destinationInput', 'checkInDateInput'),
                   // and the values are the corresponding custom input component instances (e.g., `DestinationInput`, `DateInput`, `NumberInput`).
                   // This map is populated during the `_collectAndInitializeInputs` method called in the constructor.
                   // `_inputs` map facilitates iterating through all inputs for validation and parameter collection.
                   _inputs = {}; // Format: { 'destinationInput': DestinationInput instance, 'checkInDateInput': DateInput instance, ... }


                   // Private members holding references to instances of various services and helper classes
                   // that the `SearchForm` coordinates with. These dependencies are initialized during the `SearchForm` constructor.
                   // The `SearchForm` acts as a coordinator for these services.
                   #errorReporter; // Central error handling instance (injected via parent constructor `super()`). Used to report errors consistently.
                   #messageDisplay; // Service for displaying application-level messages in the UI message area (`#mainMessageDisplay`). Created here.
                   #gaTracker; // Google Analytics tracker service instance (created here). Used for tracking user interactions and errors.
                   #idbService; // IndexedDB service instance (created here). Manages persistent client-side search history storage.
                   #googleAuthService; // Simulated Google Identity Service wrapper instance (created here). Manages simulated user sign-in state and interacts with auth UI.
                   #calendarService; // Simulated Google Calendar service instance. Provides simulated calendar event creation.
                   #emailService; // Simulated Google Email service instance. Provides simulated email sending.
                   #googlePayService; // Simulated Google Pay service wrapper instance. Manages simulated GPay readiness and payment flow.
                   #appsScriptService; // Simulated Google Apps Script service instance. Provides simulated data sending to an Apps Script endpoint (via backend gateway).
                   #genAIService; // Simulated Generative AI service instance. Provides simulated AI-generated text tips (via backend gateway).

                   #paramCollector; // Helper class instance for collecting current parameter values from the input component map (`this._inputs`) (created here).
                   #urlBuilder = ExpediaUrlBuilder; // Reference to the static `ExpediaUrlBuilder` class (no instance needed). Used for building the redirect URL.


                   // Private members holding references to various important HTML UI elements
                   // that are not individual input components but are significant parts of the application UI and are managed
                   // directly by the `SearchForm`'s logic. These elements are queried during the constructor using their IDs.
                   #searchButton; // The main search submit button HTML element (`#searchButton`).
                   #searchTextSpan; // The HTML span element inside the search button that displays the standard text (e.g., "Search Hotels").
                   #loadingSpinnerSpan; // The HTML element (often an icon like Font Awesome spinner) used for the loading spinner displayed within the search button during async operations.

                   #googleServicesSection; // The main container HTML div element for the entire Google services section (wrapping all related buttons). Controls visibility of this section.
                   #googleAuthArea; // The HTML div containing Google Sign-In related UI elements (button, status text).
                   #googleSignInButton; // The HTML button element specifically designed to trigger the simulated Google Sign-In/Out flow.
                   #googleAuthStatusElement; // The HTML element displaying the current authentication status text (e.g., "Status: Signed In as...").
                   #googleAuthTextElement; // The HTML span element inside the Google Sign-In button holding its dynamic text (e.g., "Sign in with Google", "Sign out").
                   #addToCalendarButton; // The HTML button for the "Add to Calendar" action.
                   #emailSearchDetailsButton; // The HTML button for the "Email Search Details" action.
                   #sendToAppsScriptButton; // The HTML button for the "Send to Apps Script" action.
                   #googlePayButton; // The HTML button for the "Simulated Google Pay" action.
                   #googlePayArea; // The container HTML div where the Google Pay button is placed (especially relevant for real GPay button rendering placement).


                   #searchHistorySection; // The container HTML div for the search history section. Controls visibility.
                   #searchHistoryList; // The HTML UL element (`#searchHistoryList`) where search history items (`<li>`) are displayed.
                   #clearHistoryButton; // The HTML button to clear all search history from IndexedDB (`#clearHistoryButton`).
                   #historyStatusElement; // The HTML element (`#historyStatus`) displaying status messages related to history (e.g., "Loading...", "Saved.").

                   #aiTipsSection; // The container HTML div for the GenAI tip section. Controls visibility.
                   #aiTipContentElement; // The HTML div (`#aiTipContent`) where the AI-generated destination tip text is displayed.

                   #expediaSimulatedPriceElement; // The HTML element (`#expediaSimulatedPrice`) within the results area used to display the simulated Expedia price.


                   // Protected property to store the most recently collected valid search parameters object.
                   // This object (produced by `this.#paramCollector.collect()`) holds the user's validated search criteria.
                   // It is needed by the various Google service action buttons (Calendar, Email, Apps Script, Pay) to perform their simulated operations based on the search context.
                   // Initialized to `null`. It is set after a successful validation and collection step during the `searchHotels` process.
                   _lastCollectedParams = null;


                   /**
                    * Constructor for SearchForm.
                    * This is the main entry point for setting up the entire interactive application section.
                    * It orchestrates the initialization of all its component parts and service dependencies.
                    * @param {string} elementId - The ID of the main HTML form element (`<form id="...">`) that this `SearchForm` instance will wrap and control. This element serves as the root of the component structure managed by this class. Required.
                    * @param {object} appSelectors - A configuration object containing CSS selectors for various key UI elements used by the application (components, sections, buttons, message areas). Passed down to child components and services. Required.
                    * @param {object} appConfig - The main application configuration object (from the global `AppConfig`). Contains constants, service endpoints (placeholders), IndexedDB config, message strings, etc. Required.
                    * @throws {Error} Propagates critical errors that occur during its own construction process if essential elements are missing or core dependencies cannot be initialized, preventing the application section from starting correctly.
                    */
                   constructor(elementId, appSelectors, appConfig) {
                      try {
                          Logger.info(`SearchForm constructor called for ID "${elementId}" with AppConfig version ${appConfig?.APP_VERSION || 'Unknown'}. Starting initialization steps.`);

                          // --- Step 1: Initialize Core Services (Message Display, GA, Error Reporter) ---
                          // These services are fundamental for basic application feedback and error handling. Initialize them as early as possible within the main application constructor.
                          // These services often only require access to specific UI elements or global browser APIs and do not depend on the main form element being present initially (except for the message display element).

                           // Find and store the main HTML UI element designated for displaying application-level messages (status, info, success, warning, error). This element is needed by `MessageDisplay`.
                          const mainMessageDisplayElement = document.querySelector(appSelectors.MAIN_MESSAGE_AREA);
                           // Create an instance of the `MessageDisplay` service. Pass its UI element selector.
                           // The MessageDisplay constructor logs a warning if the element isn't found, but the service instance is still created and logs messages to console as a fallback.
                           const messageDisplay = new MessageDisplay(appSelectors.MAIN_MESSAGE_AREA); // Pass the selector.
                           Logger.debug(`Core Utility: MessageDisplay service initialized.`);

                           // Create an instance of the `GoogleAnalyticsTracker` service. This service encapsulates logic for sending data to GA4 using the gtag.js API.
                           // Pass the GA Measurement ID from the application configuration. The constructor handles checking if `gtag` is available.
                           const gaTracker = new GoogleAnalyticsTracker(appConfig.GOOGLE_ANALYTICS_ID); // Pass GA ID.
                           // Display an informational message if the GA tracking ID is still the placeholder or missing. This is done by the GA Tracker constructor itself if `!isConfigured()`.
                           Logger.debug(`Core Utility: GoogleAnalyticsTracker service initialized.`);

                           // Create the central `ErrorReporter` instance. This is a crucial dependency for all other components and services for standardized error handling.
                           // It requires both the `MessageDisplay` and `GoogleAnalyticsTracker` instances to function.
                           // Pass the initialized `messageDisplay` and `gaTracker` instances.
                           const errorReporter = new ErrorReporter(messageDisplay, gaTracker); // Pass the initialized services.
                           Logger.debug(`Core Utility: ErrorReporter service initialized with MessageDisplay and GA Tracker.`);


                          // --- Step 2: Call Parent Constructor (Wrap Main Element) ---
                          // Call the parent `TravelComponent` constructor using `super()`. This is the most critical step.
                          // It will attempt to find the main form HTML element using the provided `elementId` and store its reference in `this._element`.
                          // It also sets up the component's base properties (`#componentId`, `#componentName`, `_isValid`), initializes the event handlers map (`_eventHandlers`), and importantly, stores the injected `errorReporter` instance in `this._errorReporter` for use by all inherited and contained components/services.
                          super(elementId, 'MainSearchForm', errorReporter); // Pass element ID, component name ('MainSearchForm'), and the configured error reporter.


                          // --- Step 3: Check Parent Construction Result & Handle Fatal Error ---
                          // The parent `TravelComponent` constructor logs a warning and sets `this._isValid = false` if it fails to find the main form HTML element (`this._element`).
                          // Check if `this._element` is `null` after the parent constructor returns.
                          // If the main form element is missing, the entire application section is non-functional. This is considered a fatal application error for this part of the page.
                          if (!this._element) {
                              // If the main form element is missing, the parent constructor has already logged a warning via the reporter and set `this._isValid = false`.
                              // We need to handle this as a critical application startup failure.
                              // Display a prominent, persistent fatal error message to the user using the *already initialized* `messageDisplay` instance.
                              this.#messageDisplay.showMessage(AppConfig.MESSAGES.FATAL_ERROR + ' ' + `Application startup failed. Required main form element (ID: "${elementId}") was not found in the HTML. Check the page structure and ensure the ID is correct.`, 'error', 0); // Persistent error message.
                              Logger.error(`${this.name} (${this.id}) element not found by parent constructor. Application section functionality disabled.`);

                              // In this fatal scenario, initialize *dummy* service instances for ALL services that the `SearchForm` would normally create or coordinate with.
                              // This is essential as a defensive programming measure. It prevents subsequent code in the application bootstrap (e.g., other parts of `$(document).ready`, deferred tasks, or even manual calls if debugging)
                              // from crashing due to null service references. These dummy objects provide the expected public method names but perform no real action,
                              // and typically throw a controlled error indicating the service is unavailable. This prevents `Uncaught TypeError: Cannot read properties of null` etc.
                              this.#idbService = { addSearchHistoryItem: async(...args) => { Logger.debug("Dummy IDB add called (app fatal error state).", args); throw new Error("Dummy IndexedDB disabled."); }, getSearchHistory: async(...args) => { Logger.debug("Dummy IDB get called (app fatal error state).", args); return []; }, clearSearchHistory: async(...args) => { Logger.debug("Dummy IDB clear called (app fatal error state).", args); }, dispose: () => { Logger.debug("Dummy IDB dispose (app fatal error state)."); } }; // Dummy IndexedDB Service.
                              // Dummy Simulated Google Auth Service (throws on operations indicating it's not configured/available).
                              this.#googleAuthService = { signIn: async(...args) => { Logger.debug("Dummy Auth signIn called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.AUTH_FAILED('Simulated Auth not configured due to fatal app error.')); }, signOut: async(...args) => { Logger.debug("Dummy Auth signOut called (app fatal error state).", args); }, isSignedIn: () => false, getUserEmail: () => null, getUserInfo: () => null, handleAuthToggleClick: async(...args) => { Logger.debug("Dummy Auth toggle called (app fatal error state).", args); throw new Error(AppConfig.MESSAGES.AUTH_FAILED('Simulated Auth not configured due to fatal app error.')); }, dispose: () => { Logger.debug("Dummy Auth dispose (app fatal error state)."); } };
                              // Dummy Simulated Google Calendar service.
                              this.#calendarService = { createEvent: async(...args) => { Logger.debug("Dummy Calendar called (app fatal error state).", args); throw new Error
                                                                                                                      throw new Error(errorMsg);
                         }

                         // Validate the provided ErrorReporter instance.
                         if (!errorReporter || typeof errorReporter.reportError !== 'function') {
                            const errorMsg = "_collectAndInitializeInputs: ErrorReporter instance is not valid. Cannot initialize input components reliably.";
                            Logger.error(errorMsg);
                            // Throw an error here, as subsequent component constructions depend on receiving a valid reporter.
                            throw new Error(errorMsg);
                         }


                         // Query the DOM *within the form element* for all relevant input types.
                         const formElements = this._element.querySelectorAll(AppConfig.SELECTORS.INPUT);

                         // Log the number of potential elements found based on the selector.
                         if (formElements.length === 0) {
                             Logger.warn(`_collectAndInitializeInputs: No input elements found within form ${this.id} using selector "${AppConfig.SELECTORS.INPUT}". Check HTML structure.`);
                         } else {
                              Logger.debug(`_collectAndInitializeInputs: Found ${formElements.length} potential input elements to process.`);
                         }

                         // Initialize the map that will store the created component instances. Clear any previous state.
                         this._inputs = {};

                         // Iterate through the found DOM elements (NodeList).
                         formElements.forEach(element => {
                              try {
                                 // Each input component needs a unique HTML `id` to be managed effectively.
                                 const inputId = element.id;

                                 // Skip elements without a valid ID, as we use ID to key components in the `_inputs` map.
                                 if (!inputId || inputId.trim() === '') {
                                     Logger.warn("Input element found without a valid ID. Skipping component initialization for this element:", element.tagName, element);
                                     return; // Use `return` within forEach to skip to the next iteration.
                                 }

                                 // Determine the specific type of input component to create based on a `data-input-type` attribute.
                                 const dataInputType = element.getAttribute('data-input-type');
                                 // A `data-component-name` attribute could also be used for mapping to class names directly.

                                 let inputComponent = null; // Variable to hold the instantiated component.

                                 // Use a switch statement on the `data-input-type` to select the correct class constructor.
                                 switch (dataInputType) {
                                     case 'destination':
                                         // Instantiate a DestinationInput component. Pass element ID and the shared ErrorReporter.
                                         inputComponent = new DestinationInput(inputId, errorReporter);
                                         break;
                                     case 'date':
                                          // Get the date type attribute ('check-in' or 'check-out').
                                         const dateType = element.getAttribute('data-date-type');
                                          // Instantiate a DateInput component. Pass ID, date type, and reporter.
                                         inputComponent = new DateInput(inputId, dateType, errorReporter);
                                         break;
                                      case 'number':
                                           // Instantiate a NumberInput component. Pass ID and reporter.
                                          inputComponent = new NumberInput(inputId, errorReporter);
                                          break;
                                     // Add cases here for other specific input types (e.g., 'select', 'checkbox') if you create components for them.
                                     // case 'select': inputComponent = new SelectInput(inputId, errorReporter); break;

                                     default:
                                         // For any element found by the selector that *does not* have a recognized `data-input-type`,
                                         // you could choose to instantiate a generic `InputComponent` or skip it.
                                         // In this demo, we log and skip if it doesn't map to a specific class we've defined.
                                         Logger.debug(`Skipping initialization for element ID "${inputId}" with data-input-type "${dataInputType || 'none'}". No specific component class defined for this type.`);
                                         // If you want to initialize a generic InputComponent for all other <input>/<select>/<textarea> elements with IDs:
                                         // inputComponent = new InputComponent(inputId, element.type || element.tagName, errorReporter);
                                         return; // Skip if no component was created.
                                 }

                                 // If a component instance was successfully created (`inputComponent` is not null)
                                 // AND if its internal `_element` reference is not null (meaning the component's
                                 // constructor successfully found and wrapped the DOM element):
                                 if (inputComponent && inputComponent.getElement()) {
                                     // Store the created component instance in the `this._inputs` map, keyed by its ID.
                                     this._inputs[inputId] = inputComponent;
                                      Logger.debug(`Initialized and stored component "${inputComponent.name}" for input ID "${inputId}".`);
                                 } else {
                                     // If the component's constructor failed to find its target element,
                                     // or if construction failed critically *after* `super()`, the component instance
                                     // might still exist but be non-functional (`getElement()` would return null).
                                      // Report this failure. The component is not added to the `_inputs` map.
                                     const elementFoundByComponent = inputComponent ? !!inputComponent.getElement() : false;
                                      this.#errorReporter.reportError(
                                          `${this.name}._collectAndInitializeInputs`,
                                          new Error(`Input component constructor failed to wrap element "${inputId}" or was null. Component initialization failed.`),
                                          { inputId: inputId, elementType: element.tagName, dataInputType: dataInputType, componentCreated: !!inputComponent, elementFoundByComponent: elementFoundByComponent },
                                          `Initialization error: Failed to find HTML element for input component "${inputComponent.name}" (ID "${inputId}").`,
                                          'form_collect_input_component_failed',
                                          0 // Persistent error if a required input fails init
                                      );
                                 }

                              } catch (elementProcessingError) {
                                  // Catch any unexpected errors that occur *while processing a specific element* within the forEach loop.
                                  // This prevents one bad element/component from stopping the entire collection process.
                                   const currentElementId = element?.id || 'N/A';
                                   const currentElementType = element?.tagName || 'N/A';
                                   this.#errorReporter.reportError(
                                       `${this.name}._collectAndInitializeInputs`,
                                       elementProcessingError,
                                       { elementId: currentElementId, elementType: currentElementType },
                                       `Error processing input element "${currentElementId}" during collection phase.`,
                                       'form_collect_input_element_exception' // GA error code.
                                   );
                                  // Continue to the next element in the loop.
                              }
                          });

                          // After the loop finishes, log the total number of components successfully initialized.
                          Logger.info(`Input component collection and initialization finished. ${Object.keys(this._inputs).length} components initialized.`);
                           Logger.debug(`Initialized inputs map state:`, this._inputs);

                      } catch (error) {
                           // Catch any critical errors that occur *during the overall collection and initialization process itself*.
                           this.#errorReporter.reportError(
                               `${this.name}._collectAndInitializeInputs`,
                               error,
                               {},
                               `Critical error during form input components collection.`,
                               'form_collect_inputs_critical_exception' // GA error code.
                           );
                           // Clear the inputs map in case a critical error occurred partway through.
                           this._inputs = {}; // Reset inputs map state.
                           // Re-throw the error to signal to the main application bootstrap (`SearchForm` constructor)
                           // that input component collection failed critically, likely preventing the app section from being usable.
                           throw error;
                      }
                  }


                  /**
                   * Protected method to attach event listeners to important UI buttons and elements managed by the form logic,
                   * outside of the individual input components. This includes Google service buttons, clear history, etc.
                   * Uses the parent's `_addEventListener` helper to manage `this` binding and handler cleanup.
                   */
                  _attachButtonListeners() {
                      try {
                          Logger.debug(`_attachButtonListeners called for ${this.name}.`);

                          // --- Google Sign-In Button ---
                           // Attach click listener to the Google Sign-In button. This button triggers the simulated auth flow toggle.
                          if (this.#googleSignInButton) {
                               // Use _addEventListener to attach the click handler and store the reference.
                               // Pass the specific button element as the target element in options.
                               // The handler method is `_handleGoogleSignInClick`. `_addEventListener` binds `this`.
                               this._addEventListener('click', this._handleGoogleSignInClick, { element: this.#googleSignInButton });
                               Logger.debug("Google Sign-In button click listener attached.");
                          } else {
                              // Log a warning if the button element was not found.
                              Logger.warn("_attachButtonListeners: Google Sign-In button element not found, listener not attached.");
                               // ErrorReporter would have logged this as a UI element missing error in the constructor.
                          }

                           // Note: The Google Auth Status element (`#googleAuthStatus`) also has a click listener
                           // attached to simulate the auth toggle for demo purposes. This listener is attached
                           // directly by the `GoogleIdentityServiceWrapper` class itself (its `constructor` and `dispose`),
                           // as it's primarily responsible for managing that specific element's behavior.
                           // We only attach handlers here for elements primarily controlled by the `SearchForm` logic.


                          // --- Google Service Action Buttons (Calendar, Email, Apps Script, Google Pay) ---
                          // These buttons are typically enabled/disabled based on authentication state and search data availability,
                          // and their click handlers trigger the corresponding simulated service actions.

                          // Attach click listener to the Add to Calendar button.
                          if (this.#addToCalendarButton) {
                              this._addEventListener('click', this._handleAddToCalendarClick, { element: this.#addToCalendarButton });
                              Logger.debug("Add to Calendar button click listener attached.");
                          } else {
                             Logger.warn("_attachButtonListeners: Add to Calendar button element not found, listener not attached.");
                          }

                          // Attach click listener to the Email Search Details button.
                          if (this.#emailSearchDetailsButton) {
                              this._addEventListener('click', this._handleEmailSearchDetailsClick, { element: this.#emailSearchDetailsButton });
                              Logger.debug("Email Search Details button click listener attached.");
                          } else {
                             Logger.warn("_attachButtonListeners: Email Search Details button element not found, listener not attached.");
                          }

                           // Attach click listener to the Send to Apps Script button.
                           if (this.#sendToAppsScriptButton) {
                               this._addEventListener('click', this._handleSendToAppsScriptClick, { element: this.#sendToAppsScriptButton });
                               Logger.debug("Send to Apps Script button click listener attached.");
                           } else {
                               Logger.warn("_attachButtonListeners: Send to Apps Script button element not found, listener not attached.");
                           }

                           // Attach click listener to the Google Pay button.
                           if (this.#googlePayButton) {
                               this._addEventListener('click', this._handleGooglePayClick, { element: this.#googlePayButton });
                               Logger.debug("Google Pay button click listener attached.");
                           } else {
                               Logger.warn("_attachButtonListeners: Google Pay button element not found, listener not attached.");
                           }


                          // --- Search History Buttons ---
                          // Attach click listener to the Clear History button.
                          if (this.#clearHistoryButton) {
                               this._addEventListener('click', this._handleClearHistoryClick, { element: this.#clearHistoryButton });
                              Logger.debug("Clear History button click listener attached.");
                          } else {
                              Logger.warn("_attachButtonListeners: Clear History button element not found, listener not attached.");
                           }

                           // Note: Listeners for clicking individual history list items (`<li>`) are attached dynamically
                           // within the `_renderSearchHistory` method when the history list is rendered,
                           // not here in `_attachButtonListeners`. Their removal is handled by clearing the list and removing old elements.


                          Logger.debug("_attachButtonListeners finished.");

                      } catch (error) {
                           // Report any unexpected errors occurring *during* the process of attaching button listeners.
                           this.#errorReporter.reportError(
                               `${this.name}._attachButtonListeners`,
                               error,
                               { component: this.#getComponentInfo() },
                               `Error attaching button listeners for form "${this.name}".`,
                               'form_attach_button_listeners_exception' // GA error code.
                           );
                           // Do not re-throw.
                       }
                   }


                   /**
                    * Handler for the Google Sign-In button click event. Marked async because it calls async auth methods.
                    * Triggers the simulated Google Sign-In/Out toggle managed by the `GoogleIdentityServiceWrapper`.
                    * Also updates the state of other Google service buttons after the auth state changes.
                    * @param {Event} event - The click event object.
                    */
                   async _handleGoogleSignInClick(event) {
                       try {
                           Logger.info("Google Sign-In button clicked.");
                            // Prevent default behavior if it were a submit button etc.
                            if (event?.preventDefault) event.preventDefault();
                           if (event?.stopPropagation) event.stopPropagation();

                           // Track a Google Analytics event for the button click.
                            this.#gaTracker.trackEvent('button_click', { button_id: 'google_sign_in', form_id: this.id }); // GA Event

                           // Ensure the simulated Google Auth Service is initialized and available.
                           if (!this.#googleAuthService) {
                               const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Google Auth service not available.';
                               this.#errorReporter.reportError(
                                   `${this.name}._handleGoogleSignInClick`, new Error(errorMsg),
                                   { component: this.#getComponentInfo() }, errorMsg, 'auth_service_missing'
                               );
                               // Update button state to reflect inability to proceed.
                               this._updateGoogleServiceButtonState(); // This method checks service availability internally.
                               return; // Exit the handler.
                           }


                           Logger.debug(`Calling simulated Google Auth service to toggle sign-in state (current signed-in: ${this.#googleAuthService.isSignedIn()})...`);
                           // Call the method on the simulated Google Auth Service instance that handles the toggle logic.
                           // This method (`handleAuthToggleClick`) is responsible for updating its own internal state (`#isSignedIn`, `#userEmail`)
                           // and updating its dedicated UI elements (status text, button text/state).
                           await this.#googleAuthService.handleAuthToggleClick();

                           // After the simulated sign-in/out process completes, update the state of other
                           // Google service buttons (Calendar, Email, Apps Script, Google Pay) which
                           // depend on the user's authentication status.
                           this._updateGoogleServiceButtonState();

                           Logger.debug("Google Sign-In button handler finished.");

                       } catch (error) {
                           // Catch any unexpected errors that occur *during the execution* of this handler (excluding errors within `handleAuthToggleClick` itself, which are reported by the service).
                           // Report the error using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._handleGoogleSignInClick`,
                               error,
                               { component: this.#getComponentInfo(), step: 'handler_execution' },
                               `Error handling Google Sign-In button click for form "${this.name}".`,
                               'auth_button_handler_exception' // GA error code.
                           );
                           // Ensure button states are updated even if an error occurred in this handler.
                           this._updateGoogleServiceButtonState(); // Update state defensively.
                           // Do not re-throw from an event handler.
                       }
                   }

                   /**
                    * Protected method to update the visibility and enabled/disabled state of the Google service buttons and sections.
                    * This state depends on whether a search has successfully completed (`_lastCollectedParams` is not null),
                    * the user's simulated authentication status (`this.#googleAuthService.isSignedIn()`),
                    * and the simulated readiness status of Google Pay (`this.#googlePayService.isReady()`), and whether the services are configured.
                    * Called after a search completes and after the auth state changes.
                    */
                   _updateGoogleServiceButtonState() {
                       try {
                           Logger.debug(`_updateGoogleServiceButtonState called for ${this.name}. Checking states...`);

                           // --- Check Dependencies ---
                           // Ensure the UI elements and necessary service instances are available before attempting to update states.
                           if (!this.#googleServicesSection || !this.#googleAuthService || !this.#calendarService || !this.#emailService || !this.#appsScriptService || !this.#genAIService || !this.#googlePayService || !this.#addToCalendarButton || !this.#emailSearchDetailsButton || !this.#sendToAppsScriptButton || !this.#googlePayButton || !this.#googleAuthArea || !this.#googleSignInButton || !this.#googleAuthStatusElement) {
                              Logger.warn("_updateGoogleServiceButtonState: One or more essential UI elements or service instances are missing. Skipping state update.");
                              // The ErrorReporter would have logged missing elements in the constructor.
                              // Attempt to hide the main services section as a fallback if dependencies are missing.
                              if (this.#googleServicesSection) {
                                   this.#googleServicesSection.classList.add('app-hide');
                              }
                               // Defensive: disable all individual buttons if their refs exist but services are missing.
                              if (this.#addToCalendarButton) this.#addToCalendarButton.disabled = true;
                              if (this.#emailSearchDetailsButton) this.#emailSearchDetailsButton.disabled = true;
                              if (this.#sendToAppsScriptButton) this.#sendToAppsScriptButton.disabled = true;
                              if (this.#googlePayButton) this.#googlePayButton.disabled = true;
                               if (this.#googleSignInButton) this.#googleSignInButton.disabled = true; // If AuthService missing entirely, disable button too.
                               if (this.#googleAuthStatusElement) this.#googleAuthStatusElement.textContent = 'Status: Error'; // Indicate state error.
                               return; // Exit the method.
                           }

                           // --- Get Current Application States ---
                           const isSignedIn = this.#googleAuthService.isSignedIn(); // Get simulated sign-in status.
                           const hasValidSearchParams = this._lastCollectedParams !== null; // Check if a search successfully provided parameters.

                           // Check if simulated Google Pay service is ready *and* configured (its readiness check considers configuration).
                           const isGooglePayServiceReadyAndConfigured = this.#googlePayService.isReady();

                           // Check if other simulated services that might have separate configuration (like Apps Script endpoint) are configured.
                           const isAppsScriptServiceConfigured = this.#appsScriptService.isConfigured();
                           const isGenAIServiceConfigured = this.#genAIService.isConfigured();


                           Logger.debug(`_updateGoogleServiceButtonState: States - Signed In: ${isSignedIn}, Has Search Params: ${hasValidSearchParams}, GPay Ready/Configured: ${isGooglePayServiceReadyAndConfigured}, Apps Script Configured: ${isAppsScriptServiceConfigured}, GenAI Configured: ${isGenAIServiceConfigured}.`);

                           // --- Update Visibility of Sections ---
                           // The entire Google Services section should typically only be visible *after* a successful search,
                           // as its actions require the search parameters.
                           if (this.#googleServicesSection) {
                               if (hasValidSearchParams) {
                                   // If valid search params exist, show the section. Avoid unnecessary DOM manipulation.
                                   if (this.#googleServicesSection.classList.contains('app-hide')) {
                                      this.#googleServicesSection.classList.remove('app-hide');
                                      Logger.debug("Showing Google Services section (has search params).");
                                   }
                               } else {
                                   // If no valid search params, hide the section.
                                   if (!this.#googleServicesSection.classList.contains('app-hide')) {
                                       this.#googleServicesSection.classList.add('app-hide');
                                       Logger.debug("Hiding Google Services section (no search params).");
                                   }
                               }
                           }

                           // Search History section visibility is managed by `_loadAndDisplaySearchHistory` after it fetches data.
                           // AI Tips section visibility is managed by `_fetchAndDisplayAITip` after it fetches the tip.

                           // --- Update Enabled/Disabled State of Buttons ---

                           // Update Sign-In Button State: Managed by the `GoogleIdentityServiceWrapper` itself via its `_updateUI` method,
                           // which is called automatically after `signIn`, `signOut`, or `handleCredentialResponse`.
                           // We only ensure the button element reference is valid here.
                           if (!this.#googleSignInButton) {
                                Logger.warn("_updateGoogleServiceButtonState: Google Sign-In button element is missing.");
                           }


                           // Update Add to Calendar, Email Details, Send to Apps Script Button States:
                           // These require the user to be signed in AND valid search parameters to be available.
                           const calendarEmailAppsScriptEnabled = isSignedIn && hasValidSearchParams;

                           if (this.#addToCalendarButton) {
                                // Disable the button if the required conditions are NOT met.
                                // Use a defensive check (`disabled !== !enabled`) to avoid unnecessary DOM updates.
                               if (this.#addToCalendarButton.disabled !== !calendarEmailAppsScriptEnabled) {
                                   this.#addToCalendarButton.disabled = !calendarEmailAppsScriptEnabled;
                                   Logger.debug(`Add to Calendar button disabled: ${!calendarEmailAppsScriptEnabled}`);
                               }
                           } else { Logger.warn("_updateGoogleServiceButtonState: Add to Calendar button element is missing."); }

                           if (this.#emailSearchDetailsButton) {
                               if (this.#emailSearchDetailsButton.disabled !== !calendarEmailAppsScriptEnabled) {
                                   this.#emailSearchDetailsButton.disabled = !calendarEmailAppsScriptEnabled;
                                   Logger.debug(`Email Search Details button disabled: ${!calendarEmailAppsScriptEnabled}`);
                               }
                           } else { Logger.warn("_updateGoogleServiceButtonState: Email Search Details button element is missing."); }

                           if (this.#sendToAppsScriptButton) {
                               // Note: Apps Script also requires its own endpoint to be configured. Add this check.
                               const appsScriptEnabled = calendarEmailAppsScriptEnabled && isAppsScriptServiceConfigured;
                               if (this.#sendToAppsScriptButton.disabled !== !appsScriptEnabled) {
                                   this.#sendToAppsScriptButton.disabled = !appsScriptEnabled;
                                   Logger.debug(`Send to Apps Script button disabled: ${!appsScriptEnabled} (Signed In: ${isSignedIn}, Has Params: ${hasValidSearchParams}, Configured: ${isAppsScriptServiceConfigured})`);
                               }
                           } else { Logger.warn("_updateGoogleServiceButtonState: Send to Apps Script button element is missing."); }


                           // Update Google Pay Button State:
                           // Requires the Google Pay service to be configured and ready (`isGooglePayServiceReadyAndConfigured`)
                           // AND valid search parameters to be available (`hasValidSearchParams`).
                           // Google Pay typically doesn't require the *user* to be signed into *your site's* Google Auth explicitly,
                           // but requires the user to be signed into *their* Google account in the browser, which `GooglePayServiceWrapper.isReady()` checks for implicitly in the simulation.
                           const googlePayButtonEnabled = isGooglePayServiceReadyAndConfigured && hasValidSearchParams;

                           if (this.#googlePayButton) {
                               if (this.#googlePayButton.disabled !== !googlePayButtonEnabled) {
                                    this.#googlePayButton.disabled = !googlePayButtonEnabled;
                                    Logger.debug(`Google Pay button disabled: ${!googlePayButtonEnabled} (Ready/Configured: ${isGooglePayServiceReadyAndConfigured}, Has Params: ${hasValidSearchParams})`);
                               }
                                // Optionally update button title to explain why it's disabled.
                                if (!googlePayButtonEnabled) {
                                     let reason = '';
                                     if (!isGooglePayServiceReadyAndConfigured && !hasValidSearchParams) reason = 'Not available and no search data.';
                                     else if (!isGooglePayServiceReadyAndConfigured) reason = AppConfig.MESSAGES.NOT_READY('Google Pay', 'Service unavailable');
                                     else if (!hasValidSearchParams) reason = 'No search data.';
                                    this.#googlePayButton.title = AppConfig.MESSAGES.GOOGLE_PAY_DISABLED_MESSAGE(reason);
                                } else {
                                    this.#googlePayButton.title = 'Click to make a simulated payment with Google Pay'; // Button enabled tooltip.
                                }
                           } else { Logger.warn("_updateGoogleServiceButtonState: Google Pay button element is missing."); }


                           // Clear History button state is managed by the history loading logic based on whether history exists.


                           Logger.debug("_updateGoogleServiceButtonState finished.");

                       } catch (error) {
                            // Report any unexpected errors occurring *during* the state update process.
                            this.#errorReporter.reportError(
                                `${this.name}._updateGoogleServiceButtonState`,
                                error,
                                { component: this.#getComponentInfo() },
                                `Error updating button states for form "${this.name}".`,
                                'form_update_button_state_exception' // GA error code.
                            );
                            // Do not re-throw. Attempt a defensive update of buttons if error occurred.
                            if (this.#addToCalendarButton) this.#addToCalendarButton.disabled = true;
                            if (this.#emailSearchDetailsButton) this.#emailSearchDetailsButton.disabled = true;
                            if (this.#sendToAppsScriptButton) this.#sendToAppsScriptButton.disabled = true;
                            if (this.#googlePayButton) this.#googlePayButton.disabled = true;
                             if (this.#googleSignInButton) this.#googleSignInButton.disabled = true; // Disable sign-in too if error here.
                        }
                    }

                    /**
                     * Asynchronous handler for the "Add to Calendar" button click. Marked async.
                     * Triggers the simulated process of adding a calendar event using the search details
                     * stored in `_lastCollectedParams` via the `SimulatedGoogleCalendarService`.
                     * Displays UI messages and tracks GA events throughout the process.
                     * @param {Event} event - The click event object.
                     */
                    async _handleAddToCalendarClick(event) {
                        try {
                            Logger.info(`${this.name}._handleAddToCalendarClick: "Add to Calendar" button clicked.`);
                             // Prevent default behavior and stop propagation.
                             if (event?.preventDefault) event.preventDefault();
                            if (event?.stopPropagation) event.stopPropagation();

                            // Track a Google Analytics event for the button click.
                             this.#gaTracker.trackEvent('button_click', { button_id: 'add_to_calendar', form_id: this.id }); // GA Event

                            // --- Check Dependencies and State ---
                            // Ensure the simulated Google Auth Service is available and the user is signed in.
                            // Although the button should be disabled if not signed in or if service is missing,
                            // perform checks defensively before proceeding.
                            if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                                const message = AppConfig.MESSAGES.AUTH_NEEDED; // Message asking user to sign in.
                                Logger.warn(`_handleAddToCalendarClick: User not signed in or auth service missing. Message: "${message}".`);
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning temporarily.
                                 // Track failure reason in GA.
                                 this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'auth_needed_or_missing_service' });
                                return; // Exit the handler.
                            }

                            // Ensure valid search parameters are available (stored from the last successful search).
                            if (!this._lastCollectedParams) {
                                const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating search is needed.
                                Logger.warn(`_handleAddToCalendarClick: No search data available. Message: "${message}".`);
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning temporarily.
                                 this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'no_search_data' });
                                return; // Exit the handler.
                            }
                             // Ensure the simulated Google Calendar Service is initialized and available.
                            if (!this.#calendarService) {
                                 const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Calendar service not available.';
                                this.#errorReporter.reportError(
                                    `${this.name}._handleAddToCalendarClick`, new Error(errorMsg),
                                    { component: this.#getComponentInfo() }, errorMsg, 'calendar_service_missing_critical', 0
                                ); // Persistent error message.
                                this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'calendar_service_missing_critical' });
                                return; // Exit the handler.
                             }


                            // --- Prepare Calendar Event Details ---
                            // Format the necessary details for the calendar event using the stored search parameters.
                            // Use a protected helper method for this logic.
                            Logger.debug("_handleAddToCalendarClick: Formatting calendar event details...");
                            const eventDetails = this._getCalendarEventDetails(this._lastCollectedParams);

                            // Check if formatting was successful. `_getCalendarEventDetails` returns null if required params are missing or invalid for formatting.
                            if (!eventDetails) {
                                const message = AppConfig.MESSAGES.FAILED('Calendar Add', 'Failed to format event details from search data.'); // Generic failure message.
                                Logger.error(`_handleAddToCalendarClick: Failed to format event details. Message: "${message}".`);
                                this.#messageDisplay.showMessage(message, 'error'); // Show an error message.
                                this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'format_event_details_failed' });
                                return; // Exit the handler.
                            }
                            Logger.debug("_handleAddToCalendarClick: Calendar event details formatted successfully.", eventDetails);


                            // --- Simulate Adding Event to Calendar ---
                            // Display a message indicating the process is starting and will be persistent (duration 0) while the simulated async call runs.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING, 'info', 0); // Use duration 0 for persistent message.
                             this.#gaTracker.trackEvent('calendar_add_process_started', { form_id: this.id }); // GA Event


                            Logger.debug("Calling simulated Google Calendar service to create event...", eventDetails);
                            // Call the asynchronous method on the simulated Calendar service wrapper to create the event.
                            // Use `await` to pause execution until the Promise resolves or rejects.
                            try {
                                 const result = await this.#calendarService.createEvent(eventDetails);
                                Logger.debug("Simulated createEvent result received:", result);

                                // Process the result of the simulated API call. Assume the service returns `{ success: true }` on success.
                                if (result && result.success) {
                                    // If the simulated call was successful:
                                    const successMessage = AppConfig.MESSAGES.CALENDAR_ADD_SUCCESS;
                                    Logger.info(`_handleAddToCalendarClick: ${successMessage}.`);
                                    this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily.
                                     this.#gaTracker.trackEvent('calendar_add_success', { form_id: this.id }); // GA Success Event.
                                    // Optional: If `result` includes a link to the event (`result.htmlLink`), could display that or offer a button.
                                    // Example: if (result.htmlLink) this.#messageDisplay.showMessage(`${successMessage} <a href="${result.htmlLink}" target="_blank">View Event</a>`, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS);

                                } else {
                                     // If the simulated call resolved but indicated failure (unlikely if it rejects on error, but defensive).
                                    const errorDetail = result ? (result.message || JSON.stringify(result)) : "Unknown failure response.";
                                     const message = AppConfig.MESSAGES.CALENDAR_ADD_FAILED(errorDetail); // Use the failed message template.
                                    Logger.error(`_handleAddToCalendarClick: Simulated event creation returned failure. Message: "${message}".`, { result: result });
                                    this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message.
                                    this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                                }

                            } catch (apiError) {
                                // Catch any errors thrown by the simulated Calendar service's `createEvent` method (e.g., Promise rejection).
                                Logger.error("_handleAddToCalendarClick: Error caught from simulated Calendar service call:", apiError);
                                // Report the error using the injected reporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._handleAddToCalendarClick - apiCall`,
                                    apiError, // The error object from the service.
                                    { component: this.#getComponentInfo(), step: 'simulated_api_call', eventDetails: eventDetails }, // Context including event data.
                                    AppConfig.MESSAGES.CALENDAR_ADD_FAILED(apiError.message || 'Unknown error.'), // User message template.
                                    'calendar_add_api_exception' // GA error code.
                                );
                                // The ErrorReporter handles displaying the message in the UI.
                                // GA tracking handled by the reporter via the general 'app_error' event with specific error code.
                            }


                        } catch (handlerError) {
                            // Catch any unexpected errors occurring *during the execution* of this handler (e.g., before calling the service).
                            // Report the error using the injected reporter.
                            this.#errorReporter.reportError(
                                `${this.name}._handleAddToCalendarClick`,
                                handlerError,
                                { component: this.#getComponentInfo(), step: 'handler_execution' },
                                `Error handling "Add to Calendar" button click for form "${this.name}".`,
                                'calendar_button_handler_exception' // GA error code.
                            );
                            // Ensure the persistent message is cleared if an error occurred early and it was set.
                             if (this.#messageDisplay) {
                                // Check if the current message is still the persistent "Processing..." message before clearing.
                                 const currentMessageElement = this.#messageDisplay.getElement();
                                if (currentMessageElement && currentMessageElement.textContent.includes(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false))) { // Check for base processing text
                                    this.#messageDisplay.clearMessage(); // Clear the persistent message on error.
                                }
                             }
                            // Do not re-throw from an event handler.
                        } finally {
                            // This block always executes after the try/catch.
                            // Ensure the persistent "Processing..." message is cleared if it's still active
                            // AND the final status message is not an error message.
                            if (this.#messageDisplay) {
                               const currentMessageElement = this.#messageDisplay.getElement();
                               if (currentMessageElement && currentMessageElement.textContent.includes(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                    // If it's still the processing message and not an error, clear it.
                                   // Success messages clear after a duration, error messages stay persistent unless explicitly cleared by user interaction or specific logic.
                                   this.#messageDisplay.clearMessage(); // Clear the persistent message.
                               }
                            }
                            Logger.debug("_handleAddToCalendarClick finished.");
                        }
                    }

                    /**
                     * Protected helper method to format the details of a calendar event from collected search parameters.
                     * Creates an object structure intended to mimic the body expected by the Google Calendar API's `Events: insert` method.
                     * Assumes a typical multi-day hotel stay as an "all-day" event spanning from the check-in date to the check-out date.
                     * Includes essential details like summary, location, description, start, and end dates.
                     * @param {object} params - The collected search parameters object (`_lastCollectedParams`). Required.
                     * @returns {object|null} - A plain JavaScript object representing the calendar event details if parameters are valid and sufficient, or `null` if required parameters are missing or in an invalid format for formatting.
                     */
                    _getCalendarEventDetails(params) {
                        try {
                             Logger.debug("Formatting calendar event details from parameters...", params);
                            // Check if the essential parameters needed to construct an event are present in the provided `params` object.
                            if (!params || typeof params !== 'object' || !params.destination || !params.checkInDate || !params.checkOutDate) {
                                // If required parameters are missing, log a warning and return null.
                                Logger.warn("_getCalendarEventDetails: Missing required parameters (destination, checkInDate, checkOutDate) for calendar event formatting.");
                                return null; // Cannot format event without these.
                            }

                            // Get the check-in and check-out date strings from the parameters.
                            // Expecting YYYY-MM-DD string format from the date input components.
                            const checkInDateString = params.checkInDate;
                            const checkOutDateString = params.checkOutDate;

                            // Basic validation of the date string formats. Regular expression check for YYYY-MM-DD.
                            if (typeof checkInDateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(checkInDateString) ||
                                typeof checkOutDateString !== 'string' || !/^\d{4}-\d{2}-\d{2}$/.test(checkOutDateString)) {
                                // If date strings are not in the expected format, log an error and return null.
                                Logger.error("_getCalendarEventDetails: Invalid date string format provided.", { checkInDateString: checkInDateString, checkOutDateString: checkOutDateString });
                                return null; // Cannot format event if date strings are bad.
                            }

                             // --- Calendar API Date Format Note ---
                             // The Google Calendar API expects date/time information in RFC 3339 format.
                             // For "all-day" events (like a hotel stay typically is), you can use the 'date' property
                             // with a YYYY-MM-DD string for the start and end. The 'end' date for an all-day event
                             // is the date *after* the event concludes. For a hotel stay checking out on YYYY-MM-DD,
                             // the stay lasts until that date, so the event *end* date in the API is that YYYY-MM-DD.
                             // For a 1-night stay (check-in Day 1, check-out Day 2), the event would be Day 1 to Day 2.
                             // For a 3-night stay (check-in Day 1, check-out Day 4), the event would be Day 1 to Day 4.
                             // So the API `end.date` should simply be the collected `checkOutDate` string.
                             // If you wanted specific times (e.g., 3 PM check-in, 11 AM check-out), you'd use the `dateTime` property.
                             // ------------------------------------

                             const eventStartDate = checkInDateString; // Start date of the event (check-in date string).
                             const eventEndDate = checkOutDateString; // End date of the event (check-out date string for all-day).

                            // Construct the event object using the format expected by the Google Calendar API's `Events: insert` method.
                            const event = {
                               // 'summary': Required. A brief title for the event.
                               'summary': `Hotel Stay: ${params.destination || 'Destination'}`, // Use destination from params.
                               // 'location': Optional. The physical location of the event.
                               'location': params.destination || '', // Use destination again for location.
                               // 'description': Optional. More detailed text about the event.
                                'description': `Details for your hotel search:\n\n` +
                                               `- Destination: ${params.destination || 'N/A'}\n` +
                                               `- Check-in Date: ${params.checkInDate || 'N/A'}\n` +
                                               `- Check-out Date: ${params.checkOutDate || 'N/A'}\n` +
                                               `- Adults: ${params.adults ?? 'N/A'}\n` + // Use nullish coalescing for defaults
                                               `- Children: ${params.children ?? 'N/A'}\n\n` +
                                                // Include the generated Expedia URL in the description if available.
                                               `Search/Book Link: ${this.#urlBuilder ? this.#urlBuilder.buildUrl(params, this.#errorReporter) || 'Expedia.com (URL build failed)' : 'Expedia.com (Builder not available)'}`, // Pass error reporter to static buildUrl

                               // 'start': Required. The start time or date of the event. Use 'date' for all-day events.
                               'start': {
                                 'date': eventStartDate, // YYYY-MM-DD string.
                                 // If using specific time: 'dateTime': `${eventStartDate}T15:00:00`, and may need 'timeZone'.
                                 // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone, // Get user's current timezone.
                               },
                               // 'end': Required. The end time or date of the event. Use 'date' for all-day events.
                               // For all-day, this is the date *after* the last day of the event.
                               // So, check-out date is the date after the stay, so the event 'end.date' is the check-out date.
                               'end': {
                                 'date': eventEndDate, // YYYY-MM-DD string (check-out date).
                                  // If using specific time: 'dateTime': `${eventEndDate}T11:00:00`, and may need 'timeZone'.
                                  // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                               },
                                // Optional properties for an all-day event
                                'endTimeUnspecified': true, // Indicates that the end time is not specific, often used with 'date'.
                                // Other optional properties (attendees, reminders, transparency, etc.):
                                // 'attendees': [{'email': this.#googleAuthService?.getUserEmail() || ''}], // Add the signed-in user as an attendee.
                                // 'reminders': { 'useDefault': true }, // Use the user's default reminders for this calendar.
                                // Or set custom reminders: 'reminders': { 'useDefault': false, 'overrides': [ {'method': 'popup', 'minutes': 60} ] },
                            };

                            // Log the structured event object for debugging.
                            Logger.debug("Formatted calendar event object:", event);

                            // Return the successfully formatted event object.
                            return event;

                        } catch (error) {
                             // Catch any unexpected errors occurring *within* the formatting logic.
                            this.#errorReporter.reportError(
                                `${this.name}._getCalendarEventDetails`,
                                error,
                                { component: this.#getComponentInfo(), paramsInput: params },
                                `Error formatting calendar event details for component "${this.name}".`,
                                'form_get_calendar_event_details_exception' // GA error code.
                            );
                             return null; // Always return null if formatting failed due to an error.
                        }
                    }


                    /**
                     * Asynchronous handler for the "Email Search Details" button click. Marked async.
                     * Triggers the simulated process of sending an email containing the search details
                     * stored in `_lastCollectedParams` via the `SimulatedGoogleEmailService`.
                     * Displays UI messages and tracks GA events.
                     * Assumes the email is sent TO the simulated signed-in user.
                     * @param {Event} event - The click event object.
                     */
                    async _handleEmailSearchDetailsClick(event) {
                        try {
                            Logger.info("Email Search Details button clicked.");
                             // Prevent default behavior and stop propagation.
                             if (event?.preventDefault) event.preventDefault();
                            if (event?.stopPropagation) event.stopPropagation();

                            // Track a Google Analytics event for the button click.
                            this.#gaTracker.trackEvent('button_click', { button_id: 'email_search_details', form_id: this.id }); // GA Event.

                            // --- Check Dependencies and State ---
                            // Ensure the simulated Google Auth Service is available and the user is signed in.
                            // Although the button should be disabled if not signed in or if service is missing,
                            // perform checks defensively before proceeding.
                            if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                                const message = AppConfig.MESSAGES.AUTH_NEEDED; // Message asking user to sign in.
                                Logger.warn(`_handleEmailSearchDetailsClick: User not signed in or auth service missing. Message: "${message}".`);
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning temporarily.
                                 // Track failure reason in GA.
                                 this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'auth_needed_or_missing_service' }); // GA Failure Reason.
                                return; // Exit the handler.
                            }

                            // Ensure valid search parameters are available.
                            if (!this._lastCollectedParams) {
                                const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating search is needed.
                                Logger.warn(`_handleEmailSearchDetailsClick: No search data available. Message: "${message}".`);
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning temporarily.
                                 this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'no_search_data' }); // GA Failure Reason.
                                return; // Exit the handler.
                            }

                            // Ensure the simulated Google Email Service is initialized and available.
                            if (!this.#emailService) {
                                 const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Email service not available.';
                                this.#errorReporter.reportError(
                                    `${this.name}._handleEmailSearchDetailsClick`, new Error(errorMsg),
                                    { component: this.#getComponentInfo() }, errorMsg, 'email_service_missing_critical', 0
                                ); // Persistent error message.
                                this.#gaTracker.track
                                                                   this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'email_service_missing_critical' });
                              return; // Exit the handler.
                           }


                          // --- Get Recipient Email and Format Email Details ---
                          // In this simulation, we assume the email is sent TO the simulated signed-in user's email address.
                          const userEmail = this.#googleAuthService.getUserEmail(); // Get the simulated signed-in user's email string from the auth service.

                          // Check if the user's email was successfully obtained. It might be null if authentication was partial or the user didn't grant the necessary email scope (in a real app with OAuth).
                          if (!userEmail) {
                               const message = AppConfig.MESSAGES.FAILED('Email Details', 'Cannot determine signed-in user email address.'); // Message indicating recipient email is missing.
                              Logger.error(`${this.name}._handleEmailSearchDetailsClick: Signed-in user email not available from auth service. Message: "${message}".`);
                              this.#messageDisplay.showMessage(message, 'error'); // Show an error message persistently.
                               // Track the reason for failure in Google Analytics.
                               this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'user_email_missing_from_auth_service' }); // GA Failure Reason.
                              return; // Exit the async handler.
                          }
                          Logger.debug(`_handleEmailSearchDetailsClick: Signed-in user email obtained: "${userEmail}".`);


                          // Format the email details object (`to`, `subject`, `body`) using the stored search parameters and the recipient email address.
                          // Use a protected helper method (`_getEmailDetails`) for this formatting logic.
                          Logger.debug("_handleEmailSearchDetailsClick: Formatting email details object...");
                          let emailDetailsObject = null; // Variable to hold the formatted email details object.
                          try {
                             // Call the helper method, passing the stored search parameters and the recipient email.
                             emailDetailsObject = this._getEmailDetails(this._lastCollectedParams, userEmail);

                              // Check if the email details object was created successfully by the helper method. It returns null for invalid input or errors.
                             if (!emailDetailsObject) {
                                  const message = AppConfig.MESSAGES.FAILED('Email Details', 'Failed to format email content from search data.'); // Generic formatting error message.
                                 Logger.error(`_handleEmailSearchDetailsClick: Formatting failed. Email details object is null. Message: "${message}".`);
                                 throw new Error(message); // Throw an error to be caught below.
                             }
                             Logger.debug("_handleEmailSearchDetailsClick: Email details object formatted successfully.", emailDetailsObject);

                           } catch (formatError) {
                               // If formatting fails, _getEmailDetails reports it internally. Catch the error thrown by it here.
                                // The error object already contains the user-friendly message from the helper.
                               Logger.error(`_handleEmailSearchDetailsClick: Error during email formatting process:`, formatError);
                               // The ErrorReporter used in _getEmailDetails already handled logging and reporting the error.
                               // Update the main message display if needed (ErrorReporter should cover this).
                               this.#messageDisplay.showMessage(formatError.message || AppConfig.MESSAGES.FAILED('Email Details', 'Formatting failed unexpectedly.'), 'error'); // Show message.
                               // Track the reason for failure.
                               this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'format_email_details_failed' }); // GA Failure Reason.
                               return; // Exit handler if formatting failed.
                          }


                          // --- Simulate Sending Email ---
                          // Display a persistent UI message in the main area indicating that the simulated email sending process is starting.
                          this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING, 'info', 0); // Use duration 0 for a persistent message.
                           // Track a GA event for the start of the email send process.
                           this.#gaTracker.trackEvent('email_send_process_started', { form_id: this.id, recipient: userEmail, step: 'started' }); // GA Event, include simulated recipient.


                          Logger.debug(`_handleEmailSearchDetailsClick: Calling simulated Google Email service to send email...`, emailDetailsObject);
                          // Call the asynchronous method (`sendEmail`) on the simulated Email service instance (`this.#emailService`).
                          // This method simulates making an async call (fetch/$.ajax) to a backend endpoint
                          // that would handle sending the email using secure credentials (like a backend gateway or Gmail API via server).
                          // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                          try {
                               // The `sendEmail` method on the simulated service returns a Promise. Await its result.
                               // It's designed to throw/reject on errors during its execution or the simulated API call.
                               const simulatedResponse = await this.#emailService.sendEmail(emailDetailsObject); // Await the simulated service call, passing the formatted email details.
                              // Log the result of the simulated API call and response.
                              Logger.debug("_handleEmailSearchDetailsClick: Simulated sendEmail result received:", simulatedResponse);

                              // --- Process Simulated Email Send Success ---
                              // If the Promise resolved successfully, `simulatedResponse` should contain data indicating success (e.g., { success: true, messageId: '...' }).
                              // Assume the simulated service returns an object like `{ success: true }` on success.
                              if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.success) {
                                  // If the simulated call was successful according to its response format:
                                  const successMessage = AppConfig.MESSAGES.EMAIL_SEND_SUCCESS; // Get the standard success message string.
                                  Logger.info(`_handleEmailSearchDetailsClick: ${successMessage}. Simulated response indicated success.`);

                                  // Update the main UI message area with a temporary success message.
                                  this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                  // Track a GA success event for the email sending operation.
                                   this.#gaTracker.trackEvent('email_send_success', { form_id: this.id, step: 'success', simulated_message_id: simulatedResponse.messageId || 'N/A' }); // GA Success Event, include simulated message ID if available.
                                   // Optional: Log or report more details about the simulated success.


                              } else {
                                   // --- Handle Simulated Email Send Failure (Promise Resolved, but Indicated Failure) ---
                                   // This case is reached if the simulated service's Promise resolved, but the resolved value itself indicates a failure (e.g., the simulated service returned an object like `{ success: false, message: '...' }`).
                                   // This is a common pattern for backend APIs or services to return structured error responses within the response body for known failures.
                                   // Get a detailed error message from the simulated response object or use a fallback string.
                                  const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated service.";
                                   const message = AppConfig.MESSAGES.EMAIL_SEND_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                  Logger.error(`_handleEmailSearchDetailsClick: Simulated email sending returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, dataSent: dataPayloadToSend });
                                  // Update the main UI message area with a persistent error message.
                                  this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                  // Track a GA error event with details.
                                  this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                              }

                          } catch (apiError) {
                              // --- Handle Simulated Email Send Failure (Promise Rejection) ---
                              // Catch any errors thrown (Promise rejections) by the simulated Email service's `sendEmail` method.
                              // This catch block handles simulated errors such as network issues, backend HTTP errors, JSON parsing errors,
                              // or errors specifically simulated by the `sendEmail` method (e.g., rejection due to simulated API errors or limitations).
                              Logger.error(`_handleEmailSearchDetailsClick: Error caught from simulated Email service call for form "${this.id}":`, apiError);

                              // Report the error using the injected ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleEmailSearchDetailsClick - apiCall`, // Source indicating the simulated API call stage.
                                  apiError, // The error object caught from the service rejection.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', dataSent: dataPayloadToSend }, // Context including data sent (be mindful of sensitive data logging).
                                  AppConfig.MESSAGES.EMAIL_SEND_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                  'email_send_api_exception' // GA error code for errors during API interaction.
                              );
                              // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                          } // End of simulated API call try...catch.


                      } catch (handlerError) {
                          // --- Handle Critical Errors During Overall Handler Execution ---
                          // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                          // that were not caught by the more specific try/catch blocks within (e.g., errors during setup steps, input validation check fails unexpectedly, issues accessing service instance methods before calling them).
                          // Report the error using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._handleEmailSearchDetailsClick`, // Source of the error.
                              handlerError, // The error object caught.
                              { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                              `Error handling "Email Search Details" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                              'email_button_handler_exception_overall' // GA error code for overall handler exception.
                          );
                          // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                               const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                               // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                               if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // If it's still the initial processing message and not an error, clear it.
                                   this.#messageDisplay.clearMessage();
                                   Logger.debug(`${this.name}._handleEmailSearchDetailsClick: Cleared persistent message in main area due to handler error.`);
                                }
                           } else { Logger.debug(`${this.name}._handleEmailSearchDetailsClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.

                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                      } finally {
                          // This block always executes after the try/catch structure.
                          // Ensures cleanup or final status updates not explicitly covered occur.
                          // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                          if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                             const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                             // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                             if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // Clear the persistent message.
                                 this.#messageDisplay.clearMessage();
                                Logger.debug(`${this.name}._handleEmailSearchDetailsClick: Cleared persistent message in finally.`);
                             }
                         } // Check if MessageDisplay exists.
                         Logger.debug("_handleEmailSearchDetailsClick async method execution completed.");
                      } // End of _handleEmailSearchDetailsClick try...catch...finally block.
                  } // End of _handleEmailSearchDetailsClick method definition.


                  /**
                   * Protected helper method to format the details of an email based on collected search parameters and recipient email address.
                   * Creates a simple JavaScript object containing key-value pairs for the email (`to`, `subject`, `body`) structured as might be expected by a backend endpoint acting as an email gateway.
                   * The email body includes the key search details and the generated Expedia URL. Includes validation for required input and email format.
                   * @param {object} params - The collected search parameters object (`_lastCollectedParams`). Expected keys include `destinationInput`, `checkInDateInput`, `checkOutDateInput`, `adultsCountInput`, `childrenCountInput`. Required.
                   * @param {string} recipientEmail - The email address string of the intended recipient. In this simulation, this is typically the email of the simulated signed-in user. Required.
                   * @returns {object|null} - Returns a plain JavaScript object representing the email details (`{ to: ..., subject: ..., body: ... }`) if required parameters are valid and sufficient for formatting. Returns `null` otherwise (e.g., if required parameters are missing). Throws an error for invalid recipient email format.
                   * @throws {Error} - Throws an Error if the `recipientEmail` string is provided but is in an invalid format, as this prevents email creation.
                   */
                  _getEmailDetails(params, recipientEmail) {
                      try {
                           Logger.debug("SearchForm._getEmailDetails: Formatting email details from parameters and recipient...", { paramsInput: params, recipientEmail: recipientEmail });

                          // --- Validate Input Parameters ---
                          // Check if the essential parameters needed to create the email content (destination, dates) and the recipient email address are present and valid strings.
                          // Use optional chaining `?.` and nullish coalescing `??` for safe access if parameters are missing from the `params` object.
                          if (!params || typeof params !== 'object' || !params.destinationInput || typeof params.destinationInput !== 'string' || params.destinationInput.trim() === '' ||
                              !params.checkInDateInput || typeof params.checkInDateInput !== 'string' || params.checkInDateInput.trim() === '' ||
                              !params.checkOutDateInput || typeof params.checkOutDateInput !== 'string' || params.checkOutDateInput.trim() === '' ||
                              !recipientEmail || typeof recipientEmail !== 'string' || recipientEmail.trim() === '') {
                              // If any of these essential inputs are missing or invalid strings, log a warning and return null.
                              Logger.warn("SearchForm._getEmailDetails: Missing required parameters (destinationInput, checkInDateInput, checkOutDateInput) or recipient email is missing/invalid string for formatting.");
                              // Do not throw here, just return null to indicate formatting failed due to missing/invalid data. The caller (`_handleEmailSearchDetailsClick`) handles this null return.
                              return null; // Indicate failure to format email without essential data.
                          }

                          // Perform basic format validation on the recipient email address string using a regular expression.
                          // This is a client-side check. Robust backend validation is also necessary before attempting to send real emails.
                           // Use a simple regex for a quick check.
                           const trimmedRecipientEmail = recipientEmail.trim();
                          if (!/\S+@\S+\.\S+/.test(trimmedRecipientEmail)) {
                               const formatErrorMsg = `SearchForm._getEmailDetails: Invalid recipient email format provided: "${recipientEmail}".`;
                              Logger.error(formatErrorMsg);
                              // If the recipient email format is invalid, throw an error to signal this specific type of formatting failure to the caller.
                              throw new Error(formatErrorMsg); // Throw an error indicating invalid input format for this method.
                           }


                          // --- Construct Email Content ---
                          // Create the subject line for the email. Use the destination and dates for specificity in the subject.
                           const trimmedDestination = params.destinationInput.trim(); // Get the trimmed destination again.
                          const subjectLine = `LuxStay Search: ${trimmedDestination} (${params.checkInDateInput} to ${params.checkOutDateInput})`; // Use required params for subject.

                          // Get the generated Expedia URL to include in the email body.
                          // Use the static `ExpediaUrlBuilder.buildUrl` method. Pass the collected `params` object and the `ErrorReporter` instance.
                          // The `buildUrl` method handles its own error logging and returns `null` if the URL cannot be built.
                          const searchLink = this.#urlBuilder ? this.#urlBuilder.buildUrl(params, this.#errorReporter) : null; // Pass reporter.

                          // Create the main body content of the email as a multi-line string using a template literal (` `` `).
                          // Include the key search details from the `params` object and the generated Expedia link.
                          // Add conditional text if the search link could not be built (the `buildUrl` method returns `null` in that case).
                          const emailBodyContent = `
                              Dear User,

                              Thank you for using LuxStay Finder!

                              Here are the details for your recent luxury stay search based on your input:

                              - Destination: ${trimmedDestination || 'N/A'}
                              - Check-in Date: ${params.checkInDateInput || 'N/A'}
                              - Check-out Date: ${params.checkOutDateInput || 'N/A'}
                              - Adults: ${params.adultsCountInput ?? 'N/A'}
                              - Children: ${params.childrenCountInput ?? 'N/A'}

                              ${searchLink ?
                                  `You can view available stays and book on Expedia.com by clicking the link below:\n${searchLink}` :
                                  `A direct search link could not be automatically generated based on your criteria. Please visit Expedia.com and manually enter the search details above.`
                              }

                              This email was generated by the LuxStay Finder demo application.

                              Best regards,
                              The Demo App Team
                          `.trim(); // Use `.trim()` on the entire template literal result to remove leading/trailing whitespace.


                          // --- Create Email Details Object ---
                          // Construct a simple plain JavaScript object representing the email details.
                          // This structure with keys `to`, `subject`, and `body` is a common format for passing email data
                          // to a backend endpoint or a service wrapper before actual email sending.
                          const emailDetailsObject = {
                             'to': trimmedRecipientEmail, // Use the validated and trimmed recipient email address string.
                             'subject': subjectLine, // Use the formatted subject line string.
                             'body': emailBodyContent, // Use the formatted email body text string.
                             // Add other properties if the simulated or real email sending service/backend endpoint supports them,
                             // e.g., 'from': 'noreply@yourdomain.com', 'htmlBody': '...', 'attachments': [...].
                             // Note: For the real Gmail API via a backend gateway, you might assemble a complex base64-encoded MIME message string here or on the backend.
                          };

                          // Log the structured email details object for debugging.
                          Logger.debug("SearchForm._getEmailDetails: Formatted email details object:", emailDetailsObject);

                          // Return the successfully formatted email details object.
                          return emailDetailsObject;

                      } catch (error) {
                           // --- Handle Errors During Email Formatting Logic ---
                           // Catch any unexpected errors occurring *within* this helper method's logic (e.g., errors during string manipulation, errors accessing object properties, errors from `buildUrl` if not caught there and propagated).
                           // Report this error using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._getEmailDetails`, // Source of the error.
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), paramsInput: params, recipientEmailInput: recipientEmail, step: 'email_formatting_logic_exception' }, // Context details.
                              `Error formatting email details for component "${this.name}". Cannot create email content.`, // User-friendly message template for formatting failure.
                              'form_get_email_details_exception' // GA error code for formatting exception.
                          );
                           // If formatting failed due to an error, return `null` to indicate failure to the caller (`_handleEmailSearchDetailsClick`).
                           // The caller handles displaying a user message based on this null return or a thrown error from here (like invalid recipient format).
                           return null; // Always return null on error or invalid input.
                      }
                  } // End of _getEmailDetails method definition.


                  /**
                   * Asynchronous handler for the "Send to Apps Script" button click. Marked as `async`.
                   * This method is triggered when the user clicks the button element identified by `#sendToAppsScriptButton`.
                   * It orchestrates the simulated process of sending the collected search details (stored in `_lastCollectedParams`)
                   * as a data payload to a Google Apps Script endpoint using the `SimulatedGoogleAppsScriptService`.
                   * This simulates a client-side action triggering a server-less function or a backend endpoint that interacts with Apps Script.
                   * Displays UI messages to the user (indicating progress, success, or failure) and tracks Google Analytics events throughout the process.
                   * @param {Event} event - The native DOM 'click' event object.
                   */
                  async _handleSendToAppsScriptClick(event) {
                      try {
                          Logger.info(`${this.name}._handleSendToAppsScriptClick: "Send to Apps Script" button clicked.`);
                           // Prevent the browser's default behavior for the button (if any) and stop event propagation up the DOM tree.
                           if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                          if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                          // Track a Google Analytics event indicating the "Send to Apps Script" button was clicked.
                          this.#gaTracker.trackEvent('button_click', { button_id: 'send_to_apps_script', form_id: this.id }); // GA Event.


                          // --- Check Dependencies and State ---
                          // Ensure valid search parameters are available in `_lastCollectedParams`. The Apps Script operation typically requires this data as payload.
                          if (!this._lastCollectedParams) {
                              const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating that a search is required before this action.
                              Logger.warn(`${this.name}._handleSendToAppsScriptClick: No search data available in _lastCollectedParams. Cannot send data. Message: "${message}".`);
                              this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                               // Track the reason for failure in Google Analytics.
                               this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'no_search_data_available' }); // GA Failure Reason.
                              return; // Exit the async handler as essential data is missing.
                          }

                          // Ensure the simulated Apps Script Service instance (`this.#appsScriptService`) is initialized and configured (has a non-placeholder endpoint URL).
                          // Its `isConfigured()` method checks this condition based on `AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY`.
                          if (!this.#appsScriptService || !this.#appsScriptService.isConfigured()) {
                               const message = AppConfig.MESSAGES.APPS_SCRIPT_ENDPOINT_MISSING; // Message about the Apps Script endpoint configuration missing.
                              Logger.warn(`${this.name}._handleSendToAppsScriptClick: Apps Script service not configured or instance missing. Cannot send data. Message: "${message}".`);
                              // Display the warning message temporarily in the main UI area.
                              this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message for 8 seconds.
                              // The service constructor or its initialization method should have already reported the missing configuration error persistently in the main message area via ErrorReporter.
                               // Track the reason for failure in Google Analytics.
                               this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'service_not_configured_or_missing_instance' }); // GA Failure Reason.
                              return
                                                               return; // Exit the async handler if the service is not configured or available.
                          }


                          // --- Prepare Data Payload for Apps Script ---
                          // Create the JavaScript object containing the data payload that will be sent to the Apps Script endpoint.
                          // Use the stored collected search parameters (`this._lastCollectedParams`) as the primary data.
                          // Augment this payload with other relevant context like a timestamp or basic user information (if the user is simulated signed in and Apps Script needs it).
                           Logger.debug("_handleSendToAppsScriptClick: Preparing data payload for Apps Script...");
                           let dataPayloadToSend = null; // Variable to hold the prepared data payload.
                           try {
                               // Construct the data payload object.
                                dataPayloadToSend = {
                                    // Include the collected search details object. Use defensive checks for existence.
                                   searchDetails: this._lastCollectedParams || {},
                                    // Add metadata about when the data was sent from the client. Use ISO 8601 string format for clarity and machine readability.
                                   clientTimestamp: new Date().toISOString(), // Get current timestamp.
                                    // Include information about the page the data originated from.
                                   originPage: window.location.href, // The URL of the current page.
                                    // If the user is simulated signed in via Google Identity Services, include some basic simulated user info.
                                    // The simulated auth service instance (`this.#googleAuthService`) provides user info getters.
                                   userInfo: this.#googleAuthService?.getUserInfo() || null, // Get user info object if available, otherwise null.
                                   // Add any other static or dynamic context relevant to your specific Google Apps Script (e.g., application name, version, form identifier).
                                   sourceApplication: AppConfig.APP_NAME,
                                   appVersion: AppConfig.APP_VERSION,
                                   formId: this.id
                                   // You could add more detailed context if needed by your script (e.g., browser info).
                                   // browserInfo: navigator.userAgent // Example: Add browser user agent (consider privacy implications).
                               };
                                Logger.debug("_handleSendToAppsScriptClick: Data payload prepared successfully:", dataPayloadToSend);

                                // Optional: Validate the structure/content of the prepared payload if necessary before sending.
                                 // If invalid, throw a specific error caught below.

                           } catch (preparePayloadError) {
                               // --- Handle Errors During Payload Preparation ---
                                // Catch any errors while preparing the data payload synchronously.
                                this.#errorReporter.reportError(
                                    `${this.name}._handleSendToAppsScriptClick`, preparePayloadError, // Source and error.
                                    { component: this.#getComponentInfo(), step: 'prepare_payload_for_apps_script_exception' }, // Context details.
                                    `Error preparing data to send to Apps Script. Operation failed due to internal issue.`, // User-friendly message template.
                                    'apps_script_send_prepare_payload_exception' // GA error code.
                                );
                               // Ensure the persistent "Processing..." message is cleared if an error occurred before setting it (handled below in finally),
                               // or if it was set already and isn't an error message itself.
                                if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                                    const currentMessageElement = this.#messageDisplay.getElement(); // Get display element reference.
                                     // Check if element exists, contains the PROCESSING text, and is NOT displaying a persistent error.
                                     if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                        this.#messageDisplay.clearMessage(); // Clear the persistent message.
                                         Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message after payload preparation error.`);
                                     }
                                } else { Logger.debug(`${this.name}._handleSendToAppsScriptClick: MessageDisplay service missing when handling payload error.`); }
                                // Re-throw the error to indicate that payload preparation failed and the send operation should not proceed.
                                throw preparePayloadError; // Re-throw the error.
                           } // End of preparePayload try...catch.


                          // --- Simulate Sending Data to Apps Script Endpoint ---
                          // Display a persistent UI message in the main area indicating that the simulated sending process is starting.
                          // Use a persistent message (duration 0).
                          this.#messageDisplay.showMessage(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING, 'info', 0); // Set persistent processing message.
                           // Track a GA event for the start of the "Send to Apps Script" process.
                           this.#gaTracker.trackEvent('apps_script_send_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                          Logger.debug(`_handleSendToAppsScriptClick: Calling simulated Google Apps Script service runScriptFunction with payload...`, dataPayloadToSend);
                          // Call the asynchronous method (`runScriptFunction`) on the simulated Apps Script service instance (`this.#appsScriptService`).
                          // This method simulates making an async HTTP call (fetch/$.ajax) to the configured backend endpoint (`this.#appsScriptService.#endpointUrl`),
                          // which YOUR backend would use to securely invoke the Google Apps Script function (`doPost` or `doGet`) with the provided data payload.
                          // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                          try {
                               // The `runScriptFunction` method on the simulated service returns a Promise. Await its result.
                               // It's designed to throw/reject on errors during its execution or the simulated API call.
                               const simulatedResponse = await this.#appsScriptService.runScriptFunction(dataPayloadToSend); // Await the simulated service call, passing the prepared data payload.
                              // Log the result of the simulated API call and response.
                              Logger.debug("_handleSendToAppsScriptClick: Simulated Apps Script response received:", simulatedResponse);

                              // --- Process Simulated Apps Script Response ---
                              // If the Promise resolved successfully, `simulatedResponse` should contain the data returned by the simulated Apps Script (e.g., a JSON object with a status).
                              // Check the content of the simulated response to determine success or failure from the script's logic.
                              // Assume a typical Apps Script Web App might return a JSON object like `{ result: 'success', message: '...', ... }` or `{ result: 'error', message: '...' }`.
                              if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.result === 'success') {
                                  // If the simulated call was successful according to its response format:
                                  const successMessage = AppConfig.MESSAGES.APPS_SCRIPT_SEND_SUCCESS; // Get the standard success message string.
                                  Logger.info(`_handleSendToAppsScriptClick: ${successMessage}. Simulated response indicated success.`);

                                  // Update the main UI message area with a temporary success message.
                                  this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                  // Track a GA success event for the "Send to Apps Script" operation.
                                   this.#gaTracker.trackEvent('apps_script_send_success', { form_id: this.id, step: 'success', simulated_result: simulatedResponse.result, simulated_message: simulatedResponse.message || 'N/A' }); // GA Success Event, include simulated response details.
                                   // Optional: If the simulated response contains user-relevant information (e.g., a confirmation ID, a link to the spreadsheet row), you might display it to the user or log it.
                                  if (simulatedResponse.message) {
                                       // Augment the success message with the script's message.
                                       // Use a slightly longer duration for the augmented message.
                                       this.#messageDisplay.showMessage(`${successMessage} Script message: ${simulatedResponse.message}`, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS + 2000);
                                  }
                                  if (simulatedResponse.data && simulatedResponse.data.spreadsheetRow) {
                                       Logger.info(`_handleSendToAppsScriptClick: Simulated Data written to spreadsheet row: ${simulatedResponse.data.spreadsheetRow}.`);
                                  }


                              } else {
                                   // --- Handle Simulated Apps Script Failure (Promise Resolved, but Indicated Failure) ---
                                   // This case is reached if the simulated service's Promise resolved successfully, but the resolved value itself indicates a failure
                                   // (e.g., the simulated service returned an object like `{ result: 'error', message: '...' }`, or a unexpected format).
                                   // This is a common pattern for backend APIs or services to return structured error responses within the response body for known business-logic failures.
                                   // Get a detailed error message from the simulated response object or use a fallback string.
                                  const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated Apps Script service.";
                                   const message = AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                  Logger.error(`_handleSendToAppsScriptClick: Simulated Apps Script call returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, dataSent: dataPayloadToSend });
                                  // Update the main UI message area with a persistent error message.
                                  this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                  // Track a GA error event with details.
                                  this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                              }

                          } catch (apiError) {
                              // --- Handle Simulated Apps Script Failure (Promise Rejection) ---
                              // Catch any errors thrown (Promise rejections) by the simulated Apps Script service's `runScriptFunction` method.
                              // This catch block handles simulated errors such as:
                              // - Network issues when calling the backend endpoint (`fetch` errors).
                              // - HTTP errors (4xx, 5xx) from the backend endpoint (`fetch` `!response.ok` throws).
                              // - JSON parsing errors of the backend response (`fetch` `response.json()` throws) (also handled by `_fetchBackendEndpointSimulated` if used there).
                              // - Errors originating in the Apps Script itself and propagated back by the backend, thrown as an error by the service wrapper.
                              // - Errors specifically simulated as rejections by the `runScriptFunction` method itself (e.g., random failures).
                              Logger.error(`_handleSendToAppsScriptClick: Error caught from simulated Google Apps Script service call for form "${this.id}":`, apiError);

                              // Report the error using the injected ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleSendToAppsScriptClick - apiCall`, // Source indicating the simulated API call stage.
                                  apiError, // The error object caught from the service rejection.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', dataSent: dataPayloadToSend }, // Context including data sent (be mindful of sensitive data logging).
                                  AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                  'apps_script_send_api_exception' // GA error code for errors during API interaction.
                              );
                              // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                          } // End of simulated API call try...catch.


                      } catch (handlerError) {
                          // --- Handle Critical Errors During Overall Handler Execution ---
                          // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                          // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps, accessing elements/services before validity checks if checks are buggy, issues in the overall try...catch structure).
                          // Report the error using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._handleSendToAppsScriptClick`, // Source of the error.
                              handlerError, // The error object caught.
                              { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                              `Error handling "Send to Apps Script" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                              'apps_script_button_handler_exception_overall' // GA error code for overall handler exception.
                          );

                          // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                               const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                               // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                               if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // If it's still the generic processing message and not an error, clear it.
                                   this.#messageDisplay.clearMessage();
                                   Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in main area due to handler error.`);
                                }
                           } else { Logger.debug(`${this.name}._handleSendToAppsScriptClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                              const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                              // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // Clear the persistent message.
                                  this.#messageDisplay.clearMessage();
                                 Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in finally.`);
                              }
                          } // Check if MessageDisplay exists.
                          Logger.debug("_handleSendToAppsScriptClick async method execution completed.");
                       } // End of _handleSendToAppsScriptClick try...catch...finally block.
                   } // End of _handleSendToAppsScriptClick method definition.


                   /**
                    * Asynchronous handler for the "Simulated Google Pay" button click. Marked as `async`.
                    * This method is triggered when the user clicks the button element identified by `#googlePayButton`.
                    * It orchestrates the simulated Google Pay payment flow using the stored search details (`_lastCollectedParams`).
                    * This involves checking service readiness, creating the simulated `PaymentDataRequest` object based on search/price data,
                    * calling the simulated Google Pay service (`loadPaymentData`) which mimics opening the payment UI and getting a payment token,
                    * and handling the simulated success or failure response from that simulated flow.
                    * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                    * @param {Event} event - The native DOM 'click' event object.
                    */
                   async _handleGooglePayClick(event) {
                       try {
                           Logger.info(`${this.name}._handleGooglePayClick: "Simulated Google Pay" button clicked.`);
                            // Prevent default behavior of the button (if any) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                           // Track a Google Analytics event indicating the "Simulated Google Pay" button was clicked.
                           this.#gaTracker.trackEvent('button_click', { button_id: 'simulated_google_pay', form_id: this.id }); // GA Event.

                           // --- Check Dependencies and State ---
                           // Ensure the simulated Google Pay service instance (`this.#googlePayService`) is initialized and available.
                           if (!this.#googlePayService) {
                               const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Google Pay service not available. Cannot initiate payment.'; // Critical error message.
                               // Report this critical infrastructure error via the ErrorReporter.
                               this.#errorReporter.reportError(
                                   `${this.name}._handleGooglePayClick`, new Error(errorMsg),
                                   { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'google_pay_service_missing_critical', 0 // GA error code and persistent message.
                               );
                               // The button state (_updateGoogleServiceButtonState) should reflect service missing (disabled).
                               return; // Exit the async handler if service is missing.
                           }

                           // Ensure the Google Pay service is ready (meaning it passed its simulated `isReadyToPay` check) and its configuration is valid.
                           // The button should already be disabled if not ready (handled by `_updateGoogleServiceButtonState`), but check defensively.
                           if (!this.#google```javascript
                              if (!googlePayButtonEnabled) {
                                   let reason = ''; // Default empty reason.
                                   if (!isGooglePayServiceReadyAndConfigured && !hasValidSearchParams) reason = AppConfig.MESSAGES.GOOGLE_PAY_DISABLED_MESSAGE('Not available and no search data.'); // Combine reasons.
                                   else if (!isGooglePayServiceReadyAndConfigured) reason = AppConfig.MESSAGES.GOOGLE_PAY_DISABLED_MESSAGE(AppConfig.MESSAGES.NOT_READY('Google Pay', 'Service unavailable')); // Reason based on readiness check failure.
                                   else if (!hasValidSearchParams) reason = AppConfig.MESSAGES.GOOGLE_PAY_DISABLED_MESSAGE('No search data loaded.'); // Reason based on missing search data.
                                   // If button is disabled for an unknown reason not covered here, could use a generic message.
                                   // Fallback message if determined reason is also empty or just use the base message.
                                   this.#googlePayButton.title = reason || AppConfig.MESSAGES.GOOGLE_PAY_DISABLED_MESSAGE('Button disabled.');
                               } else {
                                   // If button is enabled, set a tooltip indicating it's clickable and simulated.
                                   this.#googlePayButton.title = 'Click to make a simulated payment with Google Pay'; // Button enabled tooltip.
                               }
                           } else {
                                // Log warning if the button element is missing.
                                Logger.warn("_updateGoogleServiceButtonState: Google Pay button element reference is null. Cannot update button state.");
                                // The ErrorReporter would have logged this as a UI element missing error in the constructor.
                           }


                           // Clear History button state is managed by the history loading logic based on whether history exists.


                           Logger.debug("_updateGoogleServiceButtonState finished. Button states and section visibility updated.");

                       } catch (error) {
                            // Report any unexpected errors occurring *during the execution of the state update process*.
                           this.#errorReporter.reportError(
                               `${this.name}._updateGoogleServiceButtonState`, // Source of the error.
                               error, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'state_update_execution_exception' }, // Context details.
                               `Error updating Google service button states for form "${this.name}". UI state might be inconsistent.`, // User-friendly message template.
                               'form_update_button_state_exception' // GA error code for state update exception.
                           );
                           // Do not re-throw from this method.

                           // Attempt a defensive update of buttons in case an error occurred during the state update logic.
                           // Disable all Google service action buttons and Sign-In button to prevent actions in an inconsistent state.
                           if (this.#addToCalendarButton) this.#addToCalendarButton.disabled = true;
                           if (this.#emailSearchDetailsButton) this.#emailSearchDetailsButton.disabled = true;
                           if (this.#sendToAppsScriptButton) this.#sendToAppsScriptButton.disabled = true;
                           if (this.#googlePayButton) this.#googlePayButton.disabled = true;
                           if (this.#googleSignInButton) this.#googleSignInButton.disabled = true; // Disable sign-in too if error here.
                           if (this.#googleAuthStatusElement) this.#googleAuthStatusElement.textContent = 'Status: Error'; // Indicate status update error.
                           if (this.#googleServicesSection) {
                                if (!this.#googleServicesSection.classList.contains('app-hide')) { // If it exists and is not hidden, hide it.
                                     this.#googleServicesSection.classList.add('app-hide'); // Hide section if state update failed.
                                }
                            }
                            Logger.debug("_updateGoogleServiceButtonState: Applied defensive button disable due to error.");
                       } // End of _updateGoogleServiceButtonState try...catch.
                   } // End of _updateGoogleServiceButtonState method definition.


                   /**
                    * Asynchronous handler for the "Add to Calendar" button click. Marked `async`.
                    * This method is triggered when the user clicks the button element identified by `#addToCalendarButton`.
                    * It orchestrates the simulated process of adding a calendar event using the search details
                    * stored in `_lastCollectedParams` via the `SimulatedGoogleCalendarService`.
                    * It performs necessary checks (authentication, data availability, service availability),
                    * prepares the event data, calls the simulated service, and handles the simulated success or failure response.
                    * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                    * @param {Event} event - The native DOM 'click' event object.
                    */
                   async _handleAddToCalendarClick(event) {
                       try {
                           Logger.info(`${this.name}._handleAddToCalendarClick: "Add to Calendar" button clicked.`);
                            // Prevent default behavior of the button (if any, though it's a simple button) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up to parent elements.

                           // Track a Google Analytics event indicating the "Add to Calendar" button was clicked.
                           this.#gaTracker.trackEvent('button_click', { button_id: 'add_to_calendar', form_id: this.id }); // GA Event.

                           // --- Check Dependencies and State ---
                           // Ensure the simulated Google Auth Service instance (`this.#googleAuthService`) is initialized and available AND the user is currently signed in.
                           // The button should be disabled if these conditions are not met (managed by `_updateGoogleServiceButtonState`), but check defensively here before proceeding with the action.
                           if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                               const message = AppConfig.MESSAGES.AUTH_NEEDED; // User-friendly message prompting the user to sign in.
                               Logger.warn(`_handleAddToCalendarClick: User not signed in or simulated auth service is missing. Cannot proceed with action. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure in Google Analytics.
                                this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'auth_needed_or_service_missing' }); // GA Failure Reason.
                               return; // Exit the async handler as prerequisites are not met.
                           }
                            // Log that authentication state is valid for this action.
                           Logger.debug("_handleAddToCalendarClick: User is simulated signed in. Proceeding with data check.");

                           // Ensure valid search parameters are available in `_lastCollectedParams`.
                           // These parameters (destination, dates, etc.) are needed to prepare the calendar event details.
                           // `_lastCollectedParams` is set after a successful form validation and parameter collection during the main search process.
                           if (!this._lastCollectedParams) {
                               const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating that a search is required before this action.
                               Logger.warn(`_handleAddToCalendarClick: No search data available in _lastCollectedParams. Cannot prepare calendar event. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure.
                                this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'no_search_data_available' }); // GA Failure Reason.
                               return; // Exit the async handler as essential data is missing.
                           }
                            // Log that search data is available.
                           Logger.debug("_handleAddToCalendarClick: Search data available in _lastCollectedParams. Proceeding.");


                           // Ensure the simulated Google Calendar Service instance (`this.#calendarService`) is initialized and available.
                           // Although its button should be disabled if it's missing (handled by `_updateGoogleServiceButtonState`), check defensively here.
                           if (!this.#calendarService) {
                                const errorMsg = AppConfig.MESSAGES.CALENDAR_SERVICE_MISSING + ' Cannot add event.'; // Specific service missing message.
                                // Report this as a critical infrastructure error via the ErrorReporter.
                               this.#errorReporter.reportError(
                                   `${this.name}._handleAddToCalendarClick`, new Error(errorMsg), // Source and error object.
                                   { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'calendar_service_missing_critical', 0 // GA error code and persistent message.
                               );
                               // Exit async handler.
                               return;
                            }
                             // Log that the calendar service is available.
                            Logger.debug("_handleAddToCalendarClick: Simulated Google Calendar Service instance is available. Proceeding.");


                           // --- Prepare Calendar Event Details ---
                           // Format the necessary details for the calendar event object based on the stored search parameters.
                           // Use a protected helper method (`_getCalendarEventDetails`) which performs validation on the input parameters and constructs the event object structure.
                           Logger.debug("_handleAddToCalendarClick: Formatting calendar event details using _lastCollectedParams...");
                           let eventDetailsObject = null; // Variable to hold the formatted event details object.
                           try {
                              // Call the helper method, passing the stored search parameters. It returns null if formatting fails.
                              eventDetailsObject = this._getCalendarEventDetails(this._lastCollectedParams);

                              // Check if the event details object was created successfully by the helper method.
                             if (!eventDetailsObject) {
                                  const message = AppConfig.MESSAGES.FAILED('Calendar Add', 'Failed to format event details from search data.'); // Generic formatting error message template.
                                 Logger.error(`_handleAddToCalendarClick: Formatting failed. Event details object is null. Message: "${message}".`);
                                  // Throw an error to be caught below, indicating formatting failure.
                                 throw new Error(message); // Throw an error.
                             }
                             Logger.debug("_handleAddToCalendarClick: Calendar event details object formatted successfully.", eventDetailsObject);

                            } catch (formatError) {
                                // --- Handle Errors During Event Details Formatting ---
                                // If formatting fails, `_getCalendarEventDetails` reports it internally. Catch the error thrown by it here if it signals failure by throwing.
                                 // The error object caught here might already contain a user-friendly message.
                               Logger.error(`_handleAddToCalendarClick: Error during calendar event details formatting process:`, formatError);
                                // The ErrorReporter used in `_getCalendarEventDetails` already handled logging and reporting the error.
                                // Update the main message display if needed (ErrorReporter should cover this).
                                this.#messageDisplay.showMessage(formatError.message || AppConfig.MESSAGES.FAILED('Calendar Add', 'Formatting failed unexpectedly.'), 'error'); // Show message.
                                // Track the reason for failure.
                                this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, reason: 'format_event_details_failed' }); // GA Failure Reason.
                               return; // Exit async handler if formatting failed.
                           } // End of format details try...catch.


                          // --- Simulate Adding Event to Calendar ---
                          // Display a persistent UI message in the main area indicating that the simulated process is starting.
                          // Use a persistent message (duration 0) so it stays visible throughout the asynchronous service call delay.
                          this.#messageDisplay.showMessage(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING, 'info', 0); // Set persistent processing message.
                           // Track a GA event for the start of the "Add to Calendar" process.
                           this.#gaTracker.trackEvent('calendar_add_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                          Logger.debug(`_handleAddToCalendarClick: Calling simulated Google Calendar service to create event...`, eventDetailsObject);
                          // Call the asynchronous method (`createEvent`) on the simulated Calendar service instance (`this.#calendarService`).
                          // In a real application, this would make an async call (fetch/$.ajax/gapi.client) to a backend endpoint or Google API directly.
                          // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                          try {
                               // The `createEvent` method on the simulated service returns a Promise. Await its result.
                               // It's designed to throw/reject on errors during its execution or the simulated API call.
                               const simulatedResponse = await this.#calendarService.createEvent(eventDetailsObject); // Await the simulated service call, passing the formatted event details.
                              // Log the result of the simulated API call and response.
                              Logger.debug("_handleAddToCalendarClick: Simulated createEvent result received:", simulatedResponse);

                              // --- Process Simulated Calendar Add Success ---
                              // If the Promise resolved successfully, `simulatedResponse` should contain data indicating success (e.g., { success: true, eventId: '...' }).
                              // Assume the simulated service returns an object like `{ success: true }` on success.
                              if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.success) {
                                  // If the simulated call was successful according to its response format:
                                  const successMessage = AppConfig.MESSAGES.CALENDAR_ADD_SUCCESS; // Get the standard success message string.
                                  Logger.info(`_handleAddToCalendarClick: ${successMessage}. Simulated response indicated success.`);

                                  // Update the main UI message area with a temporary success message.
                                  this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                  // Track a GA success event for the "Add to Calendar" operation.
                                   this.#gaTracker.trackEvent('calendar_add_success', { form_id: this.id, step: 'success', simulated_event_id: simulatedResponse.eventId || 'N/A' }); // GA Success Event, include simulated event ID if available.
                                   // Optional: If the simulated response includes a link to the event (`simulatedResponse.htmlLink`), you might display it to the user or offer a button.
                                  if (simulatedResponse.htmlLink) {
                                       // Display the link in the main message area or elsewhere.
                                       const linkMessage = `Event added! <a href="${simulatedResponse.htmlLink}" target="_blank" style="color:white; text-decoration:underline;">View in Google Calendar</a>`;
                                      // Overwrite the previous temporary success message with one including the link, using a slightly longer duration.
                                       this.#messageDisplay.showMessage(linkMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS + 3000);
                                       Logger.debug("_handleAddToCalendarClick: Simulated HTML link available in response.", simulatedResponse.htmlLink);
                                   } else {
                                      Logger.debug("_handleAddToCalendarClick: No simulated HTML link available in response.");
                                   }


                              } else {
                                   // --- Handle Simulated Calendar Add Failure (Promise Resolved, but Indicated Failure) ---
                                   // This case is reached if the simulated service's Promise resolved, but the resolved value itself indicates a failure (e.g., the simulated service returned an object like `{ success: false, message: '...', ... }`).
                                   // This is a common pattern for backend APIs or services to return structured error responses for known failures.
                                   // Get a detailed error message from the simulated response object or use a fallback string.
                                  const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated service.";
                                   const message = AppConfig.MESSAGES.CALENDAR_ADD_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                  Logger.error(`_handleAddToCalendarClick: Simulated event creation returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, eventDetails: eventDetailsObject });
                                  // Update the main UI message area with a persistent error message.
                                  this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                  // Track a GA error event with details.
                                  this.#gaTracker.trackEvent('calendar_add_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                              }

                          } catch (apiError) {
                              // --- Handle Simulated Calendar Add Failure (Promise Rejection) ---
                              // Catch any errors thrown (Promise rejections) by the simulated Calendar service's `createEvent` method.
                              // This catch block handles simulated errors such as:
                              // - Network issues when calling the backend endpoint (`fetch` errors).
                              // - HTTP errors (4xx, 5xx) from the backend endpoint (`fetch` `!response.ok` throws).
                              // - JSON parsing errors of the backend response (`fetch` `response.json()` throws) (also handled by `_fetchBackendEndpointSimulated` if used there).
                              // - Errors originating in the Calendar API and propagated back by the backend.
                              // - Errors specifically simulated as rejections by the `createEvent` method (e.g., simulated permission denied, quota exceeded).
                              Logger.error(`_handleAddToCalendarClick: Error caught from simulated Google Calendar service call for form "${this.id}":`, apiError);

                              // Report the error using the injected ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleAddToCalendarClick - apiCall`, // Source indicating the simulated API call stage.
                                  apiError, // The error object caught from the service rejection.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', eventDetails: eventDetailsObject }, // Context including event data sent (be mindful of sensitive data logging).
                                  AppConfig.MESSAGES.CALENDAR_ADD_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                  'calendar_add_api_exception' // GA error code for errors during API interaction.
                              );
                              // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                          } // End of simulated API call try...catch.


                      } catch (handlerError) {
                          // --- Handle Critical Errors During Overall Handler Execution ---
                          // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                          // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps, input validation check fails unexpectedly, issues accessing service instance methods before calling them).
                          // Report the error using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._handleAddToCalendarClick`, // Source of the error.
                              handlerError, // The error object caught.
                              { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                              `Error handling "Add to Calendar" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                              'calendar_button_handler_exception_overall' // GA error code for overall handler exception.
                          );

                          // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                               const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                               // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                               if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // If it's still the generic processing message and not an error, clear it.
                                   this.#messageDisplay.clearMessage();
                                   Logger.debug(`${this.name}._handleAddToCalendarClick: Cleared persistent message in main area due to handler error.`);
                                }
                           } else { Logger.debug(`${this.name}._handleAddToCalendarClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                             const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                             // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                             if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.CALENDAR_ADD_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // Clear the persistent message.
                                 this.#messageDisplay.clearMessage();
                                Logger.debug(`${this.name}._handleAddToCalendarClick: Cleared persistent message in finally.`);
                             }
                         } // Check if MessageDisplay exists.
                         Logger.debug("_handleAddToCalendarClick async method execution completed.");
                       } // End of _handleAddToCalendarClick try...catch...finally block.
                   } // End of _handleAddToCalendarClick method definition.

                   /**
                    * Protected helper method to format the details of a calendar event from collected search parameters.
                    * Creates a plain JavaScript object containing keys and values structured to mimic the body expected by the Google Calendar API's `Events: insert` method (e.g., `summary`, `location`, `description`, `start`, `end`).
                    * Assumes a typical multi-day hotel stay booking is represented as an "all-day" event in the calendar, spanning from the check-in date up to (but not including the start of) the check-out date.
                    * Includes essential details from the search parameters like destination, dates, and travelers in the summary and description. Also includes the generated Expedia URL in the description.
                    * Performs basic validation on required input parameters before formatting.
                    * @param {object} params - The collected search parameters object (`_lastCollectedParams`). Expected keys include `destinationInput`, `checkInDateInput`, `checkOutDateInput`, `adultsCountInput`, `childrenCountInput`. Required.
                    * @returns {object|null} Returns a plain JavaScript object representing the calendar event details if required parameters are valid and sufficient for formatting. Returns `null` if required parameters are missing or in an invalid format that prevents formatting. Throws an error for critical issues during formatting logic itself.
                    * @throws {Error} - Throws an Error if a critical issue occurs *within* the formatting logic itself (e.g., invalid date format that can't be parsed for Date objects needed for calculation if applicable here).
                    */
                   _getCalendarEventDetails(params) {
                       try {
                            Logger.debug("SearchForm._getCalendarEventDetails: Formatting calendar event details from parameters...", params);

                           // --- Validate Input Parameters ---
                           // Check if the essential parameters needed to construct a meaningful calendar event (destination, check-in date, check-out date) are present in the provided `params` object.
                           // Use optional chaining `?.` and nullish coalescing `??` for safety, and explicitly check types for strings.
                           if (!params || typeof params !== 'object' || !params.destinationInput || typeof params.destinationInput !== 'string' || params.destinationInput.trim() === '' ||
                               !params.checkInDateInput || typeof params.checkInDateInput !== 'string' || params.checkInDateInput.trim() === '' ||
                               !params.checkOutDateInput || typeof params.checkOutDateInput !== 'string' || params.checkOutDateInput.trim() === '') {
                               // If any of these essential inputs are missing or not valid strings, log a warning and return null.
                               Logger.warn("SearchForm._getCalendarEventDetails: Missing required parameters (destinationInput, checkInDateInput, checkOutDateInput) for formatting calendar event details.");
                                // Do not throw here, just return null to indicate that formatting cannot proceed due to missing/invalid data.
                                return null; // Indicate failure to format event without essential data.
                            }


                           // Get the check-in and check-out date strings from the parameters object.
                           // Assume these are in YYYY-MM-DD string format as handled by `<input type="date">` and our `DateInput` component.
                           const checkInDateString = params.checkInDateInput.trim(); // Trim dates too.
                           const checkOutDateString = params.checkOutDateInput.trim();

                           // --- Basic Validation of Date String Format ---
                           // Perform a basic check on the date string format (YYYY-MM-DD). More thorough date validation is done by `DateInput._validate` and form-level validation.
                           if (!/^\d{4}-\d{2}-\d{2}$/.test(checkInDateString) || !/^\d{4}-\d{2}-\d{2}$/.test(checkOutDateString)) {
                               // If date strings are not in the expected YYYY-MM-DD format, log an error and return null.
                                const formatErrorMsg = `_getCalendarEventDetails: Invalid date string format for check-in ("${checkInDateString}") or check-out ("${checkOutDateString}"). Expected YYYY-MM-DD.`;
                               Logger.error(formatErrorMsg);
                                // Throw an error here to indicate a formatting failure due to invalid input strings. The caller (`_handleAddToCalendarClick`) catches this.
                                throw new Error(formatErrorMsg); // Throw an error.
                           }


                           // --- Calendar API Date Format Requirement Note ---
                           // When creating "all-day" events in the Google Calendar API, you typically use the 'date' property
                           // within the `start` and `end` objects, providing dates in YYYY-MM-DD string format.
                           // The `end` date for an all-day event in the API is the date *after* the last day the event takes place.
                           // For a hotel stay checking out on YYYY-MM-DD (meaning the stay is until the morning of that day),
                           // the event is considered to last up to that day. So, the Calendar API `end.date` parameter should be the check-out date string.
                           // Example: Check-in 2023-10-27, Check-out 2023-10-30 (3 nights: 27th, 28th, 29th). The event spans Day 1 (27th) to Day 4 (30th). API Start Date: 2023-10-27, API End Date: 2023-10-30.
                           // If you wanted specific times (e.g., 3 PM check-in, 11 AM check-out on the last day), you would use the `dateTime` property with RFC 3339 strings (YYYY-MM-DDTHH:mm:ss).

                           const eventStartDate = checkInDateString; // Start date for the calendar event (check-in date string).
                           const eventEndDate = checkOutDateString; // End date for the calendar event (check-out date string).


                          // --- Calculate Number of Nights (for Description) ---
                          // Calculate the number of nights based on the check-in and check-out dates to include in the event description.
                          // Use Date objects for calculation reliability, but ensure they are valid first.
                           let numberOfNights = 'N/A'; // Default if calculation fails.
                           try {
                                // Attempt to create `Date` objects from the valid date strings.
                                const checkInDateObj = new Date(checkInDateString);
                                const checkOutDateObj = new Date(checkOutDateString);

                                // Ensure both dates parsed successfully into valid `Date` objects.
                                if (!isNaN(checkInDateObj.getTime()) && !isNaN(checkOutDateObj.getTime())) {
                                    const timeDifference = checkOutDateObj.getTime() - checkInDateObj.getTime(); // Difference in milliseconds.
                                    const millisecondsPerDay = 24 * 60 * 60 * 1000; // Milliseconds in one day.

                                     // If check-out is on or before check-in, nights should be 0 or calculated appropriately (e.g., 0 or 1 depending on rule). Validation should prevent negative difference.
                                     if (timeDifference >= 0) {
                                         // Calculate the difference in days (number of nights). Use Math.round to handle potential Daylight Saving Time shifts impacting the exact time difference calculation across midnight.
                                        const calculatedNights = Math.round(timeDifference / millisecondsPerDay);
                                        numberOfNights = calculatedNights >= 0 ? calculatedNights : 0; // Ensure non-negative.
                                         Logger.debug(`_getCalendarEventDetails: Calculated ${numberOfNights} nights for description.`);
                                    } else {
                                        // Negative difference implies checkout before checkin (validation failure). Log warning.
                                         Logger.warn(`_getCalendarEventDetails: Check-out date is before check-in date (${timeDifference} ms difference). Cannot calculate nights for description. Assuming N/A.`);
                                         numberOfNights = 'N/A (Date Error)';
                                    }
                               } else {
                                   // If date strings could not be parsed into valid Date objects (despite format check passing basic regex), nights cannot be calculated.
                                   Logger.warn(`_getCalendarEventDetails: Invalid Date objects during nights calculation for description. Assuming N/A.`);
                                   numberOfNights = 'N/A (Format Error)';
                               }
                           } catch (nightsCalcError) {
                                // Catch any errors during the nights calculation process.
                                Logger.error(`_getCalendarEventDetails: Error calculating number of nights for description:`, nightsCalcError, { checkInString: checkInDateString, checkOutString: checkOutDateString });
                                numberOfNights = 'N/A (Calc Error)';
                                // Report this calculation error using the injected reporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._getCalendarEventDetails`, nightsCalcError, // Source and error.
                                    { component: this.#getComponentInfo(), checkIn: checkInDateString, checkOut: checkOutDateString, step: 'nights_calculation_exception' }, // Context.
                                    `Error calculating number of nights for event description.`, 'form_get_calendar_nights_exception' // GA error code.
                                );
                           } // End of nights calculation try...catch.


                          // --- Construct Calendar Event Object ---
                          // Build the event object structure according to the Google Calendar API Events: insert method documentation.
                          const calendarEventObject = {
                             // `summary`: REQUIRED. The primary title of the calendar event.
                             'summary': `Hotel Stay: ${trimmedDestination || 'Destination'}`, // Use the trimmed destination from parameters.

                             // `location`: OPTIONAL. The physical location of the event.
                             'location': trimmedDestination || '', // Use the trimmed destination again for location.

                             // `description`: OPTIONAL. More detailed text about the event. Use the calculated number of nights and other details.
                              'description': `Details for your hotel search:\n\n` +
                                             `- Destination: ${trimmedDestination || 'N/A'}\n` +
                                             `- Check-in Date: ${checkInDateString || 'N/A'}\n` +
                                             `- Check-out Date: ${checkOutDateString || 'N/A'}\n` +
                                              // Include the calculated number of nights in the description.
                                             `- Duration: ${numberOfNights} night${(typeof numberOfNights === 'number' && numberOfNights > 1) ? 's' : ''}\n` +
                                             `- Adults: ${params.adultsCountInput ?? 'N/A'}\n` + // Use nullish coalescing for traveler counts.
                                             `- Children: ${params.childrenCountInput ?? 'N/A'}\n\n` +
                                              // Include the generated Expedia URL (built using the static method). Pass params and reporter. Handle null URL.
                                              // Access the static builder method via `ExpediaUrlBuilder.buildUrl`.
                                             `Search/Book Link: ${ExpediaUrlBuilder.buildUrl(params, this.#errorReporter) || 'Expedia.com (Link build failed)'}`,

                             // `start`: REQUIRED. The start date/time of the event. Use 'date' property for all-day events.
                             'start': {
                               'date': eventStartDate, // YYYY-MM-DD string from check-in date.
                                // If you were adding events with specific times (e.g., 3 PM check-in): 'dateTime': `${eventStartDate}T15:00:00`, and include a 'timeZone'.
                                // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone, // Get user's current timezone (recommended for dateTime).
                             },

                             // `end`: REQUIRED. The end date/time of the event. Use 'date' property for all-day events.
                             // For all-day events, this is the date *after* the event's last day. So, for a stay ending on the check-out date, the API end date is the check-out date.
                             'end': {
                               'date': eventEndDate, // YYYY-MM-DD string from check-out date.
                                // If using specific check-out time (e.g., 11 AM): 'dateTime': `${eventEndDate}T11:00:00`, and include a 'timeZone'.
                                // 'timeZone': Intl.DateTimeFormat().resolvedOptions().timeZone,
                             },

                              // Optional properties for all-day events. `endTimeUnspecified: true` is often used with `date`-only fields.
                              // 'endTimeUnspecified': true,

                              // Add other optional properties if needed and supported by Calendar API:
                              // 'attendees': [{'email': this.#googleAuthService?.getUserEmail() || ''}], // Add the simulated signed-in user's email as an attendee if available.
                              // 'reminders': { 'useDefault': true }, // Use the user's default calendar reminders.
                              // Or customize reminders: 'reminders': { 'useDefault': false, 'overrides': [ {'method': 'popup', 'minutes': 60}, {'method': 'email', 'minutes': 1440} ] },

                         }; // End of calendarEventObject construction.

                          // Log the successfully constructed calendar event object for debugging before returning.
                          Logger.debug("SearchForm._getCalendarEventDetails: Formatted calendar event object created:", calendarEventObject);

                          // Return the successfully formatted calendar event object.
                          return calendarEventObject;

                      } catch (error) {
                           // --- Handle Critical Errors During Event Details Formatting ---
                           // Catch any unexpected errors occurring *within* this helper method's formatting logic
                           // (e.g., errors during string manipulation, errors accessing object properties, errors propagating from `buildUrl` if its error handling is insufficient).
                           Logger.error(`SearchForm._getCalendarEventDetails: CRITICAL UNEXPECTED ERROR caught during calendar event formatting!`, error);

                           // Report this critical formatting failure using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._getCalendarEventDetails`, // Source of the error.
                               error, // The error object caught.
                               { component: this.#getComponentInfo(), paramsInput: params, step: 'formatting_logic_exception' }, // Context details.
                               `Critical error formatting calendar event details for component "${this.name}". Operation cannot proceed.`, // User-friendly message template for a critical formatting failure.
                               'form_get_calendar_event_details_exception_critical' // GA error code for critical formatting exception.
                           );

                           // Return `null` to indicate that formatting failed fundamentally due to an internal error.
                           return null; // Always return null on critical error.
                       } // End of _getCalendarEventDetails try...catch.
                   } // End of _getCalendarEventDetails method definition.


                   /**
                    * Asynchronous handler for the "Email Search Details" button click. Marked as `async`.
                    * This method is triggered when the user clicks the button element identified by `#emailSearchDetailsButton`.
                    * It orchestrates the simulated process of sending an email containing the search details
                    * stored in `_lastCollectedParams` using the `SimulatedGoogleEmailService`.
                    * It performs necessary checks (authentication state, search data availability, service availability),
                    * prepares the email content, calls the simulated service, and handles the simulated success or failure response.
                    * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                    * Assumes the email is sent TO the simulated signed-in user's email address.
                    * @param {Event} event - The native DOM 'click' event object.
                    */
                   async _handleEmailSearchDetailsClick(event) {
                       try {
                           Logger.info(`${this.name}._handleEmailSearchDetailsClick: "Email Search Details" button clicked.`);
                            // Prevent default behavior of the button (if any, though it's a simple button) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up to parent elements.

                           // Track a Google Analytics event indicating the "Email Search Details" button was clicked.
                           this.#gaTracker.trackEvent('button_click', { button_id: 'email_search_details', form_id: this.id }); // GA Event.

                           // --- Check Dependencies and State ---
                           // Ensure the simulated Google Auth Service instance (`this.#googleAuthService`) is initialized and available AND the user is currently signed in.
                           // Emailing user data typically requires the user to be signed in. The button should be disabled if not signed in (managed by `_updateGoogleServiceButtonState`), perform checks defensively.
                           if (!this.#googleAuthService || !this.#googleAuthService.isSignedIn()) {
                               const message = AppConfig.MESSAGES.AUTH_NEEDED; // User-friendly message prompting the user to sign in.
                               Logger.warn(`_handleEmailSearchDetailsClick: User not simulated signed in or simulated auth service is missing. Cannot proceed with email action. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure in Google Analytics.
                                this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'auth_needed_or_service_missing' }); // GA Failure Reason.
                               return; // Exit the async handler as prerequisites are not met.
                           }
                            // Log that authentication state is valid for this action.
                           Logger.debug("_handleEmailSearchDetailsClick: User is simulated signed in. Proceeding with data and service checks.");

                           // Ensure valid search parameters are available in `_lastCollectedParams`.
                           // These parameters are essential data needed to format the email content.
                           // `_lastCollectedParams` is set after a successful form validation and parameter collection during the main search process.
                           if (!this._lastCollectedParams) {
                               const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating that a search is required before this action.
                               Logger.warn(`_handleEmailSearchDetailsClick: No search data available in _lastCollectedParams. Cannot format email content. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure.
                                this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'no_search_data' }); // GA Failure Reason.
                               return; // Exit the async handler as essential data is missing.
                           }

                           // Ensure the simulated Google Email Service instance (`this.#emailService`) is initialized and available.
                           // Although its button should be disabled if it's missing (handled by `_updateGoogleServiceButtonState`), check defensively here.
                           if (!this.#emailService) {
                                const errorMsg = AppConfig.MESSAGES.EMAIL_SERVICE_MISSING + ' Cannot send email.'; // Specific service missing message.
                               // Report this as a critical infrastructure error via the ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleEmailSearchDetailsClick`, new Error(errorMsg), // Source and error object.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'email_service_missing_critical', 0 // GA error code and persistent message.
                              ); // Persistent error message.
                               // Track failure reason.
                              this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'email_service_missing_critical' }); // GA Failure Reason.
                              return; // Exit async handler if service is missing.
                            }
                             // Log that the email service is available.
                            Logger.debug("_handleEmailSearchDetailsClick: Simulated Google Email Service instance is available. Proceeding.");


                           // --- Get Recipient Email and Format Email Details Payload ---
                           // In this simulation, we assume the email is sent TO the simulated signed-in user's email address.
                           // This would require the user to have granted permission (via OAuth scopes) to access their email address in a real app.
                           // The `GoogleIdentityServiceWrapper`'s `getUserEmail()` method provides the simulated email address.
                           const userEmailAddress = this.#googleAuthService.getUserEmail(); // Get the simulated signed-in user's email string.

                           // Check if the user's email address was successfully obtained from the auth service.
                           // It might be null if the user is not signed in (caught above), or if the simulated service has an issue, or the wrong scopes were granted (in a real OAuth scenario).
                           if (!userEmailAddress) {
                                const message = AppConfig.MESSAGES.FAILED('Email Details', 'Cannot determine signed-in user email address to send to.'); // Message indicating recipient email is missing.
                               Logger.error(`${this.name}._handleEmailSearchDetailsClick: Signed-in user email address not available from auth service. Cannot format email. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'error'); // Show an error message persistently.
                                // Track the reason for failure in Google Analytics.
                                this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'user_email_missing_from_auth_service' }); // GA Failure Reason.
                               return; // Exit the async handler if recipient email is missing.
                           }
                            Logger.debug(`_handleEmailSearchDetailsClick: Signed-in user email address obtained: "${userEmailAddress}".`);


                           // Format the email details object (`to`, `subject`, `body`) based on the stored search parameters and the recipient email address.
                           // Use a protected helper method (`_getEmailDetails`) for this formatting logic.
                           Logger.debug("_handleEmailSearchDetailsClick: Formatting email details object using _lastCollectedParams and recipient email...");
                           let emailDetailsObject = null; // Variable to hold the formatted email details object.
                           try {
                               // Call the helper method, passing the stored search parameters and the obtained recipient email address.
                               emailDetailsObject = this._getEmailDetails(this._lastCollectedParams, userEmailAddress);

                               // Check if the email details object was successfully created by the helper method.
                               // `_getEmailDetails` returns null for invalid input or throws an error for format issues.
                              if (!emailDetailsObject) {
                                   const message = AppConfig.MESSAGES.FAILED('Email Details', 'Failed to format email content from search data.'); // Generic formatting error message template.
                                  Logger.error(`_handleEmailDetailsClick: Formatting failed. Email details object is null. Message: "${message}".`);
                                  // Since the helper doesn't throw for null return, throw here to be caught below.
                                   throw new Error(message); // Throw an error.
                              }
                              Logger.debug("_handleEmailSearchDetailsClick: Email details object formatted successfully.", emailDetailsObject);

                            } catch (formatError) {
                                // --- Handle Errors During Email Details Formatting ---
                                // Catch any errors thrown *within* the `_getEmailDetails` helper method (e.g., errors during string manipulation, errors accessing properties, errors propagating from `buildUrl` if caught).
                                // The error object caught here might already contain a user-friendly message (if thrown explicitly in the helper).
                                Logger.error(`_handleEmailDetailsClick: Error during email formatting process:`, formatError);
                                // Report the error using the injected ErrorReporter.
                                 this.#errorReporter.reportError(
                                     `${this.name}._handleEmailDetailsClick - format`,
                                     formatError, // The error object caught.
                                     { component: this.#getComponentInfo(), formId: this.id, paramsInput: this._lastCollectedParams, recipient: userEmailAddress, step: 'format_email_details' }, // Context details.
                                     formatError.message || AppConfig.MESSAGES.FAILED('Email Details', 'Formatting failed unexpectedly.'), // Use the error's message or a generic fallback.
                                     'email_details_format_exception' // GA error code for formatting exception.
                                 );
                                // Update the main message display with the formatted error message.
                                this.#messageDisplay.showMessage(formatError.message || AppConfig.MESSAGES.FAILED('Email Details', 'Formatting failed unexpectedly.'), 'error'); // Show persistent error message.
                                 // Track the reason for failure.
                                this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, reason: 'format_email_details_failed' }); // GA Failure Reason.
                               return; // Exit async handler if formatting failed.
                            } // End of format details try...catch.


                           // --- Simulate Sending Email ---
                           // Display a persistent UI message in the main area indicating that the simulated email sending process is starting.
                           // Use a persistent message (duration 0) so it stays visible throughout the asynchronous service call delay.
                           this.#messageDisplay.showMessage(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING, 'info', 0); // Set persistent processing message.
                            // Track a GA event for the start of the email send process.
                            this.#gaTracker.trackEvent('email_send_process_started', { form_id: this.id, recipient: userEmailAddress, step: 'started' }); // GA Event, include simulated recipient.


                           Logger.debug(`_handleEmailSearchDetailsClick: Calling simulated Google Email service to send email...`, emailDetailsObject);
                           // Call the asynchronous method (`sendEmail`) on the simulated Email service instance (`this.#emailService`).
                           // In a real application, this would make an async HTTP call (fetch/$.ajax) to a backend endpoint
                           // (defined by `AppConfig.BACKEND_ENDPOINTS.GOOGLE_API_USER_GATEWAY` or similar)
                           // that would handle sending the email using secure credentials (like a backend gateway or Gmail API via server).
                           // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                           try {
                                // The `sendEmail` method on the simulated service returns a Promise. Await its result.
                                // It's designed to throw/reject on errors during its execution or the simulated API call.
                                const simulatedResponse = await this.#emailService.sendEmail(emailDetailsObject); // Await the simulated service call, passing the formatted email details object.
                               // Log the result of the simulated API call and response.
                               Logger.debug("_handleEmailSearchDetailsClick: Simulated sendEmail result received:", simulatedResponse);

                               // --- Process Simulated Email Send Success ---
                               // If the Promise resolved successfully, `simulatedResponse` should contain data indicating success (e.e.g., { success: true, messageId: '...' }).
                               // Assume the simulated service returns an object like `{ success: true }` on success.
                               if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.success) {
                                   // If the simulated call was successful according to its response format:
                                   const successMessage = AppConfig.MESSAGES.EMAIL_SEND_SUCCESS; // Get the standard success message string.
                                   Logger.info(`_handleEmailSearchDetailsClick: ${successMessage}. Simulated response indicated success.`);

                                   // Update the main UI message area with a temporary success message.
                                   this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                   // Track a GA success event for the email sending operation.
                                    this.#gaTracker.trackEvent('email_send_success', { form_id: this.id, step: 'success', simulated_message_id: simulatedResponse.messageId || 'N/A' }); // GA Success Event, include simulated message ID if available.
                                    // Optional: Log or report more details about the simulated success from the response.
                                   if (simulatedResponse.message) Logger.info(`_handleEmailSearchDetailsClick: Simulated script message: ${simulatedResponse.message}`);


                                } else {
                                    // --- Handle Simulated Email Send Failure (Promise Resolved, but Indicated Failure) ---
                                    // This case is reached if the simulated service's Promise resolved, but the resolved value itself indicates a failure (e.g., the simulated service returned an object like `{ success: false, message: '...' }`).
                                    // This is a common pattern for backend APIs or services to return structured error responses for known failures.
                                    // Get a detailed error message from the simulated response object or use a fallback string.
                                   const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated service.";
                                    const message = AppConfig.MESSAGES.EMAIL_SEND_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                   Logger.error(`_handleEmailSearchDetailsClick: Simulated email sending returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, dataSent: emailDetailsObject });
                                   // Update the main UI message area with a persistent error message.
                                   this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                   // Track a GA error event with details.
                                   this.#gaTracker.trackEvent('email_details_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                               } // End of simulated response processing.


                           } catch (apiError) {
                               // --- Handle Simulated Email Send Failure (Promise Rejection) ---
                               // Catch any errors thrown (Promise rejections) by the simulated Email service's `sendEmail` method.
                               // This catch block handles simulated errors such as network issues, backend HTTP errors, JSON parsing errors,
                               // errors originating in the real email API (like Gmail) and propagated back by the backend,
                               // or errors specifically simulated as rejections by the `sendEmail` method (e.g., random failures, invalid recipient format simulated at service level).
                               Logger.error(`_handleEmailSearchDetailsClick: Error caught from simulated Google Email service call for form "${this.id}":`, apiError);

                               // Report the error using the injected ErrorReporter.
                               this.#errorReporter.reportError(
                                   `${this.name}._handleEmailSearchDetailsClick - apiCall`, // Source indicating the simulated API call stage.
                                   apiError, // The error object caught from the service rejection.
                                   { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', emailDetails: emailDetailsObject }, // Context including email data sent (be mindful of sensitive data logging).
                                   AppConfig.MESSAGES.EMAIL_SEND_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                   'email_send_api_exception' // GA error code for errors during API interaction.
                               );
                               // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                           } // End of simulated API call try...catch.


                       } catch (handlerError) {
                           // --- Handle Critical Errors During Overall Handler Execution ---
                           // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                           // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps, validation check fails unexpectedly, issues accessing service instance methods before calling them, errors in the outer try block).
                           // Report the error using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._handleEmailSearchDetailsClick`, // Source of the error.
                               handlerError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                               `Error handling "Email Search Details" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                               'email_button_handler_exception_overall' // GA error code for overall handler exception.
                           );

                           // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                            if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                                const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                                // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                                if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                    // If it's still the generic processing message and not an error, clear it.
                                    this.#messageDisplay.clearMessage();
                                    Logger.debug(`${this.name}._handleEmailSearchDetailsClick: Cleared persistent message in main area due to handler error.`);
                                 }
                            } else { Logger.debug(`${this.name}._handleEmailSearchDetailsClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                            // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                              const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                              // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.EMAIL_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // Clear the persistent message.
                                  this.#messageDisplay.clearMessage();
                                 Logger.debug(`${this.name}._handleEmailSearchDetailsClick: Cleared persistent message in finally.`);
                              }
                          } // Check if MessageDisplay exists.
                          Logger.debug("_handleEmailSearchDetailsClick async method execution completed.");
                       } // End of _handleEmailSearchDetailsClick try...catch...finally block.
                   } // End of _handleEmailSearchDetailsClick method definition.


                   /**
                    * Protected helper method to format the details of an email based on collected search parameters and recipient email address.
                    * Creates a simple JavaScript object containing key-value pairs for the email (`to`, `subject`, `body`) structured as might be expected
                    * by a backend endpoint acting as an email gateway.
                    * The email body includes the key search details and the generated Expedia URL. Includes validation for required input and email format.
                    * @param {object} params - The collected search parameters object (`_lastCollectedParams`). Expected keys include `destinationInput`, `checkInDateInput`, `checkOutDateInput`, `adultsCountInput`, `childrenCountInput`. Required.
                    * @param {string} recipientEmail - The email address string of the intended recipient. In this simulation, this is typically the email of the simulated signed-in user. Required.
                    * @returns {object|null} - Returns a plain JavaScript object representing the email details (`{ to: ..., subject: ..., body: ... }`) if required parameters are valid and sufficient for formatting. Returns `null` if required parameters are missing or in an invalid format that prevents formatting. Throws an error for invalid recipient email format.
                    * @throws {Error} - Throws an Error if the `recipientEmail` string is provided but is in an invalid format, as this prevents email creation.
                    */
                   _getEmailDetails(params, recipientEmail) {
                       try {
                            Logger.debug("SearchForm._getEmailDetails: Formatting email details from parameters and recipient...", { paramsInput: params, recipientEmail: recipientEmail });

                           // --- Validate Input Parameters ---
                           // Check if the essential parameters needed to create the email content (destination, dates) and the recipient email address are present and valid strings.
                           // Use optional chaining `?.` and nullish coalescing `??` for safety, and explicitly check types for strings.
                           if (!params || typeof params !== 'object' || !params.destinationInput || typeof params.destinationInput !== 'string' || params.destinationInput.trim() === '' ||
                               !params.checkInDateInput || typeof params.checkInDateInput !== 'string' || params.checkInDateInput.trim() === '' ||
                               !params.checkOutDateInput || typeof params.checkOutDateInput !== 'string' || params.checkOutDateInput.trim() === '' ||
                               !recipientEmail || typeof recipientEmail !== 'string' || recipientEmail.trim() === '') {
                               // If any of these essential inputs are missing or invalid strings, log a warning and return null.
                               Logger.warn("SearchForm._getEmailDetails: Missing required parameters (destinationInput, checkInDateInput, checkOutDateInput) or recipient email is missing/invalid string for formatting.");
                                // Do not throw here, just return null to indicate formatting failed due to missing/invalid data. The caller (`_handleEmailSearchDetailsClick`) handles this null return.
                                return null; // Indicate failure to format email without essential data.
                            }

                           // Perform basic format validation on the recipient email address string using a regular expression.
                           // This is a client-side check. Robust backend validation is also necessary before attempting to send real emails.
                            // Use a simple regex for a quick check.
                            const trimmedRecipientEmail = recipientEmail.trim();
                           if (!/\S+@\S+\.\S+/.test(trimmedRecipientEmail)) {
                                const formatErrorMsg = `SearchForm._getEmailDetails: Invalid recipient email format provided: "${recipientEmail}".`;
                               Logger.error(formatErrorMsg);
                               // If the recipient email format is invalid, throw an error to signal this specific type of formatting failure to the caller.
                               throw new Error(formatErrorMsg); // Throw an error indicating invalid input format for this method.
                            }


                          // --- Construct Email Content ---
                          // Create the subject line for the email. Use the destination and dates for specificity in the subject.
                           const trimmedDestination = params.destinationInput.trim(); // Get the trimmed destination again.
                          const subjectLine = `LuxStay Search: ${trimmedDestination} (${params.checkInDateInput} to ${params.checkOutDateInput})`; // Use required params for subject.

                          // Get the generated Expedia URL to include in the email body.
                          // Use the static `ExpediaUrlBuilder.buildUrl` method. Pass the collected `params` object and the `ErrorReporter` instance.
                          // The `buildUrl` method handles its own error logging and returns `null` if the URL cannot be built.
                          const searchLink = this.#urlBuilder ? this.#urlBuilder.buildUrl(params, this.#errorReporter) : null; // Pass reporter.

                          // Create the main body content of the email as a multi-line string using a template literal (` `` `).
                          // Include the key search details from the `params` object and the generated Expedia link.
                          // Add conditional text if the search link could not be built (the `buildUrl` method returns `null` in that case).
                          const emailBodyContent = `
                              Dear User,

                              Thank you for using LuxStay Finder!

                              Here are the details for your recent luxury stay search based on your input:

                              - Destination: ${trimmedDestination || 'N/A'}
                              - Check-in Date: ${params.checkInDateInput || 'N/A'}
                              - Check-out Date: ${params.checkOutDateInput || 'N/A'}
                              - Adults: ${params.adultsCountInput ?? 'N/A'}
                              - Children: ${params.childrenCountInput ?? 'N/A'}

                              ${searchLink ?
                                  `You can view available stays and book on Expedia.com by clicking the link below:\n${searchLink}` :
                                  `A direct search link could not be automatically generated based on your criteria. Please visit Expedia.com and manually enter the search details above.`
                              }

                              This email was generated by the LuxStay Finder demo application.

                              Best regards,
                              The Demo App Team
                          `.trim(); // Use `.trim()` on the entire template literal result to remove leading/trailing whitespace.


                          // --- Create Email Details Object ---
                          // Construct a simple plain JavaScript object representing the email details.
                          // This structure with keys `to`, `subject`, and `body` is a common format for passing email data
                          // to a backend endpoint or a service wrapper before actual email sending.
                          const emailDetailsObject = {
                             'to': trimmedRecipientEmail, // Use the validated and trimmed recipient email address string.
                             'subject': subjectLine, // Use the formatted subject line string.
                             'body': emailBodyContent, // Use the formatted email body text string.
                             // Add other properties if the simulated or real email sending service/backend endpoint supports them,
                             // e.g., 'from': 'noreply@yourdomain.com', 'htmlBody': '...', 'attachments': [...].
                             // Note: For the real Gmail API via a backend gateway, you would typically construct a complex base64-encoded MIME message string here or on the backend.
                          };

                          // Log the structured email details object for debugging.
                          Logger.debug("SearchForm._getEmailDetails: Formatted email details object created:", emailDetailsObject);

                          // Return the successfully formatted email details object.
                          return emailDetailsObject;

                      } catch (error) {
                           // --- Handle Errors During Email Formatting Logic ---
                           // Catch any unexpected errors occurring *within* this helper method's logic (e.g., errors during string manipulation, errors accessing properties, errors propagating from `buildUrl` if caught).
                           Logger.error(`SearchForm._getEmailDetails: CRITICAL UNEXPECTED ERROR caught during email formatting!`, error);

                           // Report this critical formatting failure using the injected reporter.
                          this.#errorReporter.reportError(
                              `${this.name}._getEmailDetails`, // Source of the error.
                              error, // The error object caught.
                              { component: this.#getComponentInfo(), paramsInput: params, recipientEmailInput: recipientEmail, step: 'email_formatting_logic_exception' }, // Context details.
                              `Error formatting email details for component "${this.name}". Cannot create email content.`, // User-friendly message template for formatting failure.
                              'form_get_email_details_exception_critical' // GA error code for formatting exception.
                          );
                           // If formatting failed due to an error, return `null` to indicate failure to the caller (`_handleEmailSearchDetailsClick`).
                           // The caller handles displaying a user message based on this null return or a thrown error from here (like invalid recipient format).
                           return null; // Always return null on error or invalid input.
                       } // End of _getEmailDetails try...catch.
                   } // End of _getEmailDetails method definition.


                   /**
                    * Asynchronous handler for the "Send to Apps Script" button click. Marked as `async`.
                    * This method is triggered when the user clicks the button element identified by `#sendToAppsScriptButton`.
                    * It orchestrates the simulated process of sending the collected search details (stored in `_lastCollectedParams`)
                    * as a data payload to a Google Apps Script endpoint using the `SimulatedGoogleAppsScriptService`.
                    * This simulates a client-side action triggering a server-less function or a backend endpoint that interacts with Apps Script.
                    * Displays UI messages to the user (indicating progress, success, or failure) and tracks Google Analytics events throughout the process.
                    * @param {Event} event - The native DOM 'click' event object.
                    */
                   async _handleSendToAppsScriptClick(event) {
                       try {
                           Logger.info(`${this.name}._handleSendToAppsScriptClick: "Send to Apps Script" button clicked.`);
                            // Prevent default browser behavior of the button (if any) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                           // Track a Google Analytics event indicating the "Send to Apps Script" button was clicked.
                           this.#gaTracker.trackEvent('button_click', { button_id: 'send_to_apps_script', form_id: this.id }); // GA Event.

                           // --- Check Dependencies and State ---
                           // Ensure valid search parameters are available in `_lastCollectedParams`. The Apps Script operation typically requires this data as payload.
                           if (!this._lastCollectedParams) {
                               const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating that a search is required before this action.
                               Logger.warn(`${this.name}._handleSendToAppsScriptClick: No search data available in _lastCollectedParams. Cannot proceed with action. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure in Google Analytics.
                                this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'no_search_data_available' }); // GA Failure Reason.
                               return; // Exit the async handler as essential data is missing.
                           }

                           // Ensure the simulated Google Apps Script Service instance (`this.#appsScriptService`) is initialized and configured (has a non-placeholder endpoint URL).
                           // Its `isConfigured()` method checks this condition based on `AppConfig.BACKEND_ENDPOINTS.APPS_SCRIPT_GATEWAY`.
                           if (!this.#appsScriptService || !this.#appsScriptService.isConfigured()) {
                                const message = AppConfig.MESSAGES.APPS_SCRIPT_ENDPOINT_MISSING; // Message about the Apps Script endpoint configuration missing.
                               Logger.warn(`${this.name}._handleSendToAppsScriptClick: Apps Script service not configured or instance missing. Cannot send data. Message: "${message}".`);
                               // Display the warning message temporarily in the main UI area.
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message for 8 seconds.
                               // The service constructor or its initialization method should have already reported the missing configuration error persistently in the main message area via ErrorReporter.
                                // Track the reason for failure in Google Analytics.
                                this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, reason: 'service_not_configured_or_missing_instance' }); // GA Failure Reason.
                               return; // Exit the async handler if the service is not configured or available.
                            }


                           // --- Prepare Data Payload for Apps Script ---
                           // Create the JavaScript object containing the data payload that will be sent to the Apps Script endpoint.
                           // Use the stored collected search parameters (`this._lastCollectedParams`) as the primary data.
                           // Augment with other relevant context like a timestamp or basic user information (if the user is simulated signed in and Apps Script needs it).
                            Logger.debug("_handleSendToAppsScriptClick: Preparing data payload for Apps Script...");
                            let dataPayloadToSend = null; // Variable to hold the prepared data payload.
                            try {
                                // Construct the data payload object.
                                 dataPayloadToSend = {
                                    // Include the collected search details object. Use defensive checks for existence.
                                   searchDetails: this._lastCollectedParams || {},
                                    // Add metadata about when the data was sent from the client. Use ISO 8601 string format for clarity and machine readability.
                                   clientTimestamp: new Date().toISOString(), // Get current timestamp.
                                    // Include information about the page the data originated from.
                                   originPage: window.location.href, // The URL of the current page.
                                    // If the user is simulated signed in via Google Identity Services, include some basic simulated user info.
                                    // The simulated auth service instance (`this.#googleAuthService`) provides user info getters.
                                   userInfo: this.#googleAuthService?.getUserInfo() || null, // Get user info object if available, otherwise null.
                                   // Add other static or dynamic context relevant to your specific Google Apps Script (e.g., application name, version, form identifier).
                                   sourceApplication: AppConfig.APP_NAME,
                                   appVersion: AppConfig.APP_VERSION,
                                   formId: this.id
                                    // You could add more detailed context if needed by your script (e.g., browser info).
                                    // browserInfo: navigator.userAgent // Example: Add browser user agent (consider privacy implications).
                                };
                                 Logger.debug("_handleSendToAppsScriptClick: Data payload prepared successfully:", dataPayloadToSend);

                                // Optional: Validate the structure/content of the prepared payload if necessary before sending.
                                 // If invalid, throw a specific error caught below.

                            } catch (preparePayloadError) {
                                // --- Handle Errors During Payload Preparation ---
                                 // Catch any errors while preparing the data payload synchronously.
                                 this.#errorReporter.reportError(
                                     `${this.name}._handleSendToAppsScriptClick`, preparePayloadError, // Source and error.
                                    { component: this.#getComponentInfo(), step: 'prepare_payload_for_apps_script_exception' }, // Context details.
                                    `Error preparing data to send to Apps Script. Operation failed due to internal issue.`, // User-friendly message template.
                                     'apps_script_send_prepare_payload_exception' // GA error code.
                                );
                                // Ensure the persistent "Processing..." message is cleared if an error occurred before setting it (handled below in finally),
                                // or if it was set already and isn't an error message itself.
                                 if (this.#messageDisplay) {
                                     const currentMessageElement = this.#messageDisplay.getElement();
                                      if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                          this.#messageDisplay.clearMessage();
                                          Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message after payload preparation error.`);
                                       }
                                 } else { Logger.debug(`${this.name}._handleSendToAppsScriptClick: MessageDisplay service missing when handling payload error.`); }
                                // Re-throw the error to indicate that payload preparation failed and the send operation should not proceed.
                                throw preparePayloadError; // Re-throw the error.
                            } // End of preparePayload try...catch.


                           // --- Simulate Sending Data to Apps Script Endpoint ---
                           // Display a persistent UI message in the main area indicating that the simulated sending process is starting.
                           // Use a persistent message (duration 0) so it stays visible throughout the asynchronous service call delay.
                           this.#messageDisplay.showMessage(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING, 'info', 0); // Set persistent processing message.
                            // Track a GA event for the start of the "Send to Apps Script" process.
                            this.#gaTracker.trackEvent('apps_script_send_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                           Logger.debug(`_handleSendToAppsScriptClick: Calling simulated Google Apps Script service runScriptFunction...`, dataPayloadToSend);
                           // Call the asynchronous method (`runScriptFunction`) on the simulated Apps Script service instance (`this.#appsScriptService`).
                           // This method simulates making an async HTTP call (fetch/$.ajax) to the configured backend endpoint (`this.#appsScriptService.#endpointUrl`),
                           // which YOUR backend would use to securely invoke the Google Apps Script function (`doPost` or `doGet`) with the provided data payload.
                           // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success) or rejects (simulated failure).
                           try {
                                // The `runScriptFunction` method on the simulated service returns a Promise. Await its result.
                                // It's designed to throw/reject on errors during its execution or the simulated API call.
                                const simulatedResponse = await this.#appsScriptService.runScriptFunction(dataPayloadToSend); // Await the simulated service call, passing the prepared data payload.
                               // Log the result of the simulated API call and response.
                               Logger.debug("_handleSendToAppsScriptClick: Simulated Apps Script response received:", simulatedResponse);

                               // --- Process Simulated Apps Script Response ---
                               // If the Promise resolved successfully, `simulatedResponse` should contain the data returned by the simulated Apps Script (e.g., a JSON object with a status).
                               // Check the content of the simulated response to determine success or failure from the script's logic.
                               // Assume a typical Apps Script Web App might return a JSON object like `{ result: 'success', message: '...', ... }` or `{ result: 'error', message: '...' }`.
                               if (simulatedResponse && typeof simulatedResponse === 'object' && simulatedResponse.result === 'success') {
                                   // If the simulated call was successful according to its response format:
                                   const successMessage = AppConfig.MESSAGES.APPS_SCRIPT_SEND_SUCCESS; // Get the standard success message string.
                                   Logger.info(`_handleSendToAppsScriptClick: ${successMessage}. Simulated response indicated success.`);

                                   // Update the main UI message area with a temporary success message.
                                   this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                   // Track a GA success event for the "Send to Apps Script" operation.
                                    this.#gaTracker.trackEvent('apps_script_send_success', { form_id: this.id, step: 'success' }); // GA Success Event.
                                    // Optional: Log or report more details about the simulated success from the response.
                                   if (simulatedResponse.message) Logger.info(`_handleSend to Apps Script Click: Simulated script message: ${simulatedResponse.message}`);
                                   if (simulatedResponse.data && simulatedResponse.data.spreadsheetRow) {
                                        Logger.info(`_handleSend to Apps Script Click: Simulated Data written to spreadsheet row: ${simulatedResponse.data.spreadsheetRow}.`);
                                   }


                                } else {
                                    // --- Handle Simulated Apps Script Failure (Promise Resolved, but Indicated Failure) ---
                                    // This case is reached if the simulated service's Promise resolved, but the resolved value itself indicates a failure (e.g., the simulated service returned an object like `{ success: false, message: '...' }`).
                                    // This is a common pattern for backend APIs or services to return structured error responses for known failures.
                                    // Get a detailed error message from the simulated response object or use a fallback string.
                                   const errorDetail = simulatedResponse ? (simulatedResponse.message || simulatedResponse.error || JSON.stringify(simulatedResponse)) : "Unknown failure response structure from simulated service.";
                                    const message = AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                   Logger.error(`_handleSend to Apps Script Click: Simulated Apps Script call returned failure status in response. Message: "${message}".`, { simulatedResponse: simulatedResponse, dataSent: dataPayloadToSend });
                                   // Update the main UI message area with a persistent error message.
                                   this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                   // Track a GA error event with details.
                                   this.#gaTracker.trackEvent('apps_script_send_failed', { form_id: this.id, step: 'simulated_api_returned_failure', details: errorDetail }); // GA Error Event.
                               } // End of simulated response processing.


                            } catch (apiError) {
                                // --- Handle Simulated Apps Script Failure (Promise Rejection) ---
                                // Catch any errors thrown (Promise rejections) by the simulated Apps Script service's `runScriptFunction` method.
                                // This catch block handles simulated errors such as:
                                // - Network issues when calling the backend endpoint (`fetch` errors).
                                // - HTTP errors (4xx, 5xx) from the backend endpoint (`fetch` `!response.ok` throws).
                                // - JSON parsing errors of the backend response (`fetch` `response.json()` throws) (also handled by `_fetchBackendEndpointSimulated` if used there).
                                // - Errors originating in the Apps Script itself and propagated back by the backend.
                                // - Errors specifically simulated as rejections by the `runScriptFunction` method (e.g., random failures).
                                Logger.error(`_handleSend to Apps Script Click: Error caught from simulated Google Apps Script service call for form "${this.id}":`, apiError);

                                // Report the error using the injected ErrorReporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._handleSendToAppsScriptClick - apiCall`, // Source indicating the simulated API call stage.
                                    apiError, // The error object caught from the service rejection.
                                    { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', dataSent: dataPayloadToSend }, // Context including data sent (be mindful of sensitive data logging).
                                    AppConfig.MESSAGES.APPS_SCRIPT_SEND_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                    'apps_script_send_api_exception' // GA error code for errors during API interaction.
                                );
                                // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA.
                            } // End of simulated API call try...catch.


                       } catch (handlerError) {
                           // --- Handle Critical Errors During Overall Handler Execution ---
                           // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                           // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps, input validation check fails unexpectedly, issues accessing service instance methods before calling them).
                           // Report the error using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._handleSendToAppsScriptClick`, // Source of the error.
                               handlerError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                               `Error handling "Send to Apps Script" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                               'apps_script_button_handler_exception_overall' // GA error code for overall handler exception.
                           );

                           // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                            if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                                const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                                // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`), and does NOT have the error class (`w3-pale-red`).
                                if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                    // If it's still the generic processing message and not an error, clear it.
                                    this.#messageDisplay.clearMessage();
                                    Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in main area due to handler error.`);
                                 }
                            } else { Logger.debug(`${this.name}._handleSendToAppsScriptClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                            // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                              const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                              // If it's still the persistent "Processing..." message (`AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)`) and not currently displaying an error (`w3-pale-red`)...
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.APPS_SCRIPT_SEND_PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // Clear the persistent message.
                                  this.#messageDisplay.clearMessage();
                                 Logger.debug(`${this.name}._handleSendToAppsScriptClick: Cleared persistent message in finally.`);
                              }
                          } // Check if MessageDisplay exists.
                          Logger.debug("_handleSendToAppsScriptClick async method execution completed.");
                       } // End of _handleSendToAppsScriptClick try...catch...finally block.
                   } // End of _handleSendToAppsScriptClick method definition.


                   /**
                    * Asynchronous handler for the "Simulated Google Pay" button click. Marked as `async`.
                    * This method is triggered when the user clicks the button element identified by `#googlePayButton`.
                    * It orchestrates the simulated Google Pay payment flow using the stored search details (`_lastCollectedParams`).
                    * This involves checking service readiness, creating the simulated `PaymentDataRequest` object based on search/price data,
                    * calling the simulated Google Pay service (`loadPaymentData`) which mimics opening the payment UI and getting a payment token,
                    * and handling the simulated success or failure response from that simulated flow.
                    * Displays UI messages to the user and tracks Google Analytics events throughout the process.
                    * @param {Event} event - The native DOM 'click' event object.
                    */
                   async _handleGooglePayClick(event) {
                       try {
                           Logger.info(`${this.name}._handleGooglePayClick: "Simulated Google Pay" button clicked.`);
                            // Prevent default behavior of the button (if any) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                           // Track a Google Analytics event indicating the "Simulated Google Pay" button was clicked.
                           this.#gaTracker.trackEvent('button_click', { button_id: 'simulated_google_pay', form_id: this.id }); // GA Event.

                           // --- Check Dependencies and State ---
                           // Ensure the simulated Google Pay service instance (`this.#googlePayService`) is initialized and available.
                           if (!this.#googlePayService) {
                               const errorMsg = AppConfig.MESSAGES.FATAL_ERROR + ' Simulated Google Pay service not available. Cannot initiate payment.'; // Critical error message.
                               // Report this critical infrastructure error via the ErrorReporter.
                               this.#errorReporter.reportError(
                                   `${this.name}._handleGooglePayClick`, new Error(errorMsg),
                                   { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'google_pay_service_missing_critical', 0 // GA error code and persistent message.
                               );
                               // The button state (_updateGoogleServiceButtonState) should reflect service missing (disabled).
                               return; // Exit the async handler if service is missing.
                           }

                           // Ensure the Google Pay service is ready (meaning it passed its simulated `isReadyToPay` check) and its configuration is valid.
                           // The button should already be disabled if not ready (managed by `_updateGoogleServiceButtonState`), but check defensively.
                           if (!this.#googlePayService.isReady()) {
                               const message = AppConfig.MESSAGES.GOOGLE_PAY_UNAVAILABLE; // Standard unavailable message.
                               Logger.warn(`${this.name}._handleGooglePayClick: Google Pay service reported as not ready. Cannot proceed with action. Message: "${message}".`);
                                // Track the reason for failure (not ready).
                               this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'service_reported_not_ready' }); // GA Failure Reason.
                               this.#messageDisplay.showMessage(message, 'warning', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show warning message temporarily.
                               // Do not re-throw. Exit handler.
                               return; // Exit the async handler if GPay service is not ready.
                           }

                           // Ensure valid search parameters are available (`_lastCollectedParams` is not null).
                           // These parameters are essential for constructing the transaction details for the payment request payload.
                           // `_lastCollectedParams` is set after a successful form validation and parameter collection during the main search process.
                           if (!this._lastCollectedParams) {
                               const message = AppConfig.MESSAGES.NO_SEARCH_DATA_FOR_ACTION; // Message indicating a search is required.
                               Logger.warn(`${this.name}._handleGooglePayClick: No search data available in _lastCollectedParams. Cannot create payment request. Message: "${message}".`);
                               this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                // Track the reason for failure.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'no_search_data_for_transaction' }); // GA Failure Reason.
                               return; // Exit the async handler as essential data is missing.
                           }

                            // Note: For a real hotel booking integration using Google Pay for the final purchase, you would need
                            // the *actual, final* price of the selected hotel room obtained from your backend/Expedia API *after* the user has made a specific selection based on initial search results.
                            // This demo SIMULATES obtaining this price. Ensure the simulated price is actually available in `_lastCollectedParams` or retrieved separately here before creating the payment request.
                            // For the simulation, we'll use the simulated price that was added to `_lastCollectedParams` during the search process (`_fetchSimulatedExpediaPrice`).
                            // Check if the `simulatedPrice` property exists on `_lastCollectedParams` and has a number `price` and string `currency`.
                             if (!this._lastCollectedParams.simulatedPrice || typeof this._lastCollectedParams.simulatedPrice.price !== 'number' || typeof this._lastCollectedParams.simulatedPrice.currency !== 'string') {
                                 const message = AppConfig.MESSAGES.EXPEDIA_PRICE_MISSING_FOR_GPAY; // Message indicating that price data is needed for payment.
                                 Logger.warn(`${this.name}._handleGooglePayClick: Simulated Expedia price is missing or invalid in _lastCollectedParams. Cannot create payment request. Message: "${message}".`, { simulatedPriceData: this._lastCollectedParams.simulatedPrice });
                                this.#messageDisplay.showMessage(message, 'warning', 8000); // Show warning message temporarily.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'simulated_price_missing_for_transaction' }); // GA Failure Reason.
                                 return; // Exit the async handler if price data is missing/invalid.
                            }
                            Logger.debug(`_handleGooglePayClick: Simulated Expedia price available: ${this._lastCollectedParams.simulatedPrice.price} ${this._lastCollectedParams.simulatedPrice.currency}. Proceeding.`);


                           // --- Create Simulated Transaction Details ---
                           // Create a transaction details object (total price, currency, display items, etc.) based on the collected search parameters and the simulated price.
                           // Use a protected helper method (`_createSimulatedTransactionDetails`) from the `GooglePayServiceWrapper` instance (`this.#googlePayService`).
                           // This helper accesses the GPay configuration and performs calculations based on search parameters to format the `transactionInfo` part of the `PaymentDataRequest`.
                           Logger.debug("_handleGooglePayClick: Creating simulated transaction details object for Google Pay request...");
                           let transactionDetailsObject = null; // Variable to hold the transaction details object.
                           try {
                              // Call the helper method, passing the stored search parameters.
                              transactionDetailsObject = this.#googlePayService._createSimulatedTransactionDetails(this._lastCollectedParams); // Pass stored params.

                              // Check if transaction details were created successfully by the helper method. It returns null for invalid input or throws errors.
                             if (!transactionDetailsObject) {
                                  const message = AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Failed to create transaction details for payment request.'); // Generic error message template.
                                 Logger.error(`_handleGooglePayClick: Failed to create transaction details object. Message: "${message}".`, { paramsUsed: this._lastCollectedParams, step: 'create_transaction_details' });
                                  // Since the helper throws for critical issues, this catch block might indicate an issue returning null. Throw here to be caught below.
                                 throw new Error(message); // Throw an error.
                             }
                              Logger.debug("_handleGooglePayClick: Simulated transaction details object created:", transactionDetailsObject);

                            } catch (createTransactionDetailsError) {
                                 // --- Handle Errors During Transaction Details Creation ---
                                 // Catch any errors thrown *within* the `_createSimulatedTransactionDetails` helper method (e.g., errors accessing config, calculation logic errors).
                                 // The error object caught here might already contain a user-friendly message if thrown specifically in the helper.
                                 Logger.error(`_handleGooglePayClick: Error during transaction details creation process:`, createTransactionDetailsError);
                                 // Report the error using the injected ErrorReporter.
                                 this.#errorReporter.reportError(
                                     `${this.name}._handleGooglePayClick - createTransactionDetails`, // Source indicating the step.
                                     createTransactionDetailsError, // The error object caught.
                                     { component: this.#getComponentInfo(), formId: this.id, paramsInput: this._lastCollectedParams, step: 'create_transaction_details_execution' }, // Context.
                                     createTransactionDetailsError.message || AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Error creating transaction details.'), // Use the error's message or generic template.
                                     'google_pay_transaction_details_exception' // GA error code.
                                 );
                                 // Update the main message display with the error message.
                                this.#messageDisplay.showMessage(createTransactionDetailsError.message || AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Error creating transaction details.'), 'error'); // Show persistent error message.
                                 // Track reason for failure.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'create_transaction_details_failed' }); // GA Failure Reason.
                                return; // Exit async handler if transaction details creation failed.
                            } // End of create transaction details try...catch.


                           // --- Construct Simulated Payment Data Request ---
                           // Construct the main `PaymentDataRequest` object (structure based on Google Pay API)
                           // using the created `transactionDetailsObject` and the `GooglePayServiceWrapper`'s configuration (`this.#googlePayService._config`).
                           // Use a protected helper method (`_createPaymentDataRequest`) from the `GooglePayServiceWrapper` instance.
                           // Pass the constructed `transactionDetailsObject`.
                           Logger.debug(`${this.name}._handleGooglePayClick: Creating simulated PaymentDataRequest object...`);
                           let paymentDataRequestObject = null; // Variable to hold the Payment Data Request object.
                           try {
                              // Call the helper method, passing the `transactionDetailsObject`.
                              paymentDataRequestObject = this.#googlePayService._createPaymentDataRequest(transactionDetailsObject); // Pass the created details object.

                              // Check if the payment data request object was created successfully by the helper method. It returns null for invalid configuration/input.
                             if (!paymentDataRequestObject) {
                                  const message = AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Failed to create payment request object.'); // Generic error message template.
                                 Logger.error(`_handleGooglePayClick: Failed to create simulated PaymentDataRequest object. Message: "${message}".`);
                                  // Since the helper throws for critical issues, this check primarily handles a null return for known failures.
                                 throw new Error(message); // Throw an error to be caught below.
                             }
                              Logger.debug("_handleGooglePayClick: Simulated PaymentDataRequest object created:", paymentDataRequestObject);

                            } catch (createPaymentRequestError) {
                                 // --- Handle Errors During Payment Request Creation ---
                                 // Catch any errors thrown *within* the `_createPaymentDataRequest` helper method (e.g., errors accessing config, invalid input data structure, or if helper throws).
                                 // The error object caught here might contain a user-friendly message.
                                 Logger.error(`_handleGooglePayClick: Error during PaymentDataRequest creation process:`, createPaymentRequestError);
                                 // Report the error using the injected ErrorReporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._handleGooglePayClick - createPaymentRequest`, // Source.
                                    createPaymentRequestError, // The error object caught.
                                    { component: this.#getComponentInfo(), formId: this.id, transactionDetails: transactionDetailsObject, step: 'create_payment_request_execution' }, // Context.
                                    createPaymentRequestError.message || AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Error creating payment request.'), // Use the error's message or generic template.
                                    'google_pay_payment_request_exception' // GA error code.
                                );
                                // Update the main message display with the formatted error message.
                                this.#messageDisplay.showMessage(createPaymentRequestError.message || AppConfig.MESSAGES.FAILED('Simulated Google Pay', 'Error creating payment request.'), 'error'); // Show persistent error message.
                                 // Track reason for failure.
                                this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, reason: 'create_payment_request_failed' }); // GA Failure Reason.
                                return; // Exit async handler if PaymentDataRequest creation failed.
                            } // End of create payment request try...catch.


                           // --- Simulate Initiating Google Pay Flow ---
                           // Display a temporary UI message in the main area indicating that the Google Pay process is starting (brief message).
                           this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_CLICKED, 'info', 3000); // Show brief "Opening Google Pay..." message for 3 seconds.
                            // After the brief message duration, replace it with the persistent "Processing..." message for the duration of the async service call.
                           setTimeout(() => {
                                if (this.#messageDisplay && typeof this.#messageDisplay.showMessage === 'function') {
                                    const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                                     // Check if element exists, and its text content *still* matches the initial "CLICKED" message text AND it is NOT already displaying a persistent error.
                                     if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.GOOGLE_PAY_CLICKED('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                        // If the initial brief message is still visible and it's not an error, replace it with the persistent "Processing..." message.
                                        this.#messageDisplay.showMessage(AppConfig.MESSAGES.GOOGLE_PAY_PROCESSING, 'info', 0); // Replace with persistent "Processing..." message.
                                        Logger.debug(`${this.name}._handleGooglePayClick: Replaced brief "Clicked" message with persistent "Processing..." message.`);
                                     } else if (currentMessageElement && currentMessageElement.classList.contains('w3-pale-red')) {
                                          // If an error message was already set in the meantime (e.g., by an error caught below very quickly), don't overwrite it.
                                          Logger.debug(`${this.name}._handleGooglePayClick: Error message already displayed, not replacing with persistent processing message.`);
                                     } else {
                                         // If the initial message was already cleared or replaced by something else, do nothing.
                                        Logger.debug(`${this.name}._handleGooglePayClick: Initial "Clicked" message not found, not replacing with persistent processing message.`);
                                     }
                                } else { Logger.debug(`${this.name}._handleGooglePayClick: MessageDisplay service missing during scheduled persistent message update.`);} // Check if service exists.
                           }, 3000); // Wait for the initial brief message duration (3 seconds).


                            // Track a GA event for the start of the Google Pay process, including transaction price details as parameters.
                           this.#gaTracker.trackEvent('google_pay_process_started', { form_id: this.id, totalPrice: transactionDetailsObject.totalPrice, currency: transactionDetailsObject.currencyCode, step: 'started' }); // GA Event, include price details from transaction info.


                            Logger.debug(`${this.name}._handleGooglePayClick: Calling simulated Google Pay service loadPaymentData with request...`, paymentDataRequestObject);
                           // Call the asynchronous method (`loadPaymentData`) on the simulated Google Pay service wrapper instance (`this.#googlePayService`).
                           // In a real application using the real Google Pay API for Web (`google.payments.api.PaymentsClient`),
                           // the `loadPaymentData(paymentDataRequest)` call would:
                           // 1. Trigger the display of the Google Pay payment sheet UI (a modal popup) for the user.
                           // 2. The user interacts with the sheet (selects payment method, confirms payment, potentially provides requested contact info like email, billing address).
                           // 3. If the user confirms payment and validation passes client-side within the sheet, Google Pay tokenizes the payment method data using the configured `tokenizationSpecification`.
                           // 4. The Promise returned by `loadPaymentData` resolves with a `PaymentData` object.
                           // 5. This `PaymentData` object contains the sensitive, encrypted payment information token in `paymentMethodData.tokenizationData.token`.
                           // Use `await` to pause execution of this `async` handler until the Promise returned by the simulated service call resolves (simulated payment success) or rejects (simulated payment failure or user cancellation).
                           try {
                                // The `loadPaymentData` method on the simulated service returns a Promise. Await its resolution or rejection.
                                // It's designed to throw/reject on errors during its execution or the simulated API call.
                                const simulatedPaymentData = await this.#googlePayService.loadPaymentData(paymentDataRequestObject); // Await the simulated service call, passing the request object.
                               // Log the result received from the simulated `loadPaymentData` call.
                               Logger.debug("_handleGooglePayClick: Simulated loadPaymentData result received:", simulatedPaymentData);

                               // --- Process Simulated Payment Success ---
                               // If the Promise resolved successfully, `simulatedPaymentData` should contain the data returned by the simulated service, which mimics the `PaymentData` object from the real API.
                               // Check if the essential part of the simulated response structure is present, indicating successful tokenization (at least `paymentMethodData`).
                               if (simulatedPaymentData && typeof simulatedPaymentData === 'object' && simulatedPaymentData.paymentMethodData && simulatedPaymentData.paymentMethodData.tokenizationData && simulatedPaymentData.paymentMethodData.tokenizationData.token) {
                                   // If the simulated payment flow was successful and returned expected simulated payment data/token:
                                   Logger.info("_handleGooglePayClick: Simulated Google Pay process successful. Simulated payment data token received.");

                                   // --- Real Payment Processing Step (Requires Backend) ---
                                   // THIS IS THE MOST CRITICAL STEP REQUIRING A SECURE BACKEND SERVER IN A REAL APPLICATION.
                                   // The object `simulatedPaymentData` (if from the real Google Pay API) would contain the encrypted payment information token in `paymentMethodData.tokenizationData.token`.
                                   // This token represents the user's payment method, encrypted by Google. It's sensitive.
                                   // **YOU MUST IMMEDIATELY SEND THIS TOKEN** (`simulatedPaymentData.paymentMethodData.tokenizationData.token`)
                                   // **TO YOUR SECURE BACKEND SERVER** for processing with your chosen Payment Gateway (e.g., Stripe, Square, Adyen, Authorize.Net, etc.).
                                   // YOUR SECURE BACKEND receives the token from the client (via HTTPS POST), uses YOUR Payment Gateway's securely stored API keys/credentials (which are NEVER client-side!) to initiate and complete the charge transaction using the received token.
                                   // YOUR BACKEND then handles the response from the payment gateway (success/failure) and informs the client application about the final booking status.
                                   // NEVER ATTEMPT TO DECRYPT THE TOKEN OR CALL PAYMENT GATEWAY PROCESSING APIs DIRECTLY FROM CLIENT-SIDE JAVASCRIPT. This is a major security vulnerability.
                                   // THIS SIMULATION STOPS HERE. In a real application, you would add code here to make an `await fetch(...)` or `await $.ajax(...)` call to your backend payment processing endpoint, passing the token and transaction details.
                                   // The UI updates and success/failure handling would then depend on the response from THAT backend call.
                                   // -----------------------------------------------------------------------------


                                   // In this simulation, since we skip the backend processing, we immediately treat client-side simulated `loadPaymentData` success as overall success for UI purposes.
                                   const successMessage = AppConfig.MESSAGES.GOOGLE_PAY_SUCCESS; // Get the standard success message string.
                                   Logger.info(`_handleGooglePayClick: ${successMessage}. Simulated token obtained (truncated example): "${simulatedPaymentData.paymentMethodData.tokenizationData.token?.substring(0, 50) + '...' || 'N/A'}".`); // Log success and a truncated token example for illustration.

                                   // Update the main UI message area with a temporary success message for the payment.
                                   this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                   // Track a GA success event for the Google Pay operation. Include relevant parameters like price details.
                                   this.#gaTracker.trackEvent('google_pay_success', { form_id: this.id, totalPrice: transactionDetailsObject.totalPrice, currency: transactionDetailsObject.currencyCode, step: 'success_simulated_token_received' }); // GA Success Event, include price details from transaction info.

                                   // Optional: In a real application, after receiving confirmation from your backend that the payment was processed successfully by the payment gateway, you would perform final actions like:
                                   // 1. Clearing any payment-related client-side state or UI.
                                   // 2. Redirecting the user to an order confirmation page provided by your application (not Expedia at this stage).
                                   // 3. Displaying final booking details or a confirmation ID from the backend response.
                                   // This might involve another async call to your backend to confirm the final booking status after payment.

                               } else {
                                    // --- Handle Simulated Payment Failure (Promise Resolved, but Indicated Failure) ---
                                    // This case is reached if the simulated service's Promise resolved successfully, but the resolved value itself indicates a failure (e.g., the simulated service returned an object like `{ success: false, message: '...' }` or the structure is unexpected).
                                    // This mimics scenarios where the Google Pay API might return a response indicating failure within the sheet before final tokenization, or if your simulation logic had an error resolving the Promise with the correct structure.
                                    // This is less likely if the simulated service is designed to *reject* the Promise on typical API/processing failure, but include defensively.
                                    const errorDetail = simulatedPaymentData ? (simulatedPaymentData.message || simulatedPaymentData.error || JSON.stringify(simulatedPaymentData)) : "Unknown failure response structure from simulated service.";
                                    const message = AppConfig.MESSAGES.GOOGLE_PAY_FAILED(errorDetail); // Use the standard failed message template, including the extracted detail.
                                    Logger.error(`_handleGooglePayClick: Simulated Google Pay loadPaymentData resolved without expected success data. Message: "${message}".`, { simulatedResponse: simulatedResponse, request: paymentDataRequestObject });
                                    // Update the main UI message area with a persistent error message.
                                    this.#messageDisplay.showMessage(message, 'error'); // Show persistent error message to the user (duration 0).
                                    // Track a GA error event with details.
                                    this.#gaTracker.trackEvent('google_pay_failed', { form_id: this.id, step: 'simulated_api_resolved_invalid_response', details: errorDetail }); // GA Error Event.
                               } // End of simulated response processing.


                           } catch (apiError) {
                               // --- Handle Simulated Payment Failure (Promise Rejection) ---
                               // This catch block handles any errors thrown (Promise rejections) by the simulated Google Pay service's `loadPaymentData` method.
                               // This could simulate errors such as:
                               // - User cancelling the payment sheet UI (`loadPaymentData` Promise rejection).
                               // - Network issues during the simulated API call or processing delay.
                               // - Errors specific to the Google Pay API client-side library or its interaction with Google servers.
                               // - Errors specifically simulated as rejections by the `loadPaymentData` method (e.g., random processing failures).
                               Logger.error(`_handleGooglePayClick: Error caught from simulated Google Pay service loadPaymentData call for form "${this.id}":`, apiError);

                               // Check if the error indicates user cancellation specifically (if the simulated service adds a custom flag like `isCancelled` or includes a specific cancellation message in the error message).
                               const isUserCancelled = apiError instanceof Error && apiError.isCancelled === true || (typeof apiError?.message === 'string' && apiError.message.includes(AppConfig.MESSAGES.GOOGLE_PAY_CANCELLED('', false))); // Check custom flag or message text from config.

                               if (isUserCancelled) {
                                   // Handle user cancellation of the payment process specifically. This is typically a less critical event from an application perspective than a technical processing error.
                                   const message = AppConfig.MESSAGES.GOOGLE_PAY_CANCELLED; // Get the standard cancellation message.
                                   Logger.warn(`_handleGooglePayClick: ${message}`);
                                   this.#messageDisplay.showMessage(message, 'warning', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show cancellation message temporarily.
                                   this.#gaTracker.trackEvent('google_pay_cancelled', { form_id: this.id, step: 'cancelled_by_user' }); // GA Cancellation Event.

                               } else {
                                    // Handle other types of simulated payment failures (processing errors, API errors, network issues).
                                    // These indicate a problem preventing the payment from completing.
                                    // Report the error using the injected ErrorReporter.
                                   this.#errorReporter.reportError(
                                       `${this.name}._handleGooglePayClick - apiCall`, // Source indicating the simulated API call stage.
                                       apiError, // The error object caught from the service rejection.
                                       { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', requestDetails: paymentDataRequestObject }, // Context.
                                       AppConfig.MESSAGES.GOOGLE_PAY_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                       'google_pay_api_exception' // GA error code for non-cancellation errors during API interaction.
                                   );
                                   // The ErrorReporter handles displaying the persistent error message in the main UI and tracking in GA via the general 'app_error' event.
                               } // End if/else for user cancellation vs other failure.


                           } // End of simulated API call try...catch.


                       } catch (handlerError) {
                           // --- Handle Critical Errors During Overall Handler Execution ---
                           // This outer catch block acts as a final safety net. It catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                           // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps before calling `loadPaymentData`, issues accessing service instance methods before validity checks if checks are buggy, errors in the overall try...catch structure).
                           // Report the error using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._handleGooglePayClick`, // Source of the error.
                               handlerError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                               `Error handling "Simulated Google Pay" button click for form "${this.name}". Operation interrupted.`, // User-facing message template for handler failure.
                               'google_pay_button_handler_exception_overall' // GA error code for overall handler exception.
                           );

                           // Ensure the persistent "Processing..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                            if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                                const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                                // Check if element exists, contains text related to PROCESSING, and does NOT have the error class ('w3-pale-red').
                                // Use includes for flexibility with different PROCESSING templates.
                                if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                    // If it's still the generic processing message and not an error, clear it.
                                    this.#messageDisplay.clearMessage();
                                    Logger.debug(`${this.name}._handleGooglePayClick: Cleared persistent message in main area due to handler error.`);
                                 } else if (currentMessageElement && currentMessageElement.classList.contains('w3-pale-red')) {
                                     // If an error message was already set in the meantime, do nothing, leave it.
                                    Logger.debug(`${this.name}._handleGooglePayClick: Error message already displayed, not clearing/replacing processing message.`);
                                }
                            } else { Logger.debug(`${this.name}._handleGooglePayClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                            // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensures any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                              const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                              // If it's still displaying text related to PROCESSING and is NOT displaying an error (`w3-pale-red`)...
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // Clear the persistent message.
                                  this.#messageDisplay.clearMessage();
                                 Logger.debug(`${this.name}._handleGooglePayClick: Cleared persistent message in finally.`);
                              } else if (currentMessageElement && currentMessageElement.classList.contains('w3-pale-red')) {
                                  // If it's displaying an error message, leave it.
                                  Logger.debug(`${this.name}._handleGooglePayClick: Error message displayed, not clearing persistent message in finally.`);
                              }
                           } // Check if MessageDisplay exists.
                           Logger.debug("_handleGooglePayClick async method execution completed.");
                       } // End of _handleGooglePayClick try...catch...finally block.
                   } // End of _handleGooglePayClick method definition.


                   /**
                    * Asynchronous method to fetch a simulated Expedia hotel price for the given search parameters. Marked async.
                    * This simulates making an API call (via a backend endpoint) to get pricing information based on the search criteria.
                    * In a real application, this would involve calling *your secure backend* which would then call the Expedia Partner API using secure credentials.
                    * This method updates the dedicated simulated price display element in the UI (`#expediaSimulatedPriceElement`) with the simulated result or an error message.
                    * It is typically called during the main search process (`searchHotels`) or potentially when populating from history (if history includes price).
                    * @param {object} searchParams - The collected search parameters for which to fetch a simulated price. Expected keys include `destinationInput`, `checkInDateInput`, `checkOutDateInput`, `adultsCountInput`, `childrenCountInput`. Required for simulation calculation and context.
                    * @returns {Promise<{price: number, currency: string}|null>} A Promise resolving with a plain object containing the simulated price (as a number) and currency string (`{ price: number, currency: string }`) if the simulated fetch succeeds and generates valid data. Returns `null` if the simulated fetch failed, required parameters were insufficient, or if a critical error occurred during the setup/execution *before* the simulated backend call. The UI element for price is updated directly regardless of the return value (on success, failure, or error).
                    * @private
                    */
                   async _fetchSimulatedExpediaPrice(searchParams) {
                       try {
                            Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Starting simulated Expedia price fetch process...`, { searchParams: searchParams });

                           // --- Show Loading State for Price Display ---
                            // Update the dedicated UI element for the simulated price to show a loading indicator.
                            if (this.#expediaSimulatedPriceElement) { // Check if the element exists.
                                 // Clear previous price.
                                this.#expediaSimulatedPriceElement.textContent = '';
                                 // Set loading text and add a spinner icon using innerHTML.
                                this.#expediaSimulatedPriceElement.innerHTML = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_INIT(searchParams?.destinationInput || '...') + ` <i class="fa fa-spinner w3-spin"></i>`; // Use init message template with destination hint.
                                Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: UI updated to show loading state for price.`);
                            } else {
                                // If the element is null, log a warning that price won't be displayed.
                                Logger.warn(`${this.name}._fetchSimulatedExpediaPrice: Simulated price display element (${AppConfig.SELECTORS.EXPEDIA_SIMULATED_PRICE_DISPLAY}) is null. Price won't be displayed.`);
                                // ErrorReporter already logged UI missing error in constructor.
                            }


                           // --- Validate Input Parameters for Price Fetch ---
                           // Ensure the essential parameters required for calculating or simulating a price (destination, check-in/out dates, adults count) are present in the provided `searchParams` object and appear valid (non-null, expected types).
                           // This check should be robust; issues here prevent a meaningful price simulation or a real backend call.
                            if (!searchParams || typeof searchParams !== 'object' || !searchParams.checkInDateInput || typeof searchParams.checkInDateInput !== 'string' || searchParams.checkInDateInput.trim() === '' ||
                                !searchParams.checkOutDateInput || typeof searchParams.checkOutDateInput !== 'string' || searchParams.checkOutDateInput.trim() === '' ||
                                !searchParams.adultsCountInput || (typeof searchParams.adultsCountInput !== 'number' && typeof searchParams.adultsCountInput !== 'string') || String(searchParams.adultsCountInput).trim() === '' || parseInt(String(searchParams.adultsCountInput).trim(), 10) < 1 ||
                                !searchParams.destinationInput || typeof searchParams.destinationInput !== 'string' || searchParams.destinationInput.trim() === '') {
                                const errorMsg = 'Missing or invalid required parameters for simulated price fetch (destination, dates, adults count).';
                                Logger.warn(`${this.name}._fetchSimulatedExpediaPrice: ${errorMsg}`, { searchParams: searchParams });
                                // Report this failure using the injected ErrorReporter.
                                this.#errorReporter.reportError(
                                    `${this.name}._fetchSimulatedExpediaPrice`, new Error(errorMsg), // Source and error object.
                                    { formId: this.id, params: searchParams, step: 'param_validation_for_fetch' }, // Context.
                                    `Failed to fetch simulated price: Missing required search details.`, // User message template.
                                    'expedia_price_fetch_missing_params' // GA error code.
                                );
                                 // Update the simulated price display UI element to show a specific error message for missing data.
                                 if (this.#expediaSimulatedPriceElement) { // Check if element exists.
                                      this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Missing data.');
                                      // Remove spinner.
                                     const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                 }
                                 // Return null to indicate that fetching the price failed due to bad input data.
                                return null; // Exit async method.
                            }
                            // Log successful input parameter validation.
                            Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Input parameters validated successfully for price fetch.`);


                           // --- Simulate Calling Backend Endpoint for Price ---
                           // In a real application, you would replace the simulation below with an actual asynchronous HTTP request (`fetch` or `jQuery.ajax`)
                           // to your own backend endpoint (defined by `AppConfig.BACKEND_ENDPOINTS.EXPEDIA_SEARCH_API_GATEWAY` or a dedicated price endpoint).
                           // Your backend would receive the `searchParams`, securely call the real Expedia Partner API using server-side credentials,
                           // get the real price data for the relevant hotels based on the search criteria, and return the price data to the client.

                           /* Example structure of a REAL fetch to a backend endpoint for price (COMMENTED OUT):
                           // const backendPriceApiUrl = AppConfig.BACKEND_ENDPOINTS.EXPEDIA_SEARCH_API_GATEWAY; // Use the search gateway endpoint.
                           // // Or if there's a dedicated price endpoint: const backendPriceApiUrl = AppConfig.BACKEND_ENDPOINTS.EXPEDIA_PRICE_API;
                           //
                           // // Check if the backend endpoint URL is configured and not still a placeholder.
                           // if (!backendPriceApiUrl || typeof backendPriceApiUrl !== 'string' || backendPriceApiUrl.includes('_PLACEHOLDER')) {
                           //     const configErrorMsg = `Backend Expedia Price/Search API URL is missing or placeholder in AppConfig. Cannot perform real price fetch.`;
                           //     Logger.error(`${this.name}._fetchSimulatedExpediaPrice: ${configErrorMsg}`);
                           //     // Update the UI element to show a configuration error message.
                           //      if (this.#expediaSimulatedPriceElement) {
                           //           this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Endpoint not configured.');
                           //            const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                           //      }
                           //      // Throw a critical error to signal that the core task is impossible due to configuration.
                           //      // The calling method (`searchHotels`) will catch this setup error and handle it.
                           //     throw new Error(configErrorMsg);
                           // }
                           // Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Making REAL fetch call to backend endpoint "${backendPriceApiUrl}" for price...`, { searchParams: searchParams });
                           //
                           // try {
                           //     // Use the standard `fetch` API for making asynchronous HTTP requests.
                           //      const response = await fetch(backendPriceApiUrl, {
                           //          method: 'POST', // Use POST method to send search parameters in the request body securely.
                           //          headers: {
                           //              'Content-Type': 'application/json', // Indicate sending JSON data in the body.
                           //              // Add any required custom headers for authentication/authorization with YOUR backend gateway if needed.
                           //              // THIS IS *NOT* WHERE EXPEDIA API KEYS OR OTHER SENSITIVE SECRETS GO CLIENT-SIDE! Those live on the backend.
                           //          },
                           //          body: JSON.stringify(searchParams), // Convert the search parameters object to a JSON string for the request body.
                           //      });
                           //
                           //      // Check if the HTTP response status is successful (typically 2xx range).
                           //      if (!response.ok) {
                           //           // If the backend responded with an HTTP error status code (e.g., 400 Bad Request, 401 Unauthorized, 500 Internal Server Error).
                           //          // Read the response body as text to get potential error details from the backend. Truncate for logging safety.
                           //           const errorBodyText = await response.text();
                           //           const truncatedErrorBody = errorBodyText?.substring(0, 200) || 'No error body.'; // Get truncated error body.
                           //          const httpError = new Error(`Backend HTTP error during Expedia price fetch: ${response.status} - ${response.statusText || 'Unknown Status'}`); // Create a new Error object.
                           //          Logger.error(`${this.name}._fetchSimulatedExpediaPrice: Backend fetch failed with HTTP status ${response.status}.`, { error: httpError, responseStatus: response.status, responseTextSnippet: truncatedErrorBody, backendEndpoint: backendEndpointUrl });
                           //
                           //           // Update the UI element to show HTTP fetch failure.
                           //          if (this.#expediaSimulatedPriceElement) {
                           //               this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED(`HTTP ${response.status}`);
                           //                const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                           //           }
                           //
                           //          // Throw the HTTP error to be caught by the caller's (`searchHotels`) `catch (fetchError)` block.
                           //           // This error will be reported centrally by the ErrorReporter in `searchHotels`.
                           //          throw httpError; // Re-throw the error.
                           //      }
                           //
                           //      // Attempt to parse the JSON response data received from the backend.
                           //      // Wrap JSON parsing in a try...catch as it can fail if the backend returns non-JSON content or malformed JSON.
                           //      let responseData;
                           //      try {
                           //          responseData = await response.json(); // Parse the JSON response body into a JavaScript object.
                           //           Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Backend response received and parsed as JSON:`, responseData);
                           //      } catch (jsonParseError) {
                           //          // If JSON parsing fails (e.g., backend returned plain text, HTML, or invalid JSON).
                           //         const invalidJsonError = new Error(`Failed to parse JSON response from backend for Expedia price.`); // Create a specific error object.
                           //          Logger.error(`${this.name}._fetchSimulatedExpediaPrice: Invalid JSON response received from backend endpoint "${backendEndpointUrl}".`, { error: invalidJsonError, responseStatus: response.status, responseTextSnippet: await response.text().then(t=>t.substring(0, 200)) /* Try re-reading body as text for context */ }); // Log parsing error with response context.
                           //          // Update UI to show JSON parsing failure.
                           //          if (this.#expediaSimulatedPriceElement) {
                           //               this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Invalid JSON response.');
                           //                const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                           //          }
                           //          // Throw error indicating invalid response format to be caught by caller.
                           //          throw invalidJsonError;
                           //      }
                           //
                           //      // Validate the structure and content of the response data received from your backend gateway.
                           //      // This structure depends entirely on what YOUR backend implementation returns after calling the Expedia API.
                           //      // Add validation logic based on the expected structure for successful price data (e.g., expecting a 'price' property that is a number, a 'currency' string).
                           //      if (!responseData || typeof responseData !== 'object' || typeof responseData.price !== 'number' || typeof responseData.currency !== 'string') {
                           //           const invalidStructureError = new Error(`Invalid price data structure received from backend for Expedia price.`); // Specific error.
                           //          Logger.error(`${this.name}._fetchSimulatedExpediaPrice: Invalid response data structure received from backend.`, { responseData: responseData });
                           //           // Update UI to show invalid data format error.
                           //          if (this.#expediaSimulatedPriceElement) {
                           //               this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Invalid data format.');
                           //                const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                           //           }
                           //          // Throw specific error for bad structure to be caught by caller.
                           //           throw invalidStructureError;
                           //      }
                           //
                           //      // --- Process and Return Successful Real Data ---
                           //      // If response was successful, JSON parsed, and structure validated, process and return the data.
                           //      // Update the dedicated UI element to display the *real* price fetched. Format the price string.
                           //      if (this.#expediaSimulatedPriceElement) {
                           //           this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_SUCCESS(parseFloat(responseData.price).toFixed(2), responseData.currency); // Format for display.
                           //            const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                           //      }
                           //      Logger.info(`${this.name}._fetchSimulatedExpediaPrice: REAL fetch succeeded. Price: ${responseData.price} ${responseData.currency}.`);
                           //      // Return the successfully fetched and validated price data object.
                           //      return { price: responseData.price, currency: responseData.currency }; // Return the price object with number price.
                           //
                           // } catch (fetchOrProcessError) {
                           //      // --- Handle Any Errors During Real Fetch or Response Processing ---
                           //      // Catch any errors thrown during the fetch attempt itself (e.g., network error, CORS issues),
                           //      // or errors during response processing (HTTP errors caught by !response.ok throw, JSON parse errors thrown, response data validation throws).
                           //      Logger.error(`${this.name}._fetchSimulatedExpediaPrice: Error caught during REAL fetch or response processing:`, fetchOrProcessError);
                           //      // Re-throw the error to be caught by the caller's (`searchHotels`) `catch` block.
                           //       // The caller handles reporting this error centrally via ErrorReporter.
                           //      throw fetchOrProcessError; // Propagate the error.
                           // }
                           */


                           // --- Simulation Implementation (Current Code) ---
                           // If NOT using the real fetch structure above (because this is a simulation), execute the client-side simulation logic.
                           Logger.debug(`SimulatedExpediaPrice: Executing client-side simulation of price fetch...`);

                           // Calculate a simulated number of nights based on the date parameters provided.
                           // This calculation is for generating a plausible price for the simulation.
                           let simulatedNumNights = 1; // Default to 1 night simulation.
                           try {
                                // Attempt to create `Date` objects from the check-in and check-out date strings provided in the `searchParams` object.
                               const checkInDateStr = searchParams.checkInDateInput;
                               const checkOutDateStr = searchParams.checkOutDateInput;

                                // Check if both date strings are valid and can be parsed into valid `Date` objects for calculation.
                                // `new Date('YYYY-MM-DD')` in many environments (but not all) parses as UTC midnight. Comparison should be reliable.
                                // More robust date validation should ideally happen earlier (InputComponent, form validation).
                                const checkInDateObj = new Date(checkInDateStr);
                                const checkOutDateObj = new Date(checkOutDateStr);

                               if (!isNaN(checkInDateObj.getTime()) && !isNaN(checkOutDateObj.getTime())) { // Check if both parsed to valid Date objects.
                                    const timeDifference = checkOutDateObj.getTime() - checkInDateObj.getTime(); // Difference in milliseconds.
                                    const millisecondsPerDay = 24 * 60 * 60 * 1000; // Milliseconds in one day.

                                    // If check-out date is on or after check-in date (timeDifference >= 0), calculate the number of nights.
                                    // Round the result of the division to handle potential Daylight Saving Time shifts that might make the time difference not exactly a multiple of a day.
                                     if (timeDifference >= 0) {
                                        const calculatedNights = Math.round(timeDifference / millisecondsPerDay);
                                        simulatedNumNights = Math.max(1, calculatedNights); // Ensure a minimum of 1 night stay simulation, even if dates are same day (diffDays = 0).
                                       Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Simulated nights calculated as ${simulatedNumNights}.`);
                                   } else {
                                       // Negative difference implies checkout is before checkin (should be caught by validation, but defensively). Assume 1 night for simulation.
                                        simulatedNumNights = 1;
                                        Logger.warn(`${this.name}._fetchSimulatedExpediaPrice: Calculated negative time difference (${timeDifference} ms) for simulation calc, assuming 1 night.`);
                                   }
                               } else {
                                   // If date strings could not be parsed into valid Date objects, assume 1 night for simulation.
                                   Logger.warn(`${this.name}._fetchSimulatedExpediaPrice: Invalid date strings/objects for number of nights calculation in simulation, assuming 1 night. Check dates: "${checkInDateStr}", "${checkOutDateStr}".`);
                                   simulatedNumNights = 1;
                               }
                            } catch (dateCalcError) {
                                 // Catch any errors during date calculations for simulation (e.g., unexpected input format causing parse issues despite checks).
                                Logger.error(`${this.name}._fetchSimulatedExpediaPrice: Error calculating number of nights for simulation:`, dateCalcError, { searchParams: searchParams });
                                simulatedNumNights = 1; // Default to 1 night on error.
                                 // Report this calculation error using the injected reporter (can include context but ErrorReporter is robust).
                                 // The reporter will also log the error. No need to throw here.
                                 this.#errorReporter.reportError(
                                     `${this.name}._fetchSimulatedExpediaPrice`, dateCalcError, // Source and error.
                                     { formId: this.id, checkInString: searchParams.checkInDateInput, checkOutString: searchParams.checkOutDateInput, step: 'nights_calculation_simulation_exception' }, // Context.
                                     `Error calculating number of nights for simulated price.`, 'expedia_price_sim_nights_exception' // GA error code.
                                 );
                            } // End of nights calculation try...catch.


                            // Define a base price per night for the simulation. Make it slightly dynamic based on a random range for realism.
                            const simulatedBasePricePerNight = 150 + Math.random() * 100; // Simulate price between 150.00 and 250.00 per night.
                             // Calculate the simulated total price for the stay by multiplying base price by number of nights. Format to 2 decimal places.
                            const simulatedTotalPrice = (simulatedBasePricePerNight * simulatedNumNights).toFixed(2); // Total price simulation (string).
                            const simulatedCurrencyCode = 'USD'; // Use a fixed currency code for simulation (e.g., USD).


                            // Simulate the asynchronous delay for the API call and potential backend processing time using a Promise and `setTimeout`.
                            return new Promise((resolve, reject) => {
                                setTimeout(() => {
                                    try {
                                         // --- Simulate Success or Failure ---
                                         // Introduce randomness to simulate API call success or failure for error handling testing scenarios.
                                         // Use a configured rate for simulated service calls or a specific one for this API (e.g., 10% chance of simulated failure).
                                         const simulateSuccess = Math.random() > 0.1; // Example: 90% chance of success, 10% chance of simulated failure. Adjust rate as needed for testing.

                                         if (simulateSuccess) {
                                             // If simulating success, log the successful simulated fetch and resolve the Promise.
                                             Logger.info(`${this.name}._fetchSimulatedExpediaPrice: Simulated fetch successful for "${searchParams.destinationInput}". Simulated Price: ${simulatedTotalPrice} ${simulatedCurrencyCode}.`);

                                              // Update the dedicated UI element (`#expediaSimulatedPriceElement`) to display the simulated price result.
                                              if (this.#expediaSimulatedPriceElement) { // Check if the element exists.
                                                   // Set the text content using the price fetch success message template and the calculated simulated price/currency.
                                                   this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_SUCCESS(simulatedTotalPrice, simulatedCurrencyCode);
                                                  // Remove spinner if it was added to the element.
                                                   const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                              } else { Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Simulated price display element is null, skipping UI update.`);} // Check if element exists.

                                              // Resolve the promise with the simulated price data object.
                                              // The price property should be a number for calculation purposes (e.g., Google Pay).
                                              resolve({ price: parseFloat(simulatedTotalPrice), currency: simulatedCurrencyCode }); // Return the price object with number price.

                                           } else {
                                               // --- Simulate Failure ---
                                               // If simulating failure, log a warning and reject the Promise with a simulated error.
                                               Logger.warn(`${this.name}._fetchSimulatedExpediaPrice: Simulated fetch failed randomly for "${searchParams.destinationInput}".`);
                                                // Simulate different possible API or network error messages.
                                              const simulatedFailureMessages = [
                                                   'Simulated Expedia API call timed out.', // Simulated network timeout.
                                                   'Simulated backend gateway processing error.', // Error occurred on your backend gateway.
                                                   'Simulated invalid search criteria received by API.', // Simulated API rejection due to invalid input.
                                                   'Simulated Expedia endpoint is currently down.', // Simulated external service issue.
                                                   'Simulated processing queue is full.' // Simulated internal server issue.
                                              ];
                                               const randomErrorMsg = simulatedFailureMessages[Math.floor(Math.random() * simulatedFailureMessages.length)]; // Select a random error message.

                                               // Update the dedicated UI element (`#expediaSimulatedPriceElement`) to show the price fetch failure message.
                                              if (this.#expediaSimulatedPriceElement) { // Check if element exists.
                                                  this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED(randomErrorMsg); // Use failure template with random error message.
                                                  // Remove spinner if it was added to the element.
                                                   const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                              } else { Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Simulated price display element is null, cannot show error.`);} // Check if element exists.

                                              // Reject the promise with a new Error object including the simulated message.
                                             reject(new Error(`Simulated Expedia Price Fetch Error: ${randomErrorMsg}`)); // Reject the promise.
                                          } // End of simulateSuccess if/else.
                                    } catch (timeoutCallbackError) {
                                         // --- Handle Errors Inside Timeout Callback ---
                                         // Catch any unexpected errors occurring *within the execution of the `setTimeout` callback function itself* after the delay has passed.
                                         // This is a defensive catch for logic errors *inside* the simulation execution.
                                        this.#errorReporter.reportError(
                                             `${this.name}._fetchSimulatedExpediaPrice - timeoutCallback`, // Source indicating callback execution.
                                             timeoutCallbackError, // The error object caught.
                                             { searchParams: searchParams, step: 'simulated_async_timeout_callback_execution' }, // Context.
                                             'Internal error during simulated Expedia price fetch processing.', // User message template.
                                             'expedia_price_sim_timeout_callback_exception' // GA error code.
                                        );
                                         // Update the UI element to show a generic error if processing within timeout callback fails.
                                        if (this.#expediaSimulatedPriceElement) { // Check if element exists.
                                             this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Internal simulation error.');
                                             // Remove spinner.
                                             const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                        } else { Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Simulated price display element is null, cannot show internal error.`);} // Check if element exists.

                                        // Re-throw the error within the callback to ensure it propagates as a Promise rejection if not already handled by `reject`.
                                         reject(timeoutCallbackError); // Reject the promise with the caught error.
                                    } // End of timeout callback try...catch.
                                }, AppConfig.SIMULATED_ASYNC_PROCESS_DELAY_MS); // Use the configured delay for the simulated asynchronous operation.

                             // The Promise is returned here. It will resolve or reject based on the setTimeout callback execution.

                         } catch (setupError) {
                              // --- Handle Errors During Setup ---
                              // Catch any unexpected synchronous errors occurring *before* the asynchronous operation even starts
                              // (e.g., errors in the try block before creating the Promise, errors during input parameter validation before calling setTimeout, issues accessing config).
                              this.#errorReporter.reportError(
                                  `${this.name}._fetchSimulatedExpediaPrice`, // Source.
                                  setupError, // The error object caught.
                                  { searchParamsInput: searchParams, step: 'setup_before_async' }, // Context.
                                  'Simulated Expedia price fetch setup failed. Operation cancelled due to internal issue.', // User message template.
                                  'expedia_price_fetch_setup_exception' // GA error code.
                              );
                              // Update the dedicated UI element to show setup failure.
                               if (this.#expediaSimulatedPriceElement) { // Check if element exists.
                                    this.#expediaSimulatedPriceElement.textContent = AppConfig.MESSAGES.EXPEDIA_PRICE_FETCH_FAILED('Setup failed.'); // Use failure template with simple message.
                                    // Remove spinner.
                                   const spinner = this.#expediaSimulatedPriceElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                               } else { Logger.debug(`${this.name}._fetchSimulatedExpediaPrice: Simulated price display element is null, cannot show setup error.`);} // Check if element exists.

                              // Return null to indicate that fetching the price failed due to a setup error (synchronous failure).
                              return null; // Always return null on synchronous error in a method expected to return a Promise result or null.
                         } finally {
                              // This block always executes after the try/catch/return structure, regardless of success, failure, or error.
                              // No specific cleanup is typically needed here as UI element updates are handled within try/catch blocks.
                              Logger.debug(`${this.name}._fetchSimulatedExpediaPrice execution path finished.`);
                          }
                      } // End of _fetchSimulatedExpediaPrice method definition.

                    /**
                     * Asynchronous method to fetch a simulated AI-generated destination tip using the simulated GenAI service. Marked async.
                     * This simulates making an API call (via a backend endpoint defined by `this.#genAIService.#endpointUrl`) to a GenAI model
                     * to generate a text tip based on the user's provided `destination` input.
                     * This method initiates the fetch and updates the dedicated AI tip UI element (`#aiTipContentElement`) with the generated text result or an error message.
                     * It also ensures the AI Tips section container (`#aiTipsSection`) is visible during and after the fetch if a valid destination is available.
                     * This operation is often treated as secondary to the main search result redirect and can be designed to run concurrently (`Promise.all` in `searchHotels`) or fire-and-forget without blocking the main flow.
                     * @param {string} destination - The destination string (e.g., city name, landmark) for which to request the AI-generated tip. Required. Must be a non-empty string after trimming.
                     * @returns {Promise<void>} A Promise that resolves without a specific value (`void`) when the fetch and display process for the AI tip completes (whether successfully with a tip, successfully with no tip returned, or with a catchable error during the process). The actual tip string is not directly returned, as this method focuses on displaying it in the UI.
                     * @private
                     */
                    async _fetchAndDisplaySimulatedAITip(destination) {
                        try {
                             Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: Starting simulated AI tip fetch and display process for destination: "${destination}"...`);

                            // --- Show Loading State for AI Tip ---
                             // Ensure the AI Tips section container (`#aiTipsSection`) is visible while loading the tip, assuming it should be displayed if a destination is present.
                             if (this.#aiTipsSection) { // Check if the section element exists.
                                 if (this.#aiTipsSection.classList.contains('app-hide')) { // If it exists but is hidden, show it.
                                      this.#aiTipsSection.classList.remove('app-hide'); // Show the section.
                                      Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: Showing AI Tips section for loading.`);
                                 }
                              } else { // If the section element itself is missing.
                                 Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null. AI feature UI is unavailable.`);
                                 // ErrorReporter already logged UI missing error in constructor for the section.
                             }

                             // Update the dedicated AI tip content element (`#aiTipContentElement`) to show a loading indicator message.
                             if (this.#aiTipContentElement) { // Check if the tip content element exists.
                                  // Clear any previous tip content, error messages, or loading spinners displayed in the tip area.
                                 this.#aiTipContentElement.innerHTML = ''; // Clear existing HTML content.
                                 // Set the loading message text and add a Font Awesome spinner icon using `innerHTML`.
                                 this.#aiTipContentElement.innerHTML = AppConfig.MESSAGES.GENAI_TIP_LOADING + ` <i class="fa fa-spinner w3-spin"></i>`; // Set loading text + spinner icon.
                                 Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: UI updated to show loading state for tip.`);
                             } else {
                                // If the tip content element is missing, log a warning. The fetch can continue, but results won't be displayed.
                                Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content display element (${AppConfig.SELECTORS.AI_TIP_CONTENT_DISPLAY}) is null. Tip won't be displayed.`);
                                // ErrorReporter logged UI missing error for this element in constructor.
                             }


                             // --- Validate Input Parameter for AI Tip ---
                             // Ensure the `destination` string provided as input is not null, undefined, or empty after trimming. The simulated GenAI service needs a valid input.
                             if (!destination || typeof destination !== 'string' || destination.trim() === '') {
                                 const inputWarningMsg = `Missing or invalid destination string provided for AI tip fetch. Cannot fetch tip.`;
                                Logger.warn(`SimulatedGenAIService.getDestinationTip: ${inputWarningMsg}`, { destinationInput: destination });
                                 // If input is invalid, update the AI tip content element to show a message indicating the issue, and remove the spinner.
                                 if (this.#aiTipContentElement) { // Check if the element exists.
                                     this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED(inputWarningMsg); // Show as failure message in tip area.
                                      // Remove spinner if it was added previously.
                                     const spinner = this.#aiTipContentElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                  } else { Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when handling missing input.`);} // Check if element exists.
                                 // No ErrorReporter needed for this simple input validation handled gracefully in UI.
                                return; // Exit the async method. The Promise is not resolved/rejected explicitly here; it just finishes.
                             }
                              // Use the trimmed destination string for the simulated service call.
                            const trimmedDestination = destination.trim();


                           // --- Check GenAI Service Configuration and Availability ---
                           // Ensure the simulated GenAI service instance (`this.#genAIService`) is initialized and configured (has a non-placeholder endpoint URL).
                           // Its `isConfigured()` method checks this condition based on `AppConfig.BACKEND_ENDPOINTS.GENAI_TIP_API_GATEWAY`.
                           if (!this.#genAIService || !this.#genAIService.isConfigured()) {
                                const serviceNotConfiguredMessage = AppConfig.MESSAGES.NOT_READY('GenAI Tip Service Simulation', 'Endpoint configuration missing.'); // Get the standard message.
                                Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: GenAI service not configured or instance missing. Cannot proceed. Message: "${serviceNotConfiguredMessage}".`);
                                // Ensure the AI Tips section is visible (in case it was hidden) and display the warning message in the tip area.
                                 if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) {
                                      this.#aiTipsSection.classList.remove('app-hide'); // Show section.
                                 } else if (!this.#aiTipsSection) {
                                     Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null when handling config missing.`);
                                 }

                                if (this.#aiTipContentElement) { // Check if element exists.
                                   this.#aiTipContentElement.textContent = serviceNotConfiguredMessage; // Display warning message in the tip area.
                                    // Remove spinner if present.
                                   const spinner = this.#aiTipContentElement.querySelector('.w3-spin'); if (spinner) spinner.remove();
                                } else { Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when showing config warning.`);} // Check if element exists.
                                // The service constructor or its initialization method should have already reported the persistent config error in the main message area via ErrorReporter.
                               return; // Exit async method if service is not configured.
                            }
                             // Log that the GenAI service is available.
                            Logger.debug(`_fetchAndDisplaySimulatedAITip: Simulated GenAI Service instance is available and configured. Proceeding with simulated fetch.`);


                           // --- Simulate Calling GenAI Service ---
                           // Call the asynchronous method (`getDestinationTip`) on the simulated GenAI service instance (`this.#genAIService`).
                           // This method simulates making an async call (fetch/$.ajax) to the configured backend endpoint (`this.#genAIService.#endpointUrl`),
                           // which YOUR backend would use to securely invoke a real GenAI model using backend credentials.
                           // Use `await` to pause execution of this async handler until the Promise returned by the simulated service call resolves (simulated success with a tip string or null) or rejects (simulated failure with an error).
                           Logger.debug(`_fetchAndDisplaySimulatedAITip: Calling simulated GenAI service to get tip for "${trimmedDestination}"...`);
                            let simulatedTipResult = null; // Variable to hold the result of the simulated call (string tip or null).

                            try {
                                 // Call the async method `getDestinationTip` on the `this.#genAIService` instance, passing the trimmed destination string.
                                 // This method returns a Promise which resolves with a tip string or null on simulated success, or rejects with an error on simulated failure.
                                simulatedTipResult = await this.#genAIService.getDestinationTip(trimmedDestination); // Await the simulated service call.
                                // Log the result received from the simulated `getDestinationTip` call.
                                Logger.debug(`_fetchAndDisplaySimulatedAITip: Simulated GenAI tip fetch finished. Result: "${simulatedTipResult}".`);

                                // If the Promise rejected, the error is caught in the `catch (apiError)` block below. If it resolved with null, `simulatedTipResult` will be null.

                            } catch (apiError) {
                                 // --- Handle Simulated GenAI Failure (Promise Rejection) ---
                                 // Catch any errors thrown (Promise rejections) by the simulated GenAI service's `getDestinationTip` method.
                                 // This could simulate errors such as:
                                 // - Network issues when calling the backend endpoint (`fetch` errors).
                                 // - HTTP errors (4xx, 5xx) from the backend endpoint.
                                 // - JSON parsing errors of the backend response (`fetch` `response.json()` throws) (if used in service).
                                 // - Errors originating in the real GenAI API and propagated back by the backend.
                                 // - Errors specifically simulated as rejections by the `getDestinationTip` method (e.g., random failures, prompt safety violations, API limits).
                                Logger.error(`_fetchAndDisplaySimulatedAITip: Error caught from simulated GenAI service call for "${trimmedDestination}":`, apiError);

                                 // Report the error using the injected ErrorReporter. This handles logging, potentially a main UI message, and GA tracking.
                                 this.#errorReporter.reportError(
                                     `${this.name}._fetchAndDisplaySimulatedAITip - apiCall`, // Source indicating the simulated API call stage.
                                     apiError, // The error object caught from the service rejection.
                                     { component: this.#getComponentInfo(), formId: this.id, step: 'simulated_api_call_execution', destination: trimmedDestination }, // Context including destination.
                                     AppConfig.MESSAGES.GENAI_TIP_FAILED(apiError.message || 'Unknown error.'), // User message template, using the error's message for detail.
                                     'genai_tip_api_exception' // GA error code for errors during API interaction.
                                 );
                                 // If the simulated call failed, `simulatedTipResult` remains null in this catch block. The UI update logic below will display the "failed" state.
                             } // End of simulated API call try...catch.


                            // --- Display the Result or Error in UI ---
                            // Update the dedicated AI tip content element (`#aiTipContentElement`) based on whether a tip string was successfully obtained (`simulatedTipResult` is a non-empty string).
                            if (this.#aiTipContentElement) { // Check if the display element exists.
                                // Clear any previous content or loading spinner markup.
                                this.#aiTipContentElement.innerHTML = ''; // Clear existing HTML content.

                                // Check if a valid, non-empty tip string was successfully obtained (`simulatedTipResult` is not null or whitespace).
                                if (simulatedTipResult && typeof simulatedTipResult === 'string' && simulatedTipResult.trim() !== '') {
                                    // If a valid tip string was obtained:
                                   const finalTipText = simulatedTipResult.trim(); // Get the trimmed tip text.
                                    Logger.info(`${this.name}._fetchAndDisplaySimulatedAITip: Displaying fetched tip for "${trimmedDestination}". Content: "${finalTipText.substring(0, 50)}..."`);
                                    // Set the text content using `textContent` to safely display the plain text tip, preventing XSS issues if the AI model could output HTML.
                                    this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_SUCCESS(finalTipText); // Use the success template, passing the trimmed tip.

                                    // Optional: Add a class for success styling if needed.
                                    // this.#aiTipContentElement.classList.add('tip-success');

                                } else {
                                    // If no valid tip string was obtained (either because the simulated service resolved with null/empty string,
                                    // or because `apiError` occurred and `simulatedTipResult` remained null):
                                    // Display a generic failure message in the AI tip content element.
                                    Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: No tip obtained (simulated failure or null result) for "${trimmedDestination}". Displaying failure message.`);
                                    // The ErrorReporter or the catch block handled specific error logging. Display a general failure message in the tip area.
                                    this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED('No tip returned or API error occurred.'); // Use the standard failure message template.
                                    // Remove spinner if present (already handled by clearing innerHTML above).
                                     // Optional: Add a class for error styling if needed.
                                     // this.#aiTipContentElement.classList.add('tip-failed');
                                }

                           } else {
                               // If the AI tip content element reference is null (meaning it wasn't found during constructor), log a warning that we cannot display the tip.
                               Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content display element is null. Cannot display fetch result in UI.`);
                               // ErrorReporter already logged UI missing error for this element in constructor.
                           }

                            // Log the completion of the AI tip fetch and display process.
                            Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip finished.`);


                        } catch (handlerError) {
                             // --- Handle Errors During Overall Handler Execution ---
                             // This outer catch block catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                             // that were not caught by the more specific try...catch blocks within (e.g., errors during setup steps before calling the service, input validation check fails unexpectedly, issues accessing service instance methods before calling them).
                             Logger.error(`${this.name}._fetchAndDisplaySimulatedAITip: CRITICAL UNEXPECTED ERROR caught during AI tip fetch handler execution!`, handlerError);

                             // Report the error using the injected reporter.
                             this.#errorReporter.reportError(
                                 `${this.name}._fetchAndDisplaySimulatedAITip`, // Source of the error.
                                 handlerError, // The error object caught.
                                 { component: this.#getComponentInfo(), formId: this.id, destinationInput: destination, step: 'handler_execution_overall_exception' }, // Context.
                                 `Error fetching and displaying AI tip for form "${this.name}". Process interrupted due to internal error.`, // User-facing message template for handler failure.
                                 'genai_tip_fetch_handler_exception_overall' // GA error code for overall handler exception.
                             );
                             // Ensure the AI tip display element shows an error state in case of failure.
                             if (this.#aiTipContentElement) { // Check if the element exists.
                                  this.#aiTipContentElement.textContent = AppConfig.MESSAGES.GENAI_TIP_FAILED('An internal error occurred.'); // Display a generic error message.
                                 const spinner = this.#aiTipContentElement.querySelector('.w3-spin'); // Remove spinner if it was added.
                                  if(spinner) spinner.remove();
                              } else {
                                  Logger.warn(`${this.name}._fetchAndDisplaySimulatedAITip: AI tip content element is null when handling overall handler error.`);
                              }
                             // Ensure the AI Tips section is visible to show the error, unless its dependencies were missing entirely.
                              if (this.#aiTipsSection && this.#aiTipsSection.classList.contains('app-hide')) {
                                  this.#aiTipsSection.classList.remove('app-hide');
                              } else if (!this.#aiTipsSection) {
                                 Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip: AI Tips section element is null when handling error.`);
                              }

                             // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                         } finally {
                              // This block always executes after the try/catch structure within the async handler.
                              // Ensures cleanup or final status updates not explicitly covered occur.
                              Logger.debug(`${this.name}._fetchAndDisplaySimulatedAITip async handler execution completed.`);
                         }
                     } // End of _fetchAndDisplaySimulatedAITip method definition.


                     /**
                      * Asynchronous method to load existing search history items from the browser's IndexedDB and display them in the dedicated UI list (`#searchHistoryList`). Marked async.
                      * This method is called during application startup (`SearchForm` constructor) and potentially after clearing history (`_handleClearHistoryClick`).
                      * It handles the entire process: checking UI elements and service availability, showing a loading state, calling the `IndexedDBService`'s asynchronous method (`getSearchHistory`), processing the fetched items, rendering them as clickable list items in the UI, attaching click handlers to these items, and updating the history section status text (`#historyStatusElement`) and the "Clear History" button state.
                      * @returns {Promise<void>} A Promise that resolves without a specific value (`void`) when the history loading and display process completes (whether successfully with items, successfully with no items, or with a catchable error during the process). The Promise does not reject on a catchable error within its flow, it handles them internally and reports.
                      * @private
                      */
                     async _loadAndDisplaySearchHistory() {
                         try {
                              Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Starting search history load and display process from IndexedDB...`);

                              // --- Check Dependencies ---
                              // Ensure the necessary UI elements for displaying history (`#searchHistorySection`, `#searchHistoryList`) and the `IndexedDBService` instance are available.
                              // These references are obtained during the `SearchForm` constructor. If they are null, the history feature cannot function.
                              if (!this.#searchHistorySection || !this.#searchHistoryList || !this.#idbService) {
                                  const missingDepsMsg = AppConfig.MESSAGES.HISTORY_LOAD_FAILED('UI elements or service missing.'); // Specific failure message.
                                 Logger.warn(`${this.name}._loadAndDisplaySearchHistory: ${missingDepsMsg}. Cannot load history.`);
                                  // ErrorReporter would have logged critical UI missing errors from the constructor if elements were null then.
                                  // Update history status element if it's available to show the failure message.
                                  if (this.#historyStatusElement) this.#historyStatusElement.textContent = missingDepsMsg; // Show message in status area.
                                  // Ensure the history section is hidden or shows an error if dependencies are critically missing.
                                   if (this.#searchHistorySection && !this.#searchHistorySection.classList.contains('app-hide')) { // If it exists and is NOT hidden, hide it.
                                        this.#searchHistorySection.classList.add('app-hide');
                                        Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Hiding history section due to missing dependencies.`);
                                    } else if (!this.#searchHistorySection) {
                                        Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History section element is null.`);
                                    }
                                 // Do not re-throw. The async method finishes execution gracefully.
                                 return; // Exit the async method as dependencies are not met.
                              }

                              // Log that dependencies are met.
                             Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Dependencies met. Proceeding.`);


                              // --- Show Loading State for History Section ---
                              // Ensure the search history section container (`#searchHistorySection`) is visible while loading history items, in case it was hidden initially or after certain actions (like clearing).
                             if (this.#searchHistorySection.classList.contains('app-hide')) {
                                  this.#searchHistorySection.classList.remove('app-hide'); // Show the section by removing the utility class.
                                 Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Showing history section for loading process.`);
                              }
                              // Update the history status element (`#historyStatusElement`) to indicate that loading is in progress.
                              if (this.#historyStatusElement) { // Check if the status element exists.
                                 this.#historyStatusElement.innerHTML = AppConfig.MESSAGES.PROCESSING('Loading history'); // Show processing text + spinner icon markup.
                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show loading status.`);
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status element missing for loading update.`);}


                              // Clear the current content of the history list (`#searchHistoryList`) visually before adding new items (including the temporary loading message).
                              // This removes any existing list items or previous messages (like "Loading...", "Error...").
                              if (this.#searchHistoryList) { // Check if the list element exists.
                                 this.#searchHistoryList.innerHTML = ''; // Clear existing list items HTML content.
                                  // Add a temporary "Loading..." message as a list item while the asynchronous fetch is happening.
                                  const loadingItem = document.createElement('li'); // Create a new list item element.
                                  loadingItem.textContent = 'Loading...'; // Set text content.
                                  loadingItem.classList.add('w3-text-grey'); // Add styling class (grey text).
                                   // Style it as a non-clickable message item (centered, padding).
                                  loadingItem.style.cursor = 'default';
                                  loadingItem.style.textAlign = 'center';
                                  loadingItem.style.padding = '20px 16px';
                                 this.#searchHistoryList.appendChild(loadingItem); // Append the temporary loading message item to the list.
                                 Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show empty list with temporary loading message.`);
                              } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Search history list element missing for optimistic update.`);} // Check if list element exists.


                             // --- Fetch History Items from IndexedDB ---
                             // Call the asynchronous method (`getSearchHistory`) on the `IndexedDBService` instance (`this.#idbService`) to retrieve search history items from the local database.
                             // Use `await` to pause execution of this `async` handler until the Promise returned by `getSearchHistory` resolves (successfully with an array of items) or rejects (with an error).
                             Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Calling IndexedDB service to fetch history items...`);
                              let fetchedHistoryItems = []; // Array variable to hold the fetched history items.
                              const historyDisplayLimit = AppConfig.INDEXEDDB.HISTORY_ITEM_LIMIT; // Get the configured limit for the number of items to retrieve and display.

                              try {
                                  // Call the async method `getSearchHistory` on the `this.#idbService` instance, passing the desired display limit.
                                  // This method returns a Promise<object[]>.
                                  fetchedHistoryItems = await this.#idbService.getSearchHistory(historyDisplayLimit); // Await the promise.
                                 // If execution reaches here, the promise resolved successfully. `fetchedHistoryItems` is an array (empty array if no items found in DB).
                                  Logger.debug(`${this.name}._loadAndDisplaySearchHistory: IndexedDB service getHistory completed successfully. Received ${fetchedHistoryItems.length} item(s).`, { itemsReceivedArrayLength: fetchedHistoryItems.length, firstFewItems: fetchedHistoryItems.slice(0, 5) }); // Log array length and first few items for debugging.

                              } catch (idbError) {
                                  // --- Handle IndexedDB Fetch Errors ---
                                  // Catch any errors thrown (Promise rejections) by the IndexedDB service's `getSearchHistory` method (e.g., due to database access issues, permissions being denied by the user, database corruption during read, etc.).
                                  Logger.error(`${this.name}._loadAndDisplaySearchHistory: Error caught from IndexedDB service getHistory call:`, idbError);

                                  // Report the error using the injected ErrorReporter. This handles logging, potentially a main UI message, and GA tracking.
                                  this.#errorReporter.reportError(
                                      `${this.name}._loadAndDisplaySearchHistory - idbGet`, // Source indicating the specific operation stage.
                                      idbError, // The error object caught from the service rejection.
                                      { component: this.#getComponentInfo(), formId: this.id, step: 'indexeddb_get_history_execution' }, // Context details.
                                      AppConfig.MESSAGES.HISTORY_LOAD_FAILED(idbError.message || 'Unknown error.'), // User-friendly message template using the error's message.
                                      'history_load_exception_api' // GA error code for errors during IndexedDB API interaction.
                                  );

                                  // If the fetch failed, `fetchedHistoryItems` remains its initial state (likely an empty array []) or is undefined.
                                  // The UI update logic below will proceed with an empty array and handle displaying the "empty" state, possibly with an error message added to the status element.
                                  // Do not re-throw the error from this catch block. Handle it internally and proceed to update the UI based on the outcome (empty array).
                                  fetchedHistoryItems = []; // Explicitly ensure it's an array for the next step if fetch failed critically before array was populated.
                              } // End of IndexedDB fetch try...catch.


                           // --- Render History List UI ---
                           Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Proceeding to render fetched history items into the UI list.`);

                           // Clear the current content of the history list (`#searchHistoryList`) again *before* rendering fetched items.
                           // This removes the "Loading..." message item added earlier or any previous errors/content.
                           if (this.#searchHistoryList) { // Check if the list element exists.
                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Clearing history list UI before rendering fetched items.`);
                                this.#searchHistoryList.innerHTML = ''; // Clear existing list items HTML content.
                           } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Search history list element missing for rendering.`); }


                           // Check if any history items were successfully fetched (the array is not null/undefined AND has elements).
                           if (Array.isArray(fetchedHistoryItems) && fetchedHistoryItems.length > 0) {
                                // If valid items exist in the array, iterate through them.
                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Rendering ${fetchedHistoryItems.length} fetched history items.`);
                                fetchedHistoryItems.forEach(historyItemData => {
                                    try {
                                         // --- Create List Item Element for Each History Item ---
                                         // Create a new list item (`<li>`) HTML element for the current `historyItemData` object.
                                        const listItem = document.createElement('li');
                                        // Add W3CSS styling class for general list items if any (e.g., 'w3-hover-light-grey').

                                        // --- Populate List Item Content ---
                                        // Set the HTML content of the list item using the properties from the `historyItemData` object.
                                        // Use `innerHTML` to allow embedding `<span>` tags for styling different parts of the text (destination, dates, travelers).
                                        // Use optional chaining (`?.`) and nullish coalescing (`??`) for safety in case properties are missing in the stored data object.
                                         const itemDestination = historyItemData.destination?.trim() || 'N/A Destination'; // Get trimmed destination.
                                         const itemCheckInDate = historyItemData.checkInDate || 'N/A Date'; // Get check-in date string.
                                         const itemCheckOutDate = historyItemData.checkOutDate || 'N/A Date'; // Get check-out date string.
                                         const itemAdults = historyItemData.adults ?? 'N/A'; // Get adults count.
                                         const itemChildren = historyItemData.children ?? 'N/A'; // Get children count.
                                        listItem.innerHTML = `<strong>${itemDestination}</strong>` + // Destination text (bold).
                                                           ` <span class="date-range">${itemCheckInDate} - ${itemCheckOutDate}</span>` + // Date range text (grey).
                                                           ` <span class="travelers">(${itemAdults} adults, ${itemChildren} kids)</span>`; // Travelers text (italic, grey).

                                        // --- Store Search Data on List Item Element ---
                                        // Store the *full* `historyItemData` object as a JSON string in a `data-*` attribute (`data-search-data`) on the `<li>` element.
                                        // This is crucial for the click handler (`_handleHistoryItemClick`) to easily retrieve all the original search data
                                        // when the list item is clicked, allowing the main form to be populated with this past search data.
                                         // Ensure the `historyItemData` is a valid object before attempting to stringify it.
                                         if (historyItemData && typeof historyItemData === 'object') {
                                             try {
                                                  // Use `JSON.stringify` to convert the JavaScript object to a JSON string for storage in the data attribute.
                                                  // This stores the data physically in the DOM, retrievable later.
                                                  listItem.dataset.searchData = JSON.stringify(historyItemData); // Store the JSON string in the data attribute `data-search-data`.
                                                 // Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Stored search data JSON on list item (ID: ${historyItemData.id || 'N/A'}). Data snippet: "${listItem.dataset.searchData.substring(0, 50)}..."`); // Verbose logging.
                                              } catch (stringifyError) {
                                                  // Handle errors if an individual history item object is not serializable to JSON (e.g., contains circular references, functions, complex objects).
                                                  // Report this issue via the injected ErrorReporter.
                                                   this.#errorReporter.reportError(
                                                       `${this.name}._loadAndDisplaySearchHistory - render loop stringify`, stringifyError, // Source and error.
                                                       { formId: this.id, historyItemData: historyItemData, step: 'stringify_item_for_data_attribute' }, // Context.
                                                       `Error stringifying history item data for UI element. This item may not be clickable correctly.`, // User message template.
                                                       'history_stringify_item_exception' // GA error code.
                                                   );
                                                  // Log the problematic item data.
                                                  Logger.error(`_loadAndDisplaySearchHistory: Failed to stringify history item data for ID "${historyItemData.id || 'N/A'}":`, historyItemData, { error: stringifyError });
                                                  // Continue rendering other items despite issue with this one's data storage. The item might still appear visually without the data attribute.
                                              }
                                         } else {
                                              // If an item received from the database is not a valid object format, log a warning.
                                             Logger.warn(`${this.name}._loadAndDisplaySearchHistory: Received invalid item format from IndexedDB. Skipping data storage for item.`, { item: historyItemData });
                                              // Report this data issue.
                                              this.#errorReporter.reportError(
                                                  `${this.name}._loadAndDisplaySearchHistory - render loop invalid format`, new Error("Invalid item format from DB."),
                                                  { formId: this.id, itemReceived: historyItemData, step: 'invalid_item_format_from_db' },
                                                  `Received invalid history item data format from storage.`, 'history_invalid_item_format'
                                              );
                                         }

                                         // --- Attach Click Handler to This List Item ---
                                         // Attach a click listener specifically to this dynamically created `<li>` element.
                                         // When the user clicks this list item, the `_handleHistoryItemClick` method will be executed.
                                         // Use the parent `_addEventListener` helper method. It handles binding the handler's `this` context to the component instance and stores the handler reference for disposal (`_removeEventListeners` on the list parent).
                                         // Pass the specific `listItem` element as the target element in the options object `{ element: listItem }`.
                                          this._addEventListener('click', this._handleHistoryItemClick, { element: listItem });
                                          // Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Attached click listener to history list item (ID: ${historyItemData.id || 'N/A'}).`); // Verbose.


                                         // --- Append List Item to UI ---
                                         // Append the successfully created and configured list item element to the history list UL element (`this.#searchHistoryList`).
                                         if (this.#searchHistoryList) { // Check if the list element exists before appending.
                                            this.#searchHistoryList.appendChild(listItem); // Add the item to the visual list.
                                         } else {
                                              Logger.warn(`${this.name}._loadAndDisplaySearchHistory: Search history list element is null. Cannot append list item (ID: ${historyItemData.id || 'N/A'}).`);
                                          }

                                    } catch (renderItemError) {
                                         // --- Handle Errors Rendering a Single Item ---
                                         // Catch any unexpected errors thrown *while processing or creating the DOM element for a single history item* within the rendering loop.
                                         // This provides robustness: one corrupt or problematic item should not stop the entire list from rendering.
                                         const currentItemId = historyItemData?.id || 'N/A'; // Get ID defensively.
                                         const itemDestination = historyItemData?.destinationInput?.substring(0, 20) || 'N/A Destination'; // Get destination snippet defensively.
                                         this.#errorReporter.reportError(
                                             `${this.name}._loadAndDisplaySearchHistory - render loop item`,
                                             renderItemError, // The error object caught.
                                             { formId: this.id, historyItemId: currentItemId, itemDestination: itemDestination, step: 'render_single_item_execution' }, // Context details.
                                             `Error displaying history item "${itemDestination}". List may be incomplete.`, // User-friendly message template about UI issue.
                                             'history_render_item_exception' // GA error code.
                                         );
                                        // Log the problematic item in detail.
                                         Logger.error(`_loadAndDisplaySearchHistory: Failed to render history item:`, historyItemData, { error: renderItemError });
                                        // Optional: Add a placeholder item in the list indicating the error, if the list element exists.
                                         if (this.#searchHistoryList) { // Check if list exists.
                                              const errorItem = document.createElement('li'); // Create error item.
                                             errorItem.textContent = `Error displaying item (ID: ${currentItemId}).`; // Set text.
                                             errorItem.classList.add('w3-text-red'); // Style as error.
                                              errorItem.style.cursor = 'default'; errorItem.style.textAlign = 'center'; errorItem.style.padding = '20px 16px'; // Styling.
                                             this.#searchHistoryList.appendChild(errorItem); // Add the error message item.
                                         } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: List element missing, cannot add error item.`); }
                                        // Continue to the next item in the loop despite the error with the current one.
                                    } // End of try...catch around single item rendering.
                                }); // End of `fetchedHistoryItems.forEach` loop for rendering.

                             // --- Update "Clear History" Button State ---
                             // If there are history items successfully displayed (the loop ran and added items), the "Clear History" button should be enabled.
                             if (this.#clearHistoryButton) { // Check if the clear button element exists.
                                  // Use a defensive check `disabled !== false` to avoid unnecessary DOM updates if the state is already correct.
                                 if (this.#clearHistoryButton.disabled !== false) {
                                    this.#clearHistoryButton.disabled = false; // Enable the button.
                                    Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Enabled "Clear History" button as items were rendered.`);
                                 }
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null, cannot enable/disable.`); } // Check if element exists.


                         } else {
                             // --- Handle No History Items Found ---
                             // If the `fetchedHistoryItems` array is empty or not a valid array after the fetch attempt (either because IndexedDB was empty, or because the fetch/render process failed to yield any valid items).
                             Logger.debug(`${this.name}._loadAndDisplaySearchHistory: No history items found (or invalid data) to render after fetch.`);

                              // Add a message to the history list (`#searchHistoryList`) indicating that the history is currently empty.
                             if (this.#searchHistoryList) { // Check if the list element exists.
                                  // It should already be clear, but add the "empty" message item.
                                  this.#searchHistoryList.innerHTML = ''; // Ensure it's fully clear of previous items/loading messages.
                                  const noHistoryItem = document.createElement('li'); // Create a new list item element for the message.
                                  noHistoryItem.textContent = AppConfig.MESSAGES.HISTORY_EMPTY; // Use the standard 'History Empty' message template.
                                  noHistoryItem.classList.add('w3-text-grey'); // Add styling class.
                                  noHistoryItem.style.cursor = 'default'; // Make it non-clickable.
                                   noHistoryItem.style.textAlign = 'center'; // Center text.
                                   noHistoryItem.style.padding = '20px 16px'; // Add padding.
                                  this.#searchHistoryList.appendChild(noHistoryItem); // Append the empty message item to the list.
                                Logger.debug(`${this.name}._loadAndDisplaySearchHistory: UI updated to show empty history list message.`);
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Search history list element is null, cannot show empty message.`); } // Check if list exists.


                             // If no history items are found/displayed, the "Clear History" button should be disabled as there's nothing to clear.
                             if (this.#clearHistoryButton) { // Check if the clear button element exists.
                                  // Use a defensive check `disabled !== true`.
                                 if (this.#clearHistoryButton.disabled !== true) {
                                    this.#clearHistoryButton.disabled = true; // Disable the button.
                                    Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Disabled "Clear History" button as no items were found.`);
                                 }
                             } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null, cannot enable/disable.`); } // Check if button exists.

                         } // End of `if (Array.isArray(fetchedHistoryItems) && fetchedHistoryItems.length > 0) else` block for rendering fetched items vs. empty state.


                         // --- Update History Status UI (Final State) ---
                         // Update the history status element (`#historyStatusElement`) based on the final outcome of the loading process (success, empty, or failure).
                         // This update happens regardless of whether items were found, based on the completion of the fetch attempt.
                          if (this.#historyStatusElement) { // Check if the status element exists.
                               // If the `try` block for fetching and rendering completed without throwing an error,
                               // update the status element to a success message. The message should indicate loaded status.
                               // Check if the status element still contains the "Loading..." message. This indicates the try block completed successfully for the fetch.
                              if (typeof this.#historyStatusElement.textContent === 'string' && this.#historyStatusElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('Loading history', false)) ) {
                                   // If it's still showing the loading message, update it to the success status message.
                                   // Use the standard success message.
                                   this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_LOAD_SUCCESS; // Set success message text.

                                   // Set a short timer to clear this temporary status message if transient messages are configured (duration > 0).
                                   if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) { // Use the general message duration config for the status clearance timer.
                                        // Use a data attribute on the status element to store the timer ID, so it can be cleared if a new status message needs to be displayed.
                                        // Clear any previous timer associated with this status element's data attribute before setting a new one.
                                         if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                             clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10)); // Parse and clear the previous timeout ID.
                                            delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID from the data attribute.
                                          }
                                         // Set a new timeout.
                                        const statusClearTimerId = setTimeout(() => {
                                             // Inside the timeout callback, check if the status text *still* matches the success message *before clearing*.
                                             // This is a defensive check to avoid clearing a newer status message (e.g., an error from a subsequent button click) that might have been displayed since this timer was set.
                                             if (this.#historyStatusElement && this.#historyStatusElement.textContent === AppConfig.MESSAGES.HISTORY_LOAD_SUCCESS) {
                                                 this.#historyStatusElement.textContent = ''; // Clear the status text content after the timeout.
                                                 Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status cleared by timer.`);
                                             }
                                              if (this.#historyStatusElement) delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID from data attribute after clear attempt.
                                        }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Clear the status message after half the general message duration. Using half makes it clear before main messages disappear.
                                         if (this.#historyStatusElement) this.#historyStatusElement.dataset.statusClearTimer = statusClearTimerId.toString(); // Store the timer ID on the element's data attribute for future clearing.
                                   } // End if duration > 0 for timer setup.

                               }
                               // If the `catch (idbError)` block (or the overall `catch (overallLoadDisplayError)`) was executed, the ErrorReporter or that catch block would have already handled updating `this.#historyStatusElement`
                               // to show a specific failure message persistently. We don't need to overwrite a specific error message here.
                               // If the initial UI element was missing (`this.#historyStatusElement` is null), updates were skipped at the start.

                           } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status element missing, skipping final status update logic.`); } // Check if status element exists before updating.


                           Logger.debug(`${this.name}._loadAndDisplaySearchHistory async method execution finished.`);


                       } catch (overallLoadDisplayError) {
                            // --- Handle Any Unexpected Critical Errors During Overall Load/Display Process ---
                            // This outermost catch block acts as a final safety net for any uncaught synchronous or asynchronous errors thrown *during the entire execution of the `_loadAndDisplaySearchHistory` method itself*
                            // that were not caught by the more specific try/catch blocks within (e.g., failure in the main try block before fetching, error in the loop structure itself, errors during DOM manipulation that weren't specifically caught, unhandled exceptions propagating from inner catches).
                            // This indicates a severe failure in the history loading and display logic.
                           Logger.error(`${this.name}._loadAndDisplaySearchHistory: CRITICAL UNEXPECTED ERROR caught during history load and display process!`, overallLoadDisplayError);

                            // Report this critical failure using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._loadAndDisplaySearchHistory`, // Source of the error.
                               overallLoadDisplayError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'overall_load_display_process_critical_exception' }, // Context details.
                               AppConfig.MESSAGES.HISTORY_LOAD_FAILED(overallLoadDisplayError.message || 'Unknown error during history display.'), // User-facing message template for a critical loading failure.
                               'history_load_critical_exception_overall' // GA error code for a critical overall history load/display exception.
                           );

                           // --- Update UI to Reflect Critical Failure ---
                           // Ensure the history status element shows a failure message persistently.
                           if (this.#historyStatusElement) { // Check if status element exists.
                               this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_LOAD_FAILED(overallLoadDisplayError.message || 'Unknown error during clear.'); // Set persistent error message.
                                // Remove any potential pending timer on status element.
                                if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                    clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                   delete this.#historyStatusElement.dataset.statusClearTimer; // Remove stored ID.
                                }
                            } else { Logger.warn(`${this.name}._loadAndDisplaySearchHistory: History status element is null when handling critical error during UI update.`);} // Check if status element exists.

                           // Ensure the "Clear History" button is disabled on critical load/display failure.
                           if (this.#clearHistoryButton) { // Check if clear button exists.
                               if (this.#clearHistoryButton.disabled !== true) { // Check state defensively.
                                   this.#clearHistoryButton.disabled = true; // Disable the button.
                                   Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button disabled after critical load/display error.`);
                               }
                           } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: "Clear History" button element is null.`); } // Check if button exists.

                           // Clear the history list UI (`#searchHistoryList`) in case of partial or corrupt data/display errors
                           // and show a generic error message item in the list to the user.
                           if (this.#searchHistoryList) { // Check if list exists.
                                Logger.error(`${this.name}._loadAndDisplaySearchHistory: Clearing history list UI due to critical error during display.`);
                                this.#searchHistoryList.innerHTML = ''; // Clear existing list items.
                                // Add a generic error message item to the list.
                                const errorItem = document.createElement('li'); // Create a new list item element.
                                errorItem.textContent = 'An error occurred while trying to load or display history.'; // Error text content.
                                errorItem.classList.add('w3-text-red'); // Style as error text.
                                errorItem.style.cursor = 'default'; errorItem.style.textAlign = 'center'; errorItem.style.padding = '20px 16px'; // Styling.
                                this.#searchHistoryList.appendChild(errorItem); // Append the error message item to the list.
                               Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Added error message item to history list.`);
                           } else { Logger.warn(`${this.name}._loadAndDisplaySearchHistory: Search history list element is null when handling critical error.`); } // Check if list exists.

                           // The history section itself (`#searchHistorySection`) should remain visible to show the error message in the status area and list item, unless its dependencies were missing initially.

                           // Do not re-throw the error from an async handler's outer catch block. The error has been logged and reported by the reporter.
                       } finally {
                           // This block always executes after the try/catch/return structure within the async handler.
                           // Ensures cleanup or final status updates not explicitly covered in the try/catch logic occur.
                           // Ensure any lingering persistent "Processing..." message on the status element is cleared unless it became an error message.
                           if (this.#historyStatusElement) { // Check if status element exists.
                             const currentMessageElement = this.#historyStatusElement; // Get element reference.
                             // If it's still displaying text related to PROCESSING and is NOT displaying an error (`w3-pale-red`)...
                             if (typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                  // Clear the persistent message.
                                 this.#historyStatusElement.textContent = ''; // Clear status text.
                                 Logger.debug(`${this.name}._loadAndDisplaySearchHistory: Cleared persistent processing message in finally.`);
                             } // No else needed; if it's an error message, it should remain.
                          } else { Logger.debug(`${this.name}._loadAndDisplaySearchHistory: History status element is null in finally block.`);} // Check if element exists.

                          // Ensure any spinner inside the status element is removed.
                          if (this.#historyStatusElement) {
                              const statusSpinner = this.#historyStatusElement.querySelector('.w3-spin');
                               if (statusSpinner) statusSpinner.remove();
                           }

                           Logger.debug(`${this.name}._loadAndDisplaySearchHistory async method execution completed.`);
                       } // End of _loadAndDisplaySearchHistory try...catch...finally block.
                   } // End of _loadAndDisplaySearchHistory method definition.


                   /**
                    * Handler for clicking on a search history list item (`<li>`) within the search history list (`#searchHistoryList`).
                    * This method is attached using event delegation (a single listener on the parent `#searchHistoryList` listens for clicks on any descendant `<li>`)
                    * during the `_loadAndDisplaySearchHistory` method.
                    * When a history list item is clicked, this handler retrieves the stored search data associated with that clicked item
                    * (which was previously stored as a JSON string in the list item's `data-searchData` attribute during rendering).
                    * It then parses the data and attempts to populate the main search form inputs with this retrieved data, allowing the user to re-run a past search easily.
                    * This method does NOT automatically trigger a new search after populating the form; that would require a separate step (e.g., uncommenting form submission logic).
                    * @param {Event} event - The native DOM 'click' event object. The `event.target` property refers to the element that was clicked, but `event.target.closest('li')` is used to find the nearest `<li>` ancestor.
                    */
                   _handleHistoryItemClick(event) {
                       try {
                           Logger.debug(`${this.name}._handleHistoryItemClick: History list item clicked.`);
                            // Prevent the browser's default behavior for the click event (e.g., if the LI contained a link, prevent navigation) and stop event propagation up the DOM tree.
                            if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                           if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up to parent elements.

                           // Find the actual `<li>` list item element that was clicked (or is the closest `<li>` ancestor if a child element like a `<span>` inside was clicked).
                           // Use `event.target.closest('li')` for robust event delegation. This ensures we always get the `<li>` even if a nested element was clicked.
                           const clickedListItem = event.target.closest('li');

                           // --- Check if a Valid Clicked Item with Data Was Found ---
                           // Ensure a valid `<li>` element was found AND that it contains the stored search data in its `data-searchData` attribute.
                           // A valid item is expected to have a non-empty `data-searchData` string.
                           if (!clickedListItem || !clickedListItem.dataset || !clickedListItem.dataset.searchData || typeof clickedListItem.dataset.searchData !== 'string' || clickedListItem.dataset.searchData.trim() === '') {
                               Logger.warn(`${this.name}._handleHistoryItemClick: Clicked element is not a history list item with valid data.`);
                               // If the clicked element isn't a valid history item or doesn't have the expected data attribute content, log a warning and exit.
                               // Optionally report this click on a seemingly invalid item via GA.
                               this.#gaTracker.trackEvent('history_item_click_invalid', { form_id: this.id, reason: 'missing_list_item_or_data' });
                               return; // Exit handler.
                           }

                           // --- Ignore Non-Data Items (like 'Loading...' or 'Empty') ---
                           // The `_loadAndDisplaySearchHistory` method might add special message list items (like "Loading..." or "No recent searches found"). These items should not be clickable data items.
                           // Check if the clicked item has a specific class name indicating it's not a clickable data item (e.g., `w3-text-grey` used for messages in rendering) or if its text content matches known message strings.
                           // This prevents attempting to parse data from these non-data list items.
                           if (clickedListItem.classList.contains('w3-text-grey') || (typeof clickedListItem.textContent === 'string' && clickedListItem.textContent.includes(AppConfig.MESSAGES.HISTORY_EMPTY)) || (typeof clickedListItem.textContent === 'string' && clickedListItem.textContent.includes('Loading...')) || (typeof clickedListItem.textContent === 'string' && clickedListItem.textContent.includes('Error loading history'))) { // Check class or known message text.
                               Logger.debug(`${this.name}._handleHistoryItemClick: Clicked on a non-data history item message. Ignoring.`);
                               return; // Ignore the click and exit handler.
                           }


                           // --- Get Stored Search Data ---
                           // Retrieve the JSON string containing the stored search data from the clicked list item's `data-searchData` attribute.
                           const searchDataJsonString = clickedListItem.dataset.searchData; // Get the string from data attribute.

                           let searchDataFromHistory = null; // Variable to hold the parsed search data object.
                           try {
                                // Attempt to parse the JSON string obtained from the data attribute back into a plain JavaScript object.
                                searchDataFromHistory = JSON.parse(searchDataJsonString); // Parse the JSON string.
                              Logger.debug(`${this.name}._handleHistoryItemClick: Successfully parsed search data from history item JSON string.`, searchDataFromHistory);

                              // Check if the parsed data is a valid object.
                              if (!searchDataFromHistory || typeof searchDataFromHistory !== 'object') {
                                   const invalidDataMsg = `Parsed search data is not a valid object type.`;
                                   Logger.warn(`${this.name}._handleHistoryItemClick: ${invalidDataMsg}.`, { parsedData: searchDataFromHistory, jsonString: searchDataJsonString });
                                   throw new Error(invalidDataMsg); // Throw an error if the parsed data is not a valid object.
                               }


                           } catch (parseError) {
                                // --- Handle JSON Parsing Error ---
                                // If parsing the JSON string from the data attribute fails (e.g., the stored data was corrupted in storage or rendering logic stored bad JSON).
                               // Report this parsing error using the injected ErrorReporter.
                               this.#errorReporter.reportError(
                                    `${this.name}._handleHistoryItemClick - jsonParse`, parseError, // Source and error object.
                                    { formId: this.id, listItemTextSnippet: clickedListItem.textContent?.substring(0, 50) || 'N/A', jsonDataSnippet: searchDataJsonString?.substring(0, 100) || 'N/A', step: 'json_parse_error' }, // Context.
                                    `Error loading search data from history item. Data appears corrupted.`, // User-friendly message template for data issue.
                                    'history_item_parse_exception' // GA error code.
                               );
                               // Display a user-facing error message in the main UI area.
                               this.#messageDisplay.showMessage(`Error loading search data from history item. Data corrupted. Please try clearing history.`, 'error', 8000); // Show error message temporarily.
                                // Track the reason for failure.
                                this.#gaTracker.trackEvent('history_item_load_failed', { form_id: this.id, reason: 'parse_error_during_click' }); // GA Failure Reason.
                               return; // Exit handler if parsing failed.
                           } // End of JSON parse try...catch.


                           // --- Populate Form Inputs ---
                           // If search data was successfully parsed from the history item and is a valid object, populate the main search form inputs (`this._inputs` map) with this data.
                           Logger.info(`${this.name}._handleHistoryItemClick: Populating main search form inputs with history data for "${searchDataFromHistory.destinationInput?.trim() || 'N/A'}".`);

                           // Display a UI message informing the user that the form is being populated from history.
                            this.#messageDisplay.showMessage(AppConfig.MESSAGES.HISTORY_ITEM_CLICKED(searchDataFromHistory.destinationInput?.trim() || 'N/A'), 'info', 3000); // Show message for 3 seconds.


                           // Track a GA event indicating that a history item was clicked and its data is being used to populate the form.
                            this.#gaTracker.trackEvent('history_item_clicked', { form_id: this.id, destination: searchDataFromHistory.destinationInput?.trim() || 'N/A', step: 'populate_started' }); // GA Event.


                           // Iterate through the properties (keys) of the `searchDataFromHistory` object.
                           // The keys are expected to correspond to the input element IDs in the form.
                           Object.keys(searchDataFromHistory).forEach(dataKey => {
                               try {
                                   // Check if there is a corresponding custom input component instance managed by this form (`this._inputs`) for the current data key.
                                   const inputComponent = this._inputs[dataKey];

                                    // Ensure the input component exists in the map AND if its wrapped HTML element (`_element`) is available
                                    // AND if the element is not disabled or readonly, which would prevent setting its value programmatically.
                                   if (inputComponent && inputComponent.getElement() && !inputComponent.getElement().disabled && !inputComponent.getElement().readOnly) {
                                        // Get the HTML element associated with the component.
                                       const element = inputComponent.getElement();
                                        // Get the value for this `dataKey` from the history data object.
                                       const valueToSet = searchDataFromHistory[dataKey] ?? ''; // Value from history data. Use nullish coalescing to set empty string for null/undefined values.

                                        // --- Set Element Value ---
                                        // Set the value on the HTML element's appropriate property (`value`, `checked`, `selectedIndex`).
                                       if (element.type === 'checkbox') {
                                            element.checked = Boolean(valueToSet); // Set `checked` state for checkboxes based on the boolean representation of the history value.
                                            Logger.debug(`${this.name}._handleHistoryItemClick: Populated checkbox "${dataKey}" checked state to "${element.checked}".`);
                                       } else if (element.type === 'radio') {
                                            // For radio buttons, set the `checked` state to `true` ONLY if the history item value matches the specific radio button's `value` attribute.
                                            // All radio buttons in a group with the same `name` are considered together.
                                            if (String(element.value) === String(valueToSet)) { // Compare both `element.value` and `valueToSet` as strings for robust comparison.
                                                 element.checked = true; // Set checked state.
                                                Logger.debug(`${this.name}._handleHistoryItemClick: Populated radio "${dataKey}" checked true.`);
                                            } // Other radio buttons in the same group should automatically become unchecked by the browser.
                                       } else if (element.tagName === 'SELECT') {
                                            // For select elements, set the `value`. The browser will automatically select the `<option>` whose `value` attribute matches the set value.
                                             element.value = valueToSet; // Set the select value. Use nullish coalescing to set empty string if value is null/undefined.
                                             Logger.debug(`${this.name}._handleHistoryItemClick: Populated select "${dataKey}" value to "${element.value}".`);
                                            // Note: If the `valueToSet` does not match the `value` attribute of any `<option>` in the `<select>`, the select might not visually update correctly or might select the first option, depending on browser and HTML structure.
                                       } else {
                                            // For most standard input types (`text`, `number`, `date`, `email`, `password`, etc., and `<textarea>`), set the `value` property directly.
                                           element.value = valueToSet; // Set the `value` property. Use nullish coalescing.
                                            Logger.debug(`${this.name}._handleHistoryItemClick: Populated input "${dataKey}" value to "${element.value}".`);
                                       }

                                      // --- Trigger Events Programmatically ---
                                       // After programmatically setting the HTML element's value, manually trigger standard DOM events (`input`, `change`) on the element.
                                       // This is crucial because browser event handlers (like those attached by our `InputComponent` base class and its overrides)
                                       // typically only fire in response to *user* interactions (typing, pasting, clicking, etc.), not programmatic value changes done via JavaScript code.
                                       // Dispatching these events ensures that the component's event handlers (`_handleInput`, `_handleChange`, `_handleBlur` - if applicable)
                                       // are executed as if the user had manually entered the value. This logic updates the component's internal `_value` state, clears error messages below the input,
                                       // and triggers any component logic tied to these events (like validation on change/blur, autocomplete state updates on input).
                                       // Create and dispatch the 'input' event. Use `bubbles: true` so the event propagates up the DOM tree, allowing handlers on parent elements (like the form) to also potentially receive it if needed.
                                        const inputEvent = new Event('input', { bubbles: true }); // Simulate 'input' event.
                                        element.dispatchEvent(inputEvent);
                                        Logger.debug(`${this.name}._handleHistoryItemClick: Dispatched 'input' event for "${dataKey}".`);

                                       // Dispatch a 'change' event. The change event typically signifies that the value has been committed by the user (often on blur after value change).
                                       // Dispatching it here simulates that the "value has been confirmed loaded from history" and triggers `_handleChange`, which calls `validate()`.
                                        const changeEvent = new Event('change', { bubbles: true }); // Simulate 'change' event.
                                        element.dispatchEvent(changeEvent);
                                        Logger.debug(`${this.name}._handleHistoryItemClick: Dispatched 'change' event for "${dataKey}".`);

                                      // Optional: Explicitly trigger a 'blur' event programmatically to mimic the input losing focus after being populated.
                                      // This is often where validation is triggered if not handled by the 'change' event, and might be relevant for specific component behaviors.
                                      // This validation logic (`this.validate()`) is also explicitly triggered below the loop.
                                      // if (typeof element.blur === 'function') element.blur(); // Uncomment to simulate blur.


                                      // Optional: Explicitly trigger validation for this specific input component after setting its value.
                                       // This ensures immediate visual validity feedback for *this* input based on the newly set value, even before the form-level validation below the loop runs.
                                       // inputComponent.validate(); // Uncomment if immediate validation on population is desired for EACH input.

                                   } else if (inputComponent) {
                                        // If the corresponding input component exists, but its wrapped element is missing (element was removed from DOM after component init), or element is disabled/readonly.
                                       Logger.warn(`${this.name}._handleHistoryItemClick: Corresponding input component "${dataKey}" found but its element is invalid (${!inputComponent.getElement()}) or disabled/readonly. Cannot populate input from history.`);
                                        // Report this issue via the ErrorReporter.
                                       this.#errorReporter.reportError(
                                           `${this.name}._handleHistoryItemClick`, new Error(`Input component "${dataKey}" found but element is invalid, disabled, or readonly.`),
                                           { formId: this.id, dataKey: dataKey, step: 'populate_input_element_issue' },
                                           `Internal error populating form input "${dataKey}" from history. Element unavailable or disabled.`,
                                           'history_populate_input_element_issue' // GA error code.
                                       );
                                    } else {
                                         // If the input component for this data key doesn't exist in the map (`this._inputs[dataKey]` is undefined/null).
                                         Logger.warn(`${this.name}._handleHistoryItemClick: Corresponding input component with ID "${dataKey}" not found in inputs map. Cannot populate input from history.`);
                                          // Report this issue via the ErrorReporter.
                                          this.#errorReporter.reportError(
                                              `${this.name}._handleHistoryItemClick`, new Error(`Input component with ID "${dataKey}" not found in map.`),
                                              { formId: this.id, dataKey: dataKey, step: 'populate_input_component_not_in_map' },
                                              `Internal error populating form input "${dataKey}" (component not managed).`,
                                              'history_populate_input_component_missing' // GA error code.
                                          );
                                      }

                               } catch (populateInputError) {
                                    // --- Handle Errors During Single Input Population ---
                                    // Catch any unexpected errors that occur *while processing a single `dataKey` or attempting to populate its corresponding input* within the `forEach` loop.
                                    // This provides robustness: an error with one input element's population process should not stop the entire process of populating other inputs from history.
                                   const currentDataKey = dataKey || 'N/A'; // Get the key defensively.
                                   this.#errorReporter.reportError(
                                       `${this.name}._handleHistoryItemClick - populate loop`, // Source indicating the loop stage.
                                       populateInputError, // The error object caught.
                                       { formId: this.id, keyAttempted: currentDataKey, valueAttempted: searchDataFromHistory ? searchDataFromHistory[currentDataKey] : 'N/A', step: 'populate_input_in_loop_execution' }, // Context.
                                       `Error populating form input "${currentDataKey}" from history item data. Process for this input failed.`, // User-friendly message template.
                                       'history_populate_input_exception' // GA error code for input population exception.
                                   );
                                   // Log the problematic data for this key.
                                    Logger.error(`_handleHistoryItemClick: Failed to populate input "${currentDataKey}" from history item:`, searchDataFromHistory ? searchDataFromHistory[currentDataKey] : 'N/A', { error: populateInputError });
                                   // Continue the `forEach` loop to the next input data key despite the error with the current one.
                               } // End of try...catch around single input population.
                           }); // End of `Object.keys(searchDataFromHistory).forEach` loop for populating inputs.


                           // --- Subsequent Actions After Population ---
                           // After all inputs have been iterated and population has been attempted for each:
                           // 1. Trigger form validation (`this.validate()`) to check if the data loaded from history is currently valid.
                           //    This is important because:
                           //    - The validation state (`_isValid`) of input components and the form needs to be updated based on the newly set values.
                           //    - Cross-field validation rules (e.g., check-out after check-in, total travelers) need to be run with the new data.
                           //    - Visual validation feedback (error messages below inputs) needs to be displayed if the loaded data is invalid according to current rules.
                           // 2. Optionally, you might choose to automatically trigger a new search by programmatically submitting the form (`this.#searchButton?.click()` or `this._element?.submit()`).

                           // Trigger form validation explicitly after populating inputs. Marked async because validate() is async if subclass overrides are async (not in InputComponent).
                           try {
                                Logger.debug(`${this.name}._handleHistoryItemClick: Triggering form validation after population.`);
                               // Call the form's public `validate()` method. This method orchestrates validation for all inputs and form-level checks.
                               this.validate(); // Executes `_validateForm()`. The result (true/false) updates `this._isValid`.
                                // The boolean result is not strictly needed here unless immediate conditional logic follows.
                           } catch (validationErrorAfterPopulation) {
                                // Catch any uncaught errors *within* the form's `validate()` method execution itself (less likely if validate has internal catches).
                                Logger.error(`${this.name}._handleHistoryItemClick: Error triggering form validation after population.`, validationErrorAfterPopulation);
                                // Errors specific to validation logic within `validate()` are reported by the reporter within that method.
                                // The ErrorReporter will handle displaying a message in the UI for these errors.
                           }

                           // Optional: Automatically submit the form after loading history data.
                           // This simulates the user clicking the Search button immediately after populating from history.
                           // Uncomment the lines below if you want auto-submission. Be aware of the UX implications (immediate new search, potentially bypassing manual review).
                           // if (this.#searchButton && !this.#searchButton.disabled) { // Check if button element exists and is not disabled.
                           //     Logger.info(`${this.name}._handleHistoryItemClick: Auto-submitting form after population.`);
                           //      // Delay the click slightly to allow validation feedback to be seen.
                           //      setTimeout(() => {
                           //           try {
                           //             this.#searchButton.click(); // Simulate clicking the button. This triggers the form's submit handler (_handleSubmit).
                           //           } catch (submitError) {
                           //               Logger.error(`${this.name}._handleHistoryItemClick: Error during auto-submission button click simulation:`, submitError);
                           //                this.#errorReporter.reportError(
                           //                     `${this.name}._handleHistoryItemClick`, submitError,
                           //                     { formId: this.id, step: 'auto_submit_click_exception' },
                           //                     `Error attempting to auto-submit form after history load.`, 'history_auto_submit_exception'
                           //                );
                           //           }
                           //      }, 100); // Short delay.
                           // } else {
                           //      Logger.debug(`${this.name}._handleHistoryItemClick: Auto-submission skipped. Button is missing or disabled.`);
                           // }

                           // Note: If auto-submitting, you might want to clear or update the history status message (`#historyStatusElement`) appropriately BEFORE initiating the submit/search process.

                           // Log the completion of the history item click handler execution.
                           Logger.debug(`${this.name}._handleHistoryItemClick async method execution finished.`);


                       } catch (handlerError) {
                           // --- Handle Any Unexpected Critical Errors During Overall Handler Execution ---
                           // This outer catch block acts as a final safety net for any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                           // that were not caught by the more specific try...catch blocks within (e.g., errors during initial setup steps, issues accessing services before validity checks if checks are buggy, errors during the try...catch structure around the loop).
                           Logger.error(`${this.name}._handleHistoryItemClick: CRITICAL UNEXPECTED ERROR caught during history item click handler execution!`, handlerError);

                           // Report this critical handler failure using the injected reporter.
                           this.#errorReporter.reportError(
                               `${this.name}._handleHistoryItemClick`, // Source of the error.
                               handlerError, // The error object caught.
                               { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context details.
                               `Error handling history item click for form "${this.name}". Operation interrupted due to internal issue.`, // User-facing message template for handler failure.
                               'history_item_click_handler_exception_overall' // GA error code for overall handler exception.
                           );

                           // Ensure any persistent "Clicked..." message in the main area is cleared if it was set early and not replaced by an error message itself.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                               const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                               // Check if element exists, contains the temporary CLICKED text (`AppConfig.MESSAGES.HISTORY_ITEM_CLICKED('', false)`), and does NOT have the error class (`w3-pale-red`).
                               if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.HISTORY_ITEM_CLICKED('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // If it's still the initial temporary message and not an error, clear it.
                                   this.#messageDisplay.clearMessage();
                                   Logger.debug(`${this.name}._handleHistoryItemClick: Cleared temporary message in main area due to handler error.`);
                                }
                           } else { Logger.debug(`${this.name}._handleHistoryItemClick: MessageDisplay service missing when trying to clear temporary message.`); } // Check if service exists.


                           // The history list itself (`#searchHistoryList`) and the form inputs might be in an inconsistent state if the error occurred partway through population.
                           // For simplicity in this demo, we don't attempt complex rollback or state correction here on handler error. A user might need to clear history and re-enter.

                           // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensure any lingering persistent "Processing..." message is cleared UNLESS it became an error message.
                           // Note: For history item click, we typically don't show a long "Processing" message, only the initial brief "Clicked".
                           // The primary 'finally' cleanup of persistent messages is handled in the main `searchHotels` method.
                           Logger.debug(`${this.name}._handleHistoryItemClick async method execution completed.`);
                       } // End of _handleHistoryItemClick try...catch...finally block.
                   } // End of _handleHistoryItemClick method definition.


                  /**
                   * Asynchronous handler for the "Clear History" button click. Marked as `async`.
                   * This method is triggered when the user clicks the button element identified by `#clearHistoryButton`.
                   * It orchestrates the process of clearing all stored search history items from the browser's IndexedDB database using the `IndexedDBService`.
                   * It performs necessary checks (service availability), displays UI messages (indicating progress, success, or failure), updates the history list display to show the result of the clearing operation, and updates the state of the "Clear History" button itself.
                   * @param {Event} event - The native DOM 'click' event object.
                   */
                  async _handleClearHistoryClick(event) {
                      try {
                           Logger.info(`${this.name}._handleClearHistoryClick: "Clear History" button clicked.`);
                           // Prevent the browser's default behavior for the button (if any) and stop event propagation up the DOM tree.
                           if (event?.preventDefault) event.preventDefault(); // Prevent default click action.
                          if (event?.stopPropagation) event?.stopPropagation(); // Stop event from bubbling up.

                          // Track a Google Analytics event indicating the "Clear History" button was clicked.
                          this.#gaTracker.trackEvent('button_click', { button_id: 'clear_history', form_id: this.id }); // GA Event.

                          // --- Check Dependencies ---
                          // Ensure the `IndexedDBService` instance (`this.#idbService`) is initialized and available before attempting to call its `clearSearchHistory` method.
                          if (!this.#idbService) {
                              const errorMsg = AppConfig.MESSAGES.HISTORY_SERVICE_MISSING + ' Cannot clear history.'; // Error message indicating service missing.
                              // Report this as a critical infrastructure error via the ErrorReporter.
                              this.#errorReporter.reportError(
                                  `${this.name}._handleClearHistoryClick`, new Error(errorMsg), // Source and error object.
                                  { component: this.#getComponentInfo(), formId: this.id, step: 'service_check_missing' }, errorMsg, 'history_service_missing_critical', 0 // GA error code and persistent message.
                              ); // Display persistent error message in main UI area.
                              // Update history status element if it's available to show the error message.
                              if (this.#historyStatusElement) this.#historyStatusElement.textContent = errorMsg; // Show message in status area.
                              // Button should ideally be disabled if service is missing (handled by `_updateGoogleServiceButtonState`).
                              return; // Exit async handler if service is missing.
                           } // End of service dependency check.


                           // --- Optional User Confirmation ---
                           // You might add a JavaScript `confirm()` dialog here to ask the user for confirmation
                           // before permanently deleting all their search history data from their browser.
                           // const confirmClear = confirm("Are you sure you want to clear ALL search history from this browser? This action cannot be undone.");
                           // if (!confirmClear) {
                           //      Logger.debug(`${this.name}._handleClearHistoryClick: User cancelled history clear operation.`);
                           //     // Optional: Display a brief cancellation message to the user temporarily.
                           //      if (this.#historyStatusElement) { // Check if status element exists.
                           //           this.#historyStatusElement.textContent = 'Clear history cancelled.';
                           //           // Clear any pending timer on status element before setting a new one.
                           //           if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                           //               clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                           //              delete this.#historyStatusElement.dataset.statusClearTimer; // Remove stored ID.
                           //            }
                           //            // Set a short timer to clear this temporary message.
                           //            if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) {
                           //                const statusClearTimerId = setTimeout(() => { if (this.#historyStatusElement && this.#historyStatusElement.textContent === 'Clear history cancelled.') this.#historyStatusElement.textContent = ''; if (this.#historyStatusElement) delete this.#historyStatusElement.dataset.statusClearTimer; }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Example clear after duration.
                           //                 this.#historyStatusElement.dataset.statusClearTimer = statusClearTimerId.toString(); // Store timer ID.
                           //            }
                           //       } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element is null for cancellation message.`); } // Check if element exists.
                           //      this.#gaTracker.trackEvent('history_clear_cancelled', { form_id: this.id, step: 'user_cancelled' }); // Track cancellation.
                           //      return; // Exit async handler if user cancels.
                           // } // End of optional confirmation check.


                           // --- Show Clearing State UI ---
                           // Update the history status element (`#historyStatusElement`) to indicate that the clearing operation is now in progress.
                           if (this.#historyStatusElement) { // Check if the status element exists.
                              this.#historyStatusElement.innerHTML = AppConfig.MESSAGES.PROCESSING('Clearing history'); // Show processing text + spinner icon markup.
                             Logger.debug(`${this.name}._handleClearHistoryClick: UI updated to show clearing status.`);
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for loading update.`); } // Check if status element exists.

                           // Disable the "Clear History" button (`#clearHistoryButton`) while the operation is in progress to prevent multiple simultaneous clears.
                           if (this.#clearHistoryButton) { // Check if the clear button element exists.
                               // Use a defensive check `disabled !== true` to avoid unnecessary DOM updates if the state is already correct.
                               if (this.#clearHistoryButton.disabled !== true) {
                                  this.#clearHistoryButton.disabled = true; // Disable the button.
                                  Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button disabled during clearing.`);
                               }
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); } // Check if button exists.


                           // Optionally clear the current history list display (`#searchHistoryList`) visually immediately (optimistic UI update).
                           // This makes the UI responsive while the actual IndexedDB operation happens asynchronously in the background.
                           if (this.#searchHistoryList) { // Check if the list element exists.
                                Logger.debug(`${this.name}._handleClearHistoryClick: Clearing history list UI visually (optimistic update).`);
                               this.#searchHistoryList.innerHTML = ''; // Clear existing list items HTML content.
                                // Add a temporary "Clearing..." message as a list item while the asynchronous clear is happening.
                                const clearingItem = document.createElement('li'); // Create a new list item element.
                               clearingItem.textContent = 'Clearing...'; // Set text content.
                               clearingItem.classList.add('w3-text-grey'); // Add styling class (grey text).
                                clearingItem.style.cursor = 'default'; // Make it non-clickable.
                                clearingItem.style.textAlign = 'center'; // Center text.
                                clearingItem.style.padding = '20px 16px'; // Add padding.
                               this.#searchHistoryList.appendChild(clearingItem); // Append the temporary clearing message item to the list.
                               Logger.debug(`${this.name}._handleClearHistoryClick: UI updated to show empty list with temporary clearing message.`);
                           } else { Logger.debug(`${this.name}._handleClearHistoryClick: Search history list element missing for optimistic update.`); } // Check if list element exists.

                           // Display a persistent message in the main UI message area indicating the clearing process has started.
                           // Use a persistent message (duration 0) so it stays visible throughout the asynchronous service call delay.
                           this.#messageDisplay.showMessage(AppConfig.MESSAGES.HISTORY_CLEAR_INIT, 'info', 0); // Set persistent processing message.
                            // Track a GA event for the start of the clearing process.
                            this.#gaTracker.trackEvent('history_clear_process_started', { form_id: this.id, step: 'started' }); // GA Event.


                           // --- Execute Clear History Operation in IndexedDB ---
                           // Call the asynchronous method (`clearSearchHistory`) on the `IndexedDBService` instance (`this.#idbService`) to perform the actual data deletion in the database.
                           // Use `await` to pause execution of this async handler until the Promise returned by `clearSearchHistory` resolves (successfully) or rejects (with an error).
                           Logger.debug(`${this.name}._handleClearHistoryClick: Calling IndexedDB service to execute clear history operation...`);
                            try {
                                 // The `clearSearchHistory` method on the simulated service returns a Promise. Await its resolution or rejection.
                                 // It's designed to throw/reject on errors during its execution or the simulated API call.
                                 await this.#idbService.clearSearchHistory(); // Await the async service method. Returns Promise<void>.
                                // If execution reaches here, the `clearSearchHistory` Promise resolved successfully.
                                Logger.info(`${this.name}._handleClearHistoryClick: IndexedDB search history cleared successfully by service operation.`);

                                // --- Handle Successful Clear ---
                                const successMessage = AppConfig.MESSAGES.HISTORY_CLEARED_SUCCESS; // Get the standard success message string.
                                // Update the main UI message area with a temporary success message.
                                this.#messageDisplay.showMessage(successMessage, 'success', AppConfig.MESSAGE_DISPLAY_DURATION_MS); // Show success message temporarily for the configured duration.

                                // Track a GA success event for the history clearing operation.
                                 this.#gaTracker.trackEvent('history_clear_success', { form_id: this.id, step: 'success' }); // GA Success Event.

                                 // Update the history status element (`#historyStatusElement`) to show a success message temporarily.
                                 if (this.#historyStatusElement) { // Check if the status element exists.
                                    this.#historyStatusElement.textContent = successMessage; // Set the success message text.
                                     // Remove any potential pending timer on status element before setting a new one.
                                     if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                         clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                        delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID.
                                     }
                                    // Set a short timer to clear this temporary status message if transient messages are configured (duration > 0).
                                     if (AppConfig.MESSAGE_DISPLAY_DURATION_MS > 0) { // Use the general message duration config for the status clearance timer.
                                          const statusClearTimerId = setTimeout(() => {
                                               // Inside the timeout callback, check if the status text *still* matches the success message *before clearing*.
                                               // This avoids clearing a newer status message (e.g., an error from a subsequent button click) that might have been displayed since this timer was set.
                                               if (this.#historyStatusElement && this.#historyStatusElement.textContent === successMessage) {
                                                   this.#historyStatusElement.textContent = ''; // Clear the status text content after the timeout.
                                                   Logger.debug(`${this.name}._handleClearHistoryClick: History status cleared by timer.`);
                                               }
                                                if (this.#historyStatusElement) delete this.#historyStatusElement.dataset.statusClearTimer; // Remove the stored ID from data attribute after clear attempt.
                                          }, AppConfig.MESSAGE_DISPLAY_DURATION_MS / 2); // Clear the status message after half the general message duration. Using half makes it clear before main messages disappear.
                                          if (this.#historyStatusElement) this.#historyStatusElement.dataset.statusClearTimer = statusClearTimerId.toString(); // Store the timer ID on the element's data attribute for future clearing.
                                      } // End if duration > 0 for timer setup.
                                 } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for success update.`); } // Check if status element exists.


                                 // Update the history list display (`#searchHistoryList`) to show the "empty" state message after clearing.
                                 // The list should already be empty visually due to the optimistic update done earlier, but ensure it has the final "empty" message item.
                                 if (this.#searchHistoryList) { // Check if the list element exists.
                                      Logger.debug(`${this.name}._handleClearHistoryClick: Updating history list UI to show empty state.`);
                                      this.#searchHistoryList.innerHTML = ''; // Ensure it's fully clear.
                                      const noHistoryItem = document.createElement('li'); // Create a new list item element for the message.
                                      noHistoryItem.textContent = AppConfig.MESSAGES.HISTORY_EMPTY; // Use the standard 'History Empty' message template.
                                      noHistoryItem.classList.add('w3-text-grey'); // Add styling class.
                                      noHistoryItem.style.cursor = 'default'; // Ensure it's not clickable.
                                      noHistoryItem.style.textAlign = 'center'; // Center text.
                                      noHistoryItem.style.padding = '20px 16px'; // Add padding.
                                     this.#searchHistoryList.appendChild(noHistoryItem); // Append the empty message item to the list.
                                  Logger.debug(`${this.name}._handleClearHistoryClick: UI updated to show empty history list message.`);
                               } else { Logger.debug(`${this.name}._handleClearHistoryClick: Search history list element missing for update.`); } // Check if list element exists.


                                // After successfully clearing history, the "Clear History" button should be disabled as the list is now empty.
                                if (this.#clearHistoryButton) { // Check if the clear button exists.
                                     // Use defensive check `disabled !== true`.
                                    if (this.#clearHistoryButton.disabled !== true) {
                                       this.#clearHistoryButton.disabled = true; // Disable the button.
                                       Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button disabled after successful clear.`);
                                    }
                                } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); } // Check if button exists.


                            } catch (idbError) {
                                // --- Handle IndexedDB Clearing Errors ---
                                // Catch any errors thrown (Promise rejections) by the IndexedDB service's `clearSearchHistory` method (e.g., due to database access issues, permissions being denied by the user, database corruption during clear, etc.).
                                Logger.error(`${this.name}._handleClearHistoryClick: Error caught from IndexedDB service clear call:`, idbError);

                                // Report the error using the injected ErrorReporter. This handles logging, potentially a main UI message, and GA tracking.
                                this.#errorReporter.reportError(
                                    `${this.name}._handleClearHistoryClick - idbClear`, // Source.
                                    idbError, // The error object from the service rejection.
                                    { component: this.#getComponentInfo(), formId: this.id, step: 'indexeddb_clear_history_execution' }, // Context.
                                    AppConfig.MESSAGES.HISTORY_CLEARED_FAILED(idbError.message || 'Unknown error during clear.'), // User-friendly message template, using the error's message.
                                    'history_clear_exception_api' // GA error code for errors during API interaction.
                                );
                                // The ErrorReporter handles displaying the persistent error message in the main area.

                                // Update history status element to show failure message persistently.
                                if (this.#historyStatusElement) { // Check if status element exists.
                                   this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_CLEARED_FAILED(idbError.message || 'Unknown error during clear.'); // Set persistent error message.
                                    // Remove any potential pending timer on status element if error happens during timer delay.
                                    if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                        clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                       delete this.#historyStatusElement.dataset.statusClearTimer; // Remove stored ID.
                                    }
                                } else { Logger.debug(`${this.name}._handleClearHistoryClick: History status element missing for error update.`);} // Check if status element exists.


                                // Ensure the "Clear History" button is enabled again so the user can try clearing again if the operation failed.
                                if (this.#clearHistoryButton) { // Check if button exists.
                                    // Use defensive check `disabled !== false`.
                                   if (this.#clearHistoryButton.disabled !== false) {
                                      this.#clearHistoryButton.disabled = false; // Enable the button on failure.
                                      Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button enabled on failure.`);
                                   }
                                } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); } // Check if button exists.

                                // The history list display will likely be in an inconsistent state (maybe showing 'Clearing...' or just empty) after a failed clear attempt.
                                // It might be best practice to attempt to reload the history list after a failed clear operation, to show the user what remains or what went wrong.
                                try {
                                     Logger.debug(`${this.name}._handleClearHistoryClick: Attempting to reload history after clear failure.`);
                                     // Call the history loading method again. It handles its own async process and UI updates.
                                     // Use `await` if `_loadAndDisplaySearchHistory` returns a Promise, though it's okay if this makes the handler linger briefly.
                                    this._loadAndDisplaySearchHistory(); // Call the async history loading method.
                                } catch (reloadErrorAfterClearFailure) {
                                     // Errors that occur *during the reload attempt itself* after clear failure are handled by the `_loadAndDisplaySearchHistory`'s own error handling.
                                    Logger.error(`${this.name}._handleClearHistoryClick: Error triggering history reload after clear failure.`, reloadErrorAfterClearFailure);
                                }


                            } // End of `catch (idbError)` block for clearing history.


                        } catch (handlerError) {
                            // --- Handle Critical Errors During Overall Handler Execution ---
                            // This outermost catch block catches any uncaught synchronous or asynchronous errors thrown *during the entire execution of this handler itself*
                            // (e.g., errors during the try...catch structure, accessing elements before service checks if checks are buggy, logic errors in the outer try block before main try...catch).
                            Logger.error(`${this.name}._handleClearHistoryClick: CRITICAL UNEXPECTED ERROR caught during history item click handler execution!`, handlerError);

                            // Report the error using the injected reporter.
                            this.#errorReporter.reportError(
                                `${this.name}._handleClearHistoryClick`, // Source of the error.
                                handlerError, // The error object caught.
                                { component: this.#getComponentInfo(), formId: this.id, step: 'handler_execution_overall_exception' }, // Context.
                                `Error handling "Clear History" button click for form "${this.name}". Operation interrupted due to internal issue.`, // User-facing message template for handler failure.
                                'history_clear_button_handler_exception_overall' // GA error code for overall handler exception.
                            );

                            // Ensure UI state is reset or updated appropriately to reflect the error state if something went wrong before the main logic completed.
                            // History status element: Update text and clear any pending timer.
                            if (this.#historyStatusElement) { // Check if status element exists.
                                this.#historyStatusElement.textContent = AppConfig.MESSAGES.HISTORY_CLEARED_FAILED('An internal error occurred during handler.');
                                // Clear potential pending timer.
                                 if (typeof this.#historyStatusElement.dataset.statusClearTimer !== 'undefined') {
                                     clearTimeout(parseInt(this.#historyStatusElement.dataset.statusClearTimer, 10));
                                    delete this.#historyStatusElement.dataset.statusClearTimer; // Remove stored ID.
                                 }
                            } else { Logger.warn(`${this.name}._handleClearHistoryClick: History status element is null when handling handler error.`); } // Check if status element exists.

                            // Clear history button: Ensure it's re-enabled on error.
                            if (this.#clearHistoryButton) { // Check if button exists.
                                if (this.#clearHistoryButton.disabled !== false) { // Check state defensively.
                                    this.#clearHistoryButton.disabled = false; // Enable the button on error.
                                    Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button enabled after handler error.`);
                                 }
                            } else { Logger.debug(`${this.name}._handleClearHistoryClick: "Clear History" button element missing.`); } // Check if button exists.

                            // History list: Clear the list UI in case of partial/corrupt data and show a generic error item.
                            if (this.#searchHistoryList) { // Check if list exists.
                                 Logger.error(`${this.name}._handleClearHistoryClick: Clearing history list UI due to error during handler execution.`);
                                 this.#searchHistoryList.innerHTML = ''; // Clear existing list items.
                                 // Add a generic error message item to the list.
                                 const errorItem = document.createElement('li'); // Create a new list item element.
                                errorItem.textContent = 'An error occurred while trying to clear history.'; // Error text content.
                                errorItem.classList.add('w3-text-red'); // Style as error text.
                                 errorItem.style.cursor = 'default'; errorItem.style.textAlign = 'center'; errorItem.style.padding = '20px 16px'; // Styling.
                                this.#searchHistoryList.appendChild(errorItem); // Add the error message item to the list.
                                Logger.debug(`${this.name}._handleClearHistoryClick: Added error message item to history list.`);
                            } else { Logger.warn(`${this.name}._handleClearHistoryClick: Search history list element is null when handling handler error.`); } // Check if list exists.


                           // Ensure the persistent message in the main area is cleared if it was set and not an error message itself.
                            if (this.#messageDisplay) { // Check if MessageDisplay exists.
                                const currentMessageElement = this.#messageDisplay.getElement(); // Get the display element reference.
                                // Check if element exists, contains the PROCESSING text (`AppConfig.MESSAGES.HISTORY_CLEAR_INIT`), and does NOT have the error class (`w3-pale-red`).
                                if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.HISTORY_CLEAR_INIT) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                    // If it's still the generic processing message and not an error, clear it.
                                    this.#messageDisplay.clearMessage();
                                    Logger.debug(`${this.name}._handleClearHistoryClick: Cleared persistent message in main area due to handler error.`);
                                 }
                            } else { Logger.debug(`${this.name}._handleClearHistoryClick: MessageDisplay service missing when trying to clear persistent message.`); } // Check if service exists.


                            // Do not re-throw from an async event handler's outer catch block. The error has been logged and reported.
                       } finally {
                           // This block always executes after the try/catch structure.
                           // Ensures cleanup or final status updates not explicitly covered occur.
                           // Ensure any lingering persistent "Processing..." message is cleared unless it became an error message.
                           if (this.#messageDisplay) { // Check if MessageDisplay service exists.
                              const currentMessageElement = this.#messageDisplay.getElement(); // Get element reference.
                              // If it's still displaying text related to PROCESSING and is NOT displaying an error (`w3-pale-red`)...
                              if (currentMessageElement && typeof currentMessageElement.textContent === 'string' && currentMessageElement.textContent.includes(AppConfig.MESSAGES.PROCESSING('', false)) && !currentMessageElement.classList.contains('w3-pale-red')) {
                                   // Clear the persistent message.
                                  this.#messageDisplay.clearMessage();
                                 Logger.debug(`${this.name}._handleClearHistoryClick: Cleared persistent message in finally.`);
                              } else if (currentMessageElement && currentMessageElement.classList.contains('w3-pale-red')) {
                                  // If it's displaying an error message, leave it.
                                  Logger.debug(`${this.name}._handleClearHistoryClick: Error message displayed, not clearing persistent message in finally.`);
                              }
                           } // Check if MessageDisplay exists.

                            // Ensure any spinner inside the status element is removed if it was added.
                           if (this.#historyStatusElement) { // Check if status element exists.
                               const statusSpinner = this.#historyStatusElement.querySelector('.w3-spin');
                                if (statusSpinner) statusSpinner.remove();
                           } // Check if status element exists.

                           Logger.debug(`${this.name}._handleClearHistoryClick async method execution completed.`);
                       } // End of _handleClearHistoryClick try...catch...finally block.
                   } // End of _handleClearHistoryClick method definition.


                  /**
                   * Override dispose method from `TravelComponent`.
                   * Cleans up resources managed by the `SearchForm` instance, including disposing
                   * of all managed input component instances, all initialized service instances,
                   * and clearing references to UI elements. This prevents memory leaks when the SearchForm
                   * instance is no longer needed (e.g., if the containing HTML section is removed).
                   */
                  dispose() {
                      try {
                          Logger.info(`${this.name}.dispose: Disposing SearchForm instance: ${this.name}. Starting cleanup.`);

                          // Step 1: Call the parent's `dispose` method first.
                          // This handles base cleanup like removing event listeners attached via `_addEventListener`
                          // to the main form element and other elements explicitly passed in options,
                          // and clears the main form element reference (`this._element`).
                          super.dispose(); // Removes form submit listener and button click listeners attached via _addEventListener.

                          // Step 2: Dispose of all managed InputComponent instances.
                          // Iterate through the stored map of input components (`this._inputs`).
                          // Use Object.values to get an array of component instances.
                          Object.values(this._inputs).forEach(component => {
                               try {
                                   // Check if the current item is a valid component instance and has a public `dispose` method.
                                    if (component && typeof component.dispose === 'function') {
                                        component.dispose(); // Call the dispose method on the input component instance.
                                        Logger.debug(`Dispose: Input component "${component.id || component.name || 'unknown'}" disposed.`);
                                     } else if (component) {
                                        // If the item is an object but not a component with dispose, log that its dispose was skipped.
                                        Logger.debug(`Dispose: Input component "${component.id || component.name || 'unknown'}" instance exists but has no dispose method. Skipping disposal.`);
                                    } else {
                                        // If the item in the map is null or not a valid object.
                                         Logger.warn(`Dispose: Found invalid item in _inputs map during disposal loop. Skipping disposal.`, { item: component });
                                    }
                               } catch (compDisposeError) {
                                    // Report errors that occur *while disposing a single input component* within the loop.
                                     // Use console.error here, as the ErrorReporter instance might be disposing soon itself or fail during final cleanup stages.
                                    console.error(`CRITICAL ERROR during disposal of input component "${component ? (component.id || component.name) : 'unknown'}":`, compDisposeError, { step: 'input_component_dispose_exception' });
                                    // Continue the loop despite the error with this component.
                               }
                          });
                          // After attempting to dispose all components in the map, clear the map itself.
                          this._inputs = {}; // Replace the map reference with an empty object.
                          Logger.debug(`Dispose: All managed input components disposal process completed.`);


                          // Step 3: Dispose of all service instances that were created by the SearchForm.
                          // Iterate through the services and check if they exist and have a `dispose` method, then call it.
                          // These services also need cleanup (e.g., closing IndexedDB connections, clearing internal state or timers).

                           // IndexedDB Service Dispose: Needs to close the database connection.
                           try {
                               if (this.#idbService && typeof this.#idbService.dispose === 'function') {
                                   this.#idbService.dispose(); // Call the dispose method.
                                   Logger.debug("Dispose: IndexedDB service disposed.");
                               } else if (this.#idbService) { Logger.debug("Dispose: IndexedDB service instance exists but has no dispose method."); }
                               this.#idbService = null; // Clear reference to the service instance.
                           } catch(disposeError) { Logger.error("Dispose: Error disposing IndexedDB service:", disposeError); }


                           // Simulated Google Identity Service Wrapper Dispose (simulated): Should clean up UI element references and potentially listeners.
                           try {
                               if (this.#googleAuthService && typeof this.#googleAuthService.dispose === 'function') {
                                   this.#googleAuthService.dispose(); // Call dispose.
                                   Logger.debug("Dispose: Simulated Google Auth service disposed.");
                               } else if (this.#googleAuthService) { Logger.debug("Dispose: Simulated Google Auth service instance exists but has no dispose method."); }
                               this.#googleAuthService = null; // Clear reference.
                           } catch(disposeError) { Logger.error("Dispose: Error disposing Simulated Google Auth service:", disposeError); }

                           // Simulated Google Calendar Service Dispose: Should clean up internal state/timers.
                            try {
                                if (this.#calendarService && typeof this.#calendarService.dispose === 'function') {
                                    this.#calendarService.dispose(); // Call dispose.
                                    Logger.debug("Dispose: Simulated Google Calendar service disposed.");
                                } else if (this.#calendarService) { Logger.debug("Dispose: Simulated Google Calendar service instance exists but has no dispose method."); }
                                this.#calendarService = null; // Clear reference.
                            } catch(disposeError) { Logger.error("Dispose: Error disposing Simulated Google Calendar service:", disposeError); }

                           // Simulated Google Email Service Dispose: Should clean up internal state/timers.
                           try {
                                if (this.#emailService && typeof this.#emailService.dispose === 'function') {
                                    this.#emailService.dispose(); // Call dispose.
                                    Logger.debug("Dispose: Simulated Google Email service disposed.");
                                } else if (this.#emailService) { Logger.debug("Dispose: Simulated Google Email service instance exists but has no dispose method."); }
                                this.#emailService = null; // Clear reference.
                            }
