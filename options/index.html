<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Comprehensive Vanilla JS Option Visualizer (Fetch, IndexedDB, Cache)</title>

    <!-- W3.CSS Framework -->
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <!-- Plotly.js via CDN -->
    <script src='https://cdn.plot.ly/plotly-latest.min.js'></script>

    <!-- Google Analytics Snippet (Replace G-XXXXXXXXXX with your actual Measurement ID) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-XXXXXXXXXX"></script>
    <script>
      // Initialize Google Analytics Data Layer and gtag function
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
      // Configure Google Analytics with your Measurement ID
      gtag('config', 'G-XXXXXXXXXX'); // <-- REPLACE THIS ID
      console.log("[Analytics] Google Analytics Snippet Initialized.");
    </script>

    <!-- Application Styles -->
    <style>
        /* General Typography & Layout */
        body, h1, h2, h3, h4, h5, h6 { font-family: "Segoe UI", Arial, sans-serif; }
        .main-content-area { transition: margin-left .4s; margin-left: 250px; /* Default margin for sidebar */ }
        #page-container { min-height: 100vh; display: flex; flex-direction: column; }
        #main-content-wrapper { flex: 1; } /* Ensure content pushes footer down */

        /* Responsive adjustments */
        @media (max-width: 992px) {
            .main-content-area { margin-left: 0; /* Remove margin when sidebar collapses */ }
            .main-content-area-padded-top { padding-top: 83px !important; /* Add padding for fixed top bar */}
        }

        /* Plotly Chart Container */
        .plotly-chart-container {
            width: 100%;
            min-height: 360px;
            margin-top: 20px;
            margin-bottom: 20px;
            border: 1px solid #d1d1d1;
            background-color: #f9f9f9;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }

        /* Strategy Panel Styling */
        .strategy-panel {
            margin-bottom: 30px;
            padding: 20px 28px !important;
            border-left: 4px solid #4CAF50; /* Accent border */
            background-color: #ffffff; /* Ensure white background */
        }
        .strategy-panel h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 8px;
        }
        .strategy-construction ul { list-style: disc; margin-left: 25px; margin-top: 8px; margin-bottom: 12px; padding-left: 0; } /* Reset padding */
        .strategy-construction li { margin-bottom: 5px; line-height: 1.5; }

        /* Specific Detail Sections Styling */
        .strategy-detail-section {
            font-size: 0.95em;
            color: #444;
            margin-top: 12px;
            padding-left: 15px;
            border-left: 3px solid #e0e0e0;
            background-color: #fafafa;
            padding: 8px 15px;
            margin-bottom: 10px;
        }
        .strategy-detail-section strong { color: #222; }

        .strategy-notes { font-style: italic; color: #555; }
        .strategy-example { font-style: italic; color: #555; margin-top: 15px; font-size: 0.9em; }

        /* Specific Backgrounds for 4-Leg Strategies */
        .strategy-panel[data-strategy-id^="iron-condor"] { background-color: #e7f3fe; border-left-color: #2196F3; }
        .strategy-panel[data-strategy-id^="iron-butterfly"] { background-color: #fff9e6; border-left-color: #FFC107; }
        .strategy-panel[data-strategy-id^="reverse-iron-condor"] { background-color: #ffebee; border-left-color: #f44336; }
        .strategy-panel[data-strategy-id^="reverse-iron-butterfly"] { background-color: #fff3e0; border-left-color: #ff9800; }
        .strategy-panel[data-strategy-id^="box-spread"] { background-color: #f5f5f5; border-left-color: #9e9e9e; }

        /* Loading / Status Messages */
        .status-message { text-align: center; padding: 20px; font-size: 1.1em; border-radius: 4px; margin: 20px; }
        .loading-message { background-color: #e3f2fd; color: #1e88e5; border: 1px solid #bbdefb; }
        .error-message { background-color: #ffebee; color: #c62828; border: 1px solid #ffcdd2; }
        .offline-message { background-color: #fff9c4; color: #f57f17; border: 1px solid #fff59d; }
        .info-message { background-color: #e8f5e9; color: #2e7d32; font-size: 0.9em; padding: 10px; margin-top: 5px; border: 1px solid #c8e6c9; }

        /* Navigation Styling */
        .nav-link.active { background-color: #e0e0e0 !important; color: #000 !important; font-weight: bold; border-left: 3px solid #4CAF50; }
        .w3-sidebar .w3-button { transition: background-color 0.2s ease; }
        .w3-sidebar .w3-button:hover:not(.active) { background-color: #f1f1f1 !important; }

        /* Utility Buttons */
        .action-button { margin-top: 15px; margin-right: 10px; }
        .content-container > h2 { margin-top: 0; } /* Adjust spacing for injected content */

        /* Footer Styling */
        #app-footer {
            padding: 16px;
            margin-top: 32px; /* Ensure space above footer */
            background-color: #f1f1f1; /* W3.CSS default light grey */
            text-align: center;
            opacity: 0.9;
            font-size: 0.9em;
            border-top: 1px solid #ddd;
        }
    </style>
</head>
<body>

<div id="page-container">
    <!-- Sidebar/Menu (W3.CSS Structure) -->
    <nav class="w3-sidebar w3-bar-block w3-white w3-collapse w3-top w3-card" style="z-index:3;width:250px;" id="mySidebar">
        <div class="w3-container w3-display-container w3-padding-16">
            <i id="closeMenuButton" class="fa fa-remove w3-hide-large w3-button w3-display-topright" title="Close Menu"></i>
            <h3 class="w3-wide"><b>OPTIONS</b></h3>
        </div>
        <!-- Sidebar links will be populated by JavaScript -->
        <div id="sidebarLinks" class="w3-padding-64 w3-large w3-text-grey" style="font-weight:bold">
            <!-- Example: <a href="#about" class="w3-bar-item w3-button nav-link">About</a> -->
        </div>
    </nav>

    <!-- Top menu on small screens -->
    <header class="w3-bar w3-top w3-hide-large w3-black w3-xlarge">
        <div class="w3-bar-item w3-padding-24 w3-wide">OPTIONS</div>
        <a href="javascript:void(0)" class="w3-bar-item w3-button w3-padding-24 w3-right" id="openMenuButton"><i class="fa fa-bars"></i></a>
    </header>

    <!-- Overlay effect when opening sidebar on small screens -->
    <div class="w3-overlay w3-hide-large" style="cursor:pointer" title="close side menu" id="myOverlay"></div>

    <!-- !PAGE CONTENT! -->
    <div id="main-content-wrapper" class="main-content-area">

        <!-- Push down content on small screens -->
        <div class="w3-hide-large" style="margin-top:83px"></div>

        <!-- Top header -->
        <header class="w3-container w3-xlarge w3-padding-24">
            <span class="w3-left">Option Strategy Visualizer (Vanilla JS)</span>
            <!-- Status Indicators will be added here by JS -->
            <span id="statusIndicators" class="w3-right w3-medium"></span>
        </header>

        <!-- Main Content Area (Populated by JS) -->
        <div class="w3-container">
            <!-- Refresh Button -->
            <button id="refreshDataButton" class="w3-button w3-blue w3-small action-button" title="Fetch fresh data">
                <i class="fa fa-refresh"></i> Refresh Data
            </button>
            <span id="lastUpdated" class="w3-small w3-text-grey"></span>

             <!-- Status Message Area -->
             <div id="statusMessageArea"></div>

             <!-- Dynamic Content Container -->
            <div id="contentContainer" class="w3-container w3-padding-32">
                <!-- Content (About section, Strategy sections) will be injected here -->
            </div>
        </div>

    </div> <!-- End main-content-wrapper -->

    <!-- Footer -->
    <footer id="app-footer">
        <p>Disclaimer: Educational purposes only. Option trading involves risk. Consult a professional.</p>
        <p>Data persistence via IndexedDB & Cache API. Analytics via Google Analytics (if configured).</p>
    </footer>

</div> <!-- End page-container -->


    <!-- ============================================================ -->
    <!-- Main Vanilla JavaScript Application Logic                    -->
    <!-- ============================================================ -->
    <script>
        /**
         * ------------------------------------------------------------------------
         * Application State Variables
         * ------------------------------------------------------------------------
         * These variables hold the current state of the application, similar to
         * what React's state hooks would manage.
         */
        let appState = {
            currentSection: 'about',        // ID of the currently displayed section ('about', 'oneLeg', etc.)
            strategyData: null,             // Holds the parsed strategy data from JSON/DB/Cache
            isLoading: true,                // Flag indicating if data is currently being loaded
            error: null,                    // Holds any error message string to display
            isOffline: !navigator.onLine,   // Tracks the current network connection status
            dbConnection: null,             // Holds the active IndexedDB database connection
            dataSource: null,               // Tracks where the data was loaded from ('Network', 'IndexedDB', 'Cache', 'Initial')
            lastFetchTimestamp: null        // Timestamp of the last successful fetch attempt
        };

        /**
         * ------------------------------------------------------------------------
         * DOM Element References
         * ------------------------------------------------------------------------
         * Caching references to frequently accessed DOM elements for performance.
         */
        const DOM = {
            sidebar: document.getElementById('mySidebar'),
            sidebarLinks: document.getElementById('sidebarLinks'),
            overlay: document.getElementById('myOverlay'),
            closeMenuButton: document.getElementById('closeMenuButton'),
            openMenuButton: document.getElementById('openMenuButton'),
            contentContainer: document.getElementById('contentContainer'),
            statusMessageArea: document.getElementById('statusMessageArea'),
            statusIndicators: document.getElementById('statusIndicators'),
            refreshDataButton: document.getElementById('refreshDataButton'),
            lastUpdated: document.getElementById('lastUpdated'),
            mainContentArea: document.querySelector('.main-content-area') // Used for responsive padding
        };

        /**
         * ------------------------------------------------------------------------
         * Application Constants
         * ------------------------------------------------------------------------
         */
        const DB_NAME = 'optionStrategyDB_Vanilla_v1'; // Database name specific to this version
        const DB_VERSION = 1;                          // Database version
        const STORE_NAME = 'strategyStore_v1';         // Object store name
        const DATA_KEY = 'allStrategiesDataBlob';      // Key for storing the entire data blob in IDB
        const CACHE_NAME = 'option-strategy-cache-vanilla-v1'; // Cache Storage name
        const STRATEGIES_JSON_URL = 'strategies.json'; // URL to fetch strategy data

        /**
         * ------------------------------------------------------------------------
         * Logging Helper
         * ------------------------------------------------------------------------
         * Provides prefixed console logging for easier debugging.
         */
        const logger = {
            log: (...args) => console.log('[App Log]', ...args),
            warn: (...args) => console.warn('[App Warn]', ...args),
            error: (...args) => console.error('[App Error]', ...args),
            info: (...args) => console.info('[App Info]', ...args)
        };

        /**
         * ========================================================================
         * IndexedDB Utility Functions (Promise-based)
         * ========================================================================
         */

        /** Opens and potentially upgrades the IndexedDB. */
        function openDB() {
            return new Promise((resolve, reject) => {
                logger.log(`Opening IndexedDB: ${DB_NAME} (v${DB_VERSION})`);
                if (!window.indexedDB) {
                     logger.error("IndexedDB not supported by this browser.");
                     return reject("IndexedDB not supported.");
                }
                const request = indexedDB.open(DB_NAME, DB_VERSION);
                request.onerror = (event) => {
                    logger.error("IndexedDB connection error:", event.target.error);
                    reject(`IndexedDB error: ${event.target.error?.message || 'Unknown error'}`);
                };
                request.onsuccess = (event) => {
                    logger.log("IndexedDB connection successful.");
                    appState.dbConnection = event.target.result; // Store connection globally
                    resolve(appState.dbConnection);
                };
                request.onupgradeneeded = (event) => {
                    logger.info("IndexedDB upgrade needed.");
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains(STORE_NAME)) {
                        logger.log(`Creating Object Store: ${STORE_NAME}`);
                        db.createObjectStore(STORE_NAME); // Store entire blob, no keyPath needed
                    }
                    logger.info("IndexedDB upgrade complete.");
                };
            });
        }

        /** Saves the entire strategy data object to IndexedDB. */
        function saveDataToDB(data) {
             return new Promise(async (resolve, reject) => { // Make async to await openDB if needed
                if (!appState.dbConnection) {
                    logger.warn("No active DB connection, attempting to open...");
                    try {
                         await openDB(); // Ensure connection is established
                         if (!appState.dbConnection) throw new Error("Failed to re-open DB connection.");
                    } catch (dbErr) {
                        return reject(`Cannot save data, DB connection failed: ${dbErr}`);
                    }
                }
                if (!data || typeof data !== 'object' || Object.keys(data).length === 0) {
                    return reject("Invalid or empty data provided to saveDataToDB.");
                }

                try {
                    const transaction = appState.dbConnection.transaction([STORE_NAME], 'readwrite');
                    const store = transaction.objectStore(STORE_NAME);
                    logger.log(`Attempting to save data under key: ${DATA_KEY}`);
                    const request = store.put(data, DATA_KEY); // Store data using the predefined key

                    request.onsuccess = () => resolve(`Data successfully saved to IndexedDB.`);
                    request.onerror = (event) => reject(`Failed to save data to IndexedDB: ${event.target.error}`);
                    transaction.oncomplete = () => logger.log('IndexedDB save transaction completed.');
                    transaction.onerror = (event) => logger.error(`IndexedDB save transaction error: ${event.target.error}`);
                } catch (e) {
                    logger.error("Error initiating IndexedDB save transaction:", e);
                    reject(`IndexedDB transaction error: ${e.message}`);
                }
             });
        }

        /** Loads the strategy data object from IndexedDB. */
        function loadDataFromDB() {
            return new Promise(async (resolve, reject) => { // Make async for potential openDB call
                if (!appState.dbConnection) {
                    logger.warn("No active DB connection for loading, attempting to open...");
                     try {
                         await openDB();
                         if (!appState.dbConnection) throw new Error("Failed to re-open DB connection for loading.");
                     } catch (dbErr) {
                         return reject(`Cannot load data, DB connection failed: ${dbErr}`);
                     }
                }
                try {
                    const transaction = appState.dbConnection.transaction([STORE_NAME], 'readonly');
                    const store = transaction.objectStore(STORE_NAME);
                    logger.log(`Attempting to load data from IndexedDB using key: ${DATA_KEY}`);
                    const request = store.get(DATA_KEY);

                    request.onsuccess = (event) => {
                        if (event.target.result) {
                            logger.log("Data found in IndexedDB.");
                            resolve(event.target.result);
                        } else {
                            logger.log("No data found in IndexedDB for the key.");
                            resolve(null);
                        }
                    };
                    request.onerror = (event) => reject(`Failed to load data from IndexedDB: ${event.target.error}`);
                } catch (e) {
                     logger.error("Error initiating IndexedDB load transaction:", e);
                     reject(`IndexedDB transaction error: ${e.message}`);
                }
            });
        }

        /**
         * ========================================================================
         * Cache Storage API Utility Functions
         * ========================================================================
         */

        /** Caches the fetched data response using the Cache Storage API. */
         async function cacheDataResponse(url, data) {
            if (!('caches' in window)) {
                logger.warn("Cache Storage API not supported.");
                return;
            }
            try {
                const cache = await caches.open(CACHE_NAME);
                const responseToCache = new Response(JSON.stringify(data), {
                    headers: { 'Content-Type': 'application/json', 'X-Cached-Timestamp': Date.now() } // Add timestamp header
                });
                await cache.put(url, responseToCache);
                logger.log(`Data for ${url} successfully stored in Cache Storage.`);
            } catch (error) {
                logger.error('Failed to cache data response:', error);
            }
        }

        /** Attempts to retrieve data from the Cache Storage API. */
         async function loadDataFromCache(url) {
             if (!('caches' in window)) {
                 logger.warn("Cache Storage API not supported.");
                 return null;
             }
             try {
                 const cache = await caches.open(CACHE_NAME);
                 const cachedResponse = await cache.match(url);
                 if (cachedResponse) {
                     logger.log(`Data found in Cache Storage for ${url}.`);
                     // Optional: Check cache freshness based on X-Cached-Timestamp header if needed
                     // const timestamp = cachedResponse.headers.get('X-Cached-Timestamp');
                     // if (timestamp && (Date.now() - parseInt(timestamp)) > YOUR_EXPIRY_TIME) { ... handle stale }
                     const data = await cachedResponse.json();
                     return data;
                 } else {
                     logger.log(`No data found in Cache Storage for ${url}.`);
                     return null;
                 }
             } catch (error) {
                 logger.error(`Error loading data from Cache Storage for ${url}:`, error);
                 return null; // Treat cache error as cache miss
             }
         }

        /**
         * ========================================================================
         * Plotly Charting Functions
         * ========================================================================
         */

        /** Calculates Profit/Loss for a single option leg */
        function calculateLegPayoff(price, type, position, strike, premium) {
            let intrinsicValue = 0;
            type = type.toLowerCase(); position = position.toLowerCase();
            if (type === 'call') intrinsicValue = Math.max(0, price - strike);
            else if (type === 'put') intrinsicValue = Math.max(0, strike - price);
            if (position === 'long') return intrinsicValue - premium;
            else return -intrinsicValue + premium;
        }

        /** Generates an array of prices for the X-axis */
        function generatePriceRange(center, rangePct = 0.3, steps = 100) {
            const range = center * rangePct;
            const minP = Math.max(0.01, center - range);
            const maxP = center + range;
            const step = (maxP - minP) / steps;
            return Array.from({ length: steps + 1 }, (_, i) => minP + i * step);
        }

        /** Creates a standard Plotly layout object */
        function getPlotlyLayout(title) {
            return {
                title: { text: title, font: { size: 16, family: 'Segoe UI, Arial, sans-serif' } },
                xaxis: { title: 'Underlying Price @ Expiration', zeroline: true, gridcolor: '#efefef' },
                yaxis: { title: 'Profit / Loss ($)', zeroline: true, gridcolor: '#efefef', tickformat: '$,.2f' },
                showlegend: false,
                margin: { l: 70, r: 30, b: 50, t: 60, pad: 4 },
                hovermode: 'x unified',
                paper_bgcolor: '#f9f9f9', plot_bgcolor: '#f9f9f9'
            };
        }

        // --- Dictionary mapping JSON function names to JS implementations ---
        const plotFunctions = {
            /** Plots a single long/short call/put */
            plotBasicOption: (params) => {
                const { type, position, strike, premium } = params;
                const prices = generatePriceRange(strike);
                const profits = prices.map(price => calculateLegPayoff(price, type, position, strike, premium));
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines',
                                line: { color: position === 'long' ? (type === 'call' ? 'green' : 'blue') : 'red', width: 2.5 } };
                const posText = position.charAt(0).toUpperCase() + position.slice(1);
                const typeText = type.charAt(0).toUpperCase() + type.slice(1);
                const title = `${posText} ${strike} ${typeText} (Premium: ${premium.toFixed(2)})`;
                return { trace, title };
            },
            /** Plots vertical debit/credit spreads */
            plotVerticalSpread: (params) => {
                const { type, position, strike1, strike2, premium1, premium2 } = params;
                 const lowerK = Math.min(strike1, strike2), higherK = Math.max(strike1, strike2);
                 const lowerP = (strike1 === lowerK) ? premium1 : premium2;
                 const higherP = (strike1 === higherK) ? premium1 : premium2;
                 const prices = generatePriceRange((lowerK + higherK) / 2);
                 let profits, netCost, titlePrefix;
                 if (position === 'debit') { // Bull Call or Bear Put
                     const longK = (type === 'call') ? lowerK : higherK; const shortK = (type === 'call') ? higherK : lowerK;
                     const longP = (type === 'call') ? lowerP : higherP; const shortP = (type === 'call') ? higherP : lowerP;
                     netCost = longP - shortP;
                     profits = prices.map(price => calculateLegPayoff(price, type, 'long', longK, longP) + calculateLegPayoff(price, type, 'short', shortK, shortP));
                     titlePrefix = (type === 'call' ? "Bull Call Spread" : "Bear Put Spread");
                 } else { // Credit: Bear Call or Bull Put
                     const shortK = (type === 'call') ? lowerK : higherK; const longK = (type === 'call') ? higherK : lowerK;
                     const shortP = (type === 'call') ? lowerP : higherP; const longP = (type === 'call') ? higherP : lowerP;
                     netCost = longP - shortP; // Negative means credit
                     profits = prices.map(price => calculateLegPayoff(price, type, 'short', shortK, shortP) + calculateLegPayoff(price, type, 'long', longK, longP));
                     titlePrefix = (type === 'call' ? "Bear Call Spread" : "Bull Put Spread");
                 }
                 const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: 'purple', width: 2.5 } };
                 const costType = netCost >= 0 ? 'Debit' : 'Credit';
                 const title = `${titlePrefix} ${lowerK}/${higherK} (${costType}: ${Math.abs(netCost).toFixed(2)})`;
                 return { trace, title };
            },
            /** Plots Long Call/Put Butterfly */
            plotButterfly: (params) => {
                const { type, strike1, strike2, strike3, premium1, premium2, premium3 } = params;
                const netDebit = premium1 - (2 * premium2) + premium3;
                const prices = generatePriceRange(strike2);
                const profits = prices.map(p =>
                    calculateLegPayoff(p, type, 'long', strike1, premium1) +
                    (2 * calculateLegPayoff(p, type, 'short', strike2, premium2)) +
                    calculateLegPayoff(p, type, 'long', strike3, premium3)
                );
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: 'orange', width: 2.5 } };
                const typeText = type.charAt(0).toUpperCase() + type.slice(1);
                const title = `Long ${typeText} Butterfly ${strike1}/${strike2}/${strike3} (Debit: ${netDebit.toFixed(2)})`;
                return { trace, title };
            },
             /** Plots Standard (Short) Iron Condor */
             plotIronCondor: (params) => {
                 const { strikeP1, strikeP2, strikeC3, strikeC4, premiumP1, premiumP2, premiumC3, premiumC4 } = params;
                 const netCredit = premiumP2 + premiumC3 - premiumP1 - premiumC4;
                 const prices = generatePriceRange((strikeP2 + strikeC3) / 2);
                 const profits = prices.map(p =>
                     calculateLegPayoff(p, 'put', 'long', strikeP1, premiumP1) + calculateLegPayoff(p, 'put', 'short', strikeP2, premiumP2) +
                     calculateLegPayoff(p, 'call', 'short', strikeC3, premiumC3) + calculateLegPayoff(p, 'call', 'long', strikeC4, premiumC4)
                 );
                 const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: '#007bff', width: 2.5 } };
                 const title = `Iron Condor ${strikeP1}/${strikeP2}P ${strikeC3}/${strikeC4}C (Credit: ${netCredit.toFixed(2)})`;
                 return { trace, title };
             },
             /** Plots Standard (Short) Iron Butterfly */
             plotIronButterfly: (params) => {
                const { strikeP1, strikePC2, strikeC3, premiumP1, premiumP2, premiumC2, premiumC3 } = params;
                const netCredit = premiumP2 + premiumC2 - premiumP1 - premiumC3;
                const prices = generatePriceRange(strikePC2);
                const profits = prices.map(p =>
                    calculateLegPayoff(p, 'put', 'long', strikeP1, premiumP1) + calculateLegPayoff(p, 'put', 'short', strikePC2, premiumP2) +
                    calculateLegPayoff(p, 'call', 'short', strikePC2, premiumC2) + calculateLegPayoff(p, 'call', 'long', strikeC3, premiumC3)
                );
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: '#ffc107', width: 2.5 } };
                const title = `Iron Butterfly ${strikeP1}P / ${strikePC2}PC / ${strikeC3}C (Credit: ${netCredit.toFixed(2)})`;
                return { trace, title };
             },
             /** Plots Reverse (Long) Iron Condor */
            plotReverseIronCondor: (params) => {
                const { strikeP1, strikeP2, strikeC3, strikeC4, premiumP1, premiumP2, premiumC3, premiumC4 } = params;
                const netDebit = premiumP2 + premiumC3 - premiumP1 - premiumC4;
                const prices = generatePriceRange((strikeP2 + strikeC3) / 2);
                const profits = prices.map(p =>
                    calculateLegPayoff(p, 'put', 'short', strikeP1, premiumP1) + calculateLegPayoff(p, 'put', 'long', strikeP2, premiumP2) +
                    calculateLegPayoff(p, 'call', 'long', strikeC3, premiumC3) + calculateLegPayoff(p, 'call', 'short', strikeC4, premiumC4)
                );
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: '#dc3545', width: 2.5 } };
                const title = `Reverse Iron Condor ${strikeP1}/${strikeP2}P ${strikeC3}/${strikeC4}C (Debit: ${netDebit.toFixed(2)})`;
                return { trace, title };
            },
             /** Plots Reverse (Long) Iron Butterfly */
             plotReverseIronButterfly: (params) => {
                 const { strikeP1, strikePC2, strikeC3, premiumP1, premiumP2, premiumC2, premiumC3 } = params;
                 const netDebit = premiumP2 + premiumC2 - premiumP1 - premiumC3;
                 const prices = generatePriceRange(strikePC2);
                 const profits = prices.map(p =>
                     calculateLegPayoff(p, 'put', 'short', strikeP1, premiumP1) + calculateLegPayoff(p, 'put', 'long', strikePC2, premiumP2) +
                     calculateLegPayoff(p, 'call', 'long', strikePC2, premiumC2) + calculateLegPayoff(p, 'call', 'short', strikeC3, premiumC3)
                 );
                 const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: '#fd7e14', width: 2.5 } };
                 const title = `Reverse Iron Butterfly ${strikeP1}P / ${strikePC2}PC / ${strikeC3}C (Debit: ${netDebit.toFixed(2)})`;
                 return { trace, title };
             },
            /** Plots Long Straddle/Strangle */
            plotStraddleStrangle: (params) => {
                const { type, strikeP, strikeC, premiumP, premiumC } = params;
                const centerPrice = (strikeP + strikeC) / 2;
                const prices = generatePriceRange(centerPrice, 0.4);
                const netDebit = premiumP + premiumC;
                const profits = prices.map(p => calculateLegPayoff(p, 'put', 'long', strikeP, premiumP) + calculateLegPayoff(p, 'call', 'long', strikeC, premiumC));
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: '#6f42c1', width: 2.5 } };
                const titlePrefix = type === 'straddle' ? "Long Straddle" : "Long Strangle";
                const strikeText = type === 'straddle' ? strikeP : `${strikeP}P / ${strikeC}C`;
                const title = `${titlePrefix} ${strikeText} (Debit: ${netDebit.toFixed(2)})`;
                return { trace, title };
            },
             /** Plots Box Spread */
             plotBoxSpread: (params) => {
                const { strike1, strike2, premC1, premC2, premP1, premP2 } = params;
                const netDebit = premC1 - premC2 + premP2 - premP1;
                const valueAtExpiry = strike2 - strike1;
                const lockedInProfit = valueAtExpiry - netDebit;
                const prices = generatePriceRange(strike1 + (strike2-strike1)/2, 0.5);
                const profits = prices.map(p => lockedInProfit); // Constant profit
                const trace = { x: prices, y: profits, type: 'scatter', mode: 'lines', line: { color: 'grey', width: 2.5, dash: 'dash' } };
                const title = `Box Spread ${strike1}/${strike2} (P/L: ${lockedInProfit.toFixed(2)})`;
                return { trace, title };
            },
        }; // End plotFunctions map

        /**
         * ========================================================================
         * DOM Manipulation and Rendering Functions
         * ========================================================================
         */

         /** Clears the main content area and status messages. */
        function clearContentAreas() {
            DOM.contentContainer.innerHTML = '';
            DOM.statusMessageArea.innerHTML = '';
             // Ensure Plotly charts in the previous view are removed from memory
             const charts = DOM.contentContainer.querySelectorAll('.plotly-chart-container');
             charts.forEach(chartDiv => {
                 if (chartDiv._fullLayout && typeof Plotly !== 'undefined') { // Check if it's a Plotly div
                     try {
                         Plotly.purge(chartDiv);
                         logger.log(`Purged Plotly chart: ${chartDiv.id}`);
                     } catch (e) {
                         logger.error(`Error purging Plotly chart ${chartDiv.id}:`, e);
                     }
                 }
             });
        }

        /** Updates the status message area (loading, error, offline). */
        function updateStatusMessage() {
            DOM.statusMessageArea.innerHTML = ''; // Clear previous messages
            let message = '';
            let className = 'status-message';

            if (appState.isLoading) {
                message = 'Loading Strategy Data... Please wait.';
                className += ' loading-message';
            } else if (appState.error) {
                message = `Error: ${appState.error}`;
                className += ' error-message';
            } else if (appState.isOffline && !appState.strategyData) {
                 // Show offline message only if offline AND no data could be loaded
                message = 'Application is offline and no cached data is available.';
                className += ' offline-message';
            } else if (!appState.strategyData) {
                 // Generic message if not loading, no error, but still no data
                 message = 'No strategy data could be loaded.';
                 className += ' error-message'; // Treat as an error state
            }


            if (message) {
                const msgDiv = document.createElement('div');
                msgDiv.className = className;
                msgDiv.textContent = message;
                DOM.statusMessageArea.appendChild(msgDiv);
            }
        }

        /** Updates the status indicators in the header (Offline, Data Source). */
        function updateStatusIndicators() {
            DOM.statusIndicators.innerHTML = ''; // Clear existing
            let indicatorsHTML = '';
            if (appState.dataSource) {
                const color = appState.dataSource === 'Network' ? 'w3-green' : 'w3-blue';
                indicatorsHTML += `<span class="w3-tag w3-round ${color}">Data: ${appState.dataSource}</span>`;
            }
            if (appState.isOffline) {
                indicatorsHTML += `<span class="w3-tag w3-round w3-orange w3-margin-left">Offline</span>`;
            }
            DOM.statusIndicators.innerHTML = indicatorsHTML;
        }

        /** Renders the sidebar navigation links based on available data keys. */
        function renderSidebarLinks() {
            DOM.sidebarLinks.innerHTML = ''; // Clear existing links
            const sectionTitles = { about: 'About', oneLeg: '1-Leg', twoLeg: '2-Leg', threeLeg: '3-Leg', fourLeg: '4-Leg' };
            const keys = appState.strategyData ? Object.keys(appState.strategyData) : [];
            const validKeys = ['about', ...keys.filter(key => key !== 'about' && sectionTitles[key])];

            validKeys.forEach(key => {
                if (sectionTitles[key]) {
                    const link = document.createElement('a');
                    link.href = `#${key}`;
                    link.className = 'w3-bar-item w3-button nav-link';
                    link.textContent = `${sectionTitles[key]} Strategies`;
                    link.dataset.section = key; // Store section key in data attribute
                    link.title = `Navigate to ${sectionTitles[key]} Strategies`;
                    if (key === appState.currentSection) {
                        link.classList.add('active');
                    }
                    // Add click listener directly - simpler than delegation for few items
                    link.addEventListener('click', handleNavLinkClick);
                    DOM.sidebarLinks.appendChild(link);
                }
            });
        }

         /** Renders the content for the 'About' section. */
        function renderAboutSection() {
            clearContentAreas();
            if (!appState.strategyData?.about) {
                 DOM.contentContainer.innerHTML = '<p class="error-message">About content not available.</p>';
                 return;
            }
            const aboutData = appState.strategyData.about;
            let aboutHTML = `<h2>${aboutData.title || 'About This Visualizer'}</h2>`;
            aboutData.content?.forEach(paragraph => {
                // IMPORTANT: Only use innerHTML if the source (your JSON) is trusted.
                // For untrusted sources, sanitize the HTML first.
                aboutHTML += `<p>${paragraph}</p>`;
            });
            DOM.contentContainer.innerHTML = aboutHTML;
        }

        /** Renders a section containing multiple strategy details. */
        function renderStrategySection(sectionKey) {
            clearContentAreas();
            const sectionTitles = { oneLeg: '1-Leg', twoLeg: '2-Leg', threeLeg: '3-Leg', fourLeg: '4-Leg' };
            const sectionDescriptions = {
                 oneLeg: 'Strategies involving a single option contract (a single leg). These are the fundamental building blocks.',
                 twoLeg: 'Strategies combining two different option contracts on the same underlying. Often used to define risk, reduce cost, or express a specific market view (e.g., spreads, straddles, strangles).',
                 threeLeg: 'Strategies involving three option contracts, typically used for more complex market outlooks like neutral ranges with defined risk (e.g., butterflies).',
                 fourLeg: 'Advanced strategies using four option contracts, commonly employed for range-bound (neutral) markets or volatility plays, often with defined risk and reward (e.g., condors, iron butterflies, box spreads).'
             };

             const title = `${sectionTitles[sectionKey] || 'Unknown'} Strategies`;
             const description = sectionDescriptions[sectionKey];
             const strategies = appState.strategyData ? (appState.strategyData[sectionKey] || []) : [];

             // Create container elements
             const titleElement = document.createElement('h2');
             titleElement.textContent = title;
             DOM.contentContainer.appendChild(titleElement);

             if (description) {
                 const descElement = document.createElement('p');
                 descElement.textContent = description;
                 DOM.contentContainer.appendChild(descElement);
             }

             if (strategies.length > 0) {
                 strategies.forEach(strategy => {
                     const detailPanel = createStrategyDetailPanel(strategy);
                     DOM.contentContainer.appendChild(detailPanel);
                     // Trigger Plotly rendering *after* the panel is added to the DOM
                     if (strategy.plotlyDivId && strategy.plotFunction && strategy.parameters && plotFunctions[strategy.plotFunction]) {
                          try {
                              const plotContainer = detailPanel.querySelector(`#${strategy.plotlyDivId}`);
                              if (plotContainer) {
                                 const { trace, title: plotTitle } = plotFunctions[strategy.plotFunction](strategy.parameters);
                                 const layout = getPlotlyLayout(plotTitle);
                                 if (typeof Plotly !== 'undefined') {
                                     Plotly.newPlot(plotContainer, [trace], layout, { responsive: true });
                                     logger.log(`Rendered Plotly chart: ${strategy.plotlyDivId}`);
                                 } else {
                                     logger.warn(`Plotly library not loaded, cannot render chart ${strategy.plotlyDivId}`);
                                     plotContainer.innerHTML = '<p class="error-message">Plotly library failed to load.</p>';
                                 }
                              } else {
                                  logger.warn(`Plotly container #${strategy.plotlyDivId} not found in rendered panel.`);
                              }
                          } catch (plotError) {
                              logger.error(`Error rendering Plotly chart ${strategy.plotlyDivId}:`, plotError);
                               const plotContainer = detailPanel.querySelector(`#${strategy.plotlyDivId}`);
                               if(plotContainer) plotContainer.innerHTML = `<p class="error-message">Error rendering chart: ${plotError.message}</p>`;
                          }
                     }
                 });
             } else {
                 const infoMsg = document.createElement('p');
                 infoMsg.className = 'info-message';
                 infoMsg.textContent = 'No specific strategies loaded for this section.';
                 DOM.contentContainer.appendChild(infoMsg);
             }
        }

        /** Creates the HTML elements for a single strategy's detail panel. */
        function createStrategyDetailPanel(strategy) {
            const panel = document.createElement('div');
            panel.className = 'w3-panel w3-card-4 strategy-panel';
            panel.dataset.strategyId = strategy.id || strategy.name; // Use ID if available

            // Helper to create a paragraph with optional strong title
            const createDetailPara = (content, title = null) => {
                if (!content) return '';
                const p = document.createElement('p');
                 if (title) {
                     const strong = document.createElement('strong');
                     strong.textContent = `${title}: `;
                     p.appendChild(strong);
                 }
                 // Append content - handle potential HTML safely if needed later
                 p.appendChild(document.createTextNode(content));
                 return p.outerHTML;
            };

             // Helper to create list section
             const createListSection = (items, title) => {
                 if (!items || items.length === 0) return '';
                 let listHTML = `<div class="strategy-detail-section"><strong>${title}:</strong><ul>`;
                 items.forEach(item => { listHTML += `<li>${item}</li>`; });
                 listHTML += `</ul></div>`;
                 return listHTML;
             };

            // Build panel content - using template literal for structure
            panel.innerHTML = `
                <h3>${strategy.name || 'Unnamed Strategy'}</h3>
                ${createDetailPara(strategy.outlook, "Market Outlook")}
                ${createDetailPara(strategy.description, "Description")}

                ${strategy.construction ? `
                    <div class="strategy-construction">
                        ${createListSection(strategy.construction, "Construction")}
                        ${strategy.notes ? `<p class="strategy-notes"><em>Note: ${strategy.notes}</em></p>` : ''}
                    </div>
                ` : ''}

                ${createDetailPara(strategy.maxProfit, "Max Profit")}
                ${createDetailPara(strategy.maxLoss, "Max Loss")}
                ${createDetailPara(strategy.breakeven, "Breakeven Point(s)")}
                ${createDetailPara(strategy.greeksOverview, "Greeks Overview")}
                ${createDetailPara(strategy.whenToUse, "When to Use")}
                ${createDetailPara(strategy.risks, "Potential Risks")}

                <!-- Plotly Chart Container -->
                ${strategy.plotlyDivId ? `<div id="${strategy.plotlyDivId}" class="plotly-chart-container"></div>` : ''}

                ${strategy.example ? `<p class="strategy-example"><em>Example: ${strategy.example}</em></p>` : ''}

                <!-- Action Button -->
                <button class="w3-button w3-light-grey w3-small action-button calendar-button" data-strategy-name="${strategy.name || 'Unknown'}">
                    <i class="fa fa-calendar-plus-o"></i> Add to Calendar (Placeholder)
                </button>
            `;
            return panel;
        }

        /** Selects and renders the appropriate content based on appState.currentSection */
        function renderCurrentSection() {
            logger.log(`Rendering section: ${appState.currentSection}`);
            updateStatusMessage(); // Show loading/error state if applicable
            updateStatusIndicators();

            if (appState.isLoading || (!appState.strategyData && !appState.error)) {
                 // Don't render content if loading or if there's no data and no error yet
                clearContentAreas();
                return;
            }
             if (!appState.strategyData && appState.error) {
                 // If there's an error and no data, content area is cleared by updateStatusMessage
                 clearContentAreas();
                 return;
             }

            // Render content based on section
            switch(appState.currentSection) {
                case 'about':
                    renderAboutSection();
                    break;
                case 'oneLeg':
                case 'twoLeg':
                case 'threeLeg':
                case 'fourLeg':
                    renderStrategySection(appState.currentSection);
                    break;
                default:
                    logger.warn(`Unknown section requested: ${appState.currentSection}. Showing About.`);
                    appState.currentSection = 'about'; // Fallback to 'about'
                    renderAboutSection();
            }

            // Update sidebar active link
            updateSidebarActiveState();

             // Track page view in Google Analytics
            if (typeof gtag === 'function') {
                gtag('event', 'page_view', {
                    page_title: appState.currentSection,
                    page_path: `/#${appState.currentSection}` // Simulate path
                });
                logger.log(`[Analytics] GA event: page_view sent for section ${appState.currentSection}`);
            }
        }

        /** Updates the 'active' class on sidebar links. */
        function updateSidebarActiveState() {
            const links = DOM.sidebarLinks.querySelectorAll('.nav-link');
            links.forEach(link => {
                if (link.dataset.section === appState.currentSection) {
                    link.classList.add('active');
                } else {
                    link.classList.remove('active');
                }
            });
        }

         /**
         * ========================================================================
         * Event Handlers
         * ========================================================================
         */

         /** Handles clicks on sidebar navigation links. */
        function handleNavLinkClick(event) {
            event.preventDefault(); // Prevent default anchor behavior
            const section = event.target.dataset.section;
            if (section && section !== appState.currentSection) {
                 logger.log(`Navigation to section: ${section}`);
                 appState.currentSection = section;
                 renderCurrentSection(); // Re-render content for the new section
            }
             w3_close(); // Close sidebar on mobile after click
        }

        /** Handles click on the "Add to Calendar" placeholder button (uses event delegation). */
        function handleCalendarButtonClick(event) {
             // Check if the clicked element is the button itself or inside it
             const button = event.target.closest('.calendar-button');
             if (button) {
                 const strategyName = button.dataset.strategyName || 'Unknown Strategy';
                 logger.log(`Calendar button clicked for: ${strategyName}`);
                 // Placeholder alert - real implementation requires OAuth and API calls
                 alert(`Google Calendar Integration Placeholder\n\nStrategy: ${strategyName}\nThis demonstrates where calendar integration could occur.`);

                 // Send GA event
                 if (typeof gtag === 'function') {
                     gtag('event', 'add_to_calendar_click', {
                         'event_category': 'Strategy Engagement',
                         'event_label': strategyName,
                     });
                     logger.log(`[Analytics] GA event: add_to_calendar_click sent for ${strategyName}`);
                 }
             }
        }

        /** Handles click on the "Refresh Data" button. */
        function handleRefreshDataClick() {
            logger.log("Refresh data button clicked.");
            if (appState.isOffline) {
                logger.warn("Cannot refresh data while offline.");
                updateStatusMessageInternal("Cannot refresh data while offline.", "offline-message");
                return;
            }
            if (appState.isLoading) {
                logger.warn("Already loading data, refresh request ignored.");
                return;
            }
            // Trigger the data initialization process again
            initializeApp(true); // Pass true to indicate a forced refresh
        }

        /** Updates network status and triggers data reload if necessary. */
        function updateNetworkStatus() {
            const wasOffline = appState.isOffline;
            appState.isOffline = !navigator.onLine;
            logger.log(`Network status changed: ${appState.isOffline ? 'OFFLINE' : 'ONLINE'}`);
            updateStatusIndicators(); // Update header indicator immediately
            DOM.refreshDataButton.disabled = appState.isOffline || appState.isLoading; // Update button state

            // If we just came online, try fetching fresh data
            if (wasOffline && !appState.isOffline) {
                logger.info("Network connection restored, attempting to fetch fresh data.");
                initializeApp(true); // Force data refresh on reconnect
            } else if (appState.isOffline) {
                 // If we just went offline, ensure the UI reflects it properly
                 // Re-render to show appropriate messages if data isn't loaded
                 renderCurrentSection();
            }
        }

         /** Helper for internal status message updates without full re-render */
         function updateStatusMessageInternal(message, className) {
             DOM.statusMessageArea.innerHTML = ''; // Clear previous
             if (message) {
                 const msgDiv = document.createElement('div');
                 msgDiv.className = `status-message ${className}`;
                 msgDiv.textContent = message;
                 DOM.statusMessageArea.appendChild(msgDiv);
             }
         }

        /**
         * ========================================================================
         * W3.CSS Sidebar Responsive Logic
         * ========================================================================
         */
        function w3_open() {
            if (DOM.sidebar && DOM.overlay) {
                DOM.sidebar.style.display = 'block';
                DOM.overlay.style.display = 'block';
            }
        }
        function w3_close() {
             if (DOM.sidebar && DOM.overlay) {
                DOM.sidebar.style.display = 'none';
                DOM.overlay.style.display = 'none';
             }
        }

        /**
         * ========================================================================
         * Data Loading and Initialization Logic
         * ========================================================================
         */

        /** Main data initialization function */
        async function initializeApp(forceRefresh = false) {
            logger.log(`Initializing App. Force refresh: ${forceRefresh}`);
            appState.isLoading = true;
            appState.error = null; // Clear previous errors on new load attempt
            renderCurrentSection(); // Show loading state

            let loadedData = null;
            let source = 'Initial'; // Track origin

            try {
                 // 0. Use Embedded Data First (if not forcing refresh) for instant load feel
                 if (!forceRefresh && typeof embeddedStrategyData !== 'undefined') {
                     logger.info("Using initial embedded data.");
                     loadedData = embeddedStrategyData;
                     source = 'Initial';
                     // Store initial data in DB/Cache in the background if needed
                     // We skip this here to prioritize fetch/DB check first
                 }

                // 1. Ensure IndexedDB is available
                if (!appState.dbConnection) {
                    await openDB(); // Sets appState.dbConnection on success
                }

                // 2. Attempt Fetch if Online (or forced refresh)
                if (!appState.isOffline || forceRefresh) {
                    logger.info("Attempting to fetch data from network...");
                    try {
                        const response = await fetch(STRATEGIES_JSON_URL, {
                            cache: 'no-store', // Attempt to bypass HTTP cache
                            headers: { 'Accept': 'application/json' }
                        });
                        appState.lastFetchTimestamp = new Date(); // Record fetch attempt time

                        if (!response.ok) {
                            throw new Error(`HTTP error ${response.status}: ${response.statusText}`);
                        }
                        const networkData = await response.json();
                        logger.log("Fetch successful.");
                        loadedData = networkData; // Prioritize network data
                        source = 'Network';

                        // Asynchronously save/cache the fresh data
                        if (appState.dbConnection) {
                            saveDataToDB(loadedData).catch(err => logger.error("Background DB save failed:", err));
                        }
                        cacheDataResponse(STRATEGIES_JSON_URL, loadedData).catch(err => logger.error("Background Cache save failed:", err));

                    } catch (fetchError) {
                        logger.warn(`Fetch failed: ${fetchError.message}.`);
                        // Don't set persistent error yet, will try Cache/DB
                        appState.error = `Network fetch failed (${fetchError.message}). Trying offline sources...`;
                    }
                } else {
                    logger.info("App is offline or refresh not forced. Skipping network fetch.");
                    appState.lastFetchTimestamp = new Date(); // Still record timestamp of attempt
                }

                 // 3. Attempt Cache API if Network Failed or Skipped (and not using initial data)
                 if (!loadedData || source === 'Initial') {
                      logger.info("Attempting to load data from Cache API...");
                      const cacheData = await loadDataFromCache(STRATEGIES_JSON_URL);
                      if (cacheData) {
                          logger.log("Data loaded from Cache API.");
                          loadedData = cacheData;
                          source = 'Cache';
                          appState.error = null; // Clear fetch error if cache load succeeded
                      } else {
                           logger.info("No data found in Cache API.");
                           // Keep fetch error message if it exists
                      }
                 }


                // 4. Attempt IndexedDB if Network/Cache Failed or Skipped (and not using initial data)
                if ((!loadedData || source === 'Initial') && appState.dbConnection) {
                    logger.info("Attempting to load data from IndexedDB...");
                     try {
                        const dbData = await loadDataFromDB();
                        if (dbData) {
                            logger.log("Data loaded from IndexedDB.");
                            loadedData = dbData;
                            source = 'IndexedDB';
                            appState.error = null; // Clear fetch/cache error if DB load succeeded
                        } else {
                             logger.info("No data found in IndexedDB.");
                             // Only show persistent error if all sources failed
                             if (!loadedData) {
                                 appState.error = appState.error ? `${appState.error} AND no offline data found.` : "No strategy data found in offline storage.";
                             }
                        }
                     } catch (dbLoadError) {
                          logger.error("Failed to load from IndexedDB:", dbLoadError);
                          if (!loadedData) { // Only add DB error if nothing else loaded
                               appState.error = appState.error ? `${appState.error} AND DB load failed: ${dbLoadError}` : `DB load error: ${dbLoadError}`;
                          }
                     }
                } else if (!loadedData && !appState.dbConnection) {
                     logger.warn("Cannot load from IndexedDB - connection not available.");
                     if (!loadedData && appState.isOffline) { // If still no data and offline
                        appState.error = "App is offline and offline storage is unavailable.";
                     }
                }

                // 5. Final State Update
                appState.strategyData = loadedData;
                appState.dataSource = source; // Update data source tracker
                appState.isLoading = false; // Loading finished
                if (appState.lastFetchTimestamp) {
                    DOM.lastUpdated.textContent = `Last fetch attempt: ${appState.lastFetchTimestamp.toLocaleTimeString()}`;
                } else {
                     DOM.lastUpdated.textContent = '';
                }
                 DOM.refreshDataButton.disabled = appState.isOffline || appState.isLoading; // Final button state


            } catch (initError) {
                // Catch errors from openDB or other unexpected initialization issues
                logger.error("Critical Initialization Error:", initError);
                appState.error = `Initialization failed: ${initError.message || initError}`;
                appState.strategyData = null; // Ensure no stale data is shown
                appState.isLoading = false;
                appState.dataSource = 'Error';
            }

            // 6. Render the final state
            renderSidebarLinks(); // Update links based on loaded data keys
            renderCurrentSection(); // Render content based on final state

        } // End initializeApp

        /**
         * ========================================================================
         * Initial Setup and Event Listeners
         * ========================================================================
         */
        document.addEventListener('DOMContentLoaded', () => {
            logger.log("DOM Content Loaded. Initializing application...");

            // --- Setup Event Listeners ---

            // Sidebar toggle listeners
            DOM.openMenuButton.addEventListener('click', w3_open);
            DOM.closeMenuButton.addEventListener('click', w3_close);
            DOM.overlay.addEventListener('click', w3_close);

             // Refresh button listener
             DOM.refreshDataButton.addEventListener('click', handleRefreshDataClick);

             // Network status listeners
             window.addEventListener('online', updateNetworkStatus);
             window.addEventListener('offline', updateNetworkStatus);

            // Use event delegation for calendar buttons (more efficient than adding listener to each button)
            DOM.contentContainer.addEventListener('click', handleCalendarButtonClick);

            // --- Start Application ---
            initializeApp(); // Initial data load and rendering
        });


        /**
         * ========================================================================
         * Embedded Strategy Data (For Demo - Load from strategies.json in Production)
         * ========================================================================
         */
        // IMPORTANT: This makes the file large. In a real app, load strategies.json via fetch.
        const embeddedStrategyData = {
          "oneLeg": [
            { "id": "long-call-100", "name": "Long Call", "outlook": "Strongly Bullish", "description": "Buys the right (not obligation) to purchase the underlying at the strike price before expiration.", "construction": [ "Buy 1 Call Option" ], "maxProfit": "Unlimited (as price rises)", "maxLoss": "Premium Paid", "breakeven": "Strike Price + Premium Paid", "greeksOverview": "Positive Delta, Positive Gamma, Positive Vega, Negative Theta.", "whenToUse": "Strong conviction of a sharp upward move; Expecting increased implied volatility.", "risks": "Loses entire premium if price stays below strike. Time decay. Vega risk.", "example": "Buy 1 XYZ 100 Call for $2.50. Breakeven $102.50.", "plotFunction": "plotBasicOption", "plotlyDivId": "plotly-long-call-100", "parameters": { "type": "call", "position": "long", "strike": 100, "premium": 2.50 } },
            { "id": "short-put-95", "name": "Short Put (Naked)", "outlook": "Bullish to Neutral", "description": "Sells the obligation to buy the underlying if price falls below strike. Collects premium.", "construction": ["Sell 1 Put Option"], "maxProfit": "Premium Received", "maxLoss": "Strike Price - Premium Received (Substantial)", "breakeven": "Strike Price - Premium Received", "greeksOverview": "Positive Delta, Negative Gamma, Negative Vega, Positive Theta.", "whenToUse": "Expecting price stable or rising; High IV preferred; Willing to own stock.", "risks": "Significant loss potential on downside. Margin required. Assignment risk.", "example": "Sell 1 XYZ 95 Put for $1.80. Breakeven $93.20.", "plotFunction": "plotBasicOption", "plotlyDivId": "plotly-short-put-95", "parameters": { "type": "put", "position": "short", "strike": 95, "premium": 1.80 } },
            { "id": "short-call-105", "name": "Short Call (Naked)", "outlook": "Bearish to Neutral", "description": "Sells the obligation to sell the underlying if price rises above strike. Collects premium.", "construction": ["Sell 1 Call Option"], "maxProfit": "Premium Received", "maxLoss": "Unlimited", "breakeven": "Strike Price + Premium Received", "greeksOverview": "Negative Delta, Negative Gamma, Negative Vega, Positive Theta.", "whenToUse": "Expecting price stable or falling; High IV preferred.", "risks": "Unlimited loss potential on upside. High risk. Margin required. Assignment risk.", "example": "Sell 1 XYZ 105 Call for $1.50. Breakeven $106.50.", "plotFunction": "plotBasicOption", "plotlyDivId": "plotly-short-call-105", "parameters": { "type": "call", "position": "short", "strike": 105, "premium": 1.50 } },
            { "id": "long-put-100", "name": "Long Put", "outlook": "Strongly Bearish", "description": "Buys the right (not obligation) to sell the underlying at the strike price.", "construction": [ "Buy 1 Put Option" ], "maxProfit": "Strike Price - Premium Paid", "maxLoss": "Premium Paid", "breakeven": "Strike Price - Premium Paid", "greeksOverview": "Negative Delta, Positive Gamma, Positive Vega, Negative Theta.", "whenToUse": "Strong conviction of sharp downward move; Expecting increased IV; Hedging long stock.", "risks": "Loses premium if price stays above strike. Time decay. Vega risk.", "example": "Buy 1 XYZ 100 Put for $2.80. Breakeven $97.20.", "plotFunction": "plotBasicOption", "plotlyDivId": "plotly-long-put-100", "parameters": { "type": "put", "position": "long", "strike": 100, "premium": 2.80 } }
          ],
          "twoLeg": [
            { "id": "bull-call-spread-100-105", "name": "Bull Call Spread (Vertical Debit)", "outlook": "Moderately Bullish", "description": "Defined-risk bullish strategy. Buy lower strike call, sell higher strike call.", "construction": [ "Buy 1 Call (Lower Strike K1)", "Sell 1 Call (Higher Strike K2)" ], "maxProfit": "Difference between strikes - Net Debit Paid", "maxLoss": "Net Debit Paid", "breakeven": "Lower Strike + Net Debit Paid", "greeksOverview": "+Delta (net), Gamma varies, -Vega (net), Theta varies.", "whenToUse": "Moderately bullish, target price, defined risk, lower cost than long call.", "risks": "Max loss is debit. Profit capped. Time decay can hurt/help.", "example": "Buy 100C@$3.00, Sell 105C@$1.20. Debit $1.80. Max Profit $3.20. BE $101.80.", "plotFunction": "plotVerticalSpread", "plotlyDivId": "plotly-bull-call-spread", "parameters": { "type": "call", "position": "debit", "strike1": 100, "strike2": 105, "premium1": 3.00, "premium2": 1.20 } },
            { "id": "bear-put-spread-100-95", "name": "Bear Put Spread (Vertical Debit)", "outlook": "Moderately Bearish", "description": "Defined-risk bearish strategy. Buy higher strike put, sell lower strike put.", "construction": [ "Buy 1 Put (Higher Strike K2)", "Sell 1 Put (Lower Strike K1)" ], "maxProfit": "Difference between strikes - Net Debit Paid", "maxLoss": "Net Debit Paid", "breakeven": "Higher Strike - Net Debit Paid", "greeksOverview": "-Delta (net), Gamma varies, -Vega (net), Theta varies.", "whenToUse": "Moderately bearish, target price, defined risk.", "risks": "Max loss is debit. Profit capped.", "example": "Buy 100P@$2.80, Sell 95P@$1.10. Debit $1.70. Max Profit $3.30. BE $98.30.", "plotFunction": "plotVerticalSpread", "plotlyDivId": "plotly-bear-put-spread", "parameters": { "type": "put", "position": "debit", "strike1": 95, "strike2": 100, "premium1": 1.10, "premium2": 2.80 } },
            { "id": "bear-call-spread-105-110", "name": "Bear Call Spread (Vertical Credit)", "outlook": "Moderately Bearish / Neutral", "description": "Defined-risk strategy profiting if price stays below short call. Sell lower strike call, buy higher call.", "construction": [ "Sell 1 Call (Lower Strike K1)", "Buy 1 Call (Higher Strike K2)" ], "maxProfit": "Net Credit Received", "maxLoss": "Difference between strikes - Net Credit Received", "breakeven": "Lower Strike + Net Credit Received", "greeksOverview": "-Delta (net), -Gamma (net), +Vega (net, often small), +Theta.", "whenToUse": "Expecting price below short strike; High IV preferred; Defined risk.", "risks": "Max loss if price rallies above higher strike. Assignment risk.", "example": "Sell 105C@$1.50, Buy 110C@$0.40. Credit $1.10. Max Loss $3.90. BE $106.10.", "plotFunction": "plotVerticalSpread", "plotlyDivId": "plotly-bear-call-spread", "parameters": { "type": "call", "position": "credit", "strike1": 105, "strike2": 110, "premium1": 1.50, "premium2": 0.40 } },
            { "id": "bull-put-spread-95-90", "name": "Bull Put Spread (Vertical Credit)", "outlook": "Moderately Bullish / Neutral", "description": "Defined-risk strategy profiting if price stays above short put. Sell higher strike put, buy lower put.", "construction": [ "Sell 1 Put (Higher Strike K2)", "Buy 1 Put (Lower Strike K1)" ], "maxProfit": "Net Credit Received", "maxLoss": "Difference between strikes - Net Credit Received", "breakeven": "Higher Strike - Net Credit Received", "greeksOverview": "+Delta (net), -Gamma (net), +Vega (net), +Theta.", "whenToUse": "Expecting price above short strike; High IV preferred; Defined risk.", "risks": "Max loss if price falls below lower strike. Assignment risk.", "example": "Sell 95P@$1.80, Buy 90P@$0.50. Credit $1.30. Max Loss $3.70. BE $93.70.", "plotFunction": "plotVerticalSpread", "plotlyDivId": "plotly-bull-put-spread", "parameters": { "type": "put", "position": "credit", "strike1": 90, "strike2": 95, "premium1": 0.50, "premium2": 1.80 } },
            { "id": "long-straddle-100", "name": "Long Straddle", "outlook": "Volatile (Direction Unknown)", "description": "Buy ATM call and ATM put, same strike/expiry. Profits from large move.", "construction": [ "Buy 1 ATM Call (Strike K)", "Buy 1 ATM Put (Strike K)" ], "maxProfit": "Unlimited (up), Substantial (down)", "maxLoss": "Net Debit Paid", "breakeven": "Strike +/- Net Debit", "greeksOverview": "~0 Delta, +Gamma, +Vega, -Theta (significant).", "whenToUse": "Expecting large move (e.g., earnings), unsure direction; Expecting IV increase.", "risks": "Max loss if price static. High time decay cost. Vega risk.", "example": "Stock@$100. Buy 100C@$3.50, Buy 100P@$3.20. Debit $6.70. BE $93.30, $106.70.", "plotFunction": "plotStraddleStrangle", "plotlyDivId": "plotly-long-straddle-100", "parameters": { "type": "straddle", "strikeP": 100, "strikeC": 100, "premiumP": 3.20, "premiumC": 3.50 } },
            { "id": "long-strangle-95-105", "name": "Long Strangle", "outlook": "Volatile (Direction Unknown)", "description": "Buy OTM call and OTM put, different strikes. Cheaper than straddle, needs bigger move.", "construction": [ "Buy 1 OTM Put (Lower Strike K1)", "Buy 1 OTM Call (Higher Strike K2)" ], "maxProfit": "Unlimited (up), Substantial (down)", "maxLoss": "Net Debit Paid", "breakeven": "K2 + Net Debit; K1 - Net Debit", "greeksOverview": "~0 Delta, +Gamma, +Vega, -Theta.", "whenToUse": "Expecting very large move; Cheaper volatility play than straddle.", "risks": "Needs larger move than straddle. Max loss if price between strikes. Theta/Vega risk.", "example": "Stock@$100. Buy 95P@$1.80, Buy 105C@$1.50. Debit $3.30. BE $91.70, $108.30.", "plotFunction": "plotStraddleStrangle", "plotlyDivId": "plotly-long-strangle-95-105", "parameters": { "type": "strangle", "strikeP": 95, "strikeC": 105, "premiumP": 1.80, "premiumC": 1.50 } }
          ],
          "threeLeg": [
            { "id": "long-call-butterfly-95-100-105", "name": "Long Call Butterfly", "outlook": "Neutral (Price Pinning Middle Strike)", "description": "Defined-risk strategy expecting price at middle strike K2. Buy K1 Call, Sell 2 K2 Calls, Buy K3 Call.", "construction": [ "Buy 1 Call (Lower Strike K1)", "Sell 2 Calls (Middle Strike K2)", "Buy 1 Call (Higher Strike K3)" ], "notes": "Strikes K1, K2, K3 equidistant.", "maxProfit": "Wing Width (K2-K1) - Net Debit", "maxLoss": "Net Debit Paid", "breakeven": "K1 + Net Debit; K3 - Net Debit", "greeksOverview": "~0 Delta at K2, -Gamma, -Vega, +Theta (near K2).", "whenToUse": "High conviction price pins K2; High IV expected to fall.", "risks": "Max loss if price moves significantly. Needs precise prediction. Spread costs.", "example": "Buy 95C@$6, Sell 2x100C@$3, Buy 105C@$1. Debit $1. Max Profit $4. BE $96, $104.", "plotFunction": "plotButterfly", "plotlyDivId": "plotly-call-butterfly-95-100-105", "parameters": { "type": "call", "strike1": 95, "strike2": 100, "strike3": 105, "premium1": 6.00, "premium2": 3.00, "premium3": 1.00 } },
            { "id": "long-put-butterfly-95-100-105", "name": "Long Put Butterfly", "outlook": "Neutral (Price Pinning Middle Strike)", "description": "Similar profile to Call Butterfly, uses puts.", "construction": [ "Buy 1 Put (Lower K1)", "Sell 2 Puts (Middle K2)", "Buy 1 Put (Higher K3)" ], "notes": "Equidistant strikes.", "maxProfit": "Wing Width (K3-K2) - Net Debit", "maxLoss": "Net Debit Paid", "breakeven": "K1 + Net Debit; K3 - Net Debit", "greeksOverview": "Similar to Call Butterfly.", "whenToUse": "Same as Call Butterfly.", "risks": "Same as Call Butterfly.", "example": "Buy 95P@$1.50, Sell 2x100P@$3.50, Buy 105P@$7.10. Debit $1.60. Max Profit $3.40. BE $96.60, $103.40.", "plotFunction": "plotButterfly", "plotlyDivId": "plotly-put-butterfly-95-100-105", "parameters": { "type": "put", "strike1": 95, "strike2": 100, "strike3": 105, "premium1": 1.50, "premium2": 3.50, "premium3": 7.10 } }
          ],
          "fourLeg": [
            { "id": "iron-condor-90-95-105-110", "name": "Iron Condor (Short)", "outlook": "Neutral (Low Volatility, Range Bound)", "description": "Defined-risk strategy profiting from low volatility & time decay. Sell OTM Put spread & OTM Call spread.", "construction": [ "Buy 1 OTM Put (K1)", "Sell 1 OTM Put (K2)", "Sell 1 OTM Call (K3)", "Buy 1 OTM Call (K4)" ], "notes": "K1 < K2 < Price < K3 < K4.", "maxProfit": "Net Credit Received", "maxLoss": "Wing Width - Net Credit", "breakeven": "K2 - Credit; K3 + Credit", "greeksOverview": "~0 Delta, -Gamma, -Vega, +Theta.", "whenToUse": "Expecting price in K2-K3 range; High IV expected to fall/stabilize.", "risks": "Max loss if price moves beyond wings. Assignment risk.", "example": "Buy 90P@.5, Sell 95P@1.8, Sell 105C@1.5, Buy 110C@.4. Credit $2.40. Max Loss $2.60. BE $92.60, $107.40.", "plotFunction": "plotIronCondor", "plotlyDivId": "plotly-iron-condor-90-95-105-110", "parameters": { "strikeP1": 90, "strikeP2": 95, "strikeC3": 105, "strikeC4": 110, "premiumP1": 0.50, "premiumP2": 1.80, "premiumC3": 1.50, "premiumC4": 0.40 } },
            { "id": "iron-butterfly-90-100-110", "name": "Iron Butterfly (Short)", "outlook": "Neutral (Price Pinning Middle Strike)", "description": "Defined-risk strategy expecting minimal movement, price pins K2. Short ATM straddle + OTM wings.", "construction": [ "Buy 1 OTM Put (K1)", "Sell 1 ATM Put (K2)", "Sell 1 ATM Call (K2)", "Buy 1 OTM Call (K3)" ], "notes": "K1 < K2 < K3.", "maxProfit": "Net Credit Received", "maxLoss": "Wing Width - Net Credit", "breakeven": "K2 +/- Net Credit", "greeksOverview": "~0 Delta, --Gamma, -Vega, ++Theta.", "whenToUse": "High conviction price pins K2; Very high IV expected to collapse.", "risks": "Narrow profit zone. High gamma risk. Assignment risk.", "example": "Buy 90P@.5, Sell 100P@4, Sell 100C@3.8, Buy 110C@.4. Credit $6.90. Max Loss $3.10. BE $93.10, $106.90.", "plotFunction": "plotIronButterfly", "plotlyDivId": "plotly-iron-butterfly-90-100-110", "parameters": { "strikeP1": 90, "strikePC2": 100, "strikeC3": 110, "premiumP1": 0.50, "premiumP2": 4.00, "premiumC2": 3.80, "premiumC3": 0.40 } },
            { "id": "reverse-iron-condor-90-95-105-110", "name": "Reverse Iron Condor (Long)", "outlook": "Volatile (Expecting Breakout)", "description": "Defined-risk strategy profiting from large move. Buy OTM Put spread & OTM Call spread. Net debit.", "construction": [ "Sell 1 OTM Put (K1)", "Buy 1 OTM Put (K2)", "Buy 1 OTM Call (K3)", "Sell 1 OTM Call (K4)" ], "notes": "Opposite legs of short condor.", "maxProfit": "Wing Width - Net Debit", "maxLoss": "Net Debit Paid", "breakeven": "K2 + Debit; K3 - Debit", "greeksOverview": "~0 Delta, +Gamma, +Vega, -Theta.", "whenToUse": "Expecting large move out of K2-K3 range; Low IV expected to rise.", "risks": "Max loss if price between K2-K3. Needs significant move. Theta decay hurts.", "example": "Sell 90P@.5, Buy 95P@1.8, Buy 105C@1.5, Sell 110C@.4. Debit $2.40. Max Profit $2.60. BE $92.60, $107.40.", "plotFunction": "plotReverseIronCondor", "plotlyDivId": "plotly-reverse-iron-condor", "parameters": { "strikeP1": 90, "strikeP2": 95, "strikeC3": 105, "strikeC4": 110, "premiumP1": 0.50, "premiumP2": 1.80, "premiumC3": 1.50, "premiumC4": 0.40 } },
            { "id": "reverse-iron-butterfly-90-100-110", "name": "Reverse Iron Butterfly (Long)", "outlook": "Volatile (Expecting Strong Breakout)", "description": "Defined-risk strategy profiting from very large move from K2. Buy ATM straddle, sell wings.", "construction": [ "Sell 1 OTM Put (K1)", "Buy 1 ATM Put (K2)", "Buy 1 ATM Call (K2)", "Sell 1 OTM Call (K3)" ], "notes": "Opposite legs of short butterfly.", "maxProfit": "Wing Width - Net Debit", "maxLoss": "Net Debit Paid", "breakeven": "K2 +/- Net Debit (Check this logic)", "greeksOverview": "~0 Delta, ++Gamma, ++Vega, --Theta.", "whenToUse": "Expecting huge move from K2; Low IV expected to explode.", "risks": "Max loss if price pins K2. Needs huge move. High theta cost.", "example": "Sell 90P@.5, Buy 100P@4, Buy 100C@3.8, Sell 110C@.4. Debit $6.90. Max Profit $3.10. BE $93.10, $106.90.", "plotFunction": "plotReverseIronButterfly", "plotlyDivId": "plotly-reverse-iron-fly", "parameters": { "strikeP1": 90, "strikePC2": 100, "strikeC3": 110, "premiumP1": 0.50, "premiumP2": 4.00, "premiumC2": 3.80, "premiumC3": 0.40 } },
            { "id": "box-spread-100-110", "name": "Box Spread (Long)", "outlook": "Arbitrage / Synthetic Loan/Deposit", "description": "Combines Bull Call Spread & Bear Put Spread. Locks in theoretical risk-free profit (strike diff - debit). Mainly institutional.", "construction": [ "Buy 1 Call (K1)", "Sell 1 Call (K2)", "Buy 1 Put (K2)", "Sell 1 Put (K1)" ], "notes": "Same expiry. Payoff = K2-K1.", "maxProfit": "(K2 - K1) - Net Debit", "maxLoss": "Net Debit - (K2 - K1) (Main risk is costs/assignment)", "breakeven": "N/A", "greeksOverview": "All Greeks theoretically zero.", "whenToUse": "Financing; Exploiting put/call mispricings (rare for retail).", "risks": "Execution costs; Early assignment risk (esp. dividends).", "example": "Buy 100C@$6, Sell 110C@$1.5, Buy 110P@$1.2, Sell 100P@$4. Debit $1.70. Value $10. P/L $8.30 (pre-cost).", "plotFunction": "plotBoxSpread", "plotlyDivId": "plotly-box-spread-100-110", "parameters": { "strike1": 100, "strike2": 110, "premC1": 6.00, "premC2": 1.50, "premP1": 4.00, "premP2": 1.20 } }
          ],
           "about": {
               "title": "About This Vanilla JS Options Visualizer",
               "content": [
                   "Welcome! This is a comprehensive, single-page application demonstrating option strategy visualization using plain <strong>Vanilla JavaScript</strong>.",
                   "It avoids frameworks like React, directly manipulating the DOM to render content and manage state.",
                   "Key features include:",
                   "<ul><li>Dynamic content rendering based on navigation.</li><li>Asynchronous data fetching using the native <strong>Fetch API</strong>.</li><li>Offline data support via <strong>IndexedDB</strong> for persistence and the <strong>Cache Storage API</strong> for response caching.</li><li>Interactive payoff diagrams powered by <strong>Plotly.js</strong>.</li><li>Responsive layout using the lightweight <strong>W3.CSS</strong> framework.</li><li>Placeholders for <strong>Google Calendar</strong> integration (requires OAuth).</li><li>Basic <strong>Google Analytics</strong> event tracking for page views and interactions (requires configuration).</li></ul>",
                   "The application prioritizes loading data in the following order: Embedded Initial Data -> Network (Fetch) -> Cache API -> IndexedDB.",
                   "<strong style='color: red;'>Disclaimer:</strong> Educational tool only. Data is illustrative. Option trading involves substantial risk. Not financial advice."
               ]
           }
        }; // End embeddedStrategyData


    </script>

</body>
</html>
